/******/ (function(modules) { // webpackBootstrap
/******/ 	function hotDisposeChunk(chunkId) {
/******/ 		delete installedChunks[chunkId];
/******/ 	}
/******/ 	var parentHotUpdateCallback = window["webpackHotUpdate"];
/******/ 	window["webpackHotUpdate"] = // eslint-disable-next-line no-unused-vars
/******/ 	function webpackHotUpdateCallback(chunkId, moreModules) {
/******/ 		hotAddUpdateChunk(chunkId, moreModules);
/******/ 		if (parentHotUpdateCallback) parentHotUpdateCallback(chunkId, moreModules);
/******/ 	} ;
/******/
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	function hotDownloadUpdateChunk(chunkId) {
/******/ 		var script = document.createElement("script");
/******/ 		script.charset = "utf-8";
/******/ 		script.src = __webpack_require__.p + "" + chunkId + "." + hotCurrentHash + ".hot-update.js";
/******/ 		if (null) script.crossOrigin = null;
/******/ 		document.head.appendChild(script);
/******/ 	}
/******/
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	function hotDownloadManifest(requestTimeout) {
/******/ 		requestTimeout = requestTimeout || 10000;
/******/ 		return new Promise(function(resolve, reject) {
/******/ 			if (typeof XMLHttpRequest === "undefined") {
/******/ 				return reject(new Error("No browser support"));
/******/ 			}
/******/ 			try {
/******/ 				var request = new XMLHttpRequest();
/******/ 				var requestPath = __webpack_require__.p + "" + hotCurrentHash + ".hot-update.json";
/******/ 				request.open("GET", requestPath, true);
/******/ 				request.timeout = requestTimeout;
/******/ 				request.send(null);
/******/ 			} catch (err) {
/******/ 				return reject(err);
/******/ 			}
/******/ 			request.onreadystatechange = function() {
/******/ 				if (request.readyState !== 4) return;
/******/ 				if (request.status === 0) {
/******/ 					// timeout
/******/ 					reject(
/******/ 						new Error("Manifest request to " + requestPath + " timed out.")
/******/ 					);
/******/ 				} else if (request.status === 404) {
/******/ 					// no update available
/******/ 					resolve();
/******/ 				} else if (request.status !== 200 && request.status !== 304) {
/******/ 					// other failure
/******/ 					reject(new Error("Manifest request to " + requestPath + " failed."));
/******/ 				} else {
/******/ 					// success
/******/ 					try {
/******/ 						var update = JSON.parse(request.responseText);
/******/ 					} catch (e) {
/******/ 						reject(e);
/******/ 						return;
/******/ 					}
/******/ 					resolve(update);
/******/ 				}
/******/ 			};
/******/ 		});
/******/ 	}
/******/
/******/ 	var hotApplyOnUpdate = true;
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	var hotCurrentHash = "e1d731ff45060ae57095";
/******/ 	var hotRequestTimeout = 10000;
/******/ 	var hotCurrentModuleData = {};
/******/ 	var hotCurrentChildModule;
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	var hotCurrentParents = [];
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	var hotCurrentParentsTemp = [];
/******/
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	function hotCreateRequire(moduleId) {
/******/ 		var me = installedModules[moduleId];
/******/ 		if (!me) return __webpack_require__;
/******/ 		var fn = function(request) {
/******/ 			if (me.hot.active) {
/******/ 				if (installedModules[request]) {
/******/ 					if (installedModules[request].parents.indexOf(moduleId) === -1) {
/******/ 						installedModules[request].parents.push(moduleId);
/******/ 					}
/******/ 				} else {
/******/ 					hotCurrentParents = [moduleId];
/******/ 					hotCurrentChildModule = request;
/******/ 				}
/******/ 				if (me.children.indexOf(request) === -1) {
/******/ 					me.children.push(request);
/******/ 				}
/******/ 			} else {
/******/ 				console.warn(
/******/ 					"[HMR] unexpected require(" +
/******/ 						request +
/******/ 						") from disposed module " +
/******/ 						moduleId
/******/ 				);
/******/ 				hotCurrentParents = [];
/******/ 			}
/******/ 			return __webpack_require__(request);
/******/ 		};
/******/ 		var ObjectFactory = function ObjectFactory(name) {
/******/ 			return {
/******/ 				configurable: true,
/******/ 				enumerable: true,
/******/ 				get: function() {
/******/ 					return __webpack_require__[name];
/******/ 				},
/******/ 				set: function(value) {
/******/ 					__webpack_require__[name] = value;
/******/ 				}
/******/ 			};
/******/ 		};
/******/ 		for (var name in __webpack_require__) {
/******/ 			if (
/******/ 				Object.prototype.hasOwnProperty.call(__webpack_require__, name) &&
/******/ 				name !== "e" &&
/******/ 				name !== "t"
/******/ 			) {
/******/ 				Object.defineProperty(fn, name, ObjectFactory(name));
/******/ 			}
/******/ 		}
/******/ 		fn.e = function(chunkId) {
/******/ 			if (hotStatus === "ready") hotSetStatus("prepare");
/******/ 			hotChunksLoading++;
/******/ 			return __webpack_require__.e(chunkId).then(finishChunkLoading, function(err) {
/******/ 				finishChunkLoading();
/******/ 				throw err;
/******/ 			});
/******/
/******/ 			function finishChunkLoading() {
/******/ 				hotChunksLoading--;
/******/ 				if (hotStatus === "prepare") {
/******/ 					if (!hotWaitingFilesMap[chunkId]) {
/******/ 						hotEnsureUpdateChunk(chunkId);
/******/ 					}
/******/ 					if (hotChunksLoading === 0 && hotWaitingFiles === 0) {
/******/ 						hotUpdateDownloaded();
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 		fn.t = function(value, mode) {
/******/ 			if (mode & 1) value = fn(value);
/******/ 			return __webpack_require__.t(value, mode & ~1);
/******/ 		};
/******/ 		return fn;
/******/ 	}
/******/
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	function hotCreateModule(moduleId) {
/******/ 		var hot = {
/******/ 			// private stuff
/******/ 			_acceptedDependencies: {},
/******/ 			_declinedDependencies: {},
/******/ 			_selfAccepted: false,
/******/ 			_selfDeclined: false,
/******/ 			_disposeHandlers: [],
/******/ 			_main: hotCurrentChildModule !== moduleId,
/******/
/******/ 			// Module API
/******/ 			active: true,
/******/ 			accept: function(dep, callback) {
/******/ 				if (dep === undefined) hot._selfAccepted = true;
/******/ 				else if (typeof dep === "function") hot._selfAccepted = dep;
/******/ 				else if (typeof dep === "object")
/******/ 					for (var i = 0; i < dep.length; i++)
/******/ 						hot._acceptedDependencies[dep[i]] = callback || function() {};
/******/ 				else hot._acceptedDependencies[dep] = callback || function() {};
/******/ 			},
/******/ 			decline: function(dep) {
/******/ 				if (dep === undefined) hot._selfDeclined = true;
/******/ 				else if (typeof dep === "object")
/******/ 					for (var i = 0; i < dep.length; i++)
/******/ 						hot._declinedDependencies[dep[i]] = true;
/******/ 				else hot._declinedDependencies[dep] = true;
/******/ 			},
/******/ 			dispose: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			addDisposeHandler: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			removeDisposeHandler: function(callback) {
/******/ 				var idx = hot._disposeHandlers.indexOf(callback);
/******/ 				if (idx >= 0) hot._disposeHandlers.splice(idx, 1);
/******/ 			},
/******/
/******/ 			// Management API
/******/ 			check: hotCheck,
/******/ 			apply: hotApply,
/******/ 			status: function(l) {
/******/ 				if (!l) return hotStatus;
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			addStatusHandler: function(l) {
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			removeStatusHandler: function(l) {
/******/ 				var idx = hotStatusHandlers.indexOf(l);
/******/ 				if (idx >= 0) hotStatusHandlers.splice(idx, 1);
/******/ 			},
/******/
/******/ 			//inherit from previous dispose call
/******/ 			data: hotCurrentModuleData[moduleId]
/******/ 		};
/******/ 		hotCurrentChildModule = undefined;
/******/ 		return hot;
/******/ 	}
/******/
/******/ 	var hotStatusHandlers = [];
/******/ 	var hotStatus = "idle";
/******/
/******/ 	function hotSetStatus(newStatus) {
/******/ 		hotStatus = newStatus;
/******/ 		for (var i = 0; i < hotStatusHandlers.length; i++)
/******/ 			hotStatusHandlers[i].call(null, newStatus);
/******/ 	}
/******/
/******/ 	// while downloading
/******/ 	var hotWaitingFiles = 0;
/******/ 	var hotChunksLoading = 0;
/******/ 	var hotWaitingFilesMap = {};
/******/ 	var hotRequestedFilesMap = {};
/******/ 	var hotAvailableFilesMap = {};
/******/ 	var hotDeferred;
/******/
/******/ 	// The update info
/******/ 	var hotUpdate, hotUpdateNewHash;
/******/
/******/ 	function toModuleId(id) {
/******/ 		var isNumber = +id + "" === id;
/******/ 		return isNumber ? +id : id;
/******/ 	}
/******/
/******/ 	function hotCheck(apply) {
/******/ 		if (hotStatus !== "idle") {
/******/ 			throw new Error("check() is only allowed in idle status");
/******/ 		}
/******/ 		hotApplyOnUpdate = apply;
/******/ 		hotSetStatus("check");
/******/ 		return hotDownloadManifest(hotRequestTimeout).then(function(update) {
/******/ 			if (!update) {
/******/ 				hotSetStatus("idle");
/******/ 				return null;
/******/ 			}
/******/ 			hotRequestedFilesMap = {};
/******/ 			hotWaitingFilesMap = {};
/******/ 			hotAvailableFilesMap = update.c;
/******/ 			hotUpdateNewHash = update.h;
/******/
/******/ 			hotSetStatus("prepare");
/******/ 			var promise = new Promise(function(resolve, reject) {
/******/ 				hotDeferred = {
/******/ 					resolve: resolve,
/******/ 					reject: reject
/******/ 				};
/******/ 			});
/******/ 			hotUpdate = {};
/******/ 			var chunkId = "main";
/******/ 			// eslint-disable-next-line no-lone-blocks
/******/ 			{
/******/ 				/*globals chunkId */
/******/ 				hotEnsureUpdateChunk(chunkId);
/******/ 			}
/******/ 			if (
/******/ 				hotStatus === "prepare" &&
/******/ 				hotChunksLoading === 0 &&
/******/ 				hotWaitingFiles === 0
/******/ 			) {
/******/ 				hotUpdateDownloaded();
/******/ 			}
/******/ 			return promise;
/******/ 		});
/******/ 	}
/******/
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	function hotAddUpdateChunk(chunkId, moreModules) {
/******/ 		if (!hotAvailableFilesMap[chunkId] || !hotRequestedFilesMap[chunkId])
/******/ 			return;
/******/ 		hotRequestedFilesMap[chunkId] = false;
/******/ 		for (var moduleId in moreModules) {
/******/ 			if (Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				hotUpdate[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if (--hotWaitingFiles === 0 && hotChunksLoading === 0) {
/******/ 			hotUpdateDownloaded();
/******/ 		}
/******/ 	}
/******/
/******/ 	function hotEnsureUpdateChunk(chunkId) {
/******/ 		if (!hotAvailableFilesMap[chunkId]) {
/******/ 			hotWaitingFilesMap[chunkId] = true;
/******/ 		} else {
/******/ 			hotRequestedFilesMap[chunkId] = true;
/******/ 			hotWaitingFiles++;
/******/ 			hotDownloadUpdateChunk(chunkId);
/******/ 		}
/******/ 	}
/******/
/******/ 	function hotUpdateDownloaded() {
/******/ 		hotSetStatus("ready");
/******/ 		var deferred = hotDeferred;
/******/ 		hotDeferred = null;
/******/ 		if (!deferred) return;
/******/ 		if (hotApplyOnUpdate) {
/******/ 			// Wrap deferred object in Promise to mark it as a well-handled Promise to
/******/ 			// avoid triggering uncaught exception warning in Chrome.
/******/ 			// See https://bugs.chromium.org/p/chromium/issues/detail?id=465666
/******/ 			Promise.resolve()
/******/ 				.then(function() {
/******/ 					return hotApply(hotApplyOnUpdate);
/******/ 				})
/******/ 				.then(
/******/ 					function(result) {
/******/ 						deferred.resolve(result);
/******/ 					},
/******/ 					function(err) {
/******/ 						deferred.reject(err);
/******/ 					}
/******/ 				);
/******/ 		} else {
/******/ 			var outdatedModules = [];
/******/ 			for (var id in hotUpdate) {
/******/ 				if (Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 					outdatedModules.push(toModuleId(id));
/******/ 				}
/******/ 			}
/******/ 			deferred.resolve(outdatedModules);
/******/ 		}
/******/ 	}
/******/
/******/ 	function hotApply(options) {
/******/ 		if (hotStatus !== "ready")
/******/ 			throw new Error("apply() is only allowed in ready status");
/******/ 		options = options || {};
/******/
/******/ 		var cb;
/******/ 		var i;
/******/ 		var j;
/******/ 		var module;
/******/ 		var moduleId;
/******/
/******/ 		function getAffectedStuff(updateModuleId) {
/******/ 			var outdatedModules = [updateModuleId];
/******/ 			var outdatedDependencies = {};
/******/
/******/ 			var queue = outdatedModules.map(function(id) {
/******/ 				return {
/******/ 					chain: [id],
/******/ 					id: id
/******/ 				};
/******/ 			});
/******/ 			while (queue.length > 0) {
/******/ 				var queueItem = queue.pop();
/******/ 				var moduleId = queueItem.id;
/******/ 				var chain = queueItem.chain;
/******/ 				module = installedModules[moduleId];
/******/ 				if (!module || module.hot._selfAccepted) continue;
/******/ 				if (module.hot._selfDeclined) {
/******/ 					return {
/******/ 						type: "self-declined",
/******/ 						chain: chain,
/******/ 						moduleId: moduleId
/******/ 					};
/******/ 				}
/******/ 				if (module.hot._main) {
/******/ 					return {
/******/ 						type: "unaccepted",
/******/ 						chain: chain,
/******/ 						moduleId: moduleId
/******/ 					};
/******/ 				}
/******/ 				for (var i = 0; i < module.parents.length; i++) {
/******/ 					var parentId = module.parents[i];
/******/ 					var parent = installedModules[parentId];
/******/ 					if (!parent) continue;
/******/ 					if (parent.hot._declinedDependencies[moduleId]) {
/******/ 						return {
/******/ 							type: "declined",
/******/ 							chain: chain.concat([parentId]),
/******/ 							moduleId: moduleId,
/******/ 							parentId: parentId
/******/ 						};
/******/ 					}
/******/ 					if (outdatedModules.indexOf(parentId) !== -1) continue;
/******/ 					if (parent.hot._acceptedDependencies[moduleId]) {
/******/ 						if (!outdatedDependencies[parentId])
/******/ 							outdatedDependencies[parentId] = [];
/******/ 						addAllToSet(outdatedDependencies[parentId], [moduleId]);
/******/ 						continue;
/******/ 					}
/******/ 					delete outdatedDependencies[parentId];
/******/ 					outdatedModules.push(parentId);
/******/ 					queue.push({
/******/ 						chain: chain.concat([parentId]),
/******/ 						id: parentId
/******/ 					});
/******/ 				}
/******/ 			}
/******/
/******/ 			return {
/******/ 				type: "accepted",
/******/ 				moduleId: updateModuleId,
/******/ 				outdatedModules: outdatedModules,
/******/ 				outdatedDependencies: outdatedDependencies
/******/ 			};
/******/ 		}
/******/
/******/ 		function addAllToSet(a, b) {
/******/ 			for (var i = 0; i < b.length; i++) {
/******/ 				var item = b[i];
/******/ 				if (a.indexOf(item) === -1) a.push(item);
/******/ 			}
/******/ 		}
/******/
/******/ 		// at begin all updates modules are outdated
/******/ 		// the "outdated" status can propagate to parents if they don't accept the children
/******/ 		var outdatedDependencies = {};
/******/ 		var outdatedModules = [];
/******/ 		var appliedUpdate = {};
/******/
/******/ 		var warnUnexpectedRequire = function warnUnexpectedRequire() {
/******/ 			console.warn(
/******/ 				"[HMR] unexpected require(" + result.moduleId + ") to disposed module"
/******/ 			);
/******/ 		};
/******/
/******/ 		for (var id in hotUpdate) {
/******/ 			if (Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 				moduleId = toModuleId(id);
/******/ 				/** @type {TODO} */
/******/ 				var result;
/******/ 				if (hotUpdate[id]) {
/******/ 					result = getAffectedStuff(moduleId);
/******/ 				} else {
/******/ 					result = {
/******/ 						type: "disposed",
/******/ 						moduleId: id
/******/ 					};
/******/ 				}
/******/ 				/** @type {Error|false} */
/******/ 				var abortError = false;
/******/ 				var doApply = false;
/******/ 				var doDispose = false;
/******/ 				var chainInfo = "";
/******/ 				if (result.chain) {
/******/ 					chainInfo = "\nUpdate propagation: " + result.chain.join(" -> ");
/******/ 				}
/******/ 				switch (result.type) {
/******/ 					case "self-declined":
/******/ 						if (options.onDeclined) options.onDeclined(result);
/******/ 						if (!options.ignoreDeclined)
/******/ 							abortError = new Error(
/******/ 								"Aborted because of self decline: " +
/******/ 									result.moduleId +
/******/ 									chainInfo
/******/ 							);
/******/ 						break;
/******/ 					case "declined":
/******/ 						if (options.onDeclined) options.onDeclined(result);
/******/ 						if (!options.ignoreDeclined)
/******/ 							abortError = new Error(
/******/ 								"Aborted because of declined dependency: " +
/******/ 									result.moduleId +
/******/ 									" in " +
/******/ 									result.parentId +
/******/ 									chainInfo
/******/ 							);
/******/ 						break;
/******/ 					case "unaccepted":
/******/ 						if (options.onUnaccepted) options.onUnaccepted(result);
/******/ 						if (!options.ignoreUnaccepted)
/******/ 							abortError = new Error(
/******/ 								"Aborted because " + moduleId + " is not accepted" + chainInfo
/******/ 							);
/******/ 						break;
/******/ 					case "accepted":
/******/ 						if (options.onAccepted) options.onAccepted(result);
/******/ 						doApply = true;
/******/ 						break;
/******/ 					case "disposed":
/******/ 						if (options.onDisposed) options.onDisposed(result);
/******/ 						doDispose = true;
/******/ 						break;
/******/ 					default:
/******/ 						throw new Error("Unexception type " + result.type);
/******/ 				}
/******/ 				if (abortError) {
/******/ 					hotSetStatus("abort");
/******/ 					return Promise.reject(abortError);
/******/ 				}
/******/ 				if (doApply) {
/******/ 					appliedUpdate[moduleId] = hotUpdate[moduleId];
/******/ 					addAllToSet(outdatedModules, result.outdatedModules);
/******/ 					for (moduleId in result.outdatedDependencies) {
/******/ 						if (
/******/ 							Object.prototype.hasOwnProperty.call(
/******/ 								result.outdatedDependencies,
/******/ 								moduleId
/******/ 							)
/******/ 						) {
/******/ 							if (!outdatedDependencies[moduleId])
/******/ 								outdatedDependencies[moduleId] = [];
/******/ 							addAllToSet(
/******/ 								outdatedDependencies[moduleId],
/******/ 								result.outdatedDependencies[moduleId]
/******/ 							);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 				if (doDispose) {
/******/ 					addAllToSet(outdatedModules, [result.moduleId]);
/******/ 					appliedUpdate[moduleId] = warnUnexpectedRequire;
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// Store self accepted outdated modules to require them later by the module system
/******/ 		var outdatedSelfAcceptedModules = [];
/******/ 		for (i = 0; i < outdatedModules.length; i++) {
/******/ 			moduleId = outdatedModules[i];
/******/ 			if (
/******/ 				installedModules[moduleId] &&
/******/ 				installedModules[moduleId].hot._selfAccepted &&
/******/ 				// removed self-accepted modules should not be required
/******/ 				appliedUpdate[moduleId] !== warnUnexpectedRequire
/******/ 			) {
/******/ 				outdatedSelfAcceptedModules.push({
/******/ 					module: moduleId,
/******/ 					errorHandler: installedModules[moduleId].hot._selfAccepted
/******/ 				});
/******/ 			}
/******/ 		}
/******/
/******/ 		// Now in "dispose" phase
/******/ 		hotSetStatus("dispose");
/******/ 		Object.keys(hotAvailableFilesMap).forEach(function(chunkId) {
/******/ 			if (hotAvailableFilesMap[chunkId] === false) {
/******/ 				hotDisposeChunk(chunkId);
/******/ 			}
/******/ 		});
/******/
/******/ 		var idx;
/******/ 		var queue = outdatedModules.slice();
/******/ 		while (queue.length > 0) {
/******/ 			moduleId = queue.pop();
/******/ 			module = installedModules[moduleId];
/******/ 			if (!module) continue;
/******/
/******/ 			var data = {};
/******/
/******/ 			// Call dispose handlers
/******/ 			var disposeHandlers = module.hot._disposeHandlers;
/******/ 			for (j = 0; j < disposeHandlers.length; j++) {
/******/ 				cb = disposeHandlers[j];
/******/ 				cb(data);
/******/ 			}
/******/ 			hotCurrentModuleData[moduleId] = data;
/******/
/******/ 			// disable module (this disables requires from this module)
/******/ 			module.hot.active = false;
/******/
/******/ 			// remove module from cache
/******/ 			delete installedModules[moduleId];
/******/
/******/ 			// when disposing there is no need to call dispose handler
/******/ 			delete outdatedDependencies[moduleId];
/******/
/******/ 			// remove "parents" references from all children
/******/ 			for (j = 0; j < module.children.length; j++) {
/******/ 				var child = installedModules[module.children[j]];
/******/ 				if (!child) continue;
/******/ 				idx = child.parents.indexOf(moduleId);
/******/ 				if (idx >= 0) {
/******/ 					child.parents.splice(idx, 1);
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// remove outdated dependency from module children
/******/ 		var dependency;
/******/ 		var moduleOutdatedDependencies;
/******/ 		for (moduleId in outdatedDependencies) {
/******/ 			if (
/******/ 				Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)
/******/ 			) {
/******/ 				module = installedModules[moduleId];
/******/ 				if (module) {
/******/ 					moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 					for (j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 						dependency = moduleOutdatedDependencies[j];
/******/ 						idx = module.children.indexOf(dependency);
/******/ 						if (idx >= 0) module.children.splice(idx, 1);
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// Now in "apply" phase
/******/ 		hotSetStatus("apply");
/******/
/******/ 		hotCurrentHash = hotUpdateNewHash;
/******/
/******/ 		// insert new code
/******/ 		for (moduleId in appliedUpdate) {
/******/ 			if (Object.prototype.hasOwnProperty.call(appliedUpdate, moduleId)) {
/******/ 				modules[moduleId] = appliedUpdate[moduleId];
/******/ 			}
/******/ 		}
/******/
/******/ 		// call accept handlers
/******/ 		var error = null;
/******/ 		for (moduleId in outdatedDependencies) {
/******/ 			if (
/******/ 				Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)
/******/ 			) {
/******/ 				module = installedModules[moduleId];
/******/ 				if (module) {
/******/ 					moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 					var callbacks = [];
/******/ 					for (i = 0; i < moduleOutdatedDependencies.length; i++) {
/******/ 						dependency = moduleOutdatedDependencies[i];
/******/ 						cb = module.hot._acceptedDependencies[dependency];
/******/ 						if (cb) {
/******/ 							if (callbacks.indexOf(cb) !== -1) continue;
/******/ 							callbacks.push(cb);
/******/ 						}
/******/ 					}
/******/ 					for (i = 0; i < callbacks.length; i++) {
/******/ 						cb = callbacks[i];
/******/ 						try {
/******/ 							cb(moduleOutdatedDependencies);
/******/ 						} catch (err) {
/******/ 							if (options.onErrored) {
/******/ 								options.onErrored({
/******/ 									type: "accept-errored",
/******/ 									moduleId: moduleId,
/******/ 									dependencyId: moduleOutdatedDependencies[i],
/******/ 									error: err
/******/ 								});
/******/ 							}
/******/ 							if (!options.ignoreErrored) {
/******/ 								if (!error) error = err;
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// Load self accepted modules
/******/ 		for (i = 0; i < outdatedSelfAcceptedModules.length; i++) {
/******/ 			var item = outdatedSelfAcceptedModules[i];
/******/ 			moduleId = item.module;
/******/ 			hotCurrentParents = [moduleId];
/******/ 			try {
/******/ 				__webpack_require__(moduleId);
/******/ 			} catch (err) {
/******/ 				if (typeof item.errorHandler === "function") {
/******/ 					try {
/******/ 						item.errorHandler(err);
/******/ 					} catch (err2) {
/******/ 						if (options.onErrored) {
/******/ 							options.onErrored({
/******/ 								type: "self-accept-error-handler-errored",
/******/ 								moduleId: moduleId,
/******/ 								error: err2,
/******/ 								originalError: err
/******/ 							});
/******/ 						}
/******/ 						if (!options.ignoreErrored) {
/******/ 							if (!error) error = err2;
/******/ 						}
/******/ 						if (!error) error = err;
/******/ 					}
/******/ 				} else {
/******/ 					if (options.onErrored) {
/******/ 						options.onErrored({
/******/ 							type: "self-accept-errored",
/******/ 							moduleId: moduleId,
/******/ 							error: err
/******/ 						});
/******/ 					}
/******/ 					if (!options.ignoreErrored) {
/******/ 						if (!error) error = err;
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// handle errors in accept handlers and self accepted module load
/******/ 		if (error) {
/******/ 			hotSetStatus("fail");
/******/ 			return Promise.reject(error);
/******/ 		}
/******/
/******/ 		hotSetStatus("idle");
/******/ 		return new Promise(function(resolve) {
/******/ 			resolve(outdatedModules);
/******/ 		});
/******/ 	}
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {},
/******/ 			hot: hotCreateModule(moduleId),
/******/ 			parents: (hotCurrentParentsTemp = hotCurrentParents, hotCurrentParents = [], hotCurrentParentsTemp),
/******/ 			children: []
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, hotCreateRequire(moduleId));
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// __webpack_hash__
/******/ 	__webpack_require__.h = function() { return hotCurrentHash; };
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return hotCreateRequire("./test/script.js")(__webpack_require__.s = "./test/script.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@kissmybutton/motorcortex/dist/IncidentFromDefinition/incidentFromDescription.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/IncidentFromDefinition/incidentFromDescription.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar Group = __webpack_require__(/*! ../_BaseClasses/Group */ \"./node_modules/@kissmybutton/motorcortex/dist/_BaseClasses/Group.js\");\n\nvar DOMAwareIncident = __webpack_require__(/*! ../_responsiveness/DOMAwareIncident */ \"./node_modules/@kissmybutton/motorcortex/dist/_responsiveness/DOMAwareIncident.js\");\n\nvar DOMAwareClipIncident = __webpack_require__(/*! ../_responsiveness/DOMAwareClipIncident */ \"./node_modules/@kissmybutton/motorcortex/dist/_responsiveness/DOMAwareClipIncident.js\");\n\nvar incidentFromIngredients = __webpack_require__(/*! ./incidentFromIngredients */ \"./node_modules/@kissmybutton/motorcortex/dist/IncidentFromDefinition/incidentFromIngredients.js\");\n\nvar Channel = __webpack_require__(/*! ../_Channels/Channel */ \"./node_modules/@kissmybutton/motorcortex/dist/_Channels/Channel.js\");\n\nfunction incidentFromDescription(descriptiveIncident, contextData) {\n  /*\n  RULES:\n  - Groups can never have selectors\n  - Clips can only have selectors (and not hosts) as they participate on a Desc. Tree\n      and thus they are Clips As Incidents. The DescriptiveClips are treated a bit\n      different compared to the rest of the Incidents as they copy all of the\n      Description channels and lanes\n  - Descriptive Incidents can either have or not have selectors\n  - Descriptive Compos always have selectors\n   All Incidents of the tree, no matter their type have the static properties:\n  - Incident (which is the Incident class they need to initialise)\n  - plugin_npm_name (the plugin name they bolong to)\n  - Channel (the Channel class to handle the instance)\n  */\n  var incidentToReturn;\n\n  if (descriptiveIncident.constructor.isClip === true) {\n    incidentToReturn = new DOMAwareClipIncident(descriptiveIncident, contextData); // console.log(`incidentToReturn = ${incidentToReturn.constructor.name}`);\n\n    incidentToReturn.plugin_channel_class = Channel;\n  } else if (descriptiveIncident.constructor.Incident === Group) {\n    incidentToReturn = incidentFromIngredients({\n      id: descriptiveIncident.id,\n      attrs: descriptiveIncident.attrs,\n      props: descriptiveIncident.props,\n      Incident: descriptiveIncident.constructor.Incident,\n      plugin_npm_name: descriptiveIncident.constructor.plugin_npm_name,\n      Channel: descriptiveIncident.constructor.Channel\n    });\n\n    for (var incId in descriptiveIncident.children) {\n      var childIncident = incidentFromDescription(descriptiveIncident.children[incId].leaf, contextData);\n      incidentToReturn.addChild(childIncident, descriptiveIncident.children[incId].position);\n    }\n  } else {\n    // if it is an Incident that extends the TimeIncident (not a Group) then\n    // we should anaylse it to its element/attribute Incidents starting from\n    // the elements, that's why we create a DOMAwareIncident. It is our\n    // starting point to which the TimedIncident will be analysed to its\n    // element/attributes children.\n    incidentToReturn = new DOMAwareIncident(descriptiveIncident, contextData);\n  }\n\n  return incidentToReturn;\n}\n\nmodule.exports = incidentFromDescription;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L0luY2lkZW50RnJvbURlZmluaXRpb24vaW5jaWRlbnRGcm9tRGVzY3JpcHRpb24uanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L0luY2lkZW50RnJvbURlZmluaXRpb24vaW5jaWRlbnRGcm9tRGVzY3JpcHRpb24uanM/YTAwNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIEdyb3VwID0gcmVxdWlyZSgnLi4vX0Jhc2VDbGFzc2VzL0dyb3VwJyk7XG5cbnZhciBET01Bd2FyZUluY2lkZW50ID0gcmVxdWlyZSgnLi4vX3Jlc3BvbnNpdmVuZXNzL0RPTUF3YXJlSW5jaWRlbnQnKTtcblxudmFyIERPTUF3YXJlQ2xpcEluY2lkZW50ID0gcmVxdWlyZSgnLi4vX3Jlc3BvbnNpdmVuZXNzL0RPTUF3YXJlQ2xpcEluY2lkZW50Jyk7XG5cbnZhciBpbmNpZGVudEZyb21JbmdyZWRpZW50cyA9IHJlcXVpcmUoJy4vaW5jaWRlbnRGcm9tSW5ncmVkaWVudHMnKTtcblxudmFyIENoYW5uZWwgPSByZXF1aXJlKCcuLi9fQ2hhbm5lbHMvQ2hhbm5lbCcpO1xuXG5mdW5jdGlvbiBpbmNpZGVudEZyb21EZXNjcmlwdGlvbihkZXNjcmlwdGl2ZUluY2lkZW50LCBjb250ZXh0RGF0YSkge1xuICAvKlxuICBSVUxFUzpcbiAgLSBHcm91cHMgY2FuIG5ldmVyIGhhdmUgc2VsZWN0b3JzXG4gIC0gQ2xpcHMgY2FuIG9ubHkgaGF2ZSBzZWxlY3RvcnMgKGFuZCBub3QgaG9zdHMpIGFzIHRoZXkgcGFydGljaXBhdGUgb24gYSBEZXNjLiBUcmVlXG4gICAgICBhbmQgdGh1cyB0aGV5IGFyZSBDbGlwcyBBcyBJbmNpZGVudHMuIFRoZSBEZXNjcmlwdGl2ZUNsaXBzIGFyZSB0cmVhdGVkIGEgYml0XG4gICAgICBkaWZmZXJlbnQgY29tcGFyZWQgdG8gdGhlIHJlc3Qgb2YgdGhlIEluY2lkZW50cyBhcyB0aGV5IGNvcHkgYWxsIG9mIHRoZVxuICAgICAgRGVzY3JpcHRpb24gY2hhbm5lbHMgYW5kIGxhbmVzXG4gIC0gRGVzY3JpcHRpdmUgSW5jaWRlbnRzIGNhbiBlaXRoZXIgaGF2ZSBvciBub3QgaGF2ZSBzZWxlY3RvcnNcbiAgLSBEZXNjcmlwdGl2ZSBDb21wb3MgYWx3YXlzIGhhdmUgc2VsZWN0b3JzXG4gICBBbGwgSW5jaWRlbnRzIG9mIHRoZSB0cmVlLCBubyBtYXR0ZXIgdGhlaXIgdHlwZSBoYXZlIHRoZSBzdGF0aWMgcHJvcGVydGllczpcbiAgLSBJbmNpZGVudCAod2hpY2ggaXMgdGhlIEluY2lkZW50IGNsYXNzIHRoZXkgbmVlZCB0byBpbml0aWFsaXNlKVxuICAtIHBsdWdpbl9ucG1fbmFtZSAodGhlIHBsdWdpbiBuYW1lIHRoZXkgYm9sb25nIHRvKVxuICAtIENoYW5uZWwgKHRoZSBDaGFubmVsIGNsYXNzIHRvIGhhbmRsZSB0aGUgaW5zdGFuY2UpXG4gICovXG4gIHZhciBpbmNpZGVudFRvUmV0dXJuO1xuXG4gIGlmIChkZXNjcmlwdGl2ZUluY2lkZW50LmNvbnN0cnVjdG9yLmlzQ2xpcCA9PT0gdHJ1ZSkge1xuICAgIGluY2lkZW50VG9SZXR1cm4gPSBuZXcgRE9NQXdhcmVDbGlwSW5jaWRlbnQoZGVzY3JpcHRpdmVJbmNpZGVudCwgY29udGV4dERhdGEpOyAvLyBjb25zb2xlLmxvZyhgaW5jaWRlbnRUb1JldHVybiA9ICR7aW5jaWRlbnRUb1JldHVybi5jb25zdHJ1Y3Rvci5uYW1lfWApO1xuXG4gICAgaW5jaWRlbnRUb1JldHVybi5wbHVnaW5fY2hhbm5lbF9jbGFzcyA9IENoYW5uZWw7XG4gIH0gZWxzZSBpZiAoZGVzY3JpcHRpdmVJbmNpZGVudC5jb25zdHJ1Y3Rvci5JbmNpZGVudCA9PT0gR3JvdXApIHtcbiAgICBpbmNpZGVudFRvUmV0dXJuID0gaW5jaWRlbnRGcm9tSW5ncmVkaWVudHMoe1xuICAgICAgaWQ6IGRlc2NyaXB0aXZlSW5jaWRlbnQuaWQsXG4gICAgICBhdHRyczogZGVzY3JpcHRpdmVJbmNpZGVudC5hdHRycyxcbiAgICAgIHByb3BzOiBkZXNjcmlwdGl2ZUluY2lkZW50LnByb3BzLFxuICAgICAgSW5jaWRlbnQ6IGRlc2NyaXB0aXZlSW5jaWRlbnQuY29uc3RydWN0b3IuSW5jaWRlbnQsXG4gICAgICBwbHVnaW5fbnBtX25hbWU6IGRlc2NyaXB0aXZlSW5jaWRlbnQuY29uc3RydWN0b3IucGx1Z2luX25wbV9uYW1lLFxuICAgICAgQ2hhbm5lbDogZGVzY3JpcHRpdmVJbmNpZGVudC5jb25zdHJ1Y3Rvci5DaGFubmVsXG4gICAgfSk7XG5cbiAgICBmb3IgKHZhciBpbmNJZCBpbiBkZXNjcmlwdGl2ZUluY2lkZW50LmNoaWxkcmVuKSB7XG4gICAgICB2YXIgY2hpbGRJbmNpZGVudCA9IGluY2lkZW50RnJvbURlc2NyaXB0aW9uKGRlc2NyaXB0aXZlSW5jaWRlbnQuY2hpbGRyZW5baW5jSWRdLmxlYWYsIGNvbnRleHREYXRhKTtcbiAgICAgIGluY2lkZW50VG9SZXR1cm4uYWRkQ2hpbGQoY2hpbGRJbmNpZGVudCwgZGVzY3JpcHRpdmVJbmNpZGVudC5jaGlsZHJlbltpbmNJZF0ucG9zaXRpb24pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBpZiBpdCBpcyBhbiBJbmNpZGVudCB0aGF0IGV4dGVuZHMgdGhlIFRpbWVJbmNpZGVudCAobm90IGEgR3JvdXApIHRoZW5cbiAgICAvLyB3ZSBzaG91bGQgYW5heWxzZSBpdCB0byBpdHMgZWxlbWVudC9hdHRyaWJ1dGUgSW5jaWRlbnRzIHN0YXJ0aW5nIGZyb21cbiAgICAvLyB0aGUgZWxlbWVudHMsIHRoYXQncyB3aHkgd2UgY3JlYXRlIGEgRE9NQXdhcmVJbmNpZGVudC4gSXQgaXMgb3VyXG4gICAgLy8gc3RhcnRpbmcgcG9pbnQgdG8gd2hpY2ggdGhlIFRpbWVkSW5jaWRlbnQgd2lsbCBiZSBhbmFseXNlZCB0byBpdHNcbiAgICAvLyBlbGVtZW50L2F0dHJpYnV0ZXMgY2hpbGRyZW4uXG4gICAgaW5jaWRlbnRUb1JldHVybiA9IG5ldyBET01Bd2FyZUluY2lkZW50KGRlc2NyaXB0aXZlSW5jaWRlbnQsIGNvbnRleHREYXRhKTtcbiAgfVxuXG4gIHJldHVybiBpbmNpZGVudFRvUmV0dXJuO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluY2lkZW50RnJvbURlc2NyaXB0aW9uOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/IncidentFromDefinition/incidentFromDescription.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/IncidentFromDefinition/incidentFromIngredients.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/IncidentFromDefinition/incidentFromIngredients.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar Helper = __webpack_require__(/*! ../_coreUtils/Helper */ \"./node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\");\n\nvar helper = new Helper();\n/**\n * @param {object} ingredients -\n * {\n *      id\n *      attrs\n *      props\n *      Incident\n *      plugin_npm_name\n *      Channel\n *      context (optional)\n *      mcid (optional)\n *      dnaExtras\n * }\n **/\n\nmodule.exports = function (ingredients) {\n  if (!Object.prototype.hasOwnProperty.call(ingredients, \"dnaExtras\")) {\n    ingredients.dnaExtras = {};\n  }\n\n  var incident = new ingredients.Incident(ingredients.attrs, _objectSpread({}, ingredients.props, {\n    id: ingredients.id || helper.getAnId()\n  }), _objectSpread({}, ingredients.dnaExtras, {\n    context: ingredients.context,\n    mcid: ingredients.mcid\n  }));\n  incident.mc_plugin_npm_name = ingredients.plugin_npm_name;\n  incident.plugin_channel_class = ingredients.Channel;\n  return incident;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L0luY2lkZW50RnJvbURlZmluaXRpb24vaW5jaWRlbnRGcm9tSW5ncmVkaWVudHMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L0luY2lkZW50RnJvbURlZmluaXRpb24vaW5jaWRlbnRGcm9tSW5ncmVkaWVudHMuanM/NGI3MyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IHZhciBvd25LZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTsgaWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSAnZnVuY3Rpb24nKSB7IG93bktleXMgPSBvd25LZXlzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSkuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBzeW0pLmVudW1lcmFibGU7IH0pKTsgfSBvd25LZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG52YXIgSGVscGVyID0gcmVxdWlyZSgnLi4vX2NvcmVVdGlscy9IZWxwZXInKTtcblxudmFyIGhlbHBlciA9IG5ldyBIZWxwZXIoKTtcbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGluZ3JlZGllbnRzIC1cbiAqIHtcbiAqICAgICAgaWRcbiAqICAgICAgYXR0cnNcbiAqICAgICAgcHJvcHNcbiAqICAgICAgSW5jaWRlbnRcbiAqICAgICAgcGx1Z2luX25wbV9uYW1lXG4gKiAgICAgIENoYW5uZWxcbiAqICAgICAgY29udGV4dCAob3B0aW9uYWwpXG4gKiAgICAgIG1jaWQgKG9wdGlvbmFsKVxuICogICAgICBkbmFFeHRyYXNcbiAqIH1cbiAqKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5ncmVkaWVudHMpIHtcbiAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaW5ncmVkaWVudHMsIFwiZG5hRXh0cmFzXCIpKSB7XG4gICAgaW5ncmVkaWVudHMuZG5hRXh0cmFzID0ge307XG4gIH1cblxuICB2YXIgaW5jaWRlbnQgPSBuZXcgaW5ncmVkaWVudHMuSW5jaWRlbnQoaW5ncmVkaWVudHMuYXR0cnMsIF9vYmplY3RTcHJlYWQoe30sIGluZ3JlZGllbnRzLnByb3BzLCB7XG4gICAgaWQ6IGluZ3JlZGllbnRzLmlkIHx8IGhlbHBlci5nZXRBbklkKClcbiAgfSksIF9vYmplY3RTcHJlYWQoe30sIGluZ3JlZGllbnRzLmRuYUV4dHJhcywge1xuICAgIGNvbnRleHQ6IGluZ3JlZGllbnRzLmNvbnRleHQsXG4gICAgbWNpZDogaW5ncmVkaWVudHMubWNpZFxuICB9KSk7XG4gIGluY2lkZW50Lm1jX3BsdWdpbl9ucG1fbmFtZSA9IGluZ3JlZGllbnRzLnBsdWdpbl9ucG1fbmFtZTtcbiAgaW5jaWRlbnQucGx1Z2luX2NoYW5uZWxfY2xhc3MgPSBpbmdyZWRpZW50cy5DaGFubmVsO1xuICByZXR1cm4gaW5jaWRlbnQ7XG59OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/IncidentFromDefinition/incidentFromIngredients.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/_BaseClasses/Group.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/_BaseClasses/Group.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _decorate(decorators, factory, superClass, mixins) { var api = _getDecoratorsApi(); if (mixins) { for (var i = 0; i < mixins.length; i++) { api = mixins[i](api); } } var r = factory(function initialize(O) { api.initializeInstanceElements(O, decorated.elements); }, superClass); var decorated = api.decorateClass(_coalesceClassElements(r.d.map(_createElementDescriptor)), decorators); api.initializeClassElements(r.F, decorated.elements); return api.runClassFinishers(r.F, decorated.finishers); }\n\nfunction _getDecoratorsApi() { _getDecoratorsApi = function _getDecoratorsApi() { return api; }; var api = { elementsDefinitionOrder: [[\"method\"], [\"field\"]], initializeInstanceElements: function initializeInstanceElements(O, elements) { [\"method\", \"field\"].forEach(function (kind) { elements.forEach(function (element) { if (element.kind === kind && element.placement === \"own\") { this.defineClassElement(O, element); } }, this); }, this); }, initializeClassElements: function initializeClassElements(F, elements) { var proto = F.prototype; [\"method\", \"field\"].forEach(function (kind) { elements.forEach(function (element) { var placement = element.placement; if (element.kind === kind && (placement === \"static\" || placement === \"prototype\")) { var receiver = placement === \"static\" ? F : proto; this.defineClassElement(receiver, element); } }, this); }, this); }, defineClassElement: function defineClassElement(receiver, element) { var descriptor = element.descriptor; if (element.kind === \"field\") { var initializer = element.initializer; descriptor = { enumerable: descriptor.enumerable, writable: descriptor.writable, configurable: descriptor.configurable, value: initializer === void 0 ? void 0 : initializer.call(receiver) }; } Object.defineProperty(receiver, element.key, descriptor); }, decorateClass: function decorateClass(elements, decorators) { var newElements = []; var finishers = []; var placements = { \"static\": [], prototype: [], own: [] }; elements.forEach(function (element) { this.addElementPlacement(element, placements); }, this); elements.forEach(function (element) { if (!_hasDecorators(element)) return newElements.push(element); var elementFinishersExtras = this.decorateElement(element, placements); newElements.push(elementFinishersExtras.element); newElements.push.apply(newElements, elementFinishersExtras.extras); finishers.push.apply(finishers, elementFinishersExtras.finishers); }, this); if (!decorators) { return { elements: newElements, finishers: finishers }; } var result = this.decorateConstructor(newElements, decorators); finishers.push.apply(finishers, result.finishers); result.finishers = finishers; return result; }, addElementPlacement: function addElementPlacement(element, placements, silent) { var keys = placements[element.placement]; if (!silent && keys.indexOf(element.key) !== -1) { throw new TypeError(\"Duplicated element (\" + element.key + \")\"); } keys.push(element.key); }, decorateElement: function decorateElement(element, placements) { var extras = []; var finishers = []; for (var decorators = element.decorators, i = decorators.length - 1; i >= 0; i--) { var keys = placements[element.placement]; keys.splice(keys.indexOf(element.key), 1); var elementObject = this.fromElementDescriptor(element); var elementFinisherExtras = this.toElementFinisherExtras((0, decorators[i])(elementObject) || elementObject); element = elementFinisherExtras.element; this.addElementPlacement(element, placements); if (elementFinisherExtras.finisher) { finishers.push(elementFinisherExtras.finisher); } var newExtras = elementFinisherExtras.extras; if (newExtras) { for (var j = 0; j < newExtras.length; j++) { this.addElementPlacement(newExtras[j], placements); } extras.push.apply(extras, newExtras); } } return { element: element, finishers: finishers, extras: extras }; }, decorateConstructor: function decorateConstructor(elements, decorators) { var finishers = []; for (var i = decorators.length - 1; i >= 0; i--) { var obj = this.fromClassDescriptor(elements); var elementsAndFinisher = this.toClassDescriptor((0, decorators[i])(obj) || obj); if (elementsAndFinisher.finisher !== undefined) { finishers.push(elementsAndFinisher.finisher); } if (elementsAndFinisher.elements !== undefined) { elements = elementsAndFinisher.elements; for (var j = 0; j < elements.length - 1; j++) { for (var k = j + 1; k < elements.length; k++) { if (elements[j].key === elements[k].key && elements[j].placement === elements[k].placement) { throw new TypeError(\"Duplicated element (\" + elements[j].key + \")\"); } } } } } return { elements: elements, finishers: finishers }; }, fromElementDescriptor: function fromElementDescriptor(element) { var obj = { kind: element.kind, key: element.key, placement: element.placement, descriptor: element.descriptor }; var desc = { value: \"Descriptor\", configurable: true }; Object.defineProperty(obj, Symbol.toStringTag, desc); if (element.kind === \"field\") obj.initializer = element.initializer; return obj; }, toElementDescriptors: function toElementDescriptors(elementObjects) { if (elementObjects === undefined) return; return _toArray(elementObjects).map(function (elementObject) { var element = this.toElementDescriptor(elementObject); this.disallowProperty(elementObject, \"finisher\", \"An element descriptor\"); this.disallowProperty(elementObject, \"extras\", \"An element descriptor\"); return element; }, this); }, toElementDescriptor: function toElementDescriptor(elementObject) { var kind = String(elementObject.kind); if (kind !== \"method\" && kind !== \"field\") { throw new TypeError('An element descriptor\\'s .kind property must be either \"method\" or' + ' \"field\", but a decorator created an element descriptor with' + ' .kind \"' + kind + '\"'); } var key = _toPropertyKey(elementObject.key); var placement = String(elementObject.placement); if (placement !== \"static\" && placement !== \"prototype\" && placement !== \"own\") { throw new TypeError('An element descriptor\\'s .placement property must be one of \"static\",' + ' \"prototype\" or \"own\", but a decorator created an element descriptor' + ' with .placement \"' + placement + '\"'); } var descriptor = elementObject.descriptor; this.disallowProperty(elementObject, \"elements\", \"An element descriptor\"); var element = { kind: kind, key: key, placement: placement, descriptor: Object.assign({}, descriptor) }; if (kind !== \"field\") { this.disallowProperty(elementObject, \"initializer\", \"A method descriptor\"); } else { this.disallowProperty(descriptor, \"get\", \"The property descriptor of a field descriptor\"); this.disallowProperty(descriptor, \"set\", \"The property descriptor of a field descriptor\"); this.disallowProperty(descriptor, \"value\", \"The property descriptor of a field descriptor\"); element.initializer = elementObject.initializer; } return element; }, toElementFinisherExtras: function toElementFinisherExtras(elementObject) { var element = this.toElementDescriptor(elementObject); var finisher = _optionalCallableProperty(elementObject, \"finisher\"); var extras = this.toElementDescriptors(elementObject.extras); return { element: element, finisher: finisher, extras: extras }; }, fromClassDescriptor: function fromClassDescriptor(elements) { var obj = { kind: \"class\", elements: elements.map(this.fromElementDescriptor, this) }; var desc = { value: \"Descriptor\", configurable: true }; Object.defineProperty(obj, Symbol.toStringTag, desc); return obj; }, toClassDescriptor: function toClassDescriptor(obj) { var kind = String(obj.kind); if (kind !== \"class\") { throw new TypeError('A class descriptor\\'s .kind property must be \"class\", but a decorator' + ' created a class descriptor with .kind \"' + kind + '\"'); } this.disallowProperty(obj, \"key\", \"A class descriptor\"); this.disallowProperty(obj, \"placement\", \"A class descriptor\"); this.disallowProperty(obj, \"descriptor\", \"A class descriptor\"); this.disallowProperty(obj, \"initializer\", \"A class descriptor\"); this.disallowProperty(obj, \"extras\", \"A class descriptor\"); var finisher = _optionalCallableProperty(obj, \"finisher\"); var elements = this.toElementDescriptors(obj.elements); return { elements: elements, finisher: finisher }; }, runClassFinishers: function runClassFinishers(constructor, finishers) { for (var i = 0; i < finishers.length; i++) { var newConstructor = (0, finishers[i])(constructor); if (newConstructor !== undefined) { if (typeof newConstructor !== \"function\") { throw new TypeError(\"Finishers must return a constructor.\"); } constructor = newConstructor; } } return constructor; }, disallowProperty: function disallowProperty(obj, name, objectType) { if (obj[name] !== undefined) { throw new TypeError(objectType + \" can't have a .\" + name + \" property.\"); } } }; return api; }\n\nfunction _createElementDescriptor(def) { var key = _toPropertyKey(def.key); var descriptor; if (def.kind === \"method\") { descriptor = { value: def.value, writable: true, configurable: true, enumerable: false }; } else if (def.kind === \"get\") { descriptor = { get: def.value, configurable: true, enumerable: false }; } else if (def.kind === \"set\") { descriptor = { set: def.value, configurable: true, enumerable: false }; } else if (def.kind === \"field\") { descriptor = { configurable: true, writable: true, enumerable: true }; } var element = { kind: def.kind === \"field\" ? \"field\" : \"method\", key: key, placement: def[\"static\"] ? \"static\" : def.kind === \"field\" ? \"own\" : \"prototype\", descriptor: descriptor }; if (def.decorators) element.decorators = def.decorators; if (def.kind === \"field\") element.initializer = def.value; return element; }\n\nfunction _coalesceGetterSetter(element, other) { if (element.descriptor.get !== undefined) { other.descriptor.get = element.descriptor.get; } else { other.descriptor.set = element.descriptor.set; } }\n\nfunction _coalesceClassElements(elements) { var newElements = []; var isSameElement = function isSameElement(other) { return other.kind === \"method\" && other.key === element.key && other.placement === element.placement; }; for (var i = 0; i < elements.length; i++) { var element = elements[i]; var other; if (element.kind === \"method\" && (other = newElements.find(isSameElement))) { if (_isDataDescriptor(element.descriptor) || _isDataDescriptor(other.descriptor)) { if (_hasDecorators(element) || _hasDecorators(other)) { throw new ReferenceError(\"Duplicated methods (\" + element.key + \") can't be decorated.\"); } other.descriptor = element.descriptor; } else { if (_hasDecorators(element)) { if (_hasDecorators(other)) { throw new ReferenceError(\"Decorators can't be placed on different accessors with for \" + \"the same property (\" + element.key + \").\"); } other.decorators = element.decorators; } _coalesceGetterSetter(element, other); } } else { newElements.push(element); } } return newElements; }\n\nfunction _hasDecorators(element) { return element.decorators && element.decorators.length; }\n\nfunction _isDataDescriptor(desc) { return desc !== undefined && !(desc.value === undefined && desc.writable === undefined); }\n\nfunction _optionalCallableProperty(obj, name) { var value = obj[name]; if (value !== undefined && typeof value !== \"function\") { throw new TypeError(\"Expected '\" + name + \"' to be a function\"); } return value; }\n\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\n\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\nfunction _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nvar Node = __webpack_require__(/*! ../_Tree/Node */ \"./node_modules/@kissmybutton/motorcortex/dist/_Tree/Node.js\");\n\nvar Channel = __webpack_require__(/*! ../_Channels/Channel */ \"./node_modules/@kissmybutton/motorcortex/dist/_Channels/Channel.js\");\n\nvar handleResize = __webpack_require__(/*! ./decorators/handleResize */ \"./node_modules/@kissmybutton/motorcortex/dist/_BaseClasses/decorators/handleResize.js\");\n\nvar Group = _decorate(null, function (_initialize, _Node) {\n  var Group =\n  /*#__PURE__*/\n  function (_Node2) {\n    _inherits(Group, _Node2);\n\n    function Group(attrs, props) {\n      var _this;\n\n      _classCallCheck(this, Group);\n\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(Group).call(this, props));\n\n      _initialize(_assertThisInitialized(_this));\n\n      _this.mc_plugin_npm_name = 'motor-cortex-js';\n      _this.plugin_channel_class = Channel;\n      _this.hasIncidents = true;\n\n      _this.onGroupInitialise();\n\n      _this.calculatedDuration = 0;\n      return _this;\n    }\n\n    return Group;\n  }(_Node);\n\n  return {\n    F: Group,\n    d: [{\n      kind: \"method\",\n      key: \"onGroupInitialise\",\n      value: function onGroupInitialise() {// called when group gets initialised\n      }\n    }, {\n      kind: \"method\",\n      key: \"handleAddIncident\",\n      value: function handleAddIncident(target, payload) {\n        if (this.id === target) {\n          var incidentFromDescription = __webpack_require__(/*! ../IncidentFromDefinition/incidentFromDescription */ \"./node_modules/@kissmybutton/motorcortex/dist/IncidentFromDefinition/incidentFromDescription.js\");\n\n          return incidentFromDescription(payload.incident, payload.contextData);\n        } else {\n          return this.bypass();\n        }\n      }\n    }, {\n      kind: \"method\",\n      key: \"handleMoveIncident\",\n      value: function handleMoveIncident(target, payload) {\n        if (this.id === target) {\n          return this.getLeafById(payload.incidentId, true);\n        } else {\n          return this.bypass();\n        }\n      }\n    }, {\n      kind: \"method\",\n      key: \"handleRemoveIncident\",\n      value: function handleRemoveIncident(target, payload) {\n        if (this.id === target) {\n          return this.getLeafById(payload.incidentId, true);\n        } else {\n          return this.bypass();\n        }\n      }\n    }, {\n      kind: \"method\",\n      decorators: [handleResize],\n      key: \"handleResize\",\n      value: function handleResize() {}\n    }, {\n      kind: \"method\",\n      key: \"removeChild\",\n      value: function removeChild(id) {\n        this.children[id].leaf.lastWish();\n\n        _get(_getPrototypeOf(Group.prototype), \"removeChild\", this).call(this, id);\n      }\n      /**\n       * Returns an object that has the key of the npm plugin name the Channel of which manages the specific Incident\n       * With the same logic all Incidents that belong to this Group as categorised by plugin / channel on the same object\n       */\n\n    }, {\n      kind: \"method\",\n      key: \"getIncidentsByChannel\",\n      value: function getIncidentsByChannel() {\n        var adjustMillisecond = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n        var parentMillisecond = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n        // initially it only puts itself onthe incidentsByPlugin array, exactly as the plain Incidents do\n        var incidentsByPlugin = {};\n        incidentsByPlugin['motor-cortex-js'] = [{\n          millisecond: adjustMillisecond,\n          parentMillisecond: parentMillisecond,\n          incident: this,\n          id: this.id\n        }]; // proceed to gather the contained incidents as well\n\n        for (var childId in this.children) {\n          var child = this.children[childId];\n          var incidentsToAdd = child.leaf.getIncidentsByChannel(adjustMillisecond + child.position, adjustMillisecond);\n\n          for (var key in incidentsToAdd) {\n            if (Object.prototype.hasOwnProperty.call(incidentsByPlugin, key)) {\n              incidentsByPlugin[key] = incidentsByPlugin[key].concat(incidentsToAdd[key]);\n            } else {\n              incidentsByPlugin[key] = incidentsToAdd[key];\n            }\n          }\n        }\n\n        return incidentsByPlugin;\n      }\n    }, {\n      kind: \"method\",\n      key: \"lastWish\",\n      value: function lastWish() {\n        for (var childId in this.children) {\n          this.children[childId].leaf.lastWish();\n        }\n      }\n    }]\n  };\n}, Node);\n\nmodule.exports = Group;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19CYXNlQ2xhc3Nlcy9Hcm91cC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Aa2lzc215YnV0dG9uL21vdG9yY29ydGV4L2Rpc3QvX0Jhc2VDbGFzc2VzL0dyb3VwLmpzP2ZmZTEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9kZWNvcmF0ZShkZWNvcmF0b3JzLCBmYWN0b3J5LCBzdXBlckNsYXNzLCBtaXhpbnMpIHsgdmFyIGFwaSA9IF9nZXREZWNvcmF0b3JzQXBpKCk7IGlmIChtaXhpbnMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBtaXhpbnMubGVuZ3RoOyBpKyspIHsgYXBpID0gbWl4aW5zW2ldKGFwaSk7IH0gfSB2YXIgciA9IGZhY3RvcnkoZnVuY3Rpb24gaW5pdGlhbGl6ZShPKSB7IGFwaS5pbml0aWFsaXplSW5zdGFuY2VFbGVtZW50cyhPLCBkZWNvcmF0ZWQuZWxlbWVudHMpOyB9LCBzdXBlckNsYXNzKTsgdmFyIGRlY29yYXRlZCA9IGFwaS5kZWNvcmF0ZUNsYXNzKF9jb2FsZXNjZUNsYXNzRWxlbWVudHMoci5kLm1hcChfY3JlYXRlRWxlbWVudERlc2NyaXB0b3IpKSwgZGVjb3JhdG9ycyk7IGFwaS5pbml0aWFsaXplQ2xhc3NFbGVtZW50cyhyLkYsIGRlY29yYXRlZC5lbGVtZW50cyk7IHJldHVybiBhcGkucnVuQ2xhc3NGaW5pc2hlcnMoci5GLCBkZWNvcmF0ZWQuZmluaXNoZXJzKTsgfVxuXG5mdW5jdGlvbiBfZ2V0RGVjb3JhdG9yc0FwaSgpIHsgX2dldERlY29yYXRvcnNBcGkgPSBmdW5jdGlvbiBfZ2V0RGVjb3JhdG9yc0FwaSgpIHsgcmV0dXJuIGFwaTsgfTsgdmFyIGFwaSA9IHsgZWxlbWVudHNEZWZpbml0aW9uT3JkZXI6IFtbXCJtZXRob2RcIl0sIFtcImZpZWxkXCJdXSwgaW5pdGlhbGl6ZUluc3RhbmNlRWxlbWVudHM6IGZ1bmN0aW9uIGluaXRpYWxpemVJbnN0YW5jZUVsZW1lbnRzKE8sIGVsZW1lbnRzKSB7IFtcIm1ldGhvZFwiLCBcImZpZWxkXCJdLmZvckVhY2goZnVuY3Rpb24gKGtpbmQpIHsgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkgeyBpZiAoZWxlbWVudC5raW5kID09PSBraW5kICYmIGVsZW1lbnQucGxhY2VtZW50ID09PSBcIm93blwiKSB7IHRoaXMuZGVmaW5lQ2xhc3NFbGVtZW50KE8sIGVsZW1lbnQpOyB9IH0sIHRoaXMpOyB9LCB0aGlzKTsgfSwgaW5pdGlhbGl6ZUNsYXNzRWxlbWVudHM6IGZ1bmN0aW9uIGluaXRpYWxpemVDbGFzc0VsZW1lbnRzKEYsIGVsZW1lbnRzKSB7IHZhciBwcm90byA9IEYucHJvdG90eXBlOyBbXCJtZXRob2RcIiwgXCJmaWVsZFwiXS5mb3JFYWNoKGZ1bmN0aW9uIChraW5kKSB7IGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHsgdmFyIHBsYWNlbWVudCA9IGVsZW1lbnQucGxhY2VtZW50OyBpZiAoZWxlbWVudC5raW5kID09PSBraW5kICYmIChwbGFjZW1lbnQgPT09IFwic3RhdGljXCIgfHwgcGxhY2VtZW50ID09PSBcInByb3RvdHlwZVwiKSkgeyB2YXIgcmVjZWl2ZXIgPSBwbGFjZW1lbnQgPT09IFwic3RhdGljXCIgPyBGIDogcHJvdG87IHRoaXMuZGVmaW5lQ2xhc3NFbGVtZW50KHJlY2VpdmVyLCBlbGVtZW50KTsgfSB9LCB0aGlzKTsgfSwgdGhpcyk7IH0sIGRlZmluZUNsYXNzRWxlbWVudDogZnVuY3Rpb24gZGVmaW5lQ2xhc3NFbGVtZW50KHJlY2VpdmVyLCBlbGVtZW50KSB7IHZhciBkZXNjcmlwdG9yID0gZWxlbWVudC5kZXNjcmlwdG9yOyBpZiAoZWxlbWVudC5raW5kID09PSBcImZpZWxkXCIpIHsgdmFyIGluaXRpYWxpemVyID0gZWxlbWVudC5pbml0aWFsaXplcjsgZGVzY3JpcHRvciA9IHsgZW51bWVyYWJsZTogZGVzY3JpcHRvci5lbnVtZXJhYmxlLCB3cml0YWJsZTogZGVzY3JpcHRvci53cml0YWJsZSwgY29uZmlndXJhYmxlOiBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSwgdmFsdWU6IGluaXRpYWxpemVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbml0aWFsaXplci5jYWxsKHJlY2VpdmVyKSB9OyB9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZWNlaXZlciwgZWxlbWVudC5rZXksIGRlc2NyaXB0b3IpOyB9LCBkZWNvcmF0ZUNsYXNzOiBmdW5jdGlvbiBkZWNvcmF0ZUNsYXNzKGVsZW1lbnRzLCBkZWNvcmF0b3JzKSB7IHZhciBuZXdFbGVtZW50cyA9IFtdOyB2YXIgZmluaXNoZXJzID0gW107IHZhciBwbGFjZW1lbnRzID0geyBcInN0YXRpY1wiOiBbXSwgcHJvdG90eXBlOiBbXSwgb3duOiBbXSB9OyBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7IHRoaXMuYWRkRWxlbWVudFBsYWNlbWVudChlbGVtZW50LCBwbGFjZW1lbnRzKTsgfSwgdGhpcyk7IGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHsgaWYgKCFfaGFzRGVjb3JhdG9ycyhlbGVtZW50KSkgcmV0dXJuIG5ld0VsZW1lbnRzLnB1c2goZWxlbWVudCk7IHZhciBlbGVtZW50RmluaXNoZXJzRXh0cmFzID0gdGhpcy5kZWNvcmF0ZUVsZW1lbnQoZWxlbWVudCwgcGxhY2VtZW50cyk7IG5ld0VsZW1lbnRzLnB1c2goZWxlbWVudEZpbmlzaGVyc0V4dHJhcy5lbGVtZW50KTsgbmV3RWxlbWVudHMucHVzaC5hcHBseShuZXdFbGVtZW50cywgZWxlbWVudEZpbmlzaGVyc0V4dHJhcy5leHRyYXMpOyBmaW5pc2hlcnMucHVzaC5hcHBseShmaW5pc2hlcnMsIGVsZW1lbnRGaW5pc2hlcnNFeHRyYXMuZmluaXNoZXJzKTsgfSwgdGhpcyk7IGlmICghZGVjb3JhdG9ycykgeyByZXR1cm4geyBlbGVtZW50czogbmV3RWxlbWVudHMsIGZpbmlzaGVyczogZmluaXNoZXJzIH07IH0gdmFyIHJlc3VsdCA9IHRoaXMuZGVjb3JhdGVDb25zdHJ1Y3RvcihuZXdFbGVtZW50cywgZGVjb3JhdG9ycyk7IGZpbmlzaGVycy5wdXNoLmFwcGx5KGZpbmlzaGVycywgcmVzdWx0LmZpbmlzaGVycyk7IHJlc3VsdC5maW5pc2hlcnMgPSBmaW5pc2hlcnM7IHJldHVybiByZXN1bHQ7IH0sIGFkZEVsZW1lbnRQbGFjZW1lbnQ6IGZ1bmN0aW9uIGFkZEVsZW1lbnRQbGFjZW1lbnQoZWxlbWVudCwgcGxhY2VtZW50cywgc2lsZW50KSB7IHZhciBrZXlzID0gcGxhY2VtZW50c1tlbGVtZW50LnBsYWNlbWVudF07IGlmICghc2lsZW50ICYmIGtleXMuaW5kZXhPZihlbGVtZW50LmtleSkgIT09IC0xKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEdXBsaWNhdGVkIGVsZW1lbnQgKFwiICsgZWxlbWVudC5rZXkgKyBcIilcIik7IH0ga2V5cy5wdXNoKGVsZW1lbnQua2V5KTsgfSwgZGVjb3JhdGVFbGVtZW50OiBmdW5jdGlvbiBkZWNvcmF0ZUVsZW1lbnQoZWxlbWVudCwgcGxhY2VtZW50cykgeyB2YXIgZXh0cmFzID0gW107IHZhciBmaW5pc2hlcnMgPSBbXTsgZm9yICh2YXIgZGVjb3JhdG9ycyA9IGVsZW1lbnQuZGVjb3JhdG9ycywgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHsgdmFyIGtleXMgPSBwbGFjZW1lbnRzW2VsZW1lbnQucGxhY2VtZW50XTsga2V5cy5zcGxpY2Uoa2V5cy5pbmRleE9mKGVsZW1lbnQua2V5KSwgMSk7IHZhciBlbGVtZW50T2JqZWN0ID0gdGhpcy5mcm9tRWxlbWVudERlc2NyaXB0b3IoZWxlbWVudCk7IHZhciBlbGVtZW50RmluaXNoZXJFeHRyYXMgPSB0aGlzLnRvRWxlbWVudEZpbmlzaGVyRXh0cmFzKCgwLCBkZWNvcmF0b3JzW2ldKShlbGVtZW50T2JqZWN0KSB8fCBlbGVtZW50T2JqZWN0KTsgZWxlbWVudCA9IGVsZW1lbnRGaW5pc2hlckV4dHJhcy5lbGVtZW50OyB0aGlzLmFkZEVsZW1lbnRQbGFjZW1lbnQoZWxlbWVudCwgcGxhY2VtZW50cyk7IGlmIChlbGVtZW50RmluaXNoZXJFeHRyYXMuZmluaXNoZXIpIHsgZmluaXNoZXJzLnB1c2goZWxlbWVudEZpbmlzaGVyRXh0cmFzLmZpbmlzaGVyKTsgfSB2YXIgbmV3RXh0cmFzID0gZWxlbWVudEZpbmlzaGVyRXh0cmFzLmV4dHJhczsgaWYgKG5ld0V4dHJhcykgeyBmb3IgKHZhciBqID0gMDsgaiA8IG5ld0V4dHJhcy5sZW5ndGg7IGorKykgeyB0aGlzLmFkZEVsZW1lbnRQbGFjZW1lbnQobmV3RXh0cmFzW2pdLCBwbGFjZW1lbnRzKTsgfSBleHRyYXMucHVzaC5hcHBseShleHRyYXMsIG5ld0V4dHJhcyk7IH0gfSByZXR1cm4geyBlbGVtZW50OiBlbGVtZW50LCBmaW5pc2hlcnM6IGZpbmlzaGVycywgZXh0cmFzOiBleHRyYXMgfTsgfSwgZGVjb3JhdGVDb25zdHJ1Y3RvcjogZnVuY3Rpb24gZGVjb3JhdGVDb25zdHJ1Y3RvcihlbGVtZW50cywgZGVjb3JhdG9ycykgeyB2YXIgZmluaXNoZXJzID0gW107IGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7IHZhciBvYmogPSB0aGlzLmZyb21DbGFzc0Rlc2NyaXB0b3IoZWxlbWVudHMpOyB2YXIgZWxlbWVudHNBbmRGaW5pc2hlciA9IHRoaXMudG9DbGFzc0Rlc2NyaXB0b3IoKDAsIGRlY29yYXRvcnNbaV0pKG9iaikgfHwgb2JqKTsgaWYgKGVsZW1lbnRzQW5kRmluaXNoZXIuZmluaXNoZXIgIT09IHVuZGVmaW5lZCkgeyBmaW5pc2hlcnMucHVzaChlbGVtZW50c0FuZEZpbmlzaGVyLmZpbmlzaGVyKTsgfSBpZiAoZWxlbWVudHNBbmRGaW5pc2hlci5lbGVtZW50cyAhPT0gdW5kZWZpbmVkKSB7IGVsZW1lbnRzID0gZWxlbWVudHNBbmRGaW5pc2hlci5lbGVtZW50czsgZm9yICh2YXIgaiA9IDA7IGogPCBlbGVtZW50cy5sZW5ndGggLSAxOyBqKyspIHsgZm9yICh2YXIgayA9IGogKyAxOyBrIDwgZWxlbWVudHMubGVuZ3RoOyBrKyspIHsgaWYgKGVsZW1lbnRzW2pdLmtleSA9PT0gZWxlbWVudHNba10ua2V5ICYmIGVsZW1lbnRzW2pdLnBsYWNlbWVudCA9PT0gZWxlbWVudHNba10ucGxhY2VtZW50KSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEdXBsaWNhdGVkIGVsZW1lbnQgKFwiICsgZWxlbWVudHNbal0ua2V5ICsgXCIpXCIpOyB9IH0gfSB9IH0gcmV0dXJuIHsgZWxlbWVudHM6IGVsZW1lbnRzLCBmaW5pc2hlcnM6IGZpbmlzaGVycyB9OyB9LCBmcm9tRWxlbWVudERlc2NyaXB0b3I6IGZ1bmN0aW9uIGZyb21FbGVtZW50RGVzY3JpcHRvcihlbGVtZW50KSB7IHZhciBvYmogPSB7IGtpbmQ6IGVsZW1lbnQua2luZCwga2V5OiBlbGVtZW50LmtleSwgcGxhY2VtZW50OiBlbGVtZW50LnBsYWNlbWVudCwgZGVzY3JpcHRvcjogZWxlbWVudC5kZXNjcmlwdG9yIH07IHZhciBkZXNjID0geyB2YWx1ZTogXCJEZXNjcmlwdG9yXCIsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9OyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBTeW1ib2wudG9TdHJpbmdUYWcsIGRlc2MpOyBpZiAoZWxlbWVudC5raW5kID09PSBcImZpZWxkXCIpIG9iai5pbml0aWFsaXplciA9IGVsZW1lbnQuaW5pdGlhbGl6ZXI7IHJldHVybiBvYmo7IH0sIHRvRWxlbWVudERlc2NyaXB0b3JzOiBmdW5jdGlvbiB0b0VsZW1lbnREZXNjcmlwdG9ycyhlbGVtZW50T2JqZWN0cykgeyBpZiAoZWxlbWVudE9iamVjdHMgPT09IHVuZGVmaW5lZCkgcmV0dXJuOyByZXR1cm4gX3RvQXJyYXkoZWxlbWVudE9iamVjdHMpLm1hcChmdW5jdGlvbiAoZWxlbWVudE9iamVjdCkgeyB2YXIgZWxlbWVudCA9IHRoaXMudG9FbGVtZW50RGVzY3JpcHRvcihlbGVtZW50T2JqZWN0KTsgdGhpcy5kaXNhbGxvd1Byb3BlcnR5KGVsZW1lbnRPYmplY3QsIFwiZmluaXNoZXJcIiwgXCJBbiBlbGVtZW50IGRlc2NyaXB0b3JcIik7IHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShlbGVtZW50T2JqZWN0LCBcImV4dHJhc1wiLCBcIkFuIGVsZW1lbnQgZGVzY3JpcHRvclwiKTsgcmV0dXJuIGVsZW1lbnQ7IH0sIHRoaXMpOyB9LCB0b0VsZW1lbnREZXNjcmlwdG9yOiBmdW5jdGlvbiB0b0VsZW1lbnREZXNjcmlwdG9yKGVsZW1lbnRPYmplY3QpIHsgdmFyIGtpbmQgPSBTdHJpbmcoZWxlbWVudE9iamVjdC5raW5kKTsgaWYgKGtpbmQgIT09IFwibWV0aG9kXCIgJiYga2luZCAhPT0gXCJmaWVsZFwiKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0FuIGVsZW1lbnQgZGVzY3JpcHRvclxcJ3MgLmtpbmQgcHJvcGVydHkgbXVzdCBiZSBlaXRoZXIgXCJtZXRob2RcIiBvcicgKyAnIFwiZmllbGRcIiwgYnV0IGEgZGVjb3JhdG9yIGNyZWF0ZWQgYW4gZWxlbWVudCBkZXNjcmlwdG9yIHdpdGgnICsgJyAua2luZCBcIicgKyBraW5kICsgJ1wiJyk7IH0gdmFyIGtleSA9IF90b1Byb3BlcnR5S2V5KGVsZW1lbnRPYmplY3Qua2V5KTsgdmFyIHBsYWNlbWVudCA9IFN0cmluZyhlbGVtZW50T2JqZWN0LnBsYWNlbWVudCk7IGlmIChwbGFjZW1lbnQgIT09IFwic3RhdGljXCIgJiYgcGxhY2VtZW50ICE9PSBcInByb3RvdHlwZVwiICYmIHBsYWNlbWVudCAhPT0gXCJvd25cIikgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdBbiBlbGVtZW50IGRlc2NyaXB0b3JcXCdzIC5wbGFjZW1lbnQgcHJvcGVydHkgbXVzdCBiZSBvbmUgb2YgXCJzdGF0aWNcIiwnICsgJyBcInByb3RvdHlwZVwiIG9yIFwib3duXCIsIGJ1dCBhIGRlY29yYXRvciBjcmVhdGVkIGFuIGVsZW1lbnQgZGVzY3JpcHRvcicgKyAnIHdpdGggLnBsYWNlbWVudCBcIicgKyBwbGFjZW1lbnQgKyAnXCInKTsgfSB2YXIgZGVzY3JpcHRvciA9IGVsZW1lbnRPYmplY3QuZGVzY3JpcHRvcjsgdGhpcy5kaXNhbGxvd1Byb3BlcnR5KGVsZW1lbnRPYmplY3QsIFwiZWxlbWVudHNcIiwgXCJBbiBlbGVtZW50IGRlc2NyaXB0b3JcIik7IHZhciBlbGVtZW50ID0geyBraW5kOiBraW5kLCBrZXk6IGtleSwgcGxhY2VtZW50OiBwbGFjZW1lbnQsIGRlc2NyaXB0b3I6IE9iamVjdC5hc3NpZ24oe30sIGRlc2NyaXB0b3IpIH07IGlmIChraW5kICE9PSBcImZpZWxkXCIpIHsgdGhpcy5kaXNhbGxvd1Byb3BlcnR5KGVsZW1lbnRPYmplY3QsIFwiaW5pdGlhbGl6ZXJcIiwgXCJBIG1ldGhvZCBkZXNjcmlwdG9yXCIpOyB9IGVsc2UgeyB0aGlzLmRpc2FsbG93UHJvcGVydHkoZGVzY3JpcHRvciwgXCJnZXRcIiwgXCJUaGUgcHJvcGVydHkgZGVzY3JpcHRvciBvZiBhIGZpZWxkIGRlc2NyaXB0b3JcIik7IHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShkZXNjcmlwdG9yLCBcInNldFwiLCBcIlRoZSBwcm9wZXJ0eSBkZXNjcmlwdG9yIG9mIGEgZmllbGQgZGVzY3JpcHRvclwiKTsgdGhpcy5kaXNhbGxvd1Byb3BlcnR5KGRlc2NyaXB0b3IsIFwidmFsdWVcIiwgXCJUaGUgcHJvcGVydHkgZGVzY3JpcHRvciBvZiBhIGZpZWxkIGRlc2NyaXB0b3JcIik7IGVsZW1lbnQuaW5pdGlhbGl6ZXIgPSBlbGVtZW50T2JqZWN0LmluaXRpYWxpemVyOyB9IHJldHVybiBlbGVtZW50OyB9LCB0b0VsZW1lbnRGaW5pc2hlckV4dHJhczogZnVuY3Rpb24gdG9FbGVtZW50RmluaXNoZXJFeHRyYXMoZWxlbWVudE9iamVjdCkgeyB2YXIgZWxlbWVudCA9IHRoaXMudG9FbGVtZW50RGVzY3JpcHRvcihlbGVtZW50T2JqZWN0KTsgdmFyIGZpbmlzaGVyID0gX29wdGlvbmFsQ2FsbGFibGVQcm9wZXJ0eShlbGVtZW50T2JqZWN0LCBcImZpbmlzaGVyXCIpOyB2YXIgZXh0cmFzID0gdGhpcy50b0VsZW1lbnREZXNjcmlwdG9ycyhlbGVtZW50T2JqZWN0LmV4dHJhcyk7IHJldHVybiB7IGVsZW1lbnQ6IGVsZW1lbnQsIGZpbmlzaGVyOiBmaW5pc2hlciwgZXh0cmFzOiBleHRyYXMgfTsgfSwgZnJvbUNsYXNzRGVzY3JpcHRvcjogZnVuY3Rpb24gZnJvbUNsYXNzRGVzY3JpcHRvcihlbGVtZW50cykgeyB2YXIgb2JqID0geyBraW5kOiBcImNsYXNzXCIsIGVsZW1lbnRzOiBlbGVtZW50cy5tYXAodGhpcy5mcm9tRWxlbWVudERlc2NyaXB0b3IsIHRoaXMpIH07IHZhciBkZXNjID0geyB2YWx1ZTogXCJEZXNjcmlwdG9yXCIsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9OyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBTeW1ib2wudG9TdHJpbmdUYWcsIGRlc2MpOyByZXR1cm4gb2JqOyB9LCB0b0NsYXNzRGVzY3JpcHRvcjogZnVuY3Rpb24gdG9DbGFzc0Rlc2NyaXB0b3Iob2JqKSB7IHZhciBraW5kID0gU3RyaW5nKG9iai5raW5kKTsgaWYgKGtpbmQgIT09IFwiY2xhc3NcIikgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdBIGNsYXNzIGRlc2NyaXB0b3JcXCdzIC5raW5kIHByb3BlcnR5IG11c3QgYmUgXCJjbGFzc1wiLCBidXQgYSBkZWNvcmF0b3InICsgJyBjcmVhdGVkIGEgY2xhc3MgZGVzY3JpcHRvciB3aXRoIC5raW5kIFwiJyArIGtpbmQgKyAnXCInKTsgfSB0aGlzLmRpc2FsbG93UHJvcGVydHkob2JqLCBcImtleVwiLCBcIkEgY2xhc3MgZGVzY3JpcHRvclwiKTsgdGhpcy5kaXNhbGxvd1Byb3BlcnR5KG9iaiwgXCJwbGFjZW1lbnRcIiwgXCJBIGNsYXNzIGRlc2NyaXB0b3JcIik7IHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShvYmosIFwiZGVzY3JpcHRvclwiLCBcIkEgY2xhc3MgZGVzY3JpcHRvclwiKTsgdGhpcy5kaXNhbGxvd1Byb3BlcnR5KG9iaiwgXCJpbml0aWFsaXplclwiLCBcIkEgY2xhc3MgZGVzY3JpcHRvclwiKTsgdGhpcy5kaXNhbGxvd1Byb3BlcnR5KG9iaiwgXCJleHRyYXNcIiwgXCJBIGNsYXNzIGRlc2NyaXB0b3JcIik7IHZhciBmaW5pc2hlciA9IF9vcHRpb25hbENhbGxhYmxlUHJvcGVydHkob2JqLCBcImZpbmlzaGVyXCIpOyB2YXIgZWxlbWVudHMgPSB0aGlzLnRvRWxlbWVudERlc2NyaXB0b3JzKG9iai5lbGVtZW50cyk7IHJldHVybiB7IGVsZW1lbnRzOiBlbGVtZW50cywgZmluaXNoZXI6IGZpbmlzaGVyIH07IH0sIHJ1bkNsYXNzRmluaXNoZXJzOiBmdW5jdGlvbiBydW5DbGFzc0ZpbmlzaGVycyhjb25zdHJ1Y3RvciwgZmluaXNoZXJzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgZmluaXNoZXJzLmxlbmd0aDsgaSsrKSB7IHZhciBuZXdDb25zdHJ1Y3RvciA9ICgwLCBmaW5pc2hlcnNbaV0pKGNvbnN0cnVjdG9yKTsgaWYgKG5ld0NvbnN0cnVjdG9yICE9PSB1bmRlZmluZWQpIHsgaWYgKHR5cGVvZiBuZXdDb25zdHJ1Y3RvciAhPT0gXCJmdW5jdGlvblwiKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaW5pc2hlcnMgbXVzdCByZXR1cm4gYSBjb25zdHJ1Y3Rvci5cIik7IH0gY29uc3RydWN0b3IgPSBuZXdDb25zdHJ1Y3RvcjsgfSB9IHJldHVybiBjb25zdHJ1Y3RvcjsgfSwgZGlzYWxsb3dQcm9wZXJ0eTogZnVuY3Rpb24gZGlzYWxsb3dQcm9wZXJ0eShvYmosIG5hbWUsIG9iamVjdFR5cGUpIHsgaWYgKG9ialtuYW1lXSAhPT0gdW5kZWZpbmVkKSB7IHRocm93IG5ldyBUeXBlRXJyb3Iob2JqZWN0VHlwZSArIFwiIGNhbid0IGhhdmUgYSAuXCIgKyBuYW1lICsgXCIgcHJvcGVydHkuXCIpOyB9IH0gfTsgcmV0dXJuIGFwaTsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlRWxlbWVudERlc2NyaXB0b3IoZGVmKSB7IHZhciBrZXkgPSBfdG9Qcm9wZXJ0eUtleShkZWYua2V5KTsgdmFyIGRlc2NyaXB0b3I7IGlmIChkZWYua2luZCA9PT0gXCJtZXRob2RcIikgeyBkZXNjcmlwdG9yID0geyB2YWx1ZTogZGVmLnZhbHVlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCBlbnVtZXJhYmxlOiBmYWxzZSB9OyB9IGVsc2UgaWYgKGRlZi5raW5kID09PSBcImdldFwiKSB7IGRlc2NyaXB0b3IgPSB7IGdldDogZGVmLnZhbHVlLCBjb25maWd1cmFibGU6IHRydWUsIGVudW1lcmFibGU6IGZhbHNlIH07IH0gZWxzZSBpZiAoZGVmLmtpbmQgPT09IFwic2V0XCIpIHsgZGVzY3JpcHRvciA9IHsgc2V0OiBkZWYudmFsdWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZW51bWVyYWJsZTogZmFsc2UgfTsgfSBlbHNlIGlmIChkZWYua2luZCA9PT0gXCJmaWVsZFwiKSB7IGRlc2NyaXB0b3IgPSB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIGVudW1lcmFibGU6IHRydWUgfTsgfSB2YXIgZWxlbWVudCA9IHsga2luZDogZGVmLmtpbmQgPT09IFwiZmllbGRcIiA/IFwiZmllbGRcIiA6IFwibWV0aG9kXCIsIGtleToga2V5LCBwbGFjZW1lbnQ6IGRlZltcInN0YXRpY1wiXSA/IFwic3RhdGljXCIgOiBkZWYua2luZCA9PT0gXCJmaWVsZFwiID8gXCJvd25cIiA6IFwicHJvdG90eXBlXCIsIGRlc2NyaXB0b3I6IGRlc2NyaXB0b3IgfTsgaWYgKGRlZi5kZWNvcmF0b3JzKSBlbGVtZW50LmRlY29yYXRvcnMgPSBkZWYuZGVjb3JhdG9yczsgaWYgKGRlZi5raW5kID09PSBcImZpZWxkXCIpIGVsZW1lbnQuaW5pdGlhbGl6ZXIgPSBkZWYudmFsdWU7IHJldHVybiBlbGVtZW50OyB9XG5cbmZ1bmN0aW9uIF9jb2FsZXNjZUdldHRlclNldHRlcihlbGVtZW50LCBvdGhlcikgeyBpZiAoZWxlbWVudC5kZXNjcmlwdG9yLmdldCAhPT0gdW5kZWZpbmVkKSB7IG90aGVyLmRlc2NyaXB0b3IuZ2V0ID0gZWxlbWVudC5kZXNjcmlwdG9yLmdldDsgfSBlbHNlIHsgb3RoZXIuZGVzY3JpcHRvci5zZXQgPSBlbGVtZW50LmRlc2NyaXB0b3Iuc2V0OyB9IH1cblxuZnVuY3Rpb24gX2NvYWxlc2NlQ2xhc3NFbGVtZW50cyhlbGVtZW50cykgeyB2YXIgbmV3RWxlbWVudHMgPSBbXTsgdmFyIGlzU2FtZUVsZW1lbnQgPSBmdW5jdGlvbiBpc1NhbWVFbGVtZW50KG90aGVyKSB7IHJldHVybiBvdGhlci5raW5kID09PSBcIm1ldGhvZFwiICYmIG90aGVyLmtleSA9PT0gZWxlbWVudC5rZXkgJiYgb3RoZXIucGxhY2VtZW50ID09PSBlbGVtZW50LnBsYWNlbWVudDsgfTsgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgZWxlbWVudCA9IGVsZW1lbnRzW2ldOyB2YXIgb3RoZXI7IGlmIChlbGVtZW50LmtpbmQgPT09IFwibWV0aG9kXCIgJiYgKG90aGVyID0gbmV3RWxlbWVudHMuZmluZChpc1NhbWVFbGVtZW50KSkpIHsgaWYgKF9pc0RhdGFEZXNjcmlwdG9yKGVsZW1lbnQuZGVzY3JpcHRvcikgfHwgX2lzRGF0YURlc2NyaXB0b3Iob3RoZXIuZGVzY3JpcHRvcikpIHsgaWYgKF9oYXNEZWNvcmF0b3JzKGVsZW1lbnQpIHx8IF9oYXNEZWNvcmF0b3JzKG90aGVyKSkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJEdXBsaWNhdGVkIG1ldGhvZHMgKFwiICsgZWxlbWVudC5rZXkgKyBcIikgY2FuJ3QgYmUgZGVjb3JhdGVkLlwiKTsgfSBvdGhlci5kZXNjcmlwdG9yID0gZWxlbWVudC5kZXNjcmlwdG9yOyB9IGVsc2UgeyBpZiAoX2hhc0RlY29yYXRvcnMoZWxlbWVudCkpIHsgaWYgKF9oYXNEZWNvcmF0b3JzKG90aGVyKSkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJEZWNvcmF0b3JzIGNhbid0IGJlIHBsYWNlZCBvbiBkaWZmZXJlbnQgYWNjZXNzb3JzIHdpdGggZm9yIFwiICsgXCJ0aGUgc2FtZSBwcm9wZXJ0eSAoXCIgKyBlbGVtZW50LmtleSArIFwiKS5cIik7IH0gb3RoZXIuZGVjb3JhdG9ycyA9IGVsZW1lbnQuZGVjb3JhdG9yczsgfSBfY29hbGVzY2VHZXR0ZXJTZXR0ZXIoZWxlbWVudCwgb3RoZXIpOyB9IH0gZWxzZSB7IG5ld0VsZW1lbnRzLnB1c2goZWxlbWVudCk7IH0gfSByZXR1cm4gbmV3RWxlbWVudHM7IH1cblxuZnVuY3Rpb24gX2hhc0RlY29yYXRvcnMoZWxlbWVudCkgeyByZXR1cm4gZWxlbWVudC5kZWNvcmF0b3JzICYmIGVsZW1lbnQuZGVjb3JhdG9ycy5sZW5ndGg7IH1cblxuZnVuY3Rpb24gX2lzRGF0YURlc2NyaXB0b3IoZGVzYykgeyByZXR1cm4gZGVzYyAhPT0gdW5kZWZpbmVkICYmICEoZGVzYy52YWx1ZSA9PT0gdW5kZWZpbmVkICYmIGRlc2Mud3JpdGFibGUgPT09IHVuZGVmaW5lZCk7IH1cblxuZnVuY3Rpb24gX29wdGlvbmFsQ2FsbGFibGVQcm9wZXJ0eShvYmosIG5hbWUpIHsgdmFyIHZhbHVlID0gb2JqW25hbWVdOyBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIikgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgJ1wiICsgbmFtZSArIFwiJyB0byBiZSBhIGZ1bmN0aW9uXCIpOyB9IHJldHVybiB2YWx1ZTsgfVxuXG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleShhcmcpIHsgdmFyIGtleSA9IF90b1ByaW1pdGl2ZShhcmcsIFwic3RyaW5nXCIpOyByZXR1cm4gX3R5cGVvZihrZXkpID09PSBcInN5bWJvbFwiID8ga2V5IDogU3RyaW5nKGtleSk7IH1cblxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKGlucHV0LCBoaW50KSB7IGlmIChfdHlwZW9mKGlucHV0KSAhPT0gXCJvYmplY3RcIiB8fCBpbnB1dCA9PT0gbnVsbCkgcmV0dXJuIGlucHV0OyB2YXIgcHJpbSA9IGlucHV0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmIChwcmltICE9PSB1bmRlZmluZWQpIHsgdmFyIHJlcyA9IHByaW0uY2FsbChpbnB1dCwgaGludCB8fCBcImRlZmF1bHRcIik7IGlmIChfdHlwZW9mKHJlcykgIT09IFwib2JqZWN0XCIpIHJldHVybiByZXM7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKGhpbnQgPT09IFwic3RyaW5nXCIgPyBTdHJpbmcgOiBOdW1iZXIpKGlucHV0KTsgfVxuXG5mdW5jdGlvbiBfdG9BcnJheShhcnIpIHsgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7IH1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7IGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGl0ZXIpIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpdGVyKSA9PT0gXCJbb2JqZWN0IEFyZ3VtZW50c11cIikgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7IH1cblxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyOyB9XG5cbmZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7IF9nZXQgPSBSZWZsZWN0LmdldDsgfSBlbHNlIHsgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgdmFyIGJhc2UgPSBfc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTsgaWYgKCFiYXNlKSByZXR1cm47IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7IGlmIChkZXNjLmdldCkgeyByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7IH0gcmV0dXJuIGRlc2MudmFsdWU7IH07IH0gcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTsgfVxuXG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7IHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7IG9iamVjdCA9IF9nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhazsgfSByZXR1cm4gb2JqZWN0OyB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxudmFyIE5vZGUgPSByZXF1aXJlKCcuLi9fVHJlZS9Ob2RlJyk7XG5cbnZhciBDaGFubmVsID0gcmVxdWlyZSgnLi4vX0NoYW5uZWxzL0NoYW5uZWwnKTtcblxudmFyIGhhbmRsZVJlc2l6ZSA9IHJlcXVpcmUoJy4vZGVjb3JhdG9ycy9oYW5kbGVSZXNpemUnKTtcblxudmFyIEdyb3VwID0gX2RlY29yYXRlKG51bGwsIGZ1bmN0aW9uIChfaW5pdGlhbGl6ZSwgX05vZGUpIHtcbiAgdmFyIEdyb3VwID1cbiAgLyojX19QVVJFX18qL1xuICBmdW5jdGlvbiAoX05vZGUyKSB7XG4gICAgX2luaGVyaXRzKEdyb3VwLCBfTm9kZTIpO1xuXG4gICAgZnVuY3Rpb24gR3JvdXAoYXR0cnMsIHByb3BzKSB7XG4gICAgICB2YXIgX3RoaXM7XG5cbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBHcm91cCk7XG5cbiAgICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKEdyb3VwKS5jYWxsKHRoaXMsIHByb3BzKSk7XG5cbiAgICAgIF9pbml0aWFsaXplKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgICAgX3RoaXMubWNfcGx1Z2luX25wbV9uYW1lID0gJ21vdG9yLWNvcnRleC1qcyc7XG4gICAgICBfdGhpcy5wbHVnaW5fY2hhbm5lbF9jbGFzcyA9IENoYW5uZWw7XG4gICAgICBfdGhpcy5oYXNJbmNpZGVudHMgPSB0cnVlO1xuXG4gICAgICBfdGhpcy5vbkdyb3VwSW5pdGlhbGlzZSgpO1xuXG4gICAgICBfdGhpcy5jYWxjdWxhdGVkRHVyYXRpb24gPSAwO1xuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIHJldHVybiBHcm91cDtcbiAgfShfTm9kZSk7XG5cbiAgcmV0dXJuIHtcbiAgICBGOiBHcm91cCxcbiAgICBkOiBbe1xuICAgICAga2luZDogXCJtZXRob2RcIixcbiAgICAgIGtleTogXCJvbkdyb3VwSW5pdGlhbGlzZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uR3JvdXBJbml0aWFsaXNlKCkgey8vIGNhbGxlZCB3aGVuIGdyb3VwIGdldHMgaW5pdGlhbGlzZWRcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBraW5kOiBcIm1ldGhvZFwiLFxuICAgICAga2V5OiBcImhhbmRsZUFkZEluY2lkZW50XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlQWRkSW5jaWRlbnQodGFyZ2V0LCBwYXlsb2FkKSB7XG4gICAgICAgIGlmICh0aGlzLmlkID09PSB0YXJnZXQpIHtcbiAgICAgICAgICB2YXIgaW5jaWRlbnRGcm9tRGVzY3JpcHRpb24gPSByZXF1aXJlKCcuLi9JbmNpZGVudEZyb21EZWZpbml0aW9uL2luY2lkZW50RnJvbURlc2NyaXB0aW9uJyk7XG5cbiAgICAgICAgICByZXR1cm4gaW5jaWRlbnRGcm9tRGVzY3JpcHRpb24ocGF5bG9hZC5pbmNpZGVudCwgcGF5bG9hZC5jb250ZXh0RGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYnlwYXNzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBraW5kOiBcIm1ldGhvZFwiLFxuICAgICAga2V5OiBcImhhbmRsZU1vdmVJbmNpZGVudFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZU1vdmVJbmNpZGVudCh0YXJnZXQsIHBheWxvYWQpIHtcbiAgICAgICAgaWYgKHRoaXMuaWQgPT09IHRhcmdldCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmdldExlYWZCeUlkKHBheWxvYWQuaW5jaWRlbnRJZCwgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYnlwYXNzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBraW5kOiBcIm1ldGhvZFwiLFxuICAgICAga2V5OiBcImhhbmRsZVJlbW92ZUluY2lkZW50XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlUmVtb3ZlSW5jaWRlbnQodGFyZ2V0LCBwYXlsb2FkKSB7XG4gICAgICAgIGlmICh0aGlzLmlkID09PSB0YXJnZXQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXRMZWFmQnlJZChwYXlsb2FkLmluY2lkZW50SWQsIHRydWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLmJ5cGFzcygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2luZDogXCJtZXRob2RcIixcbiAgICAgIGRlY29yYXRvcnM6IFtoYW5kbGVSZXNpemVdLFxuICAgICAga2V5OiBcImhhbmRsZVJlc2l6ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZVJlc2l6ZSgpIHt9XG4gICAgfSwge1xuICAgICAga2luZDogXCJtZXRob2RcIixcbiAgICAgIGtleTogXCJyZW1vdmVDaGlsZFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUNoaWxkKGlkKSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW5baWRdLmxlYWYubGFzdFdpc2goKTtcblxuICAgICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihHcm91cC5wcm90b3R5cGUpLCBcInJlbW92ZUNoaWxkXCIsIHRoaXMpLmNhbGwodGhpcywgaWQpO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIGFuIG9iamVjdCB0aGF0IGhhcyB0aGUga2V5IG9mIHRoZSBucG0gcGx1Z2luIG5hbWUgdGhlIENoYW5uZWwgb2Ygd2hpY2ggbWFuYWdlcyB0aGUgc3BlY2lmaWMgSW5jaWRlbnRcbiAgICAgICAqIFdpdGggdGhlIHNhbWUgbG9naWMgYWxsIEluY2lkZW50cyB0aGF0IGJlbG9uZyB0byB0aGlzIEdyb3VwIGFzIGNhdGVnb3Jpc2VkIGJ5IHBsdWdpbiAvIGNoYW5uZWwgb24gdGhlIHNhbWUgb2JqZWN0XG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtpbmQ6IFwibWV0aG9kXCIsXG4gICAgICBrZXk6IFwiZ2V0SW5jaWRlbnRzQnlDaGFubmVsXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SW5jaWRlbnRzQnlDaGFubmVsKCkge1xuICAgICAgICB2YXIgYWRqdXN0TWlsbGlzZWNvbmQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG4gICAgICAgIHZhciBwYXJlbnRNaWxsaXNlY29uZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgICAgICAgLy8gaW5pdGlhbGx5IGl0IG9ubHkgcHV0cyBpdHNlbGYgb250aGUgaW5jaWRlbnRzQnlQbHVnaW4gYXJyYXksIGV4YWN0bHkgYXMgdGhlIHBsYWluIEluY2lkZW50cyBkb1xuICAgICAgICB2YXIgaW5jaWRlbnRzQnlQbHVnaW4gPSB7fTtcbiAgICAgICAgaW5jaWRlbnRzQnlQbHVnaW5bJ21vdG9yLWNvcnRleC1qcyddID0gW3tcbiAgICAgICAgICBtaWxsaXNlY29uZDogYWRqdXN0TWlsbGlzZWNvbmQsXG4gICAgICAgICAgcGFyZW50TWlsbGlzZWNvbmQ6IHBhcmVudE1pbGxpc2Vjb25kLFxuICAgICAgICAgIGluY2lkZW50OiB0aGlzLFxuICAgICAgICAgIGlkOiB0aGlzLmlkXG4gICAgICAgIH1dOyAvLyBwcm9jZWVkIHRvIGdhdGhlciB0aGUgY29udGFpbmVkIGluY2lkZW50cyBhcyB3ZWxsXG5cbiAgICAgICAgZm9yICh2YXIgY2hpbGRJZCBpbiB0aGlzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbltjaGlsZElkXTtcbiAgICAgICAgICB2YXIgaW5jaWRlbnRzVG9BZGQgPSBjaGlsZC5sZWFmLmdldEluY2lkZW50c0J5Q2hhbm5lbChhZGp1c3RNaWxsaXNlY29uZCArIGNoaWxkLnBvc2l0aW9uLCBhZGp1c3RNaWxsaXNlY29uZCk7XG5cbiAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gaW5jaWRlbnRzVG9BZGQpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaW5jaWRlbnRzQnlQbHVnaW4sIGtleSkpIHtcbiAgICAgICAgICAgICAgaW5jaWRlbnRzQnlQbHVnaW5ba2V5XSA9IGluY2lkZW50c0J5UGx1Z2luW2tleV0uY29uY2F0KGluY2lkZW50c1RvQWRkW2tleV0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaW5jaWRlbnRzQnlQbHVnaW5ba2V5XSA9IGluY2lkZW50c1RvQWRkW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGluY2lkZW50c0J5UGx1Z2luO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtpbmQ6IFwibWV0aG9kXCIsXG4gICAgICBrZXk6IFwibGFzdFdpc2hcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBsYXN0V2lzaCgpIHtcbiAgICAgICAgZm9yICh2YXIgY2hpbGRJZCBpbiB0aGlzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgdGhpcy5jaGlsZHJlbltjaGlsZElkXS5sZWFmLmxhc3RXaXNoKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XVxuICB9O1xufSwgTm9kZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gR3JvdXA7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/_BaseClasses/Group.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/_BaseClasses/Incident.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/_BaseClasses/Incident.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _decorate(decorators, factory, superClass, mixins) { var api = _getDecoratorsApi(); if (mixins) { for (var i = 0; i < mixins.length; i++) { api = mixins[i](api); } } var r = factory(function initialize(O) { api.initializeInstanceElements(O, decorated.elements); }, superClass); var decorated = api.decorateClass(_coalesceClassElements(r.d.map(_createElementDescriptor)), decorators); api.initializeClassElements(r.F, decorated.elements); return api.runClassFinishers(r.F, decorated.finishers); }\n\nfunction _getDecoratorsApi() { _getDecoratorsApi = function _getDecoratorsApi() { return api; }; var api = { elementsDefinitionOrder: [[\"method\"], [\"field\"]], initializeInstanceElements: function initializeInstanceElements(O, elements) { [\"method\", \"field\"].forEach(function (kind) { elements.forEach(function (element) { if (element.kind === kind && element.placement === \"own\") { this.defineClassElement(O, element); } }, this); }, this); }, initializeClassElements: function initializeClassElements(F, elements) { var proto = F.prototype; [\"method\", \"field\"].forEach(function (kind) { elements.forEach(function (element) { var placement = element.placement; if (element.kind === kind && (placement === \"static\" || placement === \"prototype\")) { var receiver = placement === \"static\" ? F : proto; this.defineClassElement(receiver, element); } }, this); }, this); }, defineClassElement: function defineClassElement(receiver, element) { var descriptor = element.descriptor; if (element.kind === \"field\") { var initializer = element.initializer; descriptor = { enumerable: descriptor.enumerable, writable: descriptor.writable, configurable: descriptor.configurable, value: initializer === void 0 ? void 0 : initializer.call(receiver) }; } Object.defineProperty(receiver, element.key, descriptor); }, decorateClass: function decorateClass(elements, decorators) { var newElements = []; var finishers = []; var placements = { \"static\": [], prototype: [], own: [] }; elements.forEach(function (element) { this.addElementPlacement(element, placements); }, this); elements.forEach(function (element) { if (!_hasDecorators(element)) return newElements.push(element); var elementFinishersExtras = this.decorateElement(element, placements); newElements.push(elementFinishersExtras.element); newElements.push.apply(newElements, elementFinishersExtras.extras); finishers.push.apply(finishers, elementFinishersExtras.finishers); }, this); if (!decorators) { return { elements: newElements, finishers: finishers }; } var result = this.decorateConstructor(newElements, decorators); finishers.push.apply(finishers, result.finishers); result.finishers = finishers; return result; }, addElementPlacement: function addElementPlacement(element, placements, silent) { var keys = placements[element.placement]; if (!silent && keys.indexOf(element.key) !== -1) { throw new TypeError(\"Duplicated element (\" + element.key + \")\"); } keys.push(element.key); }, decorateElement: function decorateElement(element, placements) { var extras = []; var finishers = []; for (var decorators = element.decorators, i = decorators.length - 1; i >= 0; i--) { var keys = placements[element.placement]; keys.splice(keys.indexOf(element.key), 1); var elementObject = this.fromElementDescriptor(element); var elementFinisherExtras = this.toElementFinisherExtras((0, decorators[i])(elementObject) || elementObject); element = elementFinisherExtras.element; this.addElementPlacement(element, placements); if (elementFinisherExtras.finisher) { finishers.push(elementFinisherExtras.finisher); } var newExtras = elementFinisherExtras.extras; if (newExtras) { for (var j = 0; j < newExtras.length; j++) { this.addElementPlacement(newExtras[j], placements); } extras.push.apply(extras, newExtras); } } return { element: element, finishers: finishers, extras: extras }; }, decorateConstructor: function decorateConstructor(elements, decorators) { var finishers = []; for (var i = decorators.length - 1; i >= 0; i--) { var obj = this.fromClassDescriptor(elements); var elementsAndFinisher = this.toClassDescriptor((0, decorators[i])(obj) || obj); if (elementsAndFinisher.finisher !== undefined) { finishers.push(elementsAndFinisher.finisher); } if (elementsAndFinisher.elements !== undefined) { elements = elementsAndFinisher.elements; for (var j = 0; j < elements.length - 1; j++) { for (var k = j + 1; k < elements.length; k++) { if (elements[j].key === elements[k].key && elements[j].placement === elements[k].placement) { throw new TypeError(\"Duplicated element (\" + elements[j].key + \")\"); } } } } } return { elements: elements, finishers: finishers }; }, fromElementDescriptor: function fromElementDescriptor(element) { var obj = { kind: element.kind, key: element.key, placement: element.placement, descriptor: element.descriptor }; var desc = { value: \"Descriptor\", configurable: true }; Object.defineProperty(obj, Symbol.toStringTag, desc); if (element.kind === \"field\") obj.initializer = element.initializer; return obj; }, toElementDescriptors: function toElementDescriptors(elementObjects) { if (elementObjects === undefined) return; return _toArray(elementObjects).map(function (elementObject) { var element = this.toElementDescriptor(elementObject); this.disallowProperty(elementObject, \"finisher\", \"An element descriptor\"); this.disallowProperty(elementObject, \"extras\", \"An element descriptor\"); return element; }, this); }, toElementDescriptor: function toElementDescriptor(elementObject) { var kind = String(elementObject.kind); if (kind !== \"method\" && kind !== \"field\") { throw new TypeError('An element descriptor\\'s .kind property must be either \"method\" or' + ' \"field\", but a decorator created an element descriptor with' + ' .kind \"' + kind + '\"'); } var key = _toPropertyKey(elementObject.key); var placement = String(elementObject.placement); if (placement !== \"static\" && placement !== \"prototype\" && placement !== \"own\") { throw new TypeError('An element descriptor\\'s .placement property must be one of \"static\",' + ' \"prototype\" or \"own\", but a decorator created an element descriptor' + ' with .placement \"' + placement + '\"'); } var descriptor = elementObject.descriptor; this.disallowProperty(elementObject, \"elements\", \"An element descriptor\"); var element = { kind: kind, key: key, placement: placement, descriptor: Object.assign({}, descriptor) }; if (kind !== \"field\") { this.disallowProperty(elementObject, \"initializer\", \"A method descriptor\"); } else { this.disallowProperty(descriptor, \"get\", \"The property descriptor of a field descriptor\"); this.disallowProperty(descriptor, \"set\", \"The property descriptor of a field descriptor\"); this.disallowProperty(descriptor, \"value\", \"The property descriptor of a field descriptor\"); element.initializer = elementObject.initializer; } return element; }, toElementFinisherExtras: function toElementFinisherExtras(elementObject) { var element = this.toElementDescriptor(elementObject); var finisher = _optionalCallableProperty(elementObject, \"finisher\"); var extras = this.toElementDescriptors(elementObject.extras); return { element: element, finisher: finisher, extras: extras }; }, fromClassDescriptor: function fromClassDescriptor(elements) { var obj = { kind: \"class\", elements: elements.map(this.fromElementDescriptor, this) }; var desc = { value: \"Descriptor\", configurable: true }; Object.defineProperty(obj, Symbol.toStringTag, desc); return obj; }, toClassDescriptor: function toClassDescriptor(obj) { var kind = String(obj.kind); if (kind !== \"class\") { throw new TypeError('A class descriptor\\'s .kind property must be \"class\", but a decorator' + ' created a class descriptor with .kind \"' + kind + '\"'); } this.disallowProperty(obj, \"key\", \"A class descriptor\"); this.disallowProperty(obj, \"placement\", \"A class descriptor\"); this.disallowProperty(obj, \"descriptor\", \"A class descriptor\"); this.disallowProperty(obj, \"initializer\", \"A class descriptor\"); this.disallowProperty(obj, \"extras\", \"A class descriptor\"); var finisher = _optionalCallableProperty(obj, \"finisher\"); var elements = this.toElementDescriptors(obj.elements); return { elements: elements, finisher: finisher }; }, runClassFinishers: function runClassFinishers(constructor, finishers) { for (var i = 0; i < finishers.length; i++) { var newConstructor = (0, finishers[i])(constructor); if (newConstructor !== undefined) { if (typeof newConstructor !== \"function\") { throw new TypeError(\"Finishers must return a constructor.\"); } constructor = newConstructor; } } return constructor; }, disallowProperty: function disallowProperty(obj, name, objectType) { if (obj[name] !== undefined) { throw new TypeError(objectType + \" can't have a .\" + name + \" property.\"); } } }; return api; }\n\nfunction _createElementDescriptor(def) { var key = _toPropertyKey(def.key); var descriptor; if (def.kind === \"method\") { descriptor = { value: def.value, writable: true, configurable: true, enumerable: false }; } else if (def.kind === \"get\") { descriptor = { get: def.value, configurable: true, enumerable: false }; } else if (def.kind === \"set\") { descriptor = { set: def.value, configurable: true, enumerable: false }; } else if (def.kind === \"field\") { descriptor = { configurable: true, writable: true, enumerable: true }; } var element = { kind: def.kind === \"field\" ? \"field\" : \"method\", key: key, placement: def[\"static\"] ? \"static\" : def.kind === \"field\" ? \"own\" : \"prototype\", descriptor: descriptor }; if (def.decorators) element.decorators = def.decorators; if (def.kind === \"field\") element.initializer = def.value; return element; }\n\nfunction _coalesceGetterSetter(element, other) { if (element.descriptor.get !== undefined) { other.descriptor.get = element.descriptor.get; } else { other.descriptor.set = element.descriptor.set; } }\n\nfunction _coalesceClassElements(elements) { var newElements = []; var isSameElement = function isSameElement(other) { return other.kind === \"method\" && other.key === element.key && other.placement === element.placement; }; for (var i = 0; i < elements.length; i++) { var element = elements[i]; var other; if (element.kind === \"method\" && (other = newElements.find(isSameElement))) { if (_isDataDescriptor(element.descriptor) || _isDataDescriptor(other.descriptor)) { if (_hasDecorators(element) || _hasDecorators(other)) { throw new ReferenceError(\"Duplicated methods (\" + element.key + \") can't be decorated.\"); } other.descriptor = element.descriptor; } else { if (_hasDecorators(element)) { if (_hasDecorators(other)) { throw new ReferenceError(\"Decorators can't be placed on different accessors with for \" + \"the same property (\" + element.key + \").\"); } other.decorators = element.decorators; } _coalesceGetterSetter(element, other); } } else { newElements.push(element); } } return newElements; }\n\nfunction _hasDecorators(element) { return element.decorators && element.decorators.length; }\n\nfunction _isDataDescriptor(desc) { return desc !== undefined && !(desc.value === undefined && desc.writable === undefined); }\n\nfunction _optionalCallableProperty(obj, name) { var value = obj[name]; if (value !== undefined && typeof value !== \"function\") { throw new TypeError(\"Expected '\" + name + \"' to be a function\"); } return value; }\n\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\n\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\nfunction _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nvar Helper = __webpack_require__(/*! ../_coreUtils/Helper */ \"./node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\");\n\nvar helper = new Helper();\n\nvar Channel = __webpack_require__(/*! ../_Channels/Channel */ \"./node_modules/@kissmybutton/motorcortex/dist/_Channels/Channel.js\");\n\nvar getIncidentsByChannel = __webpack_require__(/*! ../decorators/getIncidentsByChannel */ \"./node_modules/@kissmybutton/motorcortex/dist/decorators/getIncidentsByChannel.js\");\n/* @handleResize is missing from Incident. The reason is that when the\nExtendableClip asks for the under-resize candidates via the \"checkResize\" pipe\nmessage the message will never be handled by an Incident directly but rather via\nits corresponding DOMAwareIncident\n*/\n\n/*\ndna:\n- originalId\n- context\n*/\n\n\nvar Incident = _decorate(null, function (_initialize) {\n  var Incident = function Incident() {\n    var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var dna = arguments.length > 2 ? arguments[2] : undefined;\n\n    _classCallCheck(this, Incident);\n\n    _initialize(this);\n\n    // super(props);\n    this.attrs = attrs;\n    this.props = props;\n    this.dna = dna;\n    this.context = dna.context;\n    this.mcid = dna.mcid;\n    this.id = props.id || helper.getAnId();\n    this.modelId = props.modelId; // this parameter is initialised to false. Once the onGetContext method gets invoked this parameter\n    // is set to true so we prevent multiple executions of the onGetContext method\n\n    this.gotContext = false;\n    /*\n    these are the default values that define channeling for the default Incidents. These values get ovewriden through\n    the loadPlugin method of MC with the values found on the main.js file of the plugin\n    */\n\n    this.plugin_channel_class = Channel;\n    this.mc_plugin_npm_name = \"motor-cortex-js\";\n\n    if (Object.prototype.hasOwnProperty.call(props, \"plugin_channel_class\")) {\n      this.plugin_channel_class = props.plugin_channel_class;\n    }\n\n    if (Object.prototype.hasOwnProperty.call(props, \"mc_plugin_npm_name\")) {\n      this.mc_plugin_npm_name = props.mc_plugin_npm_name;\n    }\n\n    this.hasIncidents = false;\n    /*\n    initialValues is an object holding the autmatically computed initial values of the animatedAttrs\n    (if any). The initialValues are calculated by the AttributesChannel (only Incidents belonging to\n    an AttributesChannel have initialValues).\n    The keys set of this object is identical to the object attrs.animatedAttrs\n    The only thing the generic AttributesChannel can't calculate is the initial value of an animated attr\n    of a specific element when there are no other Incidents entered on its lanes yet. These values are\n    the \"scratchValues\" and they are strongly dependend on the nature of the lib. E.g. for a CSS animation\n    what we are looking for can be found on the computedStyle.\n    */\n\n    this.initialValues = {};\n    /*\n    The user has the ability to explicitely define the initial values for any of the animatedAttrs. The user\n    can do that by providing the initialValues object on the attrs of the constructor.\n    */\n\n    this.userDefinedInitialValues = {};\n\n    if (attrs != null && attrs != undefined) {\n      if (Object.prototype.hasOwnProperty.call(attrs, \"initialValues\")) {\n        this.userDefinedInitialValues = attrs.initialValues;\n      }\n    }\n    /**\n     * @member {boolean} - if autoGenerated is set to true, it means that this Incident has been auto-generated by its parent on initialisation.\n     * This happens when plugins export Incidents that on initialisation they automatically create other incidents and automatically put them\n     * on specific points on their timeline.\n     */\n\n\n    this.autoGenerated = false;\n    this.onInitialise(attrs, props);\n  };\n\n  return {\n    F: Incident,\n    d: [{\n      kind: \"get\",\n      key: \"selector\",\n      value: function selector() {\n        return this.props.selector;\n      }\n      /* shortcuts for attrs.attrs and attrs.animatedAttrs */\n\n    }, {\n      kind: \"get\",\n      key: \"animAttributes\",\n      value: function animAttributes() {\n        return this.attrs.animatedAttrs;\n      }\n      /**\n      This method shoudl be overwritten by the Incidents of the plugins. The method returns\n      the initial value that the element of it has as the library calculates / defines them. The\n      returned value represents the very initial value of the element's attribute before\n      any Incident that alters it gets added.\n       @returns {mixed} - the initial value of the element's attribute just when the HTML & CSS\n      of the Clip gets rendered\n      */\n\n    }, {\n      kind: \"method\",\n      key: \"getScratchValue\",\n      value: function getScratchValue() {\n        return 0;\n      }\n    }, {\n      kind: \"get\",\n      key: \"element\",\n      value: function element() {\n        if (this.contex === null) {\n          return [];\n        }\n\n        if (this.context.getElementByMCID) {\n          return this.context.getElementByMCID(this.mcid);\n        }\n\n        return this.context.getElements(this.selector)[0];\n      }\n    }, {\n      kind: \"get\",\n      key: \"attributeKey\",\n      value: function attributeKey() {\n        return Object.keys(this.attrs.animatedAttrs)[0];\n      }\n    }, {\n      kind: \"get\",\n      key: \"targetValue\",\n      value: function targetValue() {\n        return this.animAttributes[this.attributeKey];\n      }\n    }, {\n      kind: \"method\",\n      key: \"getElementAttribute\",\n      value: function getElementAttribute(attr) {\n        return this.element.getAttribute(attr);\n      }\n    }, {\n      kind: \"method\",\n      decorators: [getIncidentsByChannel],\n      key: \"getIncidentsByChannel\",\n      value: function getIncidentsByChannel() {}\n    }, {\n      kind: \"method\",\n      key: \"_hasUserDefinedInitialValue\",\n      value: function _hasUserDefinedInitialValue(attr) {\n        return Object.prototype.hasOwnProperty.call(this.userDefinedInitialValues, attr);\n      }\n    }, {\n      kind: \"method\",\n      key: \"_getUserDefinedInitialValue\",\n      value: function _getUserDefinedInitialValue(attr) {\n        return this.userDefinedInitialValues[attr];\n      }\n    }, {\n      kind: \"method\",\n      key: \"setInitialValue\",\n      value: function setInitialValue(value) {\n        if (this._hasUserDefinedInitialValue(this.attributeKey)) {\n          helper.notice(\"Incident with id \".concat(this.id, \" has initial value defined for \").concat(this.attributeKey, \" and no change is allowed on it\"));\n          return;\n        }\n\n        this.initialValues[this.attributeKey] = value;\n      }\n    }, {\n      kind: \"method\",\n      key: \"hasInitialValue\",\n      value: function hasInitialValue() {\n        var attr = this.attributeKey;\n        return this._hasUserDefinedInitialValue(attr) || Object.prototype.hasOwnProperty.call(this.initialValues, attr);\n      }\n    }, {\n      kind: \"get\",\n      key: \"initialValue\",\n      value: function initialValue() {\n        var attr = this.attributeKey;\n\n        if (this._hasUserDefinedInitialValue(attr)) {\n          return this._getUserDefinedInitialValue(attr);\n        }\n\n        return this.initialValues[attr];\n      }\n    }, {\n      kind: \"method\",\n      key: \"getInitialValue\",\n      value: function getInitialValue() {\n        var attr = this.attributeKey;\n\n        if (this._hasUserDefinedInitialValue(attr)) {\n          return this._getUserDefinedInitialValue(attr);\n        }\n\n        return this.initialValues[attr];\n      }\n    }, {\n      kind: \"method\",\n      key: \"_onGetContextOnce\",\n      value: function _onGetContextOnce() {\n        // if the Incident belongs to a fragmented context there absolutely\n        // no reason to run the getContext method of it\n        try {\n          if (this.context.fragment === true) {\n            return;\n          }\n\n          if (!this.gotContext) {\n            this.onGetContext();\n            this.gotContext = true;\n          }\n        } catch (e) {\n          console.log(e);\n          console.log(this.mcid); // console.log(this.context);\n        }\n      }\n    }, {\n      kind: \"method\",\n      key: \"onGetContext\",\n      value: function onGetContext() {\n        helper.info('Overwritte the \"onGetContext\" method with the code you want to get executed', 'info');\n      }\n    }, {\n      kind: \"method\",\n      key: \"lastWish\",\n      value: function lastWish() {}\n    }, {\n      kind: \"method\",\n      key: \"onInitialise\",\n      value: function onInitialise() {\n        helper.info('Overwritte the \"onInialise\" method with the code you want to get executed', 'info');\n      }\n      /**\n       * Method called on progress of the timed incident.\n       * @param {float} fraction - a number from 0 to 1 representing the fraction of duration covered\n       * @param {int} milliseconds - the number of milliseconds passed from start of the incident\n       */\n\n    }, {\n      kind: \"method\",\n      key: \"onProgress\",\n      value: function onProgress(fraction, milliseconds) {// eslint-disable-line no-unused-vars\n      }\n    }]\n  };\n});\n\nmodule.exports = Incident;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19CYXNlQ2xhc3Nlcy9JbmNpZGVudC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Aa2lzc215YnV0dG9uL21vdG9yY29ydGV4L2Rpc3QvX0Jhc2VDbGFzc2VzL0luY2lkZW50LmpzP2Q2ZWEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWNvcmF0ZShkZWNvcmF0b3JzLCBmYWN0b3J5LCBzdXBlckNsYXNzLCBtaXhpbnMpIHsgdmFyIGFwaSA9IF9nZXREZWNvcmF0b3JzQXBpKCk7IGlmIChtaXhpbnMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBtaXhpbnMubGVuZ3RoOyBpKyspIHsgYXBpID0gbWl4aW5zW2ldKGFwaSk7IH0gfSB2YXIgciA9IGZhY3RvcnkoZnVuY3Rpb24gaW5pdGlhbGl6ZShPKSB7IGFwaS5pbml0aWFsaXplSW5zdGFuY2VFbGVtZW50cyhPLCBkZWNvcmF0ZWQuZWxlbWVudHMpOyB9LCBzdXBlckNsYXNzKTsgdmFyIGRlY29yYXRlZCA9IGFwaS5kZWNvcmF0ZUNsYXNzKF9jb2FsZXNjZUNsYXNzRWxlbWVudHMoci5kLm1hcChfY3JlYXRlRWxlbWVudERlc2NyaXB0b3IpKSwgZGVjb3JhdG9ycyk7IGFwaS5pbml0aWFsaXplQ2xhc3NFbGVtZW50cyhyLkYsIGRlY29yYXRlZC5lbGVtZW50cyk7IHJldHVybiBhcGkucnVuQ2xhc3NGaW5pc2hlcnMoci5GLCBkZWNvcmF0ZWQuZmluaXNoZXJzKTsgfVxuXG5mdW5jdGlvbiBfZ2V0RGVjb3JhdG9yc0FwaSgpIHsgX2dldERlY29yYXRvcnNBcGkgPSBmdW5jdGlvbiBfZ2V0RGVjb3JhdG9yc0FwaSgpIHsgcmV0dXJuIGFwaTsgfTsgdmFyIGFwaSA9IHsgZWxlbWVudHNEZWZpbml0aW9uT3JkZXI6IFtbXCJtZXRob2RcIl0sIFtcImZpZWxkXCJdXSwgaW5pdGlhbGl6ZUluc3RhbmNlRWxlbWVudHM6IGZ1bmN0aW9uIGluaXRpYWxpemVJbnN0YW5jZUVsZW1lbnRzKE8sIGVsZW1lbnRzKSB7IFtcIm1ldGhvZFwiLCBcImZpZWxkXCJdLmZvckVhY2goZnVuY3Rpb24gKGtpbmQpIHsgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkgeyBpZiAoZWxlbWVudC5raW5kID09PSBraW5kICYmIGVsZW1lbnQucGxhY2VtZW50ID09PSBcIm93blwiKSB7IHRoaXMuZGVmaW5lQ2xhc3NFbGVtZW50KE8sIGVsZW1lbnQpOyB9IH0sIHRoaXMpOyB9LCB0aGlzKTsgfSwgaW5pdGlhbGl6ZUNsYXNzRWxlbWVudHM6IGZ1bmN0aW9uIGluaXRpYWxpemVDbGFzc0VsZW1lbnRzKEYsIGVsZW1lbnRzKSB7IHZhciBwcm90byA9IEYucHJvdG90eXBlOyBbXCJtZXRob2RcIiwgXCJmaWVsZFwiXS5mb3JFYWNoKGZ1bmN0aW9uIChraW5kKSB7IGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHsgdmFyIHBsYWNlbWVudCA9IGVsZW1lbnQucGxhY2VtZW50OyBpZiAoZWxlbWVudC5raW5kID09PSBraW5kICYmIChwbGFjZW1lbnQgPT09IFwic3RhdGljXCIgfHwgcGxhY2VtZW50ID09PSBcInByb3RvdHlwZVwiKSkgeyB2YXIgcmVjZWl2ZXIgPSBwbGFjZW1lbnQgPT09IFwic3RhdGljXCIgPyBGIDogcHJvdG87IHRoaXMuZGVmaW5lQ2xhc3NFbGVtZW50KHJlY2VpdmVyLCBlbGVtZW50KTsgfSB9LCB0aGlzKTsgfSwgdGhpcyk7IH0sIGRlZmluZUNsYXNzRWxlbWVudDogZnVuY3Rpb24gZGVmaW5lQ2xhc3NFbGVtZW50KHJlY2VpdmVyLCBlbGVtZW50KSB7IHZhciBkZXNjcmlwdG9yID0gZWxlbWVudC5kZXNjcmlwdG9yOyBpZiAoZWxlbWVudC5raW5kID09PSBcImZpZWxkXCIpIHsgdmFyIGluaXRpYWxpemVyID0gZWxlbWVudC5pbml0aWFsaXplcjsgZGVzY3JpcHRvciA9IHsgZW51bWVyYWJsZTogZGVzY3JpcHRvci5lbnVtZXJhYmxlLCB3cml0YWJsZTogZGVzY3JpcHRvci53cml0YWJsZSwgY29uZmlndXJhYmxlOiBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSwgdmFsdWU6IGluaXRpYWxpemVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbml0aWFsaXplci5jYWxsKHJlY2VpdmVyKSB9OyB9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZWNlaXZlciwgZWxlbWVudC5rZXksIGRlc2NyaXB0b3IpOyB9LCBkZWNvcmF0ZUNsYXNzOiBmdW5jdGlvbiBkZWNvcmF0ZUNsYXNzKGVsZW1lbnRzLCBkZWNvcmF0b3JzKSB7IHZhciBuZXdFbGVtZW50cyA9IFtdOyB2YXIgZmluaXNoZXJzID0gW107IHZhciBwbGFjZW1lbnRzID0geyBcInN0YXRpY1wiOiBbXSwgcHJvdG90eXBlOiBbXSwgb3duOiBbXSB9OyBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7IHRoaXMuYWRkRWxlbWVudFBsYWNlbWVudChlbGVtZW50LCBwbGFjZW1lbnRzKTsgfSwgdGhpcyk7IGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHsgaWYgKCFfaGFzRGVjb3JhdG9ycyhlbGVtZW50KSkgcmV0dXJuIG5ld0VsZW1lbnRzLnB1c2goZWxlbWVudCk7IHZhciBlbGVtZW50RmluaXNoZXJzRXh0cmFzID0gdGhpcy5kZWNvcmF0ZUVsZW1lbnQoZWxlbWVudCwgcGxhY2VtZW50cyk7IG5ld0VsZW1lbnRzLnB1c2goZWxlbWVudEZpbmlzaGVyc0V4dHJhcy5lbGVtZW50KTsgbmV3RWxlbWVudHMucHVzaC5hcHBseShuZXdFbGVtZW50cywgZWxlbWVudEZpbmlzaGVyc0V4dHJhcy5leHRyYXMpOyBmaW5pc2hlcnMucHVzaC5hcHBseShmaW5pc2hlcnMsIGVsZW1lbnRGaW5pc2hlcnNFeHRyYXMuZmluaXNoZXJzKTsgfSwgdGhpcyk7IGlmICghZGVjb3JhdG9ycykgeyByZXR1cm4geyBlbGVtZW50czogbmV3RWxlbWVudHMsIGZpbmlzaGVyczogZmluaXNoZXJzIH07IH0gdmFyIHJlc3VsdCA9IHRoaXMuZGVjb3JhdGVDb25zdHJ1Y3RvcihuZXdFbGVtZW50cywgZGVjb3JhdG9ycyk7IGZpbmlzaGVycy5wdXNoLmFwcGx5KGZpbmlzaGVycywgcmVzdWx0LmZpbmlzaGVycyk7IHJlc3VsdC5maW5pc2hlcnMgPSBmaW5pc2hlcnM7IHJldHVybiByZXN1bHQ7IH0sIGFkZEVsZW1lbnRQbGFjZW1lbnQ6IGZ1bmN0aW9uIGFkZEVsZW1lbnRQbGFjZW1lbnQoZWxlbWVudCwgcGxhY2VtZW50cywgc2lsZW50KSB7IHZhciBrZXlzID0gcGxhY2VtZW50c1tlbGVtZW50LnBsYWNlbWVudF07IGlmICghc2lsZW50ICYmIGtleXMuaW5kZXhPZihlbGVtZW50LmtleSkgIT09IC0xKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEdXBsaWNhdGVkIGVsZW1lbnQgKFwiICsgZWxlbWVudC5rZXkgKyBcIilcIik7IH0ga2V5cy5wdXNoKGVsZW1lbnQua2V5KTsgfSwgZGVjb3JhdGVFbGVtZW50OiBmdW5jdGlvbiBkZWNvcmF0ZUVsZW1lbnQoZWxlbWVudCwgcGxhY2VtZW50cykgeyB2YXIgZXh0cmFzID0gW107IHZhciBmaW5pc2hlcnMgPSBbXTsgZm9yICh2YXIgZGVjb3JhdG9ycyA9IGVsZW1lbnQuZGVjb3JhdG9ycywgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHsgdmFyIGtleXMgPSBwbGFjZW1lbnRzW2VsZW1lbnQucGxhY2VtZW50XTsga2V5cy5zcGxpY2Uoa2V5cy5pbmRleE9mKGVsZW1lbnQua2V5KSwgMSk7IHZhciBlbGVtZW50T2JqZWN0ID0gdGhpcy5mcm9tRWxlbWVudERlc2NyaXB0b3IoZWxlbWVudCk7IHZhciBlbGVtZW50RmluaXNoZXJFeHRyYXMgPSB0aGlzLnRvRWxlbWVudEZpbmlzaGVyRXh0cmFzKCgwLCBkZWNvcmF0b3JzW2ldKShlbGVtZW50T2JqZWN0KSB8fCBlbGVtZW50T2JqZWN0KTsgZWxlbWVudCA9IGVsZW1lbnRGaW5pc2hlckV4dHJhcy5lbGVtZW50OyB0aGlzLmFkZEVsZW1lbnRQbGFjZW1lbnQoZWxlbWVudCwgcGxhY2VtZW50cyk7IGlmIChlbGVtZW50RmluaXNoZXJFeHRyYXMuZmluaXNoZXIpIHsgZmluaXNoZXJzLnB1c2goZWxlbWVudEZpbmlzaGVyRXh0cmFzLmZpbmlzaGVyKTsgfSB2YXIgbmV3RXh0cmFzID0gZWxlbWVudEZpbmlzaGVyRXh0cmFzLmV4dHJhczsgaWYgKG5ld0V4dHJhcykgeyBmb3IgKHZhciBqID0gMDsgaiA8IG5ld0V4dHJhcy5sZW5ndGg7IGorKykgeyB0aGlzLmFkZEVsZW1lbnRQbGFjZW1lbnQobmV3RXh0cmFzW2pdLCBwbGFjZW1lbnRzKTsgfSBleHRyYXMucHVzaC5hcHBseShleHRyYXMsIG5ld0V4dHJhcyk7IH0gfSByZXR1cm4geyBlbGVtZW50OiBlbGVtZW50LCBmaW5pc2hlcnM6IGZpbmlzaGVycywgZXh0cmFzOiBleHRyYXMgfTsgfSwgZGVjb3JhdGVDb25zdHJ1Y3RvcjogZnVuY3Rpb24gZGVjb3JhdGVDb25zdHJ1Y3RvcihlbGVtZW50cywgZGVjb3JhdG9ycykgeyB2YXIgZmluaXNoZXJzID0gW107IGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7IHZhciBvYmogPSB0aGlzLmZyb21DbGFzc0Rlc2NyaXB0b3IoZWxlbWVudHMpOyB2YXIgZWxlbWVudHNBbmRGaW5pc2hlciA9IHRoaXMudG9DbGFzc0Rlc2NyaXB0b3IoKDAsIGRlY29yYXRvcnNbaV0pKG9iaikgfHwgb2JqKTsgaWYgKGVsZW1lbnRzQW5kRmluaXNoZXIuZmluaXNoZXIgIT09IHVuZGVmaW5lZCkgeyBmaW5pc2hlcnMucHVzaChlbGVtZW50c0FuZEZpbmlzaGVyLmZpbmlzaGVyKTsgfSBpZiAoZWxlbWVudHNBbmRGaW5pc2hlci5lbGVtZW50cyAhPT0gdW5kZWZpbmVkKSB7IGVsZW1lbnRzID0gZWxlbWVudHNBbmRGaW5pc2hlci5lbGVtZW50czsgZm9yICh2YXIgaiA9IDA7IGogPCBlbGVtZW50cy5sZW5ndGggLSAxOyBqKyspIHsgZm9yICh2YXIgayA9IGogKyAxOyBrIDwgZWxlbWVudHMubGVuZ3RoOyBrKyspIHsgaWYgKGVsZW1lbnRzW2pdLmtleSA9PT0gZWxlbWVudHNba10ua2V5ICYmIGVsZW1lbnRzW2pdLnBsYWNlbWVudCA9PT0gZWxlbWVudHNba10ucGxhY2VtZW50KSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEdXBsaWNhdGVkIGVsZW1lbnQgKFwiICsgZWxlbWVudHNbal0ua2V5ICsgXCIpXCIpOyB9IH0gfSB9IH0gcmV0dXJuIHsgZWxlbWVudHM6IGVsZW1lbnRzLCBmaW5pc2hlcnM6IGZpbmlzaGVycyB9OyB9LCBmcm9tRWxlbWVudERlc2NyaXB0b3I6IGZ1bmN0aW9uIGZyb21FbGVtZW50RGVzY3JpcHRvcihlbGVtZW50KSB7IHZhciBvYmogPSB7IGtpbmQ6IGVsZW1lbnQua2luZCwga2V5OiBlbGVtZW50LmtleSwgcGxhY2VtZW50OiBlbGVtZW50LnBsYWNlbWVudCwgZGVzY3JpcHRvcjogZWxlbWVudC5kZXNjcmlwdG9yIH07IHZhciBkZXNjID0geyB2YWx1ZTogXCJEZXNjcmlwdG9yXCIsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9OyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBTeW1ib2wudG9TdHJpbmdUYWcsIGRlc2MpOyBpZiAoZWxlbWVudC5raW5kID09PSBcImZpZWxkXCIpIG9iai5pbml0aWFsaXplciA9IGVsZW1lbnQuaW5pdGlhbGl6ZXI7IHJldHVybiBvYmo7IH0sIHRvRWxlbWVudERlc2NyaXB0b3JzOiBmdW5jdGlvbiB0b0VsZW1lbnREZXNjcmlwdG9ycyhlbGVtZW50T2JqZWN0cykgeyBpZiAoZWxlbWVudE9iamVjdHMgPT09IHVuZGVmaW5lZCkgcmV0dXJuOyByZXR1cm4gX3RvQXJyYXkoZWxlbWVudE9iamVjdHMpLm1hcChmdW5jdGlvbiAoZWxlbWVudE9iamVjdCkgeyB2YXIgZWxlbWVudCA9IHRoaXMudG9FbGVtZW50RGVzY3JpcHRvcihlbGVtZW50T2JqZWN0KTsgdGhpcy5kaXNhbGxvd1Byb3BlcnR5KGVsZW1lbnRPYmplY3QsIFwiZmluaXNoZXJcIiwgXCJBbiBlbGVtZW50IGRlc2NyaXB0b3JcIik7IHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShlbGVtZW50T2JqZWN0LCBcImV4dHJhc1wiLCBcIkFuIGVsZW1lbnQgZGVzY3JpcHRvclwiKTsgcmV0dXJuIGVsZW1lbnQ7IH0sIHRoaXMpOyB9LCB0b0VsZW1lbnREZXNjcmlwdG9yOiBmdW5jdGlvbiB0b0VsZW1lbnREZXNjcmlwdG9yKGVsZW1lbnRPYmplY3QpIHsgdmFyIGtpbmQgPSBTdHJpbmcoZWxlbWVudE9iamVjdC5raW5kKTsgaWYgKGtpbmQgIT09IFwibWV0aG9kXCIgJiYga2luZCAhPT0gXCJmaWVsZFwiKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0FuIGVsZW1lbnQgZGVzY3JpcHRvclxcJ3MgLmtpbmQgcHJvcGVydHkgbXVzdCBiZSBlaXRoZXIgXCJtZXRob2RcIiBvcicgKyAnIFwiZmllbGRcIiwgYnV0IGEgZGVjb3JhdG9yIGNyZWF0ZWQgYW4gZWxlbWVudCBkZXNjcmlwdG9yIHdpdGgnICsgJyAua2luZCBcIicgKyBraW5kICsgJ1wiJyk7IH0gdmFyIGtleSA9IF90b1Byb3BlcnR5S2V5KGVsZW1lbnRPYmplY3Qua2V5KTsgdmFyIHBsYWNlbWVudCA9IFN0cmluZyhlbGVtZW50T2JqZWN0LnBsYWNlbWVudCk7IGlmIChwbGFjZW1lbnQgIT09IFwic3RhdGljXCIgJiYgcGxhY2VtZW50ICE9PSBcInByb3RvdHlwZVwiICYmIHBsYWNlbWVudCAhPT0gXCJvd25cIikgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdBbiBlbGVtZW50IGRlc2NyaXB0b3JcXCdzIC5wbGFjZW1lbnQgcHJvcGVydHkgbXVzdCBiZSBvbmUgb2YgXCJzdGF0aWNcIiwnICsgJyBcInByb3RvdHlwZVwiIG9yIFwib3duXCIsIGJ1dCBhIGRlY29yYXRvciBjcmVhdGVkIGFuIGVsZW1lbnQgZGVzY3JpcHRvcicgKyAnIHdpdGggLnBsYWNlbWVudCBcIicgKyBwbGFjZW1lbnQgKyAnXCInKTsgfSB2YXIgZGVzY3JpcHRvciA9IGVsZW1lbnRPYmplY3QuZGVzY3JpcHRvcjsgdGhpcy5kaXNhbGxvd1Byb3BlcnR5KGVsZW1lbnRPYmplY3QsIFwiZWxlbWVudHNcIiwgXCJBbiBlbGVtZW50IGRlc2NyaXB0b3JcIik7IHZhciBlbGVtZW50ID0geyBraW5kOiBraW5kLCBrZXk6IGtleSwgcGxhY2VtZW50OiBwbGFjZW1lbnQsIGRlc2NyaXB0b3I6IE9iamVjdC5hc3NpZ24oe30sIGRlc2NyaXB0b3IpIH07IGlmIChraW5kICE9PSBcImZpZWxkXCIpIHsgdGhpcy5kaXNhbGxvd1Byb3BlcnR5KGVsZW1lbnRPYmplY3QsIFwiaW5pdGlhbGl6ZXJcIiwgXCJBIG1ldGhvZCBkZXNjcmlwdG9yXCIpOyB9IGVsc2UgeyB0aGlzLmRpc2FsbG93UHJvcGVydHkoZGVzY3JpcHRvciwgXCJnZXRcIiwgXCJUaGUgcHJvcGVydHkgZGVzY3JpcHRvciBvZiBhIGZpZWxkIGRlc2NyaXB0b3JcIik7IHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShkZXNjcmlwdG9yLCBcInNldFwiLCBcIlRoZSBwcm9wZXJ0eSBkZXNjcmlwdG9yIG9mIGEgZmllbGQgZGVzY3JpcHRvclwiKTsgdGhpcy5kaXNhbGxvd1Byb3BlcnR5KGRlc2NyaXB0b3IsIFwidmFsdWVcIiwgXCJUaGUgcHJvcGVydHkgZGVzY3JpcHRvciBvZiBhIGZpZWxkIGRlc2NyaXB0b3JcIik7IGVsZW1lbnQuaW5pdGlhbGl6ZXIgPSBlbGVtZW50T2JqZWN0LmluaXRpYWxpemVyOyB9IHJldHVybiBlbGVtZW50OyB9LCB0b0VsZW1lbnRGaW5pc2hlckV4dHJhczogZnVuY3Rpb24gdG9FbGVtZW50RmluaXNoZXJFeHRyYXMoZWxlbWVudE9iamVjdCkgeyB2YXIgZWxlbWVudCA9IHRoaXMudG9FbGVtZW50RGVzY3JpcHRvcihlbGVtZW50T2JqZWN0KTsgdmFyIGZpbmlzaGVyID0gX29wdGlvbmFsQ2FsbGFibGVQcm9wZXJ0eShlbGVtZW50T2JqZWN0LCBcImZpbmlzaGVyXCIpOyB2YXIgZXh0cmFzID0gdGhpcy50b0VsZW1lbnREZXNjcmlwdG9ycyhlbGVtZW50T2JqZWN0LmV4dHJhcyk7IHJldHVybiB7IGVsZW1lbnQ6IGVsZW1lbnQsIGZpbmlzaGVyOiBmaW5pc2hlciwgZXh0cmFzOiBleHRyYXMgfTsgfSwgZnJvbUNsYXNzRGVzY3JpcHRvcjogZnVuY3Rpb24gZnJvbUNsYXNzRGVzY3JpcHRvcihlbGVtZW50cykgeyB2YXIgb2JqID0geyBraW5kOiBcImNsYXNzXCIsIGVsZW1lbnRzOiBlbGVtZW50cy5tYXAodGhpcy5mcm9tRWxlbWVudERlc2NyaXB0b3IsIHRoaXMpIH07IHZhciBkZXNjID0geyB2YWx1ZTogXCJEZXNjcmlwdG9yXCIsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9OyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBTeW1ib2wudG9TdHJpbmdUYWcsIGRlc2MpOyByZXR1cm4gb2JqOyB9LCB0b0NsYXNzRGVzY3JpcHRvcjogZnVuY3Rpb24gdG9DbGFzc0Rlc2NyaXB0b3Iob2JqKSB7IHZhciBraW5kID0gU3RyaW5nKG9iai5raW5kKTsgaWYgKGtpbmQgIT09IFwiY2xhc3NcIikgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdBIGNsYXNzIGRlc2NyaXB0b3JcXCdzIC5raW5kIHByb3BlcnR5IG11c3QgYmUgXCJjbGFzc1wiLCBidXQgYSBkZWNvcmF0b3InICsgJyBjcmVhdGVkIGEgY2xhc3MgZGVzY3JpcHRvciB3aXRoIC5raW5kIFwiJyArIGtpbmQgKyAnXCInKTsgfSB0aGlzLmRpc2FsbG93UHJvcGVydHkob2JqLCBcImtleVwiLCBcIkEgY2xhc3MgZGVzY3JpcHRvclwiKTsgdGhpcy5kaXNhbGxvd1Byb3BlcnR5KG9iaiwgXCJwbGFjZW1lbnRcIiwgXCJBIGNsYXNzIGRlc2NyaXB0b3JcIik7IHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShvYmosIFwiZGVzY3JpcHRvclwiLCBcIkEgY2xhc3MgZGVzY3JpcHRvclwiKTsgdGhpcy5kaXNhbGxvd1Byb3BlcnR5KG9iaiwgXCJpbml0aWFsaXplclwiLCBcIkEgY2xhc3MgZGVzY3JpcHRvclwiKTsgdGhpcy5kaXNhbGxvd1Byb3BlcnR5KG9iaiwgXCJleHRyYXNcIiwgXCJBIGNsYXNzIGRlc2NyaXB0b3JcIik7IHZhciBmaW5pc2hlciA9IF9vcHRpb25hbENhbGxhYmxlUHJvcGVydHkob2JqLCBcImZpbmlzaGVyXCIpOyB2YXIgZWxlbWVudHMgPSB0aGlzLnRvRWxlbWVudERlc2NyaXB0b3JzKG9iai5lbGVtZW50cyk7IHJldHVybiB7IGVsZW1lbnRzOiBlbGVtZW50cywgZmluaXNoZXI6IGZpbmlzaGVyIH07IH0sIHJ1bkNsYXNzRmluaXNoZXJzOiBmdW5jdGlvbiBydW5DbGFzc0ZpbmlzaGVycyhjb25zdHJ1Y3RvciwgZmluaXNoZXJzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgZmluaXNoZXJzLmxlbmd0aDsgaSsrKSB7IHZhciBuZXdDb25zdHJ1Y3RvciA9ICgwLCBmaW5pc2hlcnNbaV0pKGNvbnN0cnVjdG9yKTsgaWYgKG5ld0NvbnN0cnVjdG9yICE9PSB1bmRlZmluZWQpIHsgaWYgKHR5cGVvZiBuZXdDb25zdHJ1Y3RvciAhPT0gXCJmdW5jdGlvblwiKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaW5pc2hlcnMgbXVzdCByZXR1cm4gYSBjb25zdHJ1Y3Rvci5cIik7IH0gY29uc3RydWN0b3IgPSBuZXdDb25zdHJ1Y3RvcjsgfSB9IHJldHVybiBjb25zdHJ1Y3RvcjsgfSwgZGlzYWxsb3dQcm9wZXJ0eTogZnVuY3Rpb24gZGlzYWxsb3dQcm9wZXJ0eShvYmosIG5hbWUsIG9iamVjdFR5cGUpIHsgaWYgKG9ialtuYW1lXSAhPT0gdW5kZWZpbmVkKSB7IHRocm93IG5ldyBUeXBlRXJyb3Iob2JqZWN0VHlwZSArIFwiIGNhbid0IGhhdmUgYSAuXCIgKyBuYW1lICsgXCIgcHJvcGVydHkuXCIpOyB9IH0gfTsgcmV0dXJuIGFwaTsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlRWxlbWVudERlc2NyaXB0b3IoZGVmKSB7IHZhciBrZXkgPSBfdG9Qcm9wZXJ0eUtleShkZWYua2V5KTsgdmFyIGRlc2NyaXB0b3I7IGlmIChkZWYua2luZCA9PT0gXCJtZXRob2RcIikgeyBkZXNjcmlwdG9yID0geyB2YWx1ZTogZGVmLnZhbHVlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCBlbnVtZXJhYmxlOiBmYWxzZSB9OyB9IGVsc2UgaWYgKGRlZi5raW5kID09PSBcImdldFwiKSB7IGRlc2NyaXB0b3IgPSB7IGdldDogZGVmLnZhbHVlLCBjb25maWd1cmFibGU6IHRydWUsIGVudW1lcmFibGU6IGZhbHNlIH07IH0gZWxzZSBpZiAoZGVmLmtpbmQgPT09IFwic2V0XCIpIHsgZGVzY3JpcHRvciA9IHsgc2V0OiBkZWYudmFsdWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZW51bWVyYWJsZTogZmFsc2UgfTsgfSBlbHNlIGlmIChkZWYua2luZCA9PT0gXCJmaWVsZFwiKSB7IGRlc2NyaXB0b3IgPSB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIGVudW1lcmFibGU6IHRydWUgfTsgfSB2YXIgZWxlbWVudCA9IHsga2luZDogZGVmLmtpbmQgPT09IFwiZmllbGRcIiA/IFwiZmllbGRcIiA6IFwibWV0aG9kXCIsIGtleToga2V5LCBwbGFjZW1lbnQ6IGRlZltcInN0YXRpY1wiXSA/IFwic3RhdGljXCIgOiBkZWYua2luZCA9PT0gXCJmaWVsZFwiID8gXCJvd25cIiA6IFwicHJvdG90eXBlXCIsIGRlc2NyaXB0b3I6IGRlc2NyaXB0b3IgfTsgaWYgKGRlZi5kZWNvcmF0b3JzKSBlbGVtZW50LmRlY29yYXRvcnMgPSBkZWYuZGVjb3JhdG9yczsgaWYgKGRlZi5raW5kID09PSBcImZpZWxkXCIpIGVsZW1lbnQuaW5pdGlhbGl6ZXIgPSBkZWYudmFsdWU7IHJldHVybiBlbGVtZW50OyB9XG5cbmZ1bmN0aW9uIF9jb2FsZXNjZUdldHRlclNldHRlcihlbGVtZW50LCBvdGhlcikgeyBpZiAoZWxlbWVudC5kZXNjcmlwdG9yLmdldCAhPT0gdW5kZWZpbmVkKSB7IG90aGVyLmRlc2NyaXB0b3IuZ2V0ID0gZWxlbWVudC5kZXNjcmlwdG9yLmdldDsgfSBlbHNlIHsgb3RoZXIuZGVzY3JpcHRvci5zZXQgPSBlbGVtZW50LmRlc2NyaXB0b3Iuc2V0OyB9IH1cblxuZnVuY3Rpb24gX2NvYWxlc2NlQ2xhc3NFbGVtZW50cyhlbGVtZW50cykgeyB2YXIgbmV3RWxlbWVudHMgPSBbXTsgdmFyIGlzU2FtZUVsZW1lbnQgPSBmdW5jdGlvbiBpc1NhbWVFbGVtZW50KG90aGVyKSB7IHJldHVybiBvdGhlci5raW5kID09PSBcIm1ldGhvZFwiICYmIG90aGVyLmtleSA9PT0gZWxlbWVudC5rZXkgJiYgb3RoZXIucGxhY2VtZW50ID09PSBlbGVtZW50LnBsYWNlbWVudDsgfTsgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgZWxlbWVudCA9IGVsZW1lbnRzW2ldOyB2YXIgb3RoZXI7IGlmIChlbGVtZW50LmtpbmQgPT09IFwibWV0aG9kXCIgJiYgKG90aGVyID0gbmV3RWxlbWVudHMuZmluZChpc1NhbWVFbGVtZW50KSkpIHsgaWYgKF9pc0RhdGFEZXNjcmlwdG9yKGVsZW1lbnQuZGVzY3JpcHRvcikgfHwgX2lzRGF0YURlc2NyaXB0b3Iob3RoZXIuZGVzY3JpcHRvcikpIHsgaWYgKF9oYXNEZWNvcmF0b3JzKGVsZW1lbnQpIHx8IF9oYXNEZWNvcmF0b3JzKG90aGVyKSkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJEdXBsaWNhdGVkIG1ldGhvZHMgKFwiICsgZWxlbWVudC5rZXkgKyBcIikgY2FuJ3QgYmUgZGVjb3JhdGVkLlwiKTsgfSBvdGhlci5kZXNjcmlwdG9yID0gZWxlbWVudC5kZXNjcmlwdG9yOyB9IGVsc2UgeyBpZiAoX2hhc0RlY29yYXRvcnMoZWxlbWVudCkpIHsgaWYgKF9oYXNEZWNvcmF0b3JzKG90aGVyKSkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJEZWNvcmF0b3JzIGNhbid0IGJlIHBsYWNlZCBvbiBkaWZmZXJlbnQgYWNjZXNzb3JzIHdpdGggZm9yIFwiICsgXCJ0aGUgc2FtZSBwcm9wZXJ0eSAoXCIgKyBlbGVtZW50LmtleSArIFwiKS5cIik7IH0gb3RoZXIuZGVjb3JhdG9ycyA9IGVsZW1lbnQuZGVjb3JhdG9yczsgfSBfY29hbGVzY2VHZXR0ZXJTZXR0ZXIoZWxlbWVudCwgb3RoZXIpOyB9IH0gZWxzZSB7IG5ld0VsZW1lbnRzLnB1c2goZWxlbWVudCk7IH0gfSByZXR1cm4gbmV3RWxlbWVudHM7IH1cblxuZnVuY3Rpb24gX2hhc0RlY29yYXRvcnMoZWxlbWVudCkgeyByZXR1cm4gZWxlbWVudC5kZWNvcmF0b3JzICYmIGVsZW1lbnQuZGVjb3JhdG9ycy5sZW5ndGg7IH1cblxuZnVuY3Rpb24gX2lzRGF0YURlc2NyaXB0b3IoZGVzYykgeyByZXR1cm4gZGVzYyAhPT0gdW5kZWZpbmVkICYmICEoZGVzYy52YWx1ZSA9PT0gdW5kZWZpbmVkICYmIGRlc2Mud3JpdGFibGUgPT09IHVuZGVmaW5lZCk7IH1cblxuZnVuY3Rpb24gX29wdGlvbmFsQ2FsbGFibGVQcm9wZXJ0eShvYmosIG5hbWUpIHsgdmFyIHZhbHVlID0gb2JqW25hbWVdOyBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIikgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgJ1wiICsgbmFtZSArIFwiJyB0byBiZSBhIGZ1bmN0aW9uXCIpOyB9IHJldHVybiB2YWx1ZTsgfVxuXG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleShhcmcpIHsgdmFyIGtleSA9IF90b1ByaW1pdGl2ZShhcmcsIFwic3RyaW5nXCIpOyByZXR1cm4gX3R5cGVvZihrZXkpID09PSBcInN5bWJvbFwiID8ga2V5IDogU3RyaW5nKGtleSk7IH1cblxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKGlucHV0LCBoaW50KSB7IGlmIChfdHlwZW9mKGlucHV0KSAhPT0gXCJvYmplY3RcIiB8fCBpbnB1dCA9PT0gbnVsbCkgcmV0dXJuIGlucHV0OyB2YXIgcHJpbSA9IGlucHV0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmIChwcmltICE9PSB1bmRlZmluZWQpIHsgdmFyIHJlcyA9IHByaW0uY2FsbChpbnB1dCwgaGludCB8fCBcImRlZmF1bHRcIik7IGlmIChfdHlwZW9mKHJlcykgIT09IFwib2JqZWN0XCIpIHJldHVybiByZXM7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKGhpbnQgPT09IFwic3RyaW5nXCIgPyBTdHJpbmcgOiBOdW1iZXIpKGlucHV0KTsgfVxuXG5mdW5jdGlvbiBfdG9BcnJheShhcnIpIHsgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7IH1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7IGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGl0ZXIpIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpdGVyKSA9PT0gXCJbb2JqZWN0IEFyZ3VtZW50c11cIikgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7IH1cblxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyOyB9XG5cbnZhciBIZWxwZXIgPSByZXF1aXJlKCcuLi9fY29yZVV0aWxzL0hlbHBlcicpO1xuXG52YXIgaGVscGVyID0gbmV3IEhlbHBlcigpO1xuXG52YXIgQ2hhbm5lbCA9IHJlcXVpcmUoJy4uL19DaGFubmVscy9DaGFubmVsJyk7XG5cbnZhciBnZXRJbmNpZGVudHNCeUNoYW5uZWwgPSByZXF1aXJlKCcuLi9kZWNvcmF0b3JzL2dldEluY2lkZW50c0J5Q2hhbm5lbCcpO1xuLyogQGhhbmRsZVJlc2l6ZSBpcyBtaXNzaW5nIGZyb20gSW5jaWRlbnQuIFRoZSByZWFzb24gaXMgdGhhdCB3aGVuIHRoZVxuRXh0ZW5kYWJsZUNsaXAgYXNrcyBmb3IgdGhlIHVuZGVyLXJlc2l6ZSBjYW5kaWRhdGVzIHZpYSB0aGUgXCJjaGVja1Jlc2l6ZVwiIHBpcGVcbm1lc3NhZ2UgdGhlIG1lc3NhZ2Ugd2lsbCBuZXZlciBiZSBoYW5kbGVkIGJ5IGFuIEluY2lkZW50IGRpcmVjdGx5IGJ1dCByYXRoZXIgdmlhXG5pdHMgY29ycmVzcG9uZGluZyBET01Bd2FyZUluY2lkZW50XG4qL1xuXG4vKlxuZG5hOlxuLSBvcmlnaW5hbElkXG4tIGNvbnRleHRcbiovXG5cblxudmFyIEluY2lkZW50ID0gX2RlY29yYXRlKG51bGwsIGZ1bmN0aW9uIChfaW5pdGlhbGl6ZSkge1xuICB2YXIgSW5jaWRlbnQgPSBmdW5jdGlvbiBJbmNpZGVudCgpIHtcbiAgICB2YXIgYXR0cnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIGRuYSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEluY2lkZW50KTtcblxuICAgIF9pbml0aWFsaXplKHRoaXMpO1xuXG4gICAgLy8gc3VwZXIocHJvcHMpO1xuICAgIHRoaXMuYXR0cnMgPSBhdHRycztcbiAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgdGhpcy5kbmEgPSBkbmE7XG4gICAgdGhpcy5jb250ZXh0ID0gZG5hLmNvbnRleHQ7XG4gICAgdGhpcy5tY2lkID0gZG5hLm1jaWQ7XG4gICAgdGhpcy5pZCA9IHByb3BzLmlkIHx8IGhlbHBlci5nZXRBbklkKCk7XG4gICAgdGhpcy5tb2RlbElkID0gcHJvcHMubW9kZWxJZDsgLy8gdGhpcyBwYXJhbWV0ZXIgaXMgaW5pdGlhbGlzZWQgdG8gZmFsc2UuIE9uY2UgdGhlIG9uR2V0Q29udGV4dCBtZXRob2QgZ2V0cyBpbnZva2VkIHRoaXMgcGFyYW1ldGVyXG4gICAgLy8gaXMgc2V0IHRvIHRydWUgc28gd2UgcHJldmVudCBtdWx0aXBsZSBleGVjdXRpb25zIG9mIHRoZSBvbkdldENvbnRleHQgbWV0aG9kXG5cbiAgICB0aGlzLmdvdENvbnRleHQgPSBmYWxzZTtcbiAgICAvKlxuICAgIHRoZXNlIGFyZSB0aGUgZGVmYXVsdCB2YWx1ZXMgdGhhdCBkZWZpbmUgY2hhbm5lbGluZyBmb3IgdGhlIGRlZmF1bHQgSW5jaWRlbnRzLiBUaGVzZSB2YWx1ZXMgZ2V0IG92ZXdyaWRlbiB0aHJvdWdoXG4gICAgdGhlIGxvYWRQbHVnaW4gbWV0aG9kIG9mIE1DIHdpdGggdGhlIHZhbHVlcyBmb3VuZCBvbiB0aGUgbWFpbi5qcyBmaWxlIG9mIHRoZSBwbHVnaW5cbiAgICAqL1xuXG4gICAgdGhpcy5wbHVnaW5fY2hhbm5lbF9jbGFzcyA9IENoYW5uZWw7XG4gICAgdGhpcy5tY19wbHVnaW5fbnBtX25hbWUgPSBcIm1vdG9yLWNvcnRleC1qc1wiO1xuXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgXCJwbHVnaW5fY2hhbm5lbF9jbGFzc1wiKSkge1xuICAgICAgdGhpcy5wbHVnaW5fY2hhbm5lbF9jbGFzcyA9IHByb3BzLnBsdWdpbl9jaGFubmVsX2NsYXNzO1xuICAgIH1cblxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIFwibWNfcGx1Z2luX25wbV9uYW1lXCIpKSB7XG4gICAgICB0aGlzLm1jX3BsdWdpbl9ucG1fbmFtZSA9IHByb3BzLm1jX3BsdWdpbl9ucG1fbmFtZTtcbiAgICB9XG5cbiAgICB0aGlzLmhhc0luY2lkZW50cyA9IGZhbHNlO1xuICAgIC8qXG4gICAgaW5pdGlhbFZhbHVlcyBpcyBhbiBvYmplY3QgaG9sZGluZyB0aGUgYXV0bWF0aWNhbGx5IGNvbXB1dGVkIGluaXRpYWwgdmFsdWVzIG9mIHRoZSBhbmltYXRlZEF0dHJzXG4gICAgKGlmIGFueSkuIFRoZSBpbml0aWFsVmFsdWVzIGFyZSBjYWxjdWxhdGVkIGJ5IHRoZSBBdHRyaWJ1dGVzQ2hhbm5lbCAob25seSBJbmNpZGVudHMgYmVsb25naW5nIHRvXG4gICAgYW4gQXR0cmlidXRlc0NoYW5uZWwgaGF2ZSBpbml0aWFsVmFsdWVzKS5cbiAgICBUaGUga2V5cyBzZXQgb2YgdGhpcyBvYmplY3QgaXMgaWRlbnRpY2FsIHRvIHRoZSBvYmplY3QgYXR0cnMuYW5pbWF0ZWRBdHRyc1xuICAgIFRoZSBvbmx5IHRoaW5nIHRoZSBnZW5lcmljIEF0dHJpYnV0ZXNDaGFubmVsIGNhbid0IGNhbGN1bGF0ZSBpcyB0aGUgaW5pdGlhbCB2YWx1ZSBvZiBhbiBhbmltYXRlZCBhdHRyXG4gICAgb2YgYSBzcGVjaWZpYyBlbGVtZW50IHdoZW4gdGhlcmUgYXJlIG5vIG90aGVyIEluY2lkZW50cyBlbnRlcmVkIG9uIGl0cyBsYW5lcyB5ZXQuIFRoZXNlIHZhbHVlcyBhcmVcbiAgICB0aGUgXCJzY3JhdGNoVmFsdWVzXCIgYW5kIHRoZXkgYXJlIHN0cm9uZ2x5IGRlcGVuZGVuZCBvbiB0aGUgbmF0dXJlIG9mIHRoZSBsaWIuIEUuZy4gZm9yIGEgQ1NTIGFuaW1hdGlvblxuICAgIHdoYXQgd2UgYXJlIGxvb2tpbmcgZm9yIGNhbiBiZSBmb3VuZCBvbiB0aGUgY29tcHV0ZWRTdHlsZS5cbiAgICAqL1xuXG4gICAgdGhpcy5pbml0aWFsVmFsdWVzID0ge307XG4gICAgLypcbiAgICBUaGUgdXNlciBoYXMgdGhlIGFiaWxpdHkgdG8gZXhwbGljaXRlbHkgZGVmaW5lIHRoZSBpbml0aWFsIHZhbHVlcyBmb3IgYW55IG9mIHRoZSBhbmltYXRlZEF0dHJzLiBUaGUgdXNlclxuICAgIGNhbiBkbyB0aGF0IGJ5IHByb3ZpZGluZyB0aGUgaW5pdGlhbFZhbHVlcyBvYmplY3Qgb24gdGhlIGF0dHJzIG9mIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAqL1xuXG4gICAgdGhpcy51c2VyRGVmaW5lZEluaXRpYWxWYWx1ZXMgPSB7fTtcblxuICAgIGlmIChhdHRycyAhPSBudWxsICYmIGF0dHJzICE9IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhdHRycywgXCJpbml0aWFsVmFsdWVzXCIpKSB7XG4gICAgICAgIHRoaXMudXNlckRlZmluZWRJbml0aWFsVmFsdWVzID0gYXR0cnMuaW5pdGlhbFZhbHVlcztcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn0gLSBpZiBhdXRvR2VuZXJhdGVkIGlzIHNldCB0byB0cnVlLCBpdCBtZWFucyB0aGF0IHRoaXMgSW5jaWRlbnQgaGFzIGJlZW4gYXV0by1nZW5lcmF0ZWQgYnkgaXRzIHBhcmVudCBvbiBpbml0aWFsaXNhdGlvbi5cbiAgICAgKiBUaGlzIGhhcHBlbnMgd2hlbiBwbHVnaW5zIGV4cG9ydCBJbmNpZGVudHMgdGhhdCBvbiBpbml0aWFsaXNhdGlvbiB0aGV5IGF1dG9tYXRpY2FsbHkgY3JlYXRlIG90aGVyIGluY2lkZW50cyBhbmQgYXV0b21hdGljYWxseSBwdXQgdGhlbVxuICAgICAqIG9uIHNwZWNpZmljIHBvaW50cyBvbiB0aGVpciB0aW1lbGluZS5cbiAgICAgKi9cblxuXG4gICAgdGhpcy5hdXRvR2VuZXJhdGVkID0gZmFsc2U7XG4gICAgdGhpcy5vbkluaXRpYWxpc2UoYXR0cnMsIHByb3BzKTtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIEY6IEluY2lkZW50LFxuICAgIGQ6IFt7XG4gICAgICBraW5kOiBcImdldFwiLFxuICAgICAga2V5OiBcInNlbGVjdG9yXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2VsZWN0b3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BzLnNlbGVjdG9yO1xuICAgICAgfVxuICAgICAgLyogc2hvcnRjdXRzIGZvciBhdHRycy5hdHRycyBhbmQgYXR0cnMuYW5pbWF0ZWRBdHRycyAqL1xuXG4gICAgfSwge1xuICAgICAga2luZDogXCJnZXRcIixcbiAgICAgIGtleTogXCJhbmltQXR0cmlidXRlc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFuaW1BdHRyaWJ1dGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdHRycy5hbmltYXRlZEF0dHJzO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICBUaGlzIG1ldGhvZCBzaG91ZGwgYmUgb3ZlcndyaXR0ZW4gYnkgdGhlIEluY2lkZW50cyBvZiB0aGUgcGx1Z2lucy4gVGhlIG1ldGhvZCByZXR1cm5zXG4gICAgICB0aGUgaW5pdGlhbCB2YWx1ZSB0aGF0IHRoZSBlbGVtZW50IG9mIGl0IGhhcyBhcyB0aGUgbGlicmFyeSBjYWxjdWxhdGVzIC8gZGVmaW5lcyB0aGVtLiBUaGVcbiAgICAgIHJldHVybmVkIHZhbHVlIHJlcHJlc2VudHMgdGhlIHZlcnkgaW5pdGlhbCB2YWx1ZSBvZiB0aGUgZWxlbWVudCdzIGF0dHJpYnV0ZSBiZWZvcmVcbiAgICAgIGFueSBJbmNpZGVudCB0aGF0IGFsdGVycyBpdCBnZXRzIGFkZGVkLlxuICAgICAgIEByZXR1cm5zIHttaXhlZH0gLSB0aGUgaW5pdGlhbCB2YWx1ZSBvZiB0aGUgZWxlbWVudCdzIGF0dHJpYnV0ZSBqdXN0IHdoZW4gdGhlIEhUTUwgJiBDU1NcbiAgICAgIG9mIHRoZSBDbGlwIGdldHMgcmVuZGVyZWRcbiAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBraW5kOiBcIm1ldGhvZFwiLFxuICAgICAga2V5OiBcImdldFNjcmF0Y2hWYWx1ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNjcmF0Y2hWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2luZDogXCJnZXRcIixcbiAgICAgIGtleTogXCJlbGVtZW50XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZWxlbWVudCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29udGV4ID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuY29udGV4dC5nZXRFbGVtZW50QnlNQ0lEKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5nZXRFbGVtZW50QnlNQ0lEKHRoaXMubWNpZCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0LmdldEVsZW1lbnRzKHRoaXMuc2VsZWN0b3IpWzBdO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtpbmQ6IFwiZ2V0XCIsXG4gICAgICBrZXk6IFwiYXR0cmlidXRlS2V5XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYXR0cmlidXRlS2V5KCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5hdHRycy5hbmltYXRlZEF0dHJzKVswXTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBraW5kOiBcImdldFwiLFxuICAgICAga2V5OiBcInRhcmdldFZhbHVlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdGFyZ2V0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFuaW1BdHRyaWJ1dGVzW3RoaXMuYXR0cmlidXRlS2V5XTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBraW5kOiBcIm1ldGhvZFwiLFxuICAgICAga2V5OiBcImdldEVsZW1lbnRBdHRyaWJ1dGVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRFbGVtZW50QXR0cmlidXRlKGF0dHIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoYXR0cik7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2luZDogXCJtZXRob2RcIixcbiAgICAgIGRlY29yYXRvcnM6IFtnZXRJbmNpZGVudHNCeUNoYW5uZWxdLFxuICAgICAga2V5OiBcImdldEluY2lkZW50c0J5Q2hhbm5lbFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEluY2lkZW50c0J5Q2hhbm5lbCgpIHt9XG4gICAgfSwge1xuICAgICAga2luZDogXCJtZXRob2RcIixcbiAgICAgIGtleTogXCJfaGFzVXNlckRlZmluZWRJbml0aWFsVmFsdWVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFzVXNlckRlZmluZWRJbml0aWFsVmFsdWUoYXR0cikge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMudXNlckRlZmluZWRJbml0aWFsVmFsdWVzLCBhdHRyKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBraW5kOiBcIm1ldGhvZFwiLFxuICAgICAga2V5OiBcIl9nZXRVc2VyRGVmaW5lZEluaXRpYWxWYWx1ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRVc2VyRGVmaW5lZEluaXRpYWxWYWx1ZShhdHRyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVzZXJEZWZpbmVkSW5pdGlhbFZhbHVlc1thdHRyXTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBraW5kOiBcIm1ldGhvZFwiLFxuICAgICAga2V5OiBcInNldEluaXRpYWxWYWx1ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldEluaXRpYWxWYWx1ZSh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5faGFzVXNlckRlZmluZWRJbml0aWFsVmFsdWUodGhpcy5hdHRyaWJ1dGVLZXkpKSB7XG4gICAgICAgICAgaGVscGVyLm5vdGljZShcIkluY2lkZW50IHdpdGggaWQgXCIuY29uY2F0KHRoaXMuaWQsIFwiIGhhcyBpbml0aWFsIHZhbHVlIGRlZmluZWQgZm9yIFwiKS5jb25jYXQodGhpcy5hdHRyaWJ1dGVLZXksIFwiIGFuZCBubyBjaGFuZ2UgaXMgYWxsb3dlZCBvbiBpdFwiKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pbml0aWFsVmFsdWVzW3RoaXMuYXR0cmlidXRlS2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtpbmQ6IFwibWV0aG9kXCIsXG4gICAgICBrZXk6IFwiaGFzSW5pdGlhbFZhbHVlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaGFzSW5pdGlhbFZhbHVlKCkge1xuICAgICAgICB2YXIgYXR0ciA9IHRoaXMuYXR0cmlidXRlS2V5O1xuICAgICAgICByZXR1cm4gdGhpcy5faGFzVXNlckRlZmluZWRJbml0aWFsVmFsdWUoYXR0cikgfHwgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuaW5pdGlhbFZhbHVlcywgYXR0cik7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2luZDogXCJnZXRcIixcbiAgICAgIGtleTogXCJpbml0aWFsVmFsdWVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0aWFsVmFsdWUoKSB7XG4gICAgICAgIHZhciBhdHRyID0gdGhpcy5hdHRyaWJ1dGVLZXk7XG5cbiAgICAgICAgaWYgKHRoaXMuX2hhc1VzZXJEZWZpbmVkSW5pdGlhbFZhbHVlKGF0dHIpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2dldFVzZXJEZWZpbmVkSW5pdGlhbFZhbHVlKGF0dHIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuaW5pdGlhbFZhbHVlc1thdHRyXTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBraW5kOiBcIm1ldGhvZFwiLFxuICAgICAga2V5OiBcImdldEluaXRpYWxWYWx1ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEluaXRpYWxWYWx1ZSgpIHtcbiAgICAgICAgdmFyIGF0dHIgPSB0aGlzLmF0dHJpYnV0ZUtleTtcblxuICAgICAgICBpZiAodGhpcy5faGFzVXNlckRlZmluZWRJbml0aWFsVmFsdWUoYXR0cikpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0VXNlckRlZmluZWRJbml0aWFsVmFsdWUoYXR0cik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5pbml0aWFsVmFsdWVzW2F0dHJdO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtpbmQ6IFwibWV0aG9kXCIsXG4gICAgICBrZXk6IFwiX29uR2V0Q29udGV4dE9uY2VcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfb25HZXRDb250ZXh0T25jZSgpIHtcbiAgICAgICAgLy8gaWYgdGhlIEluY2lkZW50IGJlbG9uZ3MgdG8gYSBmcmFnbWVudGVkIGNvbnRleHQgdGhlcmUgYWJzb2x1dGVseVxuICAgICAgICAvLyBubyByZWFzb24gdG8gcnVuIHRoZSBnZXRDb250ZXh0IG1ldGhvZCBvZiBpdFxuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICh0aGlzLmNvbnRleHQuZnJhZ21lbnQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIXRoaXMuZ290Q29udGV4dCkge1xuICAgICAgICAgICAgdGhpcy5vbkdldENvbnRleHQoKTtcbiAgICAgICAgICAgIHRoaXMuZ290Q29udGV4dCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coZSk7XG4gICAgICAgICAgY29uc29sZS5sb2codGhpcy5tY2lkKTsgLy8gY29uc29sZS5sb2codGhpcy5jb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtpbmQ6IFwibWV0aG9kXCIsXG4gICAgICBrZXk6IFwib25HZXRDb250ZXh0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gb25HZXRDb250ZXh0KCkge1xuICAgICAgICBoZWxwZXIuaW5mbygnT3ZlcndyaXR0ZSB0aGUgXCJvbkdldENvbnRleHRcIiBtZXRob2Qgd2l0aCB0aGUgY29kZSB5b3Ugd2FudCB0byBnZXQgZXhlY3V0ZWQnLCAnaW5mbycpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtpbmQ6IFwibWV0aG9kXCIsXG4gICAgICBrZXk6IFwibGFzdFdpc2hcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBsYXN0V2lzaCgpIHt9XG4gICAgfSwge1xuICAgICAga2luZDogXCJtZXRob2RcIixcbiAgICAgIGtleTogXCJvbkluaXRpYWxpc2VcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBvbkluaXRpYWxpc2UoKSB7XG4gICAgICAgIGhlbHBlci5pbmZvKCdPdmVyd3JpdHRlIHRoZSBcIm9uSW5pYWxpc2VcIiBtZXRob2Qgd2l0aCB0aGUgY29kZSB5b3Ugd2FudCB0byBnZXQgZXhlY3V0ZWQnLCAnaW5mbycpO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBNZXRob2QgY2FsbGVkIG9uIHByb2dyZXNzIG9mIHRoZSB0aW1lZCBpbmNpZGVudC5cbiAgICAgICAqIEBwYXJhbSB7ZmxvYXR9IGZyYWN0aW9uIC0gYSBudW1iZXIgZnJvbSAwIHRvIDEgcmVwcmVzZW50aW5nIHRoZSBmcmFjdGlvbiBvZiBkdXJhdGlvbiBjb3ZlcmVkXG4gICAgICAgKiBAcGFyYW0ge2ludH0gbWlsbGlzZWNvbmRzIC0gdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgcGFzc2VkIGZyb20gc3RhcnQgb2YgdGhlIGluY2lkZW50XG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtpbmQ6IFwibWV0aG9kXCIsXG4gICAgICBrZXk6IFwib25Qcm9ncmVzc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uUHJvZ3Jlc3MoZnJhY3Rpb24sIG1pbGxpc2Vjb25kcykgey8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIH1cbiAgICB9XVxuICB9O1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gSW5jaWRlbnQ7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/_BaseClasses/Incident.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/_BaseClasses/decorators/handleResize.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/_BaseClasses/decorators/handleResize.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction handleResize(pld) {\n  pld.descriptor.value = function (target, payload) {\n    // eslint-disable-line no-unused-vars\n    if (this.id === target) {\n      return this;\n    } else {\n      return this.bypass();\n    }\n  };\n}\n\nmodule.exports = handleResize;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19CYXNlQ2xhc3Nlcy9kZWNvcmF0b3JzL2hhbmRsZVJlc2l6ZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Aa2lzc215YnV0dG9uL21vdG9yY29ydGV4L2Rpc3QvX0Jhc2VDbGFzc2VzL2RlY29yYXRvcnMvaGFuZGxlUmVzaXplLmpzPzE5ZDkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIGhhbmRsZVJlc2l6ZShwbGQpIHtcbiAgcGxkLmRlc2NyaXB0b3IudmFsdWUgPSBmdW5jdGlvbiAodGFyZ2V0LCBwYXlsb2FkKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIGlmICh0aGlzLmlkID09PSB0YXJnZXQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5ieXBhc3MoKTtcbiAgICB9XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFuZGxlUmVzaXplOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/_BaseClasses/decorators/handleResize.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/_Channels/Channel.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/_Channels/Channel.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar Helper = __webpack_require__(/*! ../_coreUtils/Helper */ \"./node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\");\n\nvar helper = new Helper();\n\nvar Channel =\n/*#__PURE__*/\nfunction () {\n  function Channel(props) {\n    _classCallCheck(this, Channel);\n\n    this.runTimeInfo = props.runTimeInfo;\n    this.context = props.context;\n    this.onInitialise();\n    this.getIncidentById = props.getIncidentById; // this.type = \"plain\";\n  }\n\n  _createClass(Channel, [{\n    key: \"onInitialise\",\n    value: function onInitialise() {}\n  }, {\n    key: \"_resize\",\n    value: function _resize() {\n      helper.log('Please overwite the _resize method of the Channel');\n    }\n    /**\n     * @param {array} incidents - A collection of Incidents in the form:\n     * {\n     *  millisecond\n     *  incident\n     *  id\n     * }\n     * @returns either:\n     *   {\n     *       result:true,\n     *       execute: // an array of functions that when executed it will add the Incidents on the Channels\n     *   }\n     *   or\n     *   {\n     *       result: false,\n     *       errors\n     *   }\n     */\n\n  }, {\n    key: \"addIncidents\",\n    value: function addIncidents(incidents) {\n      // first check the Incidents addition directly using the checkAddition method of the class\n      var result = this.checkAddition(incidents);\n\n      if (result.result === false) {\n        return {\n          result: false,\n          errors: result.errors\n        };\n      } else {\n        return {\n          result: true,\n          execute: result.execute\n        };\n      }\n    }\n    /**\n     * It initially checks if the edit is allowed and if it is it retuns an array of executable functions\n     * that apply the change\n     * @param {array} incidents - the list of the incidents to edit in an array format [object, object, ...]\n     * @param {int} millisecondsDelta - the milliseconds delta to apply to the incidents\n     * @returns {object} -\n     * either:\n     {\n        result: true,\n        execute: // array of functions to be executed in order to apply the edit\n     }\n     or\n     {\n         result: false,\n         errors: // an array including all the errors / conflicts found on edit\n     }\n    */\n\n  }, {\n    key: \"editIncidents\",\n    value: function editIncidents(incidents, millisecondsDelta) {\n      // first check the Incidents addition directly using the checkAddition method of the class\n      var result = this.checkEdit(incidents, millisecondsDelta);\n\n      if (result.result === false) {\n        return {\n          result: false,\n          errors: result.errors\n        };\n      } else {\n        return {\n          result: true,\n          execute: result.execute\n        };\n      }\n    }\n    /**\n     * Method to remove incidents\n     * @param {array} incidents - the ids of the incidents to remove in an array format\n     * @param {object} props\n     * @retuns {object} -\n     * either:\n     {\n        result: true,\n        execute: // array of functions to be executed in order to apply the edit\n     }\n     or\n     {\n         result: false,\n         errors: // an array including all the errors / conflicts found on edit\n     }\n    */\n\n  }, {\n    key: \"removeIncidents\",\n    value: function removeIncidents(incidents) {\n      var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      // first check the Incidents addition directly using the checkAddition method of the class\n      var result = this.checkDelete(incidents, props);\n\n      if (result.result === false) {\n        return {\n          result: false,\n          errors: result.errors\n        };\n      } else {\n        return {\n          result: true,\n          execute: result.execute\n        };\n      }\n    }\n    /**\n     * On this method the user defines the specific rules that apply on the plugin itself and on the Incidents of the plugin itself\n     * The method should either return {result: true} or {result: false, errors:[{error-object}]}, where error-object has the structure:\n     *  {\n            incident: // reference to the Incident object that has bee discarded\n            error: // text\n        }\n    * @param {array} incidents - a colleciton of all incidents to be added on the form:\n    *\n        {\n            id\n            millisecond\n            incident\n        }\n    * @returns {object} -\n    * either:\n        {\n            result:true,\n            execute: // a function that when executed it will add the Incidents on the Channels\n        }\n        or\n        {\n            result: false,\n            errors\n        }\n    */\n\n  }, {\n    key: \"checkAddition\",\n    value: function checkAddition(incidents) {\n      // eslint-disable-line no-unused-vars\n      return {\n        result: true,\n        execute: function execute() {}\n      };\n    }\n  }, {\n    key: \"checkEdit\",\n    value: function checkEdit(incidentsArray, millisecondsDelta) {\n      // eslint-disable-line no-unused-vars\n      return {\n        result: true,\n        execute: function execute() {}\n      };\n    }\n  }, {\n    key: \"checkDelete\",\n    value: function checkDelete(incidentIds) {\n      // eslint-disable-line no-unused-vars\n      return {\n        result: true,\n        execute: function execute() {}\n      };\n    }\n  }, {\n    key: \"checkResizedIncidents\",\n    value: function checkResizedIncidents(incidents) {\n      // eslint-disable-line no-unused-vars\n      return {\n        result: true,\n        execute: function execute() {}\n      };\n    }\n  }, {\n    key: \"moveTo\",\n    value: function moveTo(from, to, contextId) {} // eslint-disable-line no-unused-vars\n\n  }], [{\n    key: \"type\",\n    get: function get() {\n      return \"plain\";\n    }\n  }]);\n\n  return Channel;\n}();\n\nmodule.exports = Channel;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19DaGFubmVscy9DaGFubmVsLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvZGlzdC9fQ2hhbm5lbHMvQ2hhbm5lbC5qcz9lMzQyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbnZhciBIZWxwZXIgPSByZXF1aXJlKCcuLi9fY29yZVV0aWxzL0hlbHBlcicpO1xuXG52YXIgaGVscGVyID0gbmV3IEhlbHBlcigpO1xuXG52YXIgQ2hhbm5lbCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENoYW5uZWwocHJvcHMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2hhbm5lbCk7XG5cbiAgICB0aGlzLnJ1blRpbWVJbmZvID0gcHJvcHMucnVuVGltZUluZm87XG4gICAgdGhpcy5jb250ZXh0ID0gcHJvcHMuY29udGV4dDtcbiAgICB0aGlzLm9uSW5pdGlhbGlzZSgpO1xuICAgIHRoaXMuZ2V0SW5jaWRlbnRCeUlkID0gcHJvcHMuZ2V0SW5jaWRlbnRCeUlkOyAvLyB0aGlzLnR5cGUgPSBcInBsYWluXCI7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQ2hhbm5lbCwgW3tcbiAgICBrZXk6IFwib25Jbml0aWFsaXNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uSW5pdGlhbGlzZSgpIHt9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3Jlc2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVzaXplKCkge1xuICAgICAgaGVscGVyLmxvZygnUGxlYXNlIG92ZXJ3aXRlIHRoZSBfcmVzaXplIG1ldGhvZCBvZiB0aGUgQ2hhbm5lbCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2FycmF5fSBpbmNpZGVudHMgLSBBIGNvbGxlY3Rpb24gb2YgSW5jaWRlbnRzIGluIHRoZSBmb3JtOlxuICAgICAqIHtcbiAgICAgKiAgbWlsbGlzZWNvbmRcbiAgICAgKiAgaW5jaWRlbnRcbiAgICAgKiAgaWRcbiAgICAgKiB9XG4gICAgICogQHJldHVybnMgZWl0aGVyOlxuICAgICAqICAge1xuICAgICAqICAgICAgIHJlc3VsdDp0cnVlLFxuICAgICAqICAgICAgIGV4ZWN1dGU6IC8vIGFuIGFycmF5IG9mIGZ1bmN0aW9ucyB0aGF0IHdoZW4gZXhlY3V0ZWQgaXQgd2lsbCBhZGQgdGhlIEluY2lkZW50cyBvbiB0aGUgQ2hhbm5lbHNcbiAgICAgKiAgIH1cbiAgICAgKiAgIG9yXG4gICAgICogICB7XG4gICAgICogICAgICAgcmVzdWx0OiBmYWxzZSxcbiAgICAgKiAgICAgICBlcnJvcnNcbiAgICAgKiAgIH1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImFkZEluY2lkZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRJbmNpZGVudHMoaW5jaWRlbnRzKSB7XG4gICAgICAvLyBmaXJzdCBjaGVjayB0aGUgSW5jaWRlbnRzIGFkZGl0aW9uIGRpcmVjdGx5IHVzaW5nIHRoZSBjaGVja0FkZGl0aW9uIG1ldGhvZCBvZiB0aGUgY2xhc3NcbiAgICAgIHZhciByZXN1bHQgPSB0aGlzLmNoZWNrQWRkaXRpb24oaW5jaWRlbnRzKTtcblxuICAgICAgaWYgKHJlc3VsdC5yZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVzdWx0OiBmYWxzZSxcbiAgICAgICAgICBlcnJvcnM6IHJlc3VsdC5lcnJvcnNcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVzdWx0OiB0cnVlLFxuICAgICAgICAgIGV4ZWN1dGU6IHJlc3VsdC5leGVjdXRlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEl0IGluaXRpYWxseSBjaGVja3MgaWYgdGhlIGVkaXQgaXMgYWxsb3dlZCBhbmQgaWYgaXQgaXMgaXQgcmV0dW5zIGFuIGFycmF5IG9mIGV4ZWN1dGFibGUgZnVuY3Rpb25zXG4gICAgICogdGhhdCBhcHBseSB0aGUgY2hhbmdlXG4gICAgICogQHBhcmFtIHthcnJheX0gaW5jaWRlbnRzIC0gdGhlIGxpc3Qgb2YgdGhlIGluY2lkZW50cyB0byBlZGl0IGluIGFuIGFycmF5IGZvcm1hdCBbb2JqZWN0LCBvYmplY3QsIC4uLl1cbiAgICAgKiBAcGFyYW0ge2ludH0gbWlsbGlzZWNvbmRzRGVsdGEgLSB0aGUgbWlsbGlzZWNvbmRzIGRlbHRhIHRvIGFwcGx5IHRvIHRoZSBpbmNpZGVudHNcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSAtXG4gICAgICogZWl0aGVyOlxuICAgICB7XG4gICAgICAgIHJlc3VsdDogdHJ1ZSxcbiAgICAgICAgZXhlY3V0ZTogLy8gYXJyYXkgb2YgZnVuY3Rpb25zIHRvIGJlIGV4ZWN1dGVkIGluIG9yZGVyIHRvIGFwcGx5IHRoZSBlZGl0XG4gICAgIH1cbiAgICAgb3JcbiAgICAge1xuICAgICAgICAgcmVzdWx0OiBmYWxzZSxcbiAgICAgICAgIGVycm9yczogLy8gYW4gYXJyYXkgaW5jbHVkaW5nIGFsbCB0aGUgZXJyb3JzIC8gY29uZmxpY3RzIGZvdW5kIG9uIGVkaXRcbiAgICAgfVxuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJlZGl0SW5jaWRlbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVkaXRJbmNpZGVudHMoaW5jaWRlbnRzLCBtaWxsaXNlY29uZHNEZWx0YSkge1xuICAgICAgLy8gZmlyc3QgY2hlY2sgdGhlIEluY2lkZW50cyBhZGRpdGlvbiBkaXJlY3RseSB1c2luZyB0aGUgY2hlY2tBZGRpdGlvbiBtZXRob2Qgb2YgdGhlIGNsYXNzXG4gICAgICB2YXIgcmVzdWx0ID0gdGhpcy5jaGVja0VkaXQoaW5jaWRlbnRzLCBtaWxsaXNlY29uZHNEZWx0YSk7XG5cbiAgICAgIGlmIChyZXN1bHQucmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlc3VsdDogZmFsc2UsXG4gICAgICAgICAgZXJyb3JzOiByZXN1bHQuZXJyb3JzXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlc3VsdDogdHJ1ZSxcbiAgICAgICAgICBleGVjdXRlOiByZXN1bHQuZXhlY3V0ZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdG8gcmVtb3ZlIGluY2lkZW50c1xuICAgICAqIEBwYXJhbSB7YXJyYXl9IGluY2lkZW50cyAtIHRoZSBpZHMgb2YgdGhlIGluY2lkZW50cyB0byByZW1vdmUgaW4gYW4gYXJyYXkgZm9ybWF0XG4gICAgICogQHBhcmFtIHtvYmplY3R9IHByb3BzXG4gICAgICogQHJldHVucyB7b2JqZWN0fSAtXG4gICAgICogZWl0aGVyOlxuICAgICB7XG4gICAgICAgIHJlc3VsdDogdHJ1ZSxcbiAgICAgICAgZXhlY3V0ZTogLy8gYXJyYXkgb2YgZnVuY3Rpb25zIHRvIGJlIGV4ZWN1dGVkIGluIG9yZGVyIHRvIGFwcGx5IHRoZSBlZGl0XG4gICAgIH1cbiAgICAgb3JcbiAgICAge1xuICAgICAgICAgcmVzdWx0OiBmYWxzZSxcbiAgICAgICAgIGVycm9yczogLy8gYW4gYXJyYXkgaW5jbHVkaW5nIGFsbCB0aGUgZXJyb3JzIC8gY29uZmxpY3RzIGZvdW5kIG9uIGVkaXRcbiAgICAgfVxuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVJbmNpZGVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlSW5jaWRlbnRzKGluY2lkZW50cykge1xuICAgICAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAgIC8vIGZpcnN0IGNoZWNrIHRoZSBJbmNpZGVudHMgYWRkaXRpb24gZGlyZWN0bHkgdXNpbmcgdGhlIGNoZWNrQWRkaXRpb24gbWV0aG9kIG9mIHRoZSBjbGFzc1xuICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuY2hlY2tEZWxldGUoaW5jaWRlbnRzLCBwcm9wcyk7XG5cbiAgICAgIGlmIChyZXN1bHQucmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlc3VsdDogZmFsc2UsXG4gICAgICAgICAgZXJyb3JzOiByZXN1bHQuZXJyb3JzXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlc3VsdDogdHJ1ZSxcbiAgICAgICAgICBleGVjdXRlOiByZXN1bHQuZXhlY3V0ZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBPbiB0aGlzIG1ldGhvZCB0aGUgdXNlciBkZWZpbmVzIHRoZSBzcGVjaWZpYyBydWxlcyB0aGF0IGFwcGx5IG9uIHRoZSBwbHVnaW4gaXRzZWxmIGFuZCBvbiB0aGUgSW5jaWRlbnRzIG9mIHRoZSBwbHVnaW4gaXRzZWxmXG4gICAgICogVGhlIG1ldGhvZCBzaG91bGQgZWl0aGVyIHJldHVybiB7cmVzdWx0OiB0cnVlfSBvciB7cmVzdWx0OiBmYWxzZSwgZXJyb3JzOlt7ZXJyb3Itb2JqZWN0fV19LCB3aGVyZSBlcnJvci1vYmplY3QgaGFzIHRoZSBzdHJ1Y3R1cmU6XG4gICAgICogIHtcbiAgICAgICAgICAgIGluY2lkZW50OiAvLyByZWZlcmVuY2UgdG8gdGhlIEluY2lkZW50IG9iamVjdCB0aGF0IGhhcyBiZWUgZGlzY2FyZGVkXG4gICAgICAgICAgICBlcnJvcjogLy8gdGV4dFxuICAgICAgICB9XG4gICAgKiBAcGFyYW0ge2FycmF5fSBpbmNpZGVudHMgLSBhIGNvbGxlY2l0b24gb2YgYWxsIGluY2lkZW50cyB0byBiZSBhZGRlZCBvbiB0aGUgZm9ybTpcbiAgICAqXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlkXG4gICAgICAgICAgICBtaWxsaXNlY29uZFxuICAgICAgICAgICAgaW5jaWRlbnRcbiAgICAgICAgfVxuICAgICogQHJldHVybnMge29iamVjdH0gLVxuICAgICogZWl0aGVyOlxuICAgICAgICB7XG4gICAgICAgICAgICByZXN1bHQ6dHJ1ZSxcbiAgICAgICAgICAgIGV4ZWN1dGU6IC8vIGEgZnVuY3Rpb24gdGhhdCB3aGVuIGV4ZWN1dGVkIGl0IHdpbGwgYWRkIHRoZSBJbmNpZGVudHMgb24gdGhlIENoYW5uZWxzXG4gICAgICAgIH1cbiAgICAgICAgb3JcbiAgICAgICAge1xuICAgICAgICAgICAgcmVzdWx0OiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yc1xuICAgICAgICB9XG4gICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNoZWNrQWRkaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tBZGRpdGlvbihpbmNpZGVudHMpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlc3VsdDogdHJ1ZSxcbiAgICAgICAgZXhlY3V0ZTogZnVuY3Rpb24gZXhlY3V0ZSgpIHt9XG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjaGVja0VkaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tFZGl0KGluY2lkZW50c0FycmF5LCBtaWxsaXNlY29uZHNEZWx0YSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVzdWx0OiB0cnVlLFxuICAgICAgICBleGVjdXRlOiBmdW5jdGlvbiBleGVjdXRlKCkge31cbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNoZWNrRGVsZXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrRGVsZXRlKGluY2lkZW50SWRzKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICByZXR1cm4ge1xuICAgICAgICByZXN1bHQ6IHRydWUsXG4gICAgICAgIGV4ZWN1dGU6IGZ1bmN0aW9uIGV4ZWN1dGUoKSB7fVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2hlY2tSZXNpemVkSW5jaWRlbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrUmVzaXplZEluY2lkZW50cyhpbmNpZGVudHMpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlc3VsdDogdHJ1ZSxcbiAgICAgICAgZXhlY3V0ZTogZnVuY3Rpb24gZXhlY3V0ZSgpIHt9XG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtb3ZlVG9cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW92ZVRvKGZyb20sIHRvLCBjb250ZXh0SWQpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuICB9XSwgW3tcbiAgICBrZXk6IFwidHlwZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIFwicGxhaW5cIjtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ2hhbm5lbDtcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBDaGFubmVsOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/_Channels/Channel.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/_Channels/_Attribute/AttributeChannel.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/_Channels/_Attribute/AttributeChannel.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar Channel = __webpack_require__(/*! ../Channel */ \"./node_modules/@kissmybutton/motorcortex/dist/_Channels/Channel.js\");\n\nvar Helper = __webpack_require__(/*! ../../_coreUtils/Helper */ \"./node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\");\n\nvar helper = new Helper();\n\nvar _filter = __webpack_require__(/*! ../../../lodash-custom-build/modularize/lodash.filter/index */ \"./node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.filter/index.js\");\n\nvar _sortBy = __webpack_require__(/*! ../../../lodash-custom-build/modularize/lodash.sortby/index */ \"./node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.sortby/index.js\");\n\nvar lanesHandler = __webpack_require__(/*! ./LanesHandler */ \"./node_modules/@kissmybutton/motorcortex/dist/_Channels/_Attribute/LanesHandler.js\");\n\nvar AttributeChannel =\n/*#__PURE__*/\nfunction (_Channel) {\n  _inherits(AttributeChannel, _Channel);\n\n  function AttributeChannel(props) {\n    var _this;\n\n    _classCallCheck(this, AttributeChannel);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(AttributeChannel).call(this, props));\n    /*\n    comboAttributes are attributes of type object, holding a number of other attributes.\n    E.g. CSS \"transform\" attribute is a combo that holds a number of other attributes such as:\n    translateX, translateY, etc. The lanes handler keeps just one lane for the combo attrs\n    in an object format keeping the value of each attribute at any given point.\n    Combo attributes are passed on the constructor of the Channel in the format:\n    props.comboAttributes: {\n        transition: ['translateX', 'translateY', ...],\n        <something_else>: ['<attrName1>', '<attrName2>', ...]\n    }\n    */\n\n    _this.comboAttributes = {};\n    /**\n     * For incidents that do not have animatedAttrs there should be only one lane per element.\n     * The attributes Channel will use a default (fake), fixed attribute for this cases so it always ends\n     * up with just one lane per element: <element_id>_<this.fixedAttributeName>\n     */\n\n    _this.fixedAttributeName = \"_\";\n\n    if (props.comboAttributes != null) {\n      _this.comboAttributes = props.comboAttributes;\n    }\n\n    _this.LanesHandler = new lanesHandler({\n      comboAttributes: _this.comboAttributes,\n      runTimeInfo: _this.runTimeInfo\n    }); // this.type = \"attributes\";\n\n    return _this;\n  }\n\n  _createClass(AttributeChannel, [{\n    key: \"setComboAttributes\",\n    value: function setComboAttributes(comboAttributes) {\n      this.comboAttributes = comboAttributes;\n      this.LanesHandler = new lanesHandler({\n        comboAttributes: this.comboAttributes\n      });\n    }\n  }, {\n    key: \"_resize\",\n    value: function _resize(durationFraction) {\n      this.LanesHandler._resize(durationFraction);\n    }\n    /* *******************************************************\n     DECISION METHODS\n     ********************************************************/\n\n    /**\n     * All of the incidents coming to this method are element-attribute incidents meaning that they only\n     * target just one element and also they include just a single attribute on the incident.attrs.animatedAttrs\n     * object\n     *\n     * @param {array} incidents - A collection of Incidents in the form:\n     * {\n     *  millisecond\n     *  incident\n     *  id\n     * }\n     * @param {string} type - can be either \"all-or-nothing\" (default) or \"keep-passing\". If type = \"all-or-nothing\"\n     *  the addition passes only if all incidents pass. If type = \"keep-passing\" the method will still return true\n     *  but will also include an errors array on its return and also will only include the success callbacks on\n     *  the execute key of its return\n     * @returns either:\n     *   {\n     *       result:true,\n     *       execute: // an array of functions that when executed it will add the Incidents on the Channels\n     *   }\n     *   or\n     *   {\n     *       result: false,\n     *       errors\n     *   }\n     */\n\n  }, {\n    key: \"checkAddition\",\n    value: function checkAddition(incidents) {\n      var _this2 = this;\n\n      var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"all-or-nothing\";\n      var LanesHandlerSandbox = this.LanesHandler.createTestLanesSanbox();\n      /* an array where we keep all affected lanes so we can slip on them at the end.\n      The format for each affected lane we keep is:\n      {\n          mcid: mcid,\n          attribute: attribute\n      }\n      */\n\n      var affectedLanes = []; // while the LanesHandlerSanbox adds lane items it makes decisions of which permanent changes should be made to\n      // the permanent and pre-existing objects it handles, such as changes on the initial values of existing animations.\n      // Because of the fact the LanesSandboxHandler is only there for testing we don't want to execute these changes\n      // during checks but still we need to know them on success. For this, the onSuccessActions array holds all executable\n      // functions retured by various LanesHandlerSanbox functions so it can execute them on success.\n\n      var onSuccessActions = [];\n      var conflicts = [];\n\n      var _loop = function _loop(i) {\n        var incidentConflicts = false; // a boolean that keeps the information whether the incident conflicts or not\n\n        var laneItem = incidents[i];\n        var incident = laneItem.incident;\n        var mcid = incident.mcid;\n        var attribute = incident.attribute || _this2.fixedAttributeName;\n        LanesHandlerSandbox.laneExists(mcid, attribute); // create the lane if it doesn't exist already\n\n        affectedLanes.push({\n          mcid: mcid,\n          attribute: attribute\n        }); // **** if the lane did exist before the new addition check for conflicts\n\n        var overlappingAnims = LanesHandlerSandbox.getOverlappingAnims(laneItem, mcid, attribute); // helper.log(overlappingAnim)\n\n        if (overlappingAnims.length > 0) {\n          incidentConflicts = true;\n          conflicts.push({\n            type: 'unauthorised, overlapping incidents on the same element',\n            meta: {\n              element_mcid: mcid,\n              attribute: attribute,\n              incident: laneItem,\n              overlappingAnims: overlappingAnims\n            }\n          });\n        }\n\n        if (!incidentConflicts) {\n          onSuccessActions.push(function () {\n            LanesHandlerSandbox.addElementToLane(mcid, attribute, laneItem.millisecond, incident);\n\n            incident._onGetContextOnce();\n          });\n        }\n      };\n\n      for (var i = 0; i < incidents.length; i++) {\n        _loop(i);\n      } // end for each incident\n      // if we have conflicts and the type = \"all-or-nothing\"\n\n\n      if (conflicts.length > 0 && type === \"all-or-nothing\") {\n        return {\n          result: false,\n          errors: conflicts\n        };\n      } else {\n        // as soon as we want all passing additions to get applied the Lanes Handler will create a callback that will be passed to the result.\n        // This callback will apply all passing additions.\n        // success message\n        var that = this;\n\n        var exec = function exec() {\n          for (var i = 0; i < onSuccessActions.length; i++) {\n            onSuccessActions[i]();\n          }\n\n          that.LanesHandler.applySandboxChanges(LanesHandlerSandbox);\n        };\n\n        return {\n          result: true,\n          errors: conflicts,\n          execute: exec\n        };\n      }\n    }\n    /**\n     * It initially checks if the edit is allowed and if it is it retuns an array of executable functions\n     * that apply the change\n     * @param {array} incidents - the list of the lane items to edit in an array format [object, object, ...]\n     * @param {int} millisecondsDelta - the milliseconds delta to apply to the incidents\n     * @returns {object} -\n     * either:\n     {\n        result: true,\n        execute: // array of functions to be executed in order to apply the edit\n     }\n     or\n     {\n         result: false,\n         errors: // an array including all the errors / conflicts found on edit\n     }\n    */\n\n  }, {\n    key: \"checkEdit\",\n    value: function checkEdit(incidents, millisecondsDelta) {\n      // console.log(incidents);\n      var affectedIncidentIds = [];\n\n      for (var i = 0; i < incidents.length; i++) {\n        affectedIncidentIds.push(incidents[i].id);\n      }\n\n      var LanesHandlerSandbox = this.LanesHandler.createTestLanesSanbox();\n      var conflicts = [];\n      var affectedLanes = []; // for each of the affectedAnimations\n\n      for (var _i = 0; _i < incidents.length; _i++) {\n        var incident = incidents[_i].incident;\n        var incidentId = incident.id;\n        var mcid = incidents[_i].incident.mcid;\n        var attribute = incidents[_i].incident.attribute || this.fixedAttributeName;\n        var lane = LanesHandlerSandbox.getLane(mcid, attribute);\n        var laneAttrs = {\n          mcid: mcid,\n          attribute: attribute // check for conflicts and edit lane items millisecond\n\n        };\n\n        for (var k = 0; k < lane.length; k++) {\n          if (lane[k].id === incidentId) {\n            affectedLanes.push(laneAttrs);\n            var affectedAnim = lane[k];\n            var testLaneElement = LanesHandlerSandbox.getLaneElementsClone(affectedAnim);\n            testLaneElement.millisecond += millisecondsDelta;\n            testLaneElement.incident = LanesHandlerSandbox.incidentsById._get(testLaneElement.id);\n            var overlappingAnims = LanesHandlerSandbox.getOverlappingAnims(testLaneElement, mcid, attribute, affectedIncidentIds);\n\n            if (overlappingAnims.length > 0) {\n              conflicts.push({\n                type: 'anauthorised, overlapping animations on the same element',\n                meta: {\n                  element_mcid: mcid,\n                  attribute: attribute,\n                  newAnimation: testLaneElement,\n                  overlappingAnims: overlappingAnims\n                }\n              });\n            }\n\n            break;\n          } // end of if we found the specific animation on the lane's sequence\n\n        } // end of each lane's item\n\n      } // end for each affected animation's id\n\n\n      if (conflicts.length > 0) {\n        return {\n          result: false,\n          errors: conflicts\n        };\n      } else {\n        var that = this;\n\n        var exec = function exec() {\n          that.LanesHandler.updateLane(affectedIncidentIds, millisecondsDelta);\n        };\n\n        return {\n          result: true,\n          execute: exec\n        };\n      }\n    }\n    /**\n     * @param {array} incidents - [{id, start, end, startDelta}]\n     * @param {boolean} fullChannelResize - if set to true then the full html channel is resizing. This is a special case as in\n     *  that case no checks should be actually perfomed nor the projected candidate should be applied directly\n     **/\n\n  }, {\n    key: \"checkResizedIncidents\",\n    value: function checkResizedIncidents(incidents) {\n      var fullChannelResize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var excludeIdsFromCheck = [];\n\n      for (var i = 0; i < incidents.length; i++) {\n        excludeIdsFromCheck.push(incidents[i].id);\n      }\n\n      var LanesHandlerSandbox = this.LanesHandler.createTestLanesSanbox();\n      var conflicts = [];\n      var affectedLanes = []; // for each of the incidents passed\n\n      for (var _i2 = 0; _i2 < incidents.length; _i2++) {\n        // get the ContextAwareIncident\n        var incident = this.LanesHandler.incidentsById._get(incidents[_i2].id);\n\n        var mcid = incident.mcid;\n        var attribute = incident.attribute || this.fixedAttributeName;\n        var lane = LanesHandlerSandbox.getLane(mcid, attribute);\n        var laneAttrs = {\n          mcid: mcid,\n          attribute: attribute\n        };\n        var testDuration = incidents[_i2].end - incidents[_i2].start; // check for conflicts and edit lane items millisecond\n\n        for (var k = 0; k < lane.length; k++) {\n          if (lane[k].id === incidents[_i2].id) {\n            affectedLanes.push(laneAttrs);\n\n            if (fullChannelResize === false) {\n              var affectedAnim = lane[k];\n              var testLaneElement = LanesHandlerSandbox.getLaneElementsClone(affectedAnim);\n              testLaneElement.millisecond += incidents[_i2].startDelta;\n              testLaneElement.incident = LanesHandlerSandbox.incidentsById._get(testLaneElement.id);\n              var overlappingAnims = LanesHandlerSandbox.getOverlappingAnims(testLaneElement, laneAttrs.mcid, laneAttrs.attribute, excludeIdsFromCheck, testDuration);\n\n              if (overlappingAnims.length > 0) {\n                conflicts.push({\n                  type: 'anauthorised overlapping animations on the same element',\n                  meta: {\n                    element_mcid: laneAttrs.mcid,\n                    attribute: laneAttrs.attribute,\n                    newAnimation: testLaneElement,\n                    overlappingAnims: overlappingAnims\n                  }\n                });\n              }\n            }\n\n            break;\n          } // end of if we found the specific animation on the lane's sequence\n\n        } // end of each lane's item\n\n      } // end for each affected animation's id\n\n\n      if (conflicts.length > 0) {\n        return {\n          result: false,\n          errors: conflicts\n        };\n      } else {\n        var that = this;\n\n        var exec = function exec() {\n          // updateLanes (only this time animation by animation as the milliseconds delta is not standard for all)\n          // as soon as there are no conflicts the Lanes Handler applies the changes before sending over the\n          // success message\n          for (var _i3 = 0; _i3 < incidents.length; _i3++) {\n            that.LanesHandler.updateLane([incidents[_i3].id], incidents[_i3].startDelta);\n          }\n        };\n\n        return {\n          execute: exec,\n          result: true\n        };\n      }\n    }\n    /**\n     *\n     */\n\n  }, {\n    key: \"checkDelete\",\n    value: function checkDelete(removedAnimations) {\n      var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      // eslint-disable-line no-unused-vars\n      var removedAnimationIds = [];\n\n      for (var i = 0; i < removedAnimations.length; i++) {\n        removedAnimationIds.push(removedAnimations[i].id);\n      }\n\n      var that = this;\n\n      var exec = function exec() {\n        that.LanesHandler.deleteAnimations(removedAnimationIds);\n      };\n\n      return {\n        result: true,\n        execute: exec\n      };\n    }\n    /**\n     * Slips to just one lane forwards\n     * @param {array} lane - the lane to slip into\n     * @param {object} laneData - an object with keys: attribute & mcid\n     * @param {int} currentMillisecond - the millisecond the slip starts from\n     * @param {int} millisecond - the target millisecond of the slip\n     * @param {string} contextId - the contextId of the Incidents to slip\n     */\n\n  }, {\n    key: \"slipIntoLaneForwards\",\n    value: function slipIntoLaneForwards(lane, laneData, currentMillisecond, millisecond, contextId) {\n      var forceReset = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n      // console.log(lane, currentMillisecond, millisecond);\n      var that = this;\n\n      var participatingAnims = _filter(lane, function (laneItem) {\n        return laneItem.millisecond + that.incidentsById._get(laneItem.id).duration >= currentMillisecond && laneItem.millisecond + that.incidentsById._get(laneItem.id).duration <= millisecond || // it ends after currentMillisecond and before target millisecond\n        that.incidentsById._get(laneItem.id).duration + laneItem.millisecond >= millisecond && laneItem.millisecond <= millisecond; // or it ends after the target millisecond but also starts before it\n      });\n\n      if (participatingAnims.length == 0) {\n        if (forceReset === true) {\n          var firstIncident = this.incidentsById._get(lane[0].id);\n\n          firstIncident.onProgress(0, 0, contextId);\n        }\n\n        return true;\n      }\n\n      participatingAnims = _sortBy(participatingAnims, [function (laneItem) {\n        return laneItem.millisecond;\n      }]); // We only care about the last (in chronological order) Incident, as this\n      // will define the final value\n\n      var lastIndex = participatingAnims.length - 1;\n\n      var participatingAnim = this.incidentsById._get(participatingAnims[lastIndex].id);\n\n      var startMillisecond = participatingAnims[lastIndex].millisecond; // if the animation ends before the target millisecond\n\n      if (participatingAnim.duration + startMillisecond <= millisecond) {\n        // and it's the last one on the row\n        participatingAnim.onProgress(1, participatingAnim.duration, contextId);\n      } else {\n        // slip for the specific element and the specific attribute. Set the Animation as paused or playing a\n        // and store this info somewhere\n        var percentageComplete = (millisecond - startMillisecond) / participatingAnim.duration;\n        participatingAnim.onProgress(percentageComplete, millisecond - startMillisecond, contextId);\n      }\n    }\n    /**\n     * Slips to just one lane backwards\n     * @param {array} lane - the lane to slip into\n     * @param {object} laneData - an object with keys: attribute & mcid\n     * @param {int} currentMillisecond - the millisecond the slip starts from\n     * @param {int} millisecond - the target millisecond of the slip\n     * @param {string} contextId - the contextId of the Incidents to slip\n     */\n\n  }, {\n    key: \"slipToLaneBackwards\",\n    value: function slipToLaneBackwards(lane, laneData, currentMillisecond, millisecond, contextId) {\n      var forceReset = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n      // we take all Animations that are either currently running or\n      // they end after the destination point\n      // helper.log('<------');\n      var that = this;\n\n      var participatingAnims = _filter(lane, function (laneItem) {\n        var laneItemEnd = that.incidentsById._get(laneItem.id).duration + laneItem.millisecond;\n        return laneItemEnd <= millisecond && laneItemEnd >= currentMillisecond || // they end in the hot area\n        laneItem.millisecond >= currentMillisecond && laneItem.millisecond <= millisecond || // they start in the hot area\n        laneItem.millisecond < currentMillisecond && laneItemEnd > millisecond; // they overlap the hot area\n      });\n\n      if (participatingAnims.length == 0) {\n        if (participatingAnims.length == 0) {\n          if (forceReset === true) {\n            var firstIncident = this.incidentsById._get(lane[lane.length - 1].id);\n\n            firstIncident.onProgress(1, firstIncident.duration, contextId);\n          }\n\n          return true;\n        }\n\n        return true;\n      }\n\n      participatingAnims = _sortBy(participatingAnims, [function (laneItem) {\n        return laneItem.millisecond;\n      }]); // We only care about the first (in chronological order) Incident, as this\n      // will define the final value of the backwards move\n\n      var lastIndex = 0;\n\n      var participatingAnim = this.incidentsById._get(participatingAnims[lastIndex].id);\n\n      var startMillisecond = participatingAnims[lastIndex].millisecond; // if the animation starts after the target millisecond\n\n      if (startMillisecond >= millisecond) {\n        participatingAnim.onProgress(0, 0, contextId);\n      } else {\n        // slip for the specific element and the specific attribute. Set the Animation as paused or playing a\n        // and store this info somewhere\n        var percentageComplete = (millisecond - startMillisecond) / participatingAnim.duration;\n        participatingAnim.onProgress(percentageComplete, millisecond - startMillisecond, contextId);\n      }\n    }\n    /**\n     @param {int} from - the millisecond to start from\n     @param {int} to - the millisecond to go to\n     @param {sring} contextId - the context id to \"move\"\n     @param {boolean} forceReset - set to true if status recalc is needed after edit\n     */\n\n  }, {\n    key: \"moveTo\",\n    value: function moveTo(from, to, contextId) {\n      var forceReset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n      // step 1: iterate through all lanes\n      var laneKeys = this.lanes._keys();\n\n      for (var i = 0; i < laneKeys.length; i++) {\n        var laneid = laneKeys[i];\n\n        var lane = this.lanes._get(laneid);\n\n        var laneData = helper.getMCIDandAttrOutOfLaneKey(laneid);\n\n        if (from <= to) {\n          this.slipIntoLaneForwards(lane, laneData, from, to, contextId, forceReset);\n        } else if (from > to) {\n          this.slipToLaneBackwards(lane, laneData, from, to, contextId, forceReset);\n        }\n      }\n    }\n  }, {\n    key: \"lanes\",\n    get: function get() {\n      return this.LanesHandler.lanes;\n    }\n  }, {\n    key: \"incidentsById\",\n    get: function get() {\n      return this.LanesHandler.incidentsById;\n    }\n  }], [{\n    key: \"type\",\n    get: function get() {\n      return \"attributes\";\n    }\n  }]);\n\n  return AttributeChannel;\n}(Channel);\n\nmodule.exports = AttributeChannel;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19DaGFubmVscy9fQXR0cmlidXRlL0F0dHJpYnV0ZUNoYW5uZWwuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19DaGFubmVscy9fQXR0cmlidXRlL0F0dHJpYnV0ZUNoYW5uZWwuanM/ODU1NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbnZhciBDaGFubmVsID0gcmVxdWlyZSgnLi4vQ2hhbm5lbCcpO1xuXG52YXIgSGVscGVyID0gcmVxdWlyZSgnLi4vLi4vX2NvcmVVdGlscy9IZWxwZXInKTtcblxudmFyIGhlbHBlciA9IG5ldyBIZWxwZXIoKTtcblxudmFyIF9maWx0ZXIgPSByZXF1aXJlKCcuLi8uLi8uLi9sb2Rhc2gtY3VzdG9tLWJ1aWxkL21vZHVsYXJpemUvbG9kYXNoLmZpbHRlci9pbmRleCcpO1xuXG52YXIgX3NvcnRCeSA9IHJlcXVpcmUoJy4uLy4uLy4uL2xvZGFzaC1jdXN0b20tYnVpbGQvbW9kdWxhcml6ZS9sb2Rhc2guc29ydGJ5L2luZGV4Jyk7XG5cbnZhciBsYW5lc0hhbmRsZXIgPSByZXF1aXJlKCcuL0xhbmVzSGFuZGxlcicpO1xuXG52YXIgQXR0cmlidXRlQ2hhbm5lbCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0NoYW5uZWwpIHtcbiAgX2luaGVyaXRzKEF0dHJpYnV0ZUNoYW5uZWwsIF9DaGFubmVsKTtcblxuICBmdW5jdGlvbiBBdHRyaWJ1dGVDaGFubmVsKHByb3BzKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEF0dHJpYnV0ZUNoYW5uZWwpO1xuXG4gICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoQXR0cmlidXRlQ2hhbm5lbCkuY2FsbCh0aGlzLCBwcm9wcykpO1xuICAgIC8qXG4gICAgY29tYm9BdHRyaWJ1dGVzIGFyZSBhdHRyaWJ1dGVzIG9mIHR5cGUgb2JqZWN0LCBob2xkaW5nIGEgbnVtYmVyIG9mIG90aGVyIGF0dHJpYnV0ZXMuXG4gICAgRS5nLiBDU1MgXCJ0cmFuc2Zvcm1cIiBhdHRyaWJ1dGUgaXMgYSBjb21ibyB0aGF0IGhvbGRzIGEgbnVtYmVyIG9mIG90aGVyIGF0dHJpYnV0ZXMgc3VjaCBhczpcbiAgICB0cmFuc2xhdGVYLCB0cmFuc2xhdGVZLCBldGMuIFRoZSBsYW5lcyBoYW5kbGVyIGtlZXBzIGp1c3Qgb25lIGxhbmUgZm9yIHRoZSBjb21ibyBhdHRyc1xuICAgIGluIGFuIG9iamVjdCBmb3JtYXQga2VlcGluZyB0aGUgdmFsdWUgb2YgZWFjaCBhdHRyaWJ1dGUgYXQgYW55IGdpdmVuIHBvaW50LlxuICAgIENvbWJvIGF0dHJpYnV0ZXMgYXJlIHBhc3NlZCBvbiB0aGUgY29uc3RydWN0b3Igb2YgdGhlIENoYW5uZWwgaW4gdGhlIGZvcm1hdDpcbiAgICBwcm9wcy5jb21ib0F0dHJpYnV0ZXM6IHtcbiAgICAgICAgdHJhbnNpdGlvbjogWyd0cmFuc2xhdGVYJywgJ3RyYW5zbGF0ZVknLCAuLi5dLFxuICAgICAgICA8c29tZXRoaW5nX2Vsc2U+OiBbJzxhdHRyTmFtZTE+JywgJzxhdHRyTmFtZTI+JywgLi4uXVxuICAgIH1cbiAgICAqL1xuXG4gICAgX3RoaXMuY29tYm9BdHRyaWJ1dGVzID0ge307XG4gICAgLyoqXG4gICAgICogRm9yIGluY2lkZW50cyB0aGF0IGRvIG5vdCBoYXZlIGFuaW1hdGVkQXR0cnMgdGhlcmUgc2hvdWxkIGJlIG9ubHkgb25lIGxhbmUgcGVyIGVsZW1lbnQuXG4gICAgICogVGhlIGF0dHJpYnV0ZXMgQ2hhbm5lbCB3aWxsIHVzZSBhIGRlZmF1bHQgKGZha2UpLCBmaXhlZCBhdHRyaWJ1dGUgZm9yIHRoaXMgY2FzZXMgc28gaXQgYWx3YXlzIGVuZHNcbiAgICAgKiB1cCB3aXRoIGp1c3Qgb25lIGxhbmUgcGVyIGVsZW1lbnQ6IDxlbGVtZW50X2lkPl88dGhpcy5maXhlZEF0dHJpYnV0ZU5hbWU+XG4gICAgICovXG5cbiAgICBfdGhpcy5maXhlZEF0dHJpYnV0ZU5hbWUgPSBcIl9cIjtcblxuICAgIGlmIChwcm9wcy5jb21ib0F0dHJpYnV0ZXMgIT0gbnVsbCkge1xuICAgICAgX3RoaXMuY29tYm9BdHRyaWJ1dGVzID0gcHJvcHMuY29tYm9BdHRyaWJ1dGVzO1xuICAgIH1cblxuICAgIF90aGlzLkxhbmVzSGFuZGxlciA9IG5ldyBsYW5lc0hhbmRsZXIoe1xuICAgICAgY29tYm9BdHRyaWJ1dGVzOiBfdGhpcy5jb21ib0F0dHJpYnV0ZXMsXG4gICAgICBydW5UaW1lSW5mbzogX3RoaXMucnVuVGltZUluZm9cbiAgICB9KTsgLy8gdGhpcy50eXBlID0gXCJhdHRyaWJ1dGVzXCI7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQXR0cmlidXRlQ2hhbm5lbCwgW3tcbiAgICBrZXk6IFwic2V0Q29tYm9BdHRyaWJ1dGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldENvbWJvQXR0cmlidXRlcyhjb21ib0F0dHJpYnV0ZXMpIHtcbiAgICAgIHRoaXMuY29tYm9BdHRyaWJ1dGVzID0gY29tYm9BdHRyaWJ1dGVzO1xuICAgICAgdGhpcy5MYW5lc0hhbmRsZXIgPSBuZXcgbGFuZXNIYW5kbGVyKHtcbiAgICAgICAgY29tYm9BdHRyaWJ1dGVzOiB0aGlzLmNvbWJvQXR0cmlidXRlc1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9yZXNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Jlc2l6ZShkdXJhdGlvbkZyYWN0aW9uKSB7XG4gICAgICB0aGlzLkxhbmVzSGFuZGxlci5fcmVzaXplKGR1cmF0aW9uRnJhY3Rpb24pO1xuICAgIH1cbiAgICAvKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgIERFQ0lTSU9OIE1FVEhPRFNcbiAgICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAvKipcbiAgICAgKiBBbGwgb2YgdGhlIGluY2lkZW50cyBjb21pbmcgdG8gdGhpcyBtZXRob2QgYXJlIGVsZW1lbnQtYXR0cmlidXRlIGluY2lkZW50cyBtZWFuaW5nIHRoYXQgdGhleSBvbmx5XG4gICAgICogdGFyZ2V0IGp1c3Qgb25lIGVsZW1lbnQgYW5kIGFsc28gdGhleSBpbmNsdWRlIGp1c3QgYSBzaW5nbGUgYXR0cmlidXRlIG9uIHRoZSBpbmNpZGVudC5hdHRycy5hbmltYXRlZEF0dHJzXG4gICAgICogb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2FycmF5fSBpbmNpZGVudHMgLSBBIGNvbGxlY3Rpb24gb2YgSW5jaWRlbnRzIGluIHRoZSBmb3JtOlxuICAgICAqIHtcbiAgICAgKiAgbWlsbGlzZWNvbmRcbiAgICAgKiAgaW5jaWRlbnRcbiAgICAgKiAgaWRcbiAgICAgKiB9XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBjYW4gYmUgZWl0aGVyIFwiYWxsLW9yLW5vdGhpbmdcIiAoZGVmYXVsdCkgb3IgXCJrZWVwLXBhc3NpbmdcIi4gSWYgdHlwZSA9IFwiYWxsLW9yLW5vdGhpbmdcIlxuICAgICAqICB0aGUgYWRkaXRpb24gcGFzc2VzIG9ubHkgaWYgYWxsIGluY2lkZW50cyBwYXNzLiBJZiB0eXBlID0gXCJrZWVwLXBhc3NpbmdcIiB0aGUgbWV0aG9kIHdpbGwgc3RpbGwgcmV0dXJuIHRydWVcbiAgICAgKiAgYnV0IHdpbGwgYWxzbyBpbmNsdWRlIGFuIGVycm9ycyBhcnJheSBvbiBpdHMgcmV0dXJuIGFuZCBhbHNvIHdpbGwgb25seSBpbmNsdWRlIHRoZSBzdWNjZXNzIGNhbGxiYWNrcyBvblxuICAgICAqICB0aGUgZXhlY3V0ZSBrZXkgb2YgaXRzIHJldHVyblxuICAgICAqIEByZXR1cm5zIGVpdGhlcjpcbiAgICAgKiAgIHtcbiAgICAgKiAgICAgICByZXN1bHQ6dHJ1ZSxcbiAgICAgKiAgICAgICBleGVjdXRlOiAvLyBhbiBhcnJheSBvZiBmdW5jdGlvbnMgdGhhdCB3aGVuIGV4ZWN1dGVkIGl0IHdpbGwgYWRkIHRoZSBJbmNpZGVudHMgb24gdGhlIENoYW5uZWxzXG4gICAgICogICB9XG4gICAgICogICBvclxuICAgICAqICAge1xuICAgICAqICAgICAgIHJlc3VsdDogZmFsc2UsXG4gICAgICogICAgICAgZXJyb3JzXG4gICAgICogICB9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjaGVja0FkZGl0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrQWRkaXRpb24oaW5jaWRlbnRzKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIHR5cGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFwiYWxsLW9yLW5vdGhpbmdcIjtcbiAgICAgIHZhciBMYW5lc0hhbmRsZXJTYW5kYm94ID0gdGhpcy5MYW5lc0hhbmRsZXIuY3JlYXRlVGVzdExhbmVzU2FuYm94KCk7XG4gICAgICAvKiBhbiBhcnJheSB3aGVyZSB3ZSBrZWVwIGFsbCBhZmZlY3RlZCBsYW5lcyBzbyB3ZSBjYW4gc2xpcCBvbiB0aGVtIGF0IHRoZSBlbmQuXG4gICAgICBUaGUgZm9ybWF0IGZvciBlYWNoIGFmZmVjdGVkIGxhbmUgd2Uga2VlcCBpczpcbiAgICAgIHtcbiAgICAgICAgICBtY2lkOiBtY2lkLFxuICAgICAgICAgIGF0dHJpYnV0ZTogYXR0cmlidXRlXG4gICAgICB9XG4gICAgICAqL1xuXG4gICAgICB2YXIgYWZmZWN0ZWRMYW5lcyA9IFtdOyAvLyB3aGlsZSB0aGUgTGFuZXNIYW5kbGVyU2FuYm94IGFkZHMgbGFuZSBpdGVtcyBpdCBtYWtlcyBkZWNpc2lvbnMgb2Ygd2hpY2ggcGVybWFuZW50IGNoYW5nZXMgc2hvdWxkIGJlIG1hZGUgdG9cbiAgICAgIC8vIHRoZSBwZXJtYW5lbnQgYW5kIHByZS1leGlzdGluZyBvYmplY3RzIGl0IGhhbmRsZXMsIHN1Y2ggYXMgY2hhbmdlcyBvbiB0aGUgaW5pdGlhbCB2YWx1ZXMgb2YgZXhpc3RpbmcgYW5pbWF0aW9ucy5cbiAgICAgIC8vIEJlY2F1c2Ugb2YgdGhlIGZhY3QgdGhlIExhbmVzU2FuZGJveEhhbmRsZXIgaXMgb25seSB0aGVyZSBmb3IgdGVzdGluZyB3ZSBkb24ndCB3YW50IHRvIGV4ZWN1dGUgdGhlc2UgY2hhbmdlc1xuICAgICAgLy8gZHVyaW5nIGNoZWNrcyBidXQgc3RpbGwgd2UgbmVlZCB0byBrbm93IHRoZW0gb24gc3VjY2Vzcy4gRm9yIHRoaXMsIHRoZSBvblN1Y2Nlc3NBY3Rpb25zIGFycmF5IGhvbGRzIGFsbCBleGVjdXRhYmxlXG4gICAgICAvLyBmdW5jdGlvbnMgcmV0dXJlZCBieSB2YXJpb3VzIExhbmVzSGFuZGxlclNhbmJveCBmdW5jdGlvbnMgc28gaXQgY2FuIGV4ZWN1dGUgdGhlbSBvbiBzdWNjZXNzLlxuXG4gICAgICB2YXIgb25TdWNjZXNzQWN0aW9ucyA9IFtdO1xuICAgICAgdmFyIGNvbmZsaWN0cyA9IFtdO1xuXG4gICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChpKSB7XG4gICAgICAgIHZhciBpbmNpZGVudENvbmZsaWN0cyA9IGZhbHNlOyAvLyBhIGJvb2xlYW4gdGhhdCBrZWVwcyB0aGUgaW5mb3JtYXRpb24gd2hldGhlciB0aGUgaW5jaWRlbnQgY29uZmxpY3RzIG9yIG5vdFxuXG4gICAgICAgIHZhciBsYW5lSXRlbSA9IGluY2lkZW50c1tpXTtcbiAgICAgICAgdmFyIGluY2lkZW50ID0gbGFuZUl0ZW0uaW5jaWRlbnQ7XG4gICAgICAgIHZhciBtY2lkID0gaW5jaWRlbnQubWNpZDtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IGluY2lkZW50LmF0dHJpYnV0ZSB8fCBfdGhpczIuZml4ZWRBdHRyaWJ1dGVOYW1lO1xuICAgICAgICBMYW5lc0hhbmRsZXJTYW5kYm94LmxhbmVFeGlzdHMobWNpZCwgYXR0cmlidXRlKTsgLy8gY3JlYXRlIHRoZSBsYW5lIGlmIGl0IGRvZXNuJ3QgZXhpc3QgYWxyZWFkeVxuXG4gICAgICAgIGFmZmVjdGVkTGFuZXMucHVzaCh7XG4gICAgICAgICAgbWNpZDogbWNpZCxcbiAgICAgICAgICBhdHRyaWJ1dGU6IGF0dHJpYnV0ZVxuICAgICAgICB9KTsgLy8gKioqKiBpZiB0aGUgbGFuZSBkaWQgZXhpc3QgYmVmb3JlIHRoZSBuZXcgYWRkaXRpb24gY2hlY2sgZm9yIGNvbmZsaWN0c1xuXG4gICAgICAgIHZhciBvdmVybGFwcGluZ0FuaW1zID0gTGFuZXNIYW5kbGVyU2FuZGJveC5nZXRPdmVybGFwcGluZ0FuaW1zKGxhbmVJdGVtLCBtY2lkLCBhdHRyaWJ1dGUpOyAvLyBoZWxwZXIubG9nKG92ZXJsYXBwaW5nQW5pbSlcblxuICAgICAgICBpZiAob3ZlcmxhcHBpbmdBbmltcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgaW5jaWRlbnRDb25mbGljdHMgPSB0cnVlO1xuICAgICAgICAgIGNvbmZsaWN0cy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6ICd1bmF1dGhvcmlzZWQsIG92ZXJsYXBwaW5nIGluY2lkZW50cyBvbiB0aGUgc2FtZSBlbGVtZW50JyxcbiAgICAgICAgICAgIG1ldGE6IHtcbiAgICAgICAgICAgICAgZWxlbWVudF9tY2lkOiBtY2lkLFxuICAgICAgICAgICAgICBhdHRyaWJ1dGU6IGF0dHJpYnV0ZSxcbiAgICAgICAgICAgICAgaW5jaWRlbnQ6IGxhbmVJdGVtLFxuICAgICAgICAgICAgICBvdmVybGFwcGluZ0FuaW1zOiBvdmVybGFwcGluZ0FuaW1zXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWluY2lkZW50Q29uZmxpY3RzKSB7XG4gICAgICAgICAgb25TdWNjZXNzQWN0aW9ucy5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIExhbmVzSGFuZGxlclNhbmRib3guYWRkRWxlbWVudFRvTGFuZShtY2lkLCBhdHRyaWJ1dGUsIGxhbmVJdGVtLm1pbGxpc2Vjb25kLCBpbmNpZGVudCk7XG5cbiAgICAgICAgICAgIGluY2lkZW50Ll9vbkdldENvbnRleHRPbmNlKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5jaWRlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIF9sb29wKGkpO1xuICAgICAgfSAvLyBlbmQgZm9yIGVhY2ggaW5jaWRlbnRcbiAgICAgIC8vIGlmIHdlIGhhdmUgY29uZmxpY3RzIGFuZCB0aGUgdHlwZSA9IFwiYWxsLW9yLW5vdGhpbmdcIlxuXG5cbiAgICAgIGlmIChjb25mbGljdHMubGVuZ3RoID4gMCAmJiB0eXBlID09PSBcImFsbC1vci1ub3RoaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZXN1bHQ6IGZhbHNlLFxuICAgICAgICAgIGVycm9yczogY29uZmxpY3RzXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBhcyBzb29uIGFzIHdlIHdhbnQgYWxsIHBhc3NpbmcgYWRkaXRpb25zIHRvIGdldCBhcHBsaWVkIHRoZSBMYW5lcyBIYW5kbGVyIHdpbGwgY3JlYXRlIGEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIHBhc3NlZCB0byB0aGUgcmVzdWx0LlxuICAgICAgICAvLyBUaGlzIGNhbGxiYWNrIHdpbGwgYXBwbHkgYWxsIHBhc3NpbmcgYWRkaXRpb25zLlxuICAgICAgICAvLyBzdWNjZXNzIG1lc3NhZ2VcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgIHZhciBleGVjID0gZnVuY3Rpb24gZXhlYygpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9uU3VjY2Vzc0FjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG9uU3VjY2Vzc0FjdGlvbnNbaV0oKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGF0LkxhbmVzSGFuZGxlci5hcHBseVNhbmRib3hDaGFuZ2VzKExhbmVzSGFuZGxlclNhbmRib3gpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVzdWx0OiB0cnVlLFxuICAgICAgICAgIGVycm9yczogY29uZmxpY3RzLFxuICAgICAgICAgIGV4ZWN1dGU6IGV4ZWNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSXQgaW5pdGlhbGx5IGNoZWNrcyBpZiB0aGUgZWRpdCBpcyBhbGxvd2VkIGFuZCBpZiBpdCBpcyBpdCByZXR1bnMgYW4gYXJyYXkgb2YgZXhlY3V0YWJsZSBmdW5jdGlvbnNcbiAgICAgKiB0aGF0IGFwcGx5IHRoZSBjaGFuZ2VcbiAgICAgKiBAcGFyYW0ge2FycmF5fSBpbmNpZGVudHMgLSB0aGUgbGlzdCBvZiB0aGUgbGFuZSBpdGVtcyB0byBlZGl0IGluIGFuIGFycmF5IGZvcm1hdCBbb2JqZWN0LCBvYmplY3QsIC4uLl1cbiAgICAgKiBAcGFyYW0ge2ludH0gbWlsbGlzZWNvbmRzRGVsdGEgLSB0aGUgbWlsbGlzZWNvbmRzIGRlbHRhIHRvIGFwcGx5IHRvIHRoZSBpbmNpZGVudHNcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSAtXG4gICAgICogZWl0aGVyOlxuICAgICB7XG4gICAgICAgIHJlc3VsdDogdHJ1ZSxcbiAgICAgICAgZXhlY3V0ZTogLy8gYXJyYXkgb2YgZnVuY3Rpb25zIHRvIGJlIGV4ZWN1dGVkIGluIG9yZGVyIHRvIGFwcGx5IHRoZSBlZGl0XG4gICAgIH1cbiAgICAgb3JcbiAgICAge1xuICAgICAgICAgcmVzdWx0OiBmYWxzZSxcbiAgICAgICAgIGVycm9yczogLy8gYW4gYXJyYXkgaW5jbHVkaW5nIGFsbCB0aGUgZXJyb3JzIC8gY29uZmxpY3RzIGZvdW5kIG9uIGVkaXRcbiAgICAgfVxuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjaGVja0VkaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tFZGl0KGluY2lkZW50cywgbWlsbGlzZWNvbmRzRGVsdGEpIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKGluY2lkZW50cyk7XG4gICAgICB2YXIgYWZmZWN0ZWRJbmNpZGVudElkcyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluY2lkZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBhZmZlY3RlZEluY2lkZW50SWRzLnB1c2goaW5jaWRlbnRzW2ldLmlkKTtcbiAgICAgIH1cblxuICAgICAgdmFyIExhbmVzSGFuZGxlclNhbmRib3ggPSB0aGlzLkxhbmVzSGFuZGxlci5jcmVhdGVUZXN0TGFuZXNTYW5ib3goKTtcbiAgICAgIHZhciBjb25mbGljdHMgPSBbXTtcbiAgICAgIHZhciBhZmZlY3RlZExhbmVzID0gW107IC8vIGZvciBlYWNoIG9mIHRoZSBhZmZlY3RlZEFuaW1hdGlvbnNcblxuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGluY2lkZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIGluY2lkZW50ID0gaW5jaWRlbnRzW19pXS5pbmNpZGVudDtcbiAgICAgICAgdmFyIGluY2lkZW50SWQgPSBpbmNpZGVudC5pZDtcbiAgICAgICAgdmFyIG1jaWQgPSBpbmNpZGVudHNbX2ldLmluY2lkZW50Lm1jaWQ7XG4gICAgICAgIHZhciBhdHRyaWJ1dGUgPSBpbmNpZGVudHNbX2ldLmluY2lkZW50LmF0dHJpYnV0ZSB8fCB0aGlzLmZpeGVkQXR0cmlidXRlTmFtZTtcbiAgICAgICAgdmFyIGxhbmUgPSBMYW5lc0hhbmRsZXJTYW5kYm94LmdldExhbmUobWNpZCwgYXR0cmlidXRlKTtcbiAgICAgICAgdmFyIGxhbmVBdHRycyA9IHtcbiAgICAgICAgICBtY2lkOiBtY2lkLFxuICAgICAgICAgIGF0dHJpYnV0ZTogYXR0cmlidXRlIC8vIGNoZWNrIGZvciBjb25mbGljdHMgYW5kIGVkaXQgbGFuZSBpdGVtcyBtaWxsaXNlY29uZFxuXG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBsYW5lLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgaWYgKGxhbmVba10uaWQgPT09IGluY2lkZW50SWQpIHtcbiAgICAgICAgICAgIGFmZmVjdGVkTGFuZXMucHVzaChsYW5lQXR0cnMpO1xuICAgICAgICAgICAgdmFyIGFmZmVjdGVkQW5pbSA9IGxhbmVba107XG4gICAgICAgICAgICB2YXIgdGVzdExhbmVFbGVtZW50ID0gTGFuZXNIYW5kbGVyU2FuZGJveC5nZXRMYW5lRWxlbWVudHNDbG9uZShhZmZlY3RlZEFuaW0pO1xuICAgICAgICAgICAgdGVzdExhbmVFbGVtZW50Lm1pbGxpc2Vjb25kICs9IG1pbGxpc2Vjb25kc0RlbHRhO1xuICAgICAgICAgICAgdGVzdExhbmVFbGVtZW50LmluY2lkZW50ID0gTGFuZXNIYW5kbGVyU2FuZGJveC5pbmNpZGVudHNCeUlkLl9nZXQodGVzdExhbmVFbGVtZW50LmlkKTtcbiAgICAgICAgICAgIHZhciBvdmVybGFwcGluZ0FuaW1zID0gTGFuZXNIYW5kbGVyU2FuZGJveC5nZXRPdmVybGFwcGluZ0FuaW1zKHRlc3RMYW5lRWxlbWVudCwgbWNpZCwgYXR0cmlidXRlLCBhZmZlY3RlZEluY2lkZW50SWRzKTtcblxuICAgICAgICAgICAgaWYgKG92ZXJsYXBwaW5nQW5pbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBjb25mbGljdHMucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2FuYXV0aG9yaXNlZCwgb3ZlcmxhcHBpbmcgYW5pbWF0aW9ucyBvbiB0aGUgc2FtZSBlbGVtZW50JyxcbiAgICAgICAgICAgICAgICBtZXRhOiB7XG4gICAgICAgICAgICAgICAgICBlbGVtZW50X21jaWQ6IG1jaWQsXG4gICAgICAgICAgICAgICAgICBhdHRyaWJ1dGU6IGF0dHJpYnV0ZSxcbiAgICAgICAgICAgICAgICAgIG5ld0FuaW1hdGlvbjogdGVzdExhbmVFbGVtZW50LFxuICAgICAgICAgICAgICAgICAgb3ZlcmxhcHBpbmdBbmltczogb3ZlcmxhcHBpbmdBbmltc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gLy8gZW5kIG9mIGlmIHdlIGZvdW5kIHRoZSBzcGVjaWZpYyBhbmltYXRpb24gb24gdGhlIGxhbmUncyBzZXF1ZW5jZVxuXG4gICAgICAgIH0gLy8gZW5kIG9mIGVhY2ggbGFuZSdzIGl0ZW1cblxuICAgICAgfSAvLyBlbmQgZm9yIGVhY2ggYWZmZWN0ZWQgYW5pbWF0aW9uJ3MgaWRcblxuXG4gICAgICBpZiAoY29uZmxpY3RzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZXN1bHQ6IGZhbHNlLFxuICAgICAgICAgIGVycm9yczogY29uZmxpY3RzXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGV4ZWMgPSBmdW5jdGlvbiBleGVjKCkge1xuICAgICAgICAgIHRoYXQuTGFuZXNIYW5kbGVyLnVwZGF0ZUxhbmUoYWZmZWN0ZWRJbmNpZGVudElkcywgbWlsbGlzZWNvbmRzRGVsdGEpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVzdWx0OiB0cnVlLFxuICAgICAgICAgIGV4ZWN1dGU6IGV4ZWNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHthcnJheX0gaW5jaWRlbnRzIC0gW3tpZCwgc3RhcnQsIGVuZCwgc3RhcnREZWx0YX1dXG4gICAgICogQHBhcmFtIHtib29sZWFufSBmdWxsQ2hhbm5lbFJlc2l6ZSAtIGlmIHNldCB0byB0cnVlIHRoZW4gdGhlIGZ1bGwgaHRtbCBjaGFubmVsIGlzIHJlc2l6aW5nLiBUaGlzIGlzIGEgc3BlY2lhbCBjYXNlIGFzIGluXG4gICAgICogIHRoYXQgY2FzZSBubyBjaGVja3Mgc2hvdWxkIGJlIGFjdHVhbGx5IHBlcmZvbWVkIG5vciB0aGUgcHJvamVjdGVkIGNhbmRpZGF0ZSBzaG91bGQgYmUgYXBwbGllZCBkaXJlY3RseVxuICAgICAqKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNoZWNrUmVzaXplZEluY2lkZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja1Jlc2l6ZWRJbmNpZGVudHMoaW5jaWRlbnRzKSB7XG4gICAgICB2YXIgZnVsbENoYW5uZWxSZXNpemUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgICAgdmFyIGV4Y2x1ZGVJZHNGcm9tQ2hlY2sgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmNpZGVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZXhjbHVkZUlkc0Zyb21DaGVjay5wdXNoKGluY2lkZW50c1tpXS5pZCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBMYW5lc0hhbmRsZXJTYW5kYm94ID0gdGhpcy5MYW5lc0hhbmRsZXIuY3JlYXRlVGVzdExhbmVzU2FuYm94KCk7XG4gICAgICB2YXIgY29uZmxpY3RzID0gW107XG4gICAgICB2YXIgYWZmZWN0ZWRMYW5lcyA9IFtdOyAvLyBmb3IgZWFjaCBvZiB0aGUgaW5jaWRlbnRzIHBhc3NlZFxuXG4gICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBpbmNpZGVudHMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICAvLyBnZXQgdGhlIENvbnRleHRBd2FyZUluY2lkZW50XG4gICAgICAgIHZhciBpbmNpZGVudCA9IHRoaXMuTGFuZXNIYW5kbGVyLmluY2lkZW50c0J5SWQuX2dldChpbmNpZGVudHNbX2kyXS5pZCk7XG5cbiAgICAgICAgdmFyIG1jaWQgPSBpbmNpZGVudC5tY2lkO1xuICAgICAgICB2YXIgYXR0cmlidXRlID0gaW5jaWRlbnQuYXR0cmlidXRlIHx8IHRoaXMuZml4ZWRBdHRyaWJ1dGVOYW1lO1xuICAgICAgICB2YXIgbGFuZSA9IExhbmVzSGFuZGxlclNhbmRib3guZ2V0TGFuZShtY2lkLCBhdHRyaWJ1dGUpO1xuICAgICAgICB2YXIgbGFuZUF0dHJzID0ge1xuICAgICAgICAgIG1jaWQ6IG1jaWQsXG4gICAgICAgICAgYXR0cmlidXRlOiBhdHRyaWJ1dGVcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHRlc3REdXJhdGlvbiA9IGluY2lkZW50c1tfaTJdLmVuZCAtIGluY2lkZW50c1tfaTJdLnN0YXJ0OyAvLyBjaGVjayBmb3IgY29uZmxpY3RzIGFuZCBlZGl0IGxhbmUgaXRlbXMgbWlsbGlzZWNvbmRcblxuICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGxhbmUubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICBpZiAobGFuZVtrXS5pZCA9PT0gaW5jaWRlbnRzW19pMl0uaWQpIHtcbiAgICAgICAgICAgIGFmZmVjdGVkTGFuZXMucHVzaChsYW5lQXR0cnMpO1xuXG4gICAgICAgICAgICBpZiAoZnVsbENoYW5uZWxSZXNpemUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIHZhciBhZmZlY3RlZEFuaW0gPSBsYW5lW2tdO1xuICAgICAgICAgICAgICB2YXIgdGVzdExhbmVFbGVtZW50ID0gTGFuZXNIYW5kbGVyU2FuZGJveC5nZXRMYW5lRWxlbWVudHNDbG9uZShhZmZlY3RlZEFuaW0pO1xuICAgICAgICAgICAgICB0ZXN0TGFuZUVsZW1lbnQubWlsbGlzZWNvbmQgKz0gaW5jaWRlbnRzW19pMl0uc3RhcnREZWx0YTtcbiAgICAgICAgICAgICAgdGVzdExhbmVFbGVtZW50LmluY2lkZW50ID0gTGFuZXNIYW5kbGVyU2FuZGJveC5pbmNpZGVudHNCeUlkLl9nZXQodGVzdExhbmVFbGVtZW50LmlkKTtcbiAgICAgICAgICAgICAgdmFyIG92ZXJsYXBwaW5nQW5pbXMgPSBMYW5lc0hhbmRsZXJTYW5kYm94LmdldE92ZXJsYXBwaW5nQW5pbXModGVzdExhbmVFbGVtZW50LCBsYW5lQXR0cnMubWNpZCwgbGFuZUF0dHJzLmF0dHJpYnV0ZSwgZXhjbHVkZUlkc0Zyb21DaGVjaywgdGVzdER1cmF0aW9uKTtcblxuICAgICAgICAgICAgICBpZiAob3ZlcmxhcHBpbmdBbmltcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uZmxpY3RzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgdHlwZTogJ2FuYXV0aG9yaXNlZCBvdmVybGFwcGluZyBhbmltYXRpb25zIG9uIHRoZSBzYW1lIGVsZW1lbnQnLFxuICAgICAgICAgICAgICAgICAgbWV0YToge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50X21jaWQ6IGxhbmVBdHRycy5tY2lkLFxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGU6IGxhbmVBdHRycy5hdHRyaWJ1dGUsXG4gICAgICAgICAgICAgICAgICAgIG5ld0FuaW1hdGlvbjogdGVzdExhbmVFbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICBvdmVybGFwcGluZ0FuaW1zOiBvdmVybGFwcGluZ0FuaW1zXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSAvLyBlbmQgb2YgaWYgd2UgZm91bmQgdGhlIHNwZWNpZmljIGFuaW1hdGlvbiBvbiB0aGUgbGFuZSdzIHNlcXVlbmNlXG5cbiAgICAgICAgfSAvLyBlbmQgb2YgZWFjaCBsYW5lJ3MgaXRlbVxuXG4gICAgICB9IC8vIGVuZCBmb3IgZWFjaCBhZmZlY3RlZCBhbmltYXRpb24ncyBpZFxuXG5cbiAgICAgIGlmIChjb25mbGljdHMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlc3VsdDogZmFsc2UsXG4gICAgICAgICAgZXJyb3JzOiBjb25mbGljdHNcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgICB2YXIgZXhlYyA9IGZ1bmN0aW9uIGV4ZWMoKSB7XG4gICAgICAgICAgLy8gdXBkYXRlTGFuZXMgKG9ubHkgdGhpcyB0aW1lIGFuaW1hdGlvbiBieSBhbmltYXRpb24gYXMgdGhlIG1pbGxpc2Vjb25kcyBkZWx0YSBpcyBub3Qgc3RhbmRhcmQgZm9yIGFsbClcbiAgICAgICAgICAvLyBhcyBzb29uIGFzIHRoZXJlIGFyZSBubyBjb25mbGljdHMgdGhlIExhbmVzIEhhbmRsZXIgYXBwbGllcyB0aGUgY2hhbmdlcyBiZWZvcmUgc2VuZGluZyBvdmVyIHRoZVxuICAgICAgICAgIC8vIHN1Y2Nlc3MgbWVzc2FnZVxuICAgICAgICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IGluY2lkZW50cy5sZW5ndGg7IF9pMysrKSB7XG4gICAgICAgICAgICB0aGF0LkxhbmVzSGFuZGxlci51cGRhdGVMYW5lKFtpbmNpZGVudHNbX2kzXS5pZF0sIGluY2lkZW50c1tfaTNdLnN0YXJ0RGVsdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGV4ZWN1dGU6IGV4ZWMsXG4gICAgICAgICAgcmVzdWx0OiB0cnVlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjaGVja0RlbGV0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja0RlbGV0ZShyZW1vdmVkQW5pbWF0aW9ucykge1xuICAgICAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIHZhciByZW1vdmVkQW5pbWF0aW9uSWRzID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVtb3ZlZEFuaW1hdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVtb3ZlZEFuaW1hdGlvbklkcy5wdXNoKHJlbW92ZWRBbmltYXRpb25zW2ldLmlkKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICB2YXIgZXhlYyA9IGZ1bmN0aW9uIGV4ZWMoKSB7XG4gICAgICAgIHRoYXQuTGFuZXNIYW5kbGVyLmRlbGV0ZUFuaW1hdGlvbnMocmVtb3ZlZEFuaW1hdGlvbklkcyk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICByZXN1bHQ6IHRydWUsXG4gICAgICAgIGV4ZWN1dGU6IGV4ZWNcbiAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNsaXBzIHRvIGp1c3Qgb25lIGxhbmUgZm9yd2FyZHNcbiAgICAgKiBAcGFyYW0ge2FycmF5fSBsYW5lIC0gdGhlIGxhbmUgdG8gc2xpcCBpbnRvXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGxhbmVEYXRhIC0gYW4gb2JqZWN0IHdpdGgga2V5czogYXR0cmlidXRlICYgbWNpZFxuICAgICAqIEBwYXJhbSB7aW50fSBjdXJyZW50TWlsbGlzZWNvbmQgLSB0aGUgbWlsbGlzZWNvbmQgdGhlIHNsaXAgc3RhcnRzIGZyb21cbiAgICAgKiBAcGFyYW0ge2ludH0gbWlsbGlzZWNvbmQgLSB0aGUgdGFyZ2V0IG1pbGxpc2Vjb25kIG9mIHRoZSBzbGlwXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRleHRJZCAtIHRoZSBjb250ZXh0SWQgb2YgdGhlIEluY2lkZW50cyB0byBzbGlwXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzbGlwSW50b0xhbmVGb3J3YXJkc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzbGlwSW50b0xhbmVGb3J3YXJkcyhsYW5lLCBsYW5lRGF0YSwgY3VycmVudE1pbGxpc2Vjb25kLCBtaWxsaXNlY29uZCwgY29udGV4dElkKSB7XG4gICAgICB2YXIgZm9yY2VSZXNldCA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogZmFsc2U7XG4gICAgICAvLyBjb25zb2xlLmxvZyhsYW5lLCBjdXJyZW50TWlsbGlzZWNvbmQsIG1pbGxpc2Vjb25kKTtcbiAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgdmFyIHBhcnRpY2lwYXRpbmdBbmltcyA9IF9maWx0ZXIobGFuZSwgZnVuY3Rpb24gKGxhbmVJdGVtKSB7XG4gICAgICAgIHJldHVybiBsYW5lSXRlbS5taWxsaXNlY29uZCArIHRoYXQuaW5jaWRlbnRzQnlJZC5fZ2V0KGxhbmVJdGVtLmlkKS5kdXJhdGlvbiA+PSBjdXJyZW50TWlsbGlzZWNvbmQgJiYgbGFuZUl0ZW0ubWlsbGlzZWNvbmQgKyB0aGF0LmluY2lkZW50c0J5SWQuX2dldChsYW5lSXRlbS5pZCkuZHVyYXRpb24gPD0gbWlsbGlzZWNvbmQgfHwgLy8gaXQgZW5kcyBhZnRlciBjdXJyZW50TWlsbGlzZWNvbmQgYW5kIGJlZm9yZSB0YXJnZXQgbWlsbGlzZWNvbmRcbiAgICAgICAgdGhhdC5pbmNpZGVudHNCeUlkLl9nZXQobGFuZUl0ZW0uaWQpLmR1cmF0aW9uICsgbGFuZUl0ZW0ubWlsbGlzZWNvbmQgPj0gbWlsbGlzZWNvbmQgJiYgbGFuZUl0ZW0ubWlsbGlzZWNvbmQgPD0gbWlsbGlzZWNvbmQ7IC8vIG9yIGl0IGVuZHMgYWZ0ZXIgdGhlIHRhcmdldCBtaWxsaXNlY29uZCBidXQgYWxzbyBzdGFydHMgYmVmb3JlIGl0XG4gICAgICB9KTtcblxuICAgICAgaWYgKHBhcnRpY2lwYXRpbmdBbmltcy5sZW5ndGggPT0gMCkge1xuICAgICAgICBpZiAoZm9yY2VSZXNldCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHZhciBmaXJzdEluY2lkZW50ID0gdGhpcy5pbmNpZGVudHNCeUlkLl9nZXQobGFuZVswXS5pZCk7XG5cbiAgICAgICAgICBmaXJzdEluY2lkZW50Lm9uUHJvZ3Jlc3MoMCwgMCwgY29udGV4dElkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBwYXJ0aWNpcGF0aW5nQW5pbXMgPSBfc29ydEJ5KHBhcnRpY2lwYXRpbmdBbmltcywgW2Z1bmN0aW9uIChsYW5lSXRlbSkge1xuICAgICAgICByZXR1cm4gbGFuZUl0ZW0ubWlsbGlzZWNvbmQ7XG4gICAgICB9XSk7IC8vIFdlIG9ubHkgY2FyZSBhYm91dCB0aGUgbGFzdCAoaW4gY2hyb25vbG9naWNhbCBvcmRlcikgSW5jaWRlbnQsIGFzIHRoaXNcbiAgICAgIC8vIHdpbGwgZGVmaW5lIHRoZSBmaW5hbCB2YWx1ZVxuXG4gICAgICB2YXIgbGFzdEluZGV4ID0gcGFydGljaXBhdGluZ0FuaW1zLmxlbmd0aCAtIDE7XG5cbiAgICAgIHZhciBwYXJ0aWNpcGF0aW5nQW5pbSA9IHRoaXMuaW5jaWRlbnRzQnlJZC5fZ2V0KHBhcnRpY2lwYXRpbmdBbmltc1tsYXN0SW5kZXhdLmlkKTtcblxuICAgICAgdmFyIHN0YXJ0TWlsbGlzZWNvbmQgPSBwYXJ0aWNpcGF0aW5nQW5pbXNbbGFzdEluZGV4XS5taWxsaXNlY29uZDsgLy8gaWYgdGhlIGFuaW1hdGlvbiBlbmRzIGJlZm9yZSB0aGUgdGFyZ2V0IG1pbGxpc2Vjb25kXG5cbiAgICAgIGlmIChwYXJ0aWNpcGF0aW5nQW5pbS5kdXJhdGlvbiArIHN0YXJ0TWlsbGlzZWNvbmQgPD0gbWlsbGlzZWNvbmQpIHtcbiAgICAgICAgLy8gYW5kIGl0J3MgdGhlIGxhc3Qgb25lIG9uIHRoZSByb3dcbiAgICAgICAgcGFydGljaXBhdGluZ0FuaW0ub25Qcm9ncmVzcygxLCBwYXJ0aWNpcGF0aW5nQW5pbS5kdXJhdGlvbiwgY29udGV4dElkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHNsaXAgZm9yIHRoZSBzcGVjaWZpYyBlbGVtZW50IGFuZCB0aGUgc3BlY2lmaWMgYXR0cmlidXRlLiBTZXQgdGhlIEFuaW1hdGlvbiBhcyBwYXVzZWQgb3IgcGxheWluZyBhXG4gICAgICAgIC8vIGFuZCBzdG9yZSB0aGlzIGluZm8gc29tZXdoZXJlXG4gICAgICAgIHZhciBwZXJjZW50YWdlQ29tcGxldGUgPSAobWlsbGlzZWNvbmQgLSBzdGFydE1pbGxpc2Vjb25kKSAvIHBhcnRpY2lwYXRpbmdBbmltLmR1cmF0aW9uO1xuICAgICAgICBwYXJ0aWNpcGF0aW5nQW5pbS5vblByb2dyZXNzKHBlcmNlbnRhZ2VDb21wbGV0ZSwgbWlsbGlzZWNvbmQgLSBzdGFydE1pbGxpc2Vjb25kLCBjb250ZXh0SWQpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTbGlwcyB0byBqdXN0IG9uZSBsYW5lIGJhY2t3YXJkc1xuICAgICAqIEBwYXJhbSB7YXJyYXl9IGxhbmUgLSB0aGUgbGFuZSB0byBzbGlwIGludG9cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gbGFuZURhdGEgLSBhbiBvYmplY3Qgd2l0aCBrZXlzOiBhdHRyaWJ1dGUgJiBtY2lkXG4gICAgICogQHBhcmFtIHtpbnR9IGN1cnJlbnRNaWxsaXNlY29uZCAtIHRoZSBtaWxsaXNlY29uZCB0aGUgc2xpcCBzdGFydHMgZnJvbVxuICAgICAqIEBwYXJhbSB7aW50fSBtaWxsaXNlY29uZCAtIHRoZSB0YXJnZXQgbWlsbGlzZWNvbmQgb2YgdGhlIHNsaXBcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29udGV4dElkIC0gdGhlIGNvbnRleHRJZCBvZiB0aGUgSW5jaWRlbnRzIHRvIHNsaXBcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNsaXBUb0xhbmVCYWNrd2FyZHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2xpcFRvTGFuZUJhY2t3YXJkcyhsYW5lLCBsYW5lRGF0YSwgY3VycmVudE1pbGxpc2Vjb25kLCBtaWxsaXNlY29uZCwgY29udGV4dElkKSB7XG4gICAgICB2YXIgZm9yY2VSZXNldCA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogZmFsc2U7XG4gICAgICAvLyB3ZSB0YWtlIGFsbCBBbmltYXRpb25zIHRoYXQgYXJlIGVpdGhlciBjdXJyZW50bHkgcnVubmluZyBvclxuICAgICAgLy8gdGhleSBlbmQgYWZ0ZXIgdGhlIGRlc3RpbmF0aW9uIHBvaW50XG4gICAgICAvLyBoZWxwZXIubG9nKCc8LS0tLS0tJyk7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgIHZhciBwYXJ0aWNpcGF0aW5nQW5pbXMgPSBfZmlsdGVyKGxhbmUsIGZ1bmN0aW9uIChsYW5lSXRlbSkge1xuICAgICAgICB2YXIgbGFuZUl0ZW1FbmQgPSB0aGF0LmluY2lkZW50c0J5SWQuX2dldChsYW5lSXRlbS5pZCkuZHVyYXRpb24gKyBsYW5lSXRlbS5taWxsaXNlY29uZDtcbiAgICAgICAgcmV0dXJuIGxhbmVJdGVtRW5kIDw9IG1pbGxpc2Vjb25kICYmIGxhbmVJdGVtRW5kID49IGN1cnJlbnRNaWxsaXNlY29uZCB8fCAvLyB0aGV5IGVuZCBpbiB0aGUgaG90IGFyZWFcbiAgICAgICAgbGFuZUl0ZW0ubWlsbGlzZWNvbmQgPj0gY3VycmVudE1pbGxpc2Vjb25kICYmIGxhbmVJdGVtLm1pbGxpc2Vjb25kIDw9IG1pbGxpc2Vjb25kIHx8IC8vIHRoZXkgc3RhcnQgaW4gdGhlIGhvdCBhcmVhXG4gICAgICAgIGxhbmVJdGVtLm1pbGxpc2Vjb25kIDwgY3VycmVudE1pbGxpc2Vjb25kICYmIGxhbmVJdGVtRW5kID4gbWlsbGlzZWNvbmQ7IC8vIHRoZXkgb3ZlcmxhcCB0aGUgaG90IGFyZWFcbiAgICAgIH0pO1xuXG4gICAgICBpZiAocGFydGljaXBhdGluZ0FuaW1zLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIGlmIChwYXJ0aWNpcGF0aW5nQW5pbXMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICBpZiAoZm9yY2VSZXNldCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFyIGZpcnN0SW5jaWRlbnQgPSB0aGlzLmluY2lkZW50c0J5SWQuX2dldChsYW5lW2xhbmUubGVuZ3RoIC0gMV0uaWQpO1xuXG4gICAgICAgICAgICBmaXJzdEluY2lkZW50Lm9uUHJvZ3Jlc3MoMSwgZmlyc3RJbmNpZGVudC5kdXJhdGlvbiwgY29udGV4dElkKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBwYXJ0aWNpcGF0aW5nQW5pbXMgPSBfc29ydEJ5KHBhcnRpY2lwYXRpbmdBbmltcywgW2Z1bmN0aW9uIChsYW5lSXRlbSkge1xuICAgICAgICByZXR1cm4gbGFuZUl0ZW0ubWlsbGlzZWNvbmQ7XG4gICAgICB9XSk7IC8vIFdlIG9ubHkgY2FyZSBhYm91dCB0aGUgZmlyc3QgKGluIGNocm9ub2xvZ2ljYWwgb3JkZXIpIEluY2lkZW50LCBhcyB0aGlzXG4gICAgICAvLyB3aWxsIGRlZmluZSB0aGUgZmluYWwgdmFsdWUgb2YgdGhlIGJhY2t3YXJkcyBtb3ZlXG5cbiAgICAgIHZhciBsYXN0SW5kZXggPSAwO1xuXG4gICAgICB2YXIgcGFydGljaXBhdGluZ0FuaW0gPSB0aGlzLmluY2lkZW50c0J5SWQuX2dldChwYXJ0aWNpcGF0aW5nQW5pbXNbbGFzdEluZGV4XS5pZCk7XG5cbiAgICAgIHZhciBzdGFydE1pbGxpc2Vjb25kID0gcGFydGljaXBhdGluZ0FuaW1zW2xhc3RJbmRleF0ubWlsbGlzZWNvbmQ7IC8vIGlmIHRoZSBhbmltYXRpb24gc3RhcnRzIGFmdGVyIHRoZSB0YXJnZXQgbWlsbGlzZWNvbmRcblxuICAgICAgaWYgKHN0YXJ0TWlsbGlzZWNvbmQgPj0gbWlsbGlzZWNvbmQpIHtcbiAgICAgICAgcGFydGljaXBhdGluZ0FuaW0ub25Qcm9ncmVzcygwLCAwLCBjb250ZXh0SWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gc2xpcCBmb3IgdGhlIHNwZWNpZmljIGVsZW1lbnQgYW5kIHRoZSBzcGVjaWZpYyBhdHRyaWJ1dGUuIFNldCB0aGUgQW5pbWF0aW9uIGFzIHBhdXNlZCBvciBwbGF5aW5nIGFcbiAgICAgICAgLy8gYW5kIHN0b3JlIHRoaXMgaW5mbyBzb21ld2hlcmVcbiAgICAgICAgdmFyIHBlcmNlbnRhZ2VDb21wbGV0ZSA9IChtaWxsaXNlY29uZCAtIHN0YXJ0TWlsbGlzZWNvbmQpIC8gcGFydGljaXBhdGluZ0FuaW0uZHVyYXRpb247XG4gICAgICAgIHBhcnRpY2lwYXRpbmdBbmltLm9uUHJvZ3Jlc3MocGVyY2VudGFnZUNvbXBsZXRlLCBtaWxsaXNlY29uZCAtIHN0YXJ0TWlsbGlzZWNvbmQsIGNvbnRleHRJZCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICBAcGFyYW0ge2ludH0gZnJvbSAtIHRoZSBtaWxsaXNlY29uZCB0byBzdGFydCBmcm9tXG4gICAgIEBwYXJhbSB7aW50fSB0byAtIHRoZSBtaWxsaXNlY29uZCB0byBnbyB0b1xuICAgICBAcGFyYW0ge3NyaW5nfSBjb250ZXh0SWQgLSB0aGUgY29udGV4dCBpZCB0byBcIm1vdmVcIlxuICAgICBAcGFyYW0ge2Jvb2xlYW59IGZvcmNlUmVzZXQgLSBzZXQgdG8gdHJ1ZSBpZiBzdGF0dXMgcmVjYWxjIGlzIG5lZWRlZCBhZnRlciBlZGl0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJtb3ZlVG9cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW92ZVRvKGZyb20sIHRvLCBjb250ZXh0SWQpIHtcbiAgICAgIHZhciBmb3JjZVJlc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBmYWxzZTtcblxuICAgICAgLy8gc3RlcCAxOiBpdGVyYXRlIHRocm91Z2ggYWxsIGxhbmVzXG4gICAgICB2YXIgbGFuZUtleXMgPSB0aGlzLmxhbmVzLl9rZXlzKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGFuZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGxhbmVpZCA9IGxhbmVLZXlzW2ldO1xuXG4gICAgICAgIHZhciBsYW5lID0gdGhpcy5sYW5lcy5fZ2V0KGxhbmVpZCk7XG5cbiAgICAgICAgdmFyIGxhbmVEYXRhID0gaGVscGVyLmdldE1DSURhbmRBdHRyT3V0T2ZMYW5lS2V5KGxhbmVpZCk7XG5cbiAgICAgICAgaWYgKGZyb20gPD0gdG8pIHtcbiAgICAgICAgICB0aGlzLnNsaXBJbnRvTGFuZUZvcndhcmRzKGxhbmUsIGxhbmVEYXRhLCBmcm9tLCB0bywgY29udGV4dElkLCBmb3JjZVJlc2V0KTtcbiAgICAgICAgfSBlbHNlIGlmIChmcm9tID4gdG8pIHtcbiAgICAgICAgICB0aGlzLnNsaXBUb0xhbmVCYWNrd2FyZHMobGFuZSwgbGFuZURhdGEsIGZyb20sIHRvLCBjb250ZXh0SWQsIGZvcmNlUmVzZXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxhbmVzXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5MYW5lc0hhbmRsZXIubGFuZXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluY2lkZW50c0J5SWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLkxhbmVzSGFuZGxlci5pbmNpZGVudHNCeUlkO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcInR5cGVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBcImF0dHJpYnV0ZXNcIjtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQXR0cmlidXRlQ2hhbm5lbDtcbn0oQ2hhbm5lbCk7XG5cbm1vZHVsZS5leHBvcnRzID0gQXR0cmlidXRlQ2hhbm5lbDsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/_Channels/_Attribute/AttributeChannel.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/_Channels/_Attribute/LanesHandler.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/_Channels/_Attribute/LanesHandler.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar _filter = __webpack_require__(/*! ../../../lodash-custom-build/modularize/lodash.filter/index */ \"./node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.filter/index.js\");\n\nvar _sortBy = __webpack_require__(/*! ../../../lodash-custom-build/modularize/lodash.sortby/index */ \"./node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.sortby/index.js\");\n\nvar _findIndex = __webpack_require__(/*! ../../../lodash-custom-build/modularize/lodash.findindex/index */ \"./node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.findindex/index.js\");\n\nvar Helper = __webpack_require__(/*! ../../_coreUtils/Helper */ \"./node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\");\n\nvar helper = new Helper({\n  logLevel: 4\n});\n\nvar Collection = __webpack_require__(/*! ./helpers/Collection */ \"./node_modules/@kissmybutton/motorcortex/dist/_Channels/_Attribute/helpers/Collection.js\");\n\nvar SandboxLanes = __webpack_require__(/*! ./helpers/SandboxLanes */ \"./node_modules/@kissmybutton/motorcortex/dist/_Channels/_Attribute/helpers/SandboxLanes.js\");\n\nvar SandboxCollection = __webpack_require__(/*! ./helpers/SandboxCollection */ \"./node_modules/@kissmybutton/motorcortex/dist/_Channels/_Attribute/helpers/SandboxCollection.js\");\n\nvar SandboxIncidentsById = __webpack_require__(/*! ./helpers/SandboxIncidentsById */ \"./node_modules/@kissmybutton/motorcortex/dist/_Channels/_Attribute/helpers/SandboxIncidentsById.js\");\n\nvar setInitialValueForCombo = __webpack_require__(/*! ./helpers/ComboAttrsCascading */ \"./node_modules/@kissmybutton/motorcortex/dist/_Channels/_Attribute/helpers/ComboAttrsCascading.js\");\n\nvar LanesHandler =\n/*#__PURE__*/\nfunction () {\n  function LanesHandler() {\n    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, LanesHandler);\n\n    /*\n     * Keeps the lanes of the Channel in the form:\n     * {\n     *  <motorcortex-id>_<attribute>: [\n     *      {\n     *          id: the id of the Incident\n     *          millisecond: the millisecond of the channel this Animation (that affects the selector/attribute pair) runs\n     *      }\n     *  ]\n     * }\n     /** @type {{}}\n     */\n    this.lanes = new Collection({});\n\n    if (props.lanes) {\n      this.lanes = props.lanes;\n    }\n\n    this.comboAttributes = {};\n\n    if (props.comboAttributes != null) {\n      this.comboAttributes = props.comboAttributes;\n    }\n\n    this.runTimeInfo = props.runTimeInfo;\n    /*\n    Keeps an indexing of the lanes each Animation belongs to. The form is the following:\n    belongingLaneKeysByAnimationId: {\n        <animation_id>: [laneKey1, laneKey2, ...],\n        <animation_id>: [laneKey2, laneKey3, ...],\n        ...\n    }\n     */\n\n    this.belongingLaneKeysByAnimationId = new Collection({});\n\n    if (props.belongingLaneKeysByAnimationId) {\n      this.belongingLaneKeysByAnimationId = props.belongingLaneKeysByAnimationId;\n    }\n    /*\n    keeps all Incidents (that appear on the lanes) mapped on a key - value pair\n    object on which the keys are the ids and the values the corresponding Incidents.\n    The Incidents of this object are ContextAwareIncidents\n    */\n\n\n    this.incidentsById = new Collection({});\n\n    if (props.incidentsById) {\n      this.incidentsById = props.incidentsById;\n    }\n  }\n  /**\n   * This method resizes all the lanes of the Lanes Handler by the durationFraction provided.\n   * No checks are performed.\n   * This method is been invoked in cases where a full Clip gets resized, so no conflict checks need to\n   * run.\n   * @param {float} durationFration: the fraction between the new duration and the current\n   */\n\n\n  _createClass(LanesHandler, [{\n    key: \"_resize\",\n    value: function _resize(durationFraction) {\n      var keys = this.lanes._keys();\n\n      for (var i = 0; i < keys.length; i++) {\n        var key = keys[i];\n\n        var theLane = this.lanes._get(key);\n\n        for (var _i = 0; _i < theLane.length; _i++) {\n          theLane[_i].millisecond = theLane[_i].millisecond * durationFraction;\n        }\n      }\n    }\n    /**\n     * it creates a new LanesHandler that acts as a sanbox for testing changes\n     */\n\n  }, {\n    key: \"createTestLanesSanbox\",\n    value: function createTestLanesSanbox() {\n      var props = {\n        lanes: new SandboxLanes(this.lanes._export()),\n        belongingLaneKeysByAnimationId: new SandboxCollection(this.belongingLaneKeysByAnimationId._export()),\n        incidentsById: new SandboxIncidentsById(this.incidentsById._export())\n      };\n\n      if (this.comboAttributes) {\n        props.comboAttributes = this.comboAttributes;\n      }\n\n      return new LanesHandler(props);\n    }\n  }, {\n    key: \"getLanesCopy\",\n    value: function getLanesCopy(lane) {\n      var laneToReturn = [];\n\n      for (var i = 0; i < lane.length; i++) {\n        laneToReturn.push({\n          id: lane[i].id,\n          millisecond: lane[i].millisecond * 1\n        });\n      }\n\n      return laneToReturn;\n    }\n  }, {\n    key: \"getLaneElementsClone\",\n    value: function getLaneElementsClone(laneElement) {\n      return {\n        id: laneElement.id,\n        millisecond: laneElement.millisecond * 1\n      };\n    }\n  }, {\n    key: \"applySandboxChanges\",\n    value: function applySandboxChanges(SanboxObject) {\n      this.lanes = new Collection(SanboxObject.lanes._export());\n      this.belongingLaneKeysByAnimationId = new Collection(SanboxObject.belongingLaneKeysByAnimationId._export());\n      this.incidentsById = new Collection(SanboxObject.incidentsById._export());\n    }\n  }, {\n    key: \"getLane\",\n    value: function getLane(mcid, attr) {\n      return this.lanes._get(helper.getLaneKey(mcid, attr));\n    }\n    /**\n     * return true if lane exists or false otherwise\n     * @param {String} mcid\n     * @param {String} attr\n     * @param {boolean} ifNotCreateIt - if is set to true and the lane doesn't exist it creates it but still returning false\n     */\n\n  }, {\n    key: \"laneExists\",\n    value: function laneExists(mcid, attr) {\n      var ifNotCreateIt = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var laneKey = helper.getLaneKey(mcid, attr);\n\n      if (!this.lanes._hasOwnProperty(laneKey)) {\n        if (ifNotCreateIt) {\n          this.lanes._set(laneKey, []);\n        }\n\n        return false;\n      } else {\n        return true;\n      }\n    }\n    /**\n     * @param {Object} newAnim - an object of the form of a lane item (with keys \"millisecond\" and \"incident\"\n     * @param {string} mcid\n     * @param {String} attr\n     * @param {array} excludeIdsFromCheck - optional. If exists it excludes all the ids of this array from check. This\n     *  parameter has been added for the edit checks where an animation might overlap another animation that participates on\n     *  the move, something that should not happen as the edited animations pre-existed without conflicts and the move of all\n     *  of them together guarantees that there is going to be no conflict between them even after the edit\n     * @param {int} testDuration - optional. This parameter is used when the channel needs to addcheck overlaps after duration\n     *  edits, so the testDuration is passed (we don't want to polute the original animation object as it refers to the real one)\n     * @retuns {array} - a list of all overlapping animations of the lane\n     */\n\n  }, {\n    key: \"getOverlappingAnims\",\n    value: function getOverlappingAnims(newAnim, mcid, attr) {\n      var excludeIdsFromCheck = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n      var testDuration = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n      var that = this;\n\n      var overlappingAnims = _filter(this.lanes._get(helper.getLaneKey(mcid, attr)), function (existingAnim) {\n        var durationToUseOnChecks = newAnim.incident.duration;\n\n        if (testDuration != null) {\n          durationToUseOnChecks = testDuration;\n        }\n\n        return existingAnim.id != newAnim.incident.id && excludeIdsFromCheck.indexOf(existingAnim.id) < 0 && ( // existing anim starts within the new anim's extend\n        existingAnim.millisecond >= newAnim.millisecond && existingAnim.millisecond < durationToUseOnChecks + newAnim.millisecond || // or ends within the new anim's extend\n        existingAnim.millisecond + that.incidentsById._get(existingAnim.id).duration > newAnim.millisecond && existingAnim.millisecond + that.incidentsById._get(existingAnim.id).duration <= durationToUseOnChecks + newAnim.millisecond // or it starts before and ends after the new anim's extend\n        || existingAnim.millisecond < newAnim.millisecond && existingAnim.millisecond + that.incidentsById._get(existingAnim.id).duration > durationToUseOnChecks + newAnim.millisecond);\n      });\n\n      return overlappingAnims;\n    }\n    /**\n     * it justs adds the lane item to the lane and adjusts the initial values of the Anims in sequence\n     * No checks are performed, just execution.\n     * @param {String} mcid\n     * @param {String} attr\n     * @param {int} millisecond\n     * @param {Object} incident\n     */\n\n  }, {\n    key: \"addElementToLane\",\n    value: function addElementToLane(mcid, attr, millisecond, incident) {\n      var laneKey = helper.getLaneKey(mcid, attr);\n\n      this.incidentsById._set(incident.id, incident);\n\n      var laneElement = {\n        millisecond: millisecond,\n        id: incident.id\n      };\n      this.laneExists(mcid, attr, true);\n\n      var theLane = this.lanes._get(laneKey);\n\n      theLane.push(laneElement);\n      theLane = _sortBy(theLane, ['millisecond']);\n\n      this.lanes._set(laneKey, theLane); // indexing stuff\n\n\n      if (!this.belongingLaneKeysByAnimationId._hasOwnProperty(incident.id)) {\n        this.belongingLaneKeysByAnimationId._set(incident.id, []);\n      }\n\n      this.belongingLaneKeysByAnimationId._get(incident.id).push(laneKey); // indexing\n\n\n      var newAnimsIndex = _findIndex(theLane, function (item) {\n        return item.id === incident.id;\n      }); // helper.log(newAnimsIndex);\n      // step 1: set the intial values of the new Animation\n\n\n      if (newAnimsIndex === 0) {\n        // if the newly entered animation is the first of the lane\n        if (theLane.length > 1) {\n          // and it has other animations too\n          if (this.incidentsById._get(theLane[1].id).hasInitialValue()) {\n            // if the initial value of the following animation\n            // which used to be first is already calculated \"steal\" it\n            incident.setInitialValue(this.incidentsById._get(theLane[1].id).getInitialValue());\n          }\n        } else {\n          // else take it directly from the dom\n          incident.setInitialValue(incident.getScratchValue());\n        }\n      } else {\n        incident.setInitialValue(this.incidentsById._get(theLane[newAnimsIndex - 1].id).animatedAttributeValue);\n      }\n      /* if the attribute of the lane is a compo attribute */\n\n\n      if (Object.prototype.hasOwnProperty.call(this.comboAttributes, attr)) {\n        var incidentInitialValues = incident.getInitialValue();\n        setInitialValueForCombo(theLane, this.incidentsById, incidentInitialValues, newAnimsIndex);\n      }\n\n      var onSuccessAction = function onSuccessAction() {}; // step 2: set the inital values of the following Animation (if any)\n\n\n      var that = this;\n\n      if (newAnimsIndex + 1 < theLane.length) {\n        onSuccessAction = function onSuccessAction() {\n          that.incidentsById._get(theLane[newAnimsIndex + 1].id).setInitialValue(incident.animatedAttributeValue);\n\n          if (that.incidentsById._get(theLane[newAnimsIndex + 1].id).gotContext) {\n            that.incidentsById._get(theLane[newAnimsIndex + 1].id).lastWish();\n\n            that.incidentsById._get(theLane[newAnimsIndex + 1].id).onGetContext();\n          }\n        };\n      }\n\n      onSuccessAction();\n    }\n    /**\n     * it justs updates the lane\n     * No checks are performed, just execution\n     * @param {array} affectedAnimationsIds\n     * @param {int} millisecondDelta\n     */\n\n  }, {\n    key: \"updateLane\",\n    value: function updateLane(affectedAnimationsIds, millisecondsDelta) {\n      var _this = this;\n\n      // first we group the affected animations by lanes\n      var affectedLanes = {};\n      var that = this;\n\n      for (var i = 0; i < affectedAnimationsIds.length; i++) {\n        var belongingLanes = this.belongingLaneKeysByAnimationId._get(affectedAnimationsIds[i]);\n\n        for (var j = 0; j < belongingLanes.length; j++) {\n          var laneKey = belongingLanes[j];\n\n          if (!Object.prototype.hasOwnProperty.call(affectedLanes, laneKey)) {\n            affectedLanes[laneKey] = {\n              animations: [],\n              lane: that.lanes._get(laneKey),\n              laneData: helper.getMCIDandAttrOutOfLaneKey(belongingLanes[j])\n            };\n          }\n\n          affectedLanes[laneKey].animations.push(affectedAnimationsIds[i]);\n        }\n      } // for each of the affected lanes\n\n\n      for (var _laneKey in affectedLanes) {\n        var affectedLane = affectedLanes[_laneKey];\n        var lane = affectedLane.lane;\n        var laneData = affectedLane.laneData;\n\n        var laneBeforeEdit = _sortBy(this.getLanesCopy(lane), ['millisecond']);\n\n        var isComboAttr = Object.prototype.hasOwnProperty.call(this.comboAttributes, laneData.attribute); // edit lane items millisecond\n\n        for (var k = 0; k < lane.length; k++) {\n          if (affectedLane.animations.indexOf(lane[k].id) >= 0) {\n            lane[k].millisecond += millisecondsDelta;\n          }\n        } // end for searching for the animations within the lane\n\n\n        var sortedLane = _sortBy(lane, ['millisecond']);\n\n        this.lanes._set(_laneKey, sortedLane);\n\n        lane = sortedLane;\n\n        var _loop = function _loop(_i2) {\n          var animationToCheck = affectedLane.animations[_i2];\n\n          var animationIndexBeforeEdit = _findIndex(laneBeforeEdit, function (item) {\n            return item.id === animationToCheck;\n          });\n\n          var animationIndexAfterEdit = _findIndex(lane, function (item) {\n            return item.id === animationToCheck;\n          });\n\n          var animation = _this.incidentsById._get(lane[animationIndexAfterEdit].id);\n\n          if (animationIndexBeforeEdit !== animationIndexAfterEdit || animationIndexAfterEdit > 1) {\n            if (animationIndexBeforeEdit + 1 < lane.length) {\n              // if the animation was not the last animation on the lane before the edit\n              // we should take care of the initial values of the animation's previous successor\n              if (animationIndexBeforeEdit === 0) {\n                // if the edited animation was the first one before the edit\n                // if it has initial values, pass them to its previous successor as its new initial values\n                if (animation.hasInitialValue() !== false) {\n                  // get the initial value of the edited animation and set it as initial value of the new 0 index\n                  if (isComboAttr) {\n                    setInitialValueForCombo(lane, _this.incidentsById, animation.getInitialValue(), 0);\n                  } else {\n                    _this.incidentsById._get(laneBeforeEdit[1].id).setInitialValue(animation.getInitialValue());\n\n                    _this.incidentsById._get(laneBeforeEdit[1].id).onGetContext();\n                  }\n                } else {\n                  // otherwise calculate the initial value on the fly, out of the dom and set it to the new 0\n                  if (isComboAttr) {\n                    setInitialValueForCombo(lane, _this.incidentsById, _this.incidentsById._get(laneBeforeEdit[1].id).getScratchValue(), 0);\n                  } else {\n                    _this.incidentsById._get(laneBeforeEdit[1].id).setInitialValue(_this.incidentsById._get(laneBeforeEdit[1].id).getScratchValue());\n\n                    _this.incidentsById._get(laneBeforeEdit[1].id).onGetContext();\n                  }\n                }\n              } else {\n                // else if the edited animation was not the first one before the edit\n                // meaning its previous successor is not the first one on the lane after the edit\n                // just grab the target value of the new previous animation of the animation's previous successor and set it as initial value\n                if (isComboAttr) {\n                  var indexToAffect = animationIndexAfterEdit > animationIndexBeforeEdit ? animationIndexBeforeEdit : animationIndexAfterEdit;\n                  setInitialValueForCombo(lane, _this.incidentsById, _this.incidentsById._get(laneBeforeEdit[animationIndexBeforeEdit - 1].id).animatedAttributeValue, indexToAffect);\n                } else {\n                  _this.incidentsById._get(laneBeforeEdit[animationIndexBeforeEdit + 1].id).setInitialValue(_this.incidentsById._get(laneBeforeEdit[animationIndexBeforeEdit - 1].id).animatedAttributeValue);\n\n                  _this.incidentsById._get(laneBeforeEdit[animationIndexBeforeEdit + 1].id).onGetContext();\n                }\n              }\n            } // for the edited animation itself now:\n\n\n            if (animationIndexAfterEdit === 0) {\n              // is it the first one (after edit)?\n              // does the previously zero index animation has initial value?\n              if (_this.incidentsById._get(laneBeforeEdit[0].id).hasInitialValue()) {\n                // get the initial values of the previously 0 indexed animation of the lane\n                if (isComboAttr) {\n                  setInitialValueForCombo(lane, _this.incidentsById, _this.incidentsById._get(laneBeforeEdit[0].id).getInitialValue(), animationIndexAfterEdit);\n                } else {\n                  animation.setInitialValue(_this.incidentsById._get(laneBeforeEdit[0].id).getInitialValue());\n                  animation.onGetContext();\n                }\n              } else {\n                // otherwise calculate the initial value on the fly, our of the dom\n                if (isComboAttr) {\n                  setInitialValueForCombo(lane, _this.incidentsById, animation.getScratchValue(), animationIndexAfterEdit);\n                } else {\n                  animation.setInitialValue(animation.getScratchValue());\n                  animation.onGetContext();\n                }\n              }\n            } else {\n              // else if it is not the first one after editd\n              // just grab the target value of the previous animation on the updated lane and set it as its initial value\n              if (isComboAttr) {\n                setInitialValueForCombo(lane, _this.incidentsById, _this.incidentsById._get(lane[animationIndexAfterEdit - 1].id).animatedAttributeValue, animationIndexAfterEdit);\n              } else {\n                animation.setInitialValue(_this.incidentsById._get(lane[animationIndexAfterEdit - 1].id).animatedAttributeValue);\n                animation.onGetContext();\n              }\n            } // for its new next animation (if it has one)\n\n\n            if (animationIndexAfterEdit + 1 < lane.length) {\n              // set its initial value to equal the target value of the edited animation\n              if (isComboAttr) {\n                setInitialValueForCombo(lane, _this.incidentsById, animation.animatedAttributeValue, animationIndexAfterEdit + 1);\n              } else {\n                _this.incidentsById._get(lane[animationIndexAfterEdit + 1].id).setInitialValue(animation.animatedAttributeValue);\n\n                _this.incidentsById._get(lane[animationIndexAfterEdit + 1].id).onGetContext();\n              }\n            }\n          }\n        };\n\n        for (var _i2 = 0; _i2 < affectedLane.animations.length; _i2++) {\n          _loop(_i2);\n        }\n      } // end for each of the belonging lanes of the animation\n\n    }\n    /**\n     * removes the list of animations as provided\n     * @param {array} removedAnimations - an array with the removed animations' ids\n     */\n\n  }, {\n    key: \"deleteAnimations\",\n    value: function deleteAnimations(removedAnimations) {\n      var affectedLanes = {};\n\n      for (var i = 0; i < removedAnimations.length; i++) {\n        var id = removedAnimations[i]; // for each lane the affected Animation appears in\n\n        var belongingLanes = this.belongingLaneKeysByAnimationId._get(id);\n\n        for (var j = 0; j < belongingLanes.length; j++) {\n          var lane = this.lanes._get(belongingLanes[j]);\n\n          var animationIndexBeforeEdit = -1;\n\n          for (var k = 0; k < lane.length; k++) {\n            if (lane[k].id === id) {\n              animationIndexBeforeEdit = k;\n              break;\n            }\n          } // helper.log(animationIndexBeforeEdit);\n\n\n          var animationToDelete = Object.assign({}, lane[animationIndexBeforeEdit]);\n\n          var animationObjectToDelete = this.incidentsById._get(animationToDelete.id);\n\n          var laneData = helper.getMCIDandAttrOutOfLaneKey(belongingLanes[j]); // gets the lane without the removed animation\n\n          var newLane = [];\n\n          for (var _k = 0; _k < lane.length; _k++) {\n            if (lane[_k].id != id) {\n              newLane.push(lane[_k]);\n            }\n          }\n\n          this.lanes._set(belongingLanes[j], newLane);\n\n          lane = this.lanes._get(belongingLanes[j]);\n\n          if (lane.length === 0) {\n            // in case there are no more animations on the lane any more we reset\n            // the lane by running the progress(0,0), so that the affected elements\n            // will get back to their original attribute value\n            animationObjectToDelete.onProgress(0, 0);\n\n            this.lanes._delete(belongingLanes[j]);\n\n            if (Object.prototype.hasOwnProperty.call(affectedLanes, belongingLanes[j])) {\n              delete affectedLanes[belongingLanes[j]];\n            }\n          } else {\n            affectedLanes[belongingLanes[j]] = helper.getMCIDandAttrOutOfLaneKey(belongingLanes[j]);\n\n            if (animationIndexBeforeEdit < lane.length && this.incidentsById._get(animationToDelete.id).getInitialValue() !== false) {\n              if (Object.prototype.hasOwnProperty.call(this.comboAttributes, laneData.attribute)) {\n                setInitialValueForCombo(lane, this.incidentsById, this.incidentsById._get(animationToDelete.id).getInitialValue(), animationIndexBeforeEdit);\n              } else {\n                this.incidentsById._get(lane[animationIndexBeforeEdit].id).setInitialValue(this.incidentsById._get(animationToDelete.id).getInitialValue());\n\n                this.incidentsById._get(lane[animationIndexBeforeEdit].id).onGetContext();\n              }\n            }\n          }\n        }\n\n        this.belongingLaneKeysByAnimationId._delete(removedAnimations[i]);\n      }\n\n      return affectedLanes;\n    }\n  }]);\n\n  return LanesHandler;\n}();\n\nmodule.exports = LanesHandler;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19DaGFubmVscy9fQXR0cmlidXRlL0xhbmVzSGFuZGxlci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Aa2lzc215YnV0dG9uL21vdG9yY29ydGV4L2Rpc3QvX0NoYW5uZWxzL19BdHRyaWJ1dGUvTGFuZXNIYW5kbGVyLmpzPzFmMjYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxudmFyIF9maWx0ZXIgPSByZXF1aXJlKCcuLi8uLi8uLi9sb2Rhc2gtY3VzdG9tLWJ1aWxkL21vZHVsYXJpemUvbG9kYXNoLmZpbHRlci9pbmRleCcpO1xuXG52YXIgX3NvcnRCeSA9IHJlcXVpcmUoJy4uLy4uLy4uL2xvZGFzaC1jdXN0b20tYnVpbGQvbW9kdWxhcml6ZS9sb2Rhc2guc29ydGJ5L2luZGV4Jyk7XG5cbnZhciBfZmluZEluZGV4ID0gcmVxdWlyZSgnLi4vLi4vLi4vbG9kYXNoLWN1c3RvbS1idWlsZC9tb2R1bGFyaXplL2xvZGFzaC5maW5kaW5kZXgvaW5kZXgnKTtcblxudmFyIEhlbHBlciA9IHJlcXVpcmUoJy4uLy4uL19jb3JlVXRpbHMvSGVscGVyJyk7XG5cbnZhciBoZWxwZXIgPSBuZXcgSGVscGVyKHtcbiAgbG9nTGV2ZWw6IDRcbn0pO1xuXG52YXIgQ29sbGVjdGlvbiA9IHJlcXVpcmUoJy4vaGVscGVycy9Db2xsZWN0aW9uJyk7XG5cbnZhciBTYW5kYm94TGFuZXMgPSByZXF1aXJlKCcuL2hlbHBlcnMvU2FuZGJveExhbmVzJyk7XG5cbnZhciBTYW5kYm94Q29sbGVjdGlvbiA9IHJlcXVpcmUoJy4vaGVscGVycy9TYW5kYm94Q29sbGVjdGlvbicpO1xuXG52YXIgU2FuZGJveEluY2lkZW50c0J5SWQgPSByZXF1aXJlKCcuL2hlbHBlcnMvU2FuZGJveEluY2lkZW50c0J5SWQnKTtcblxudmFyIHNldEluaXRpYWxWYWx1ZUZvckNvbWJvID0gcmVxdWlyZSgnLi9oZWxwZXJzL0NvbWJvQXR0cnNDYXNjYWRpbmcnKTtcblxudmFyIExhbmVzSGFuZGxlciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIExhbmVzSGFuZGxlcigpIHtcbiAgICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExhbmVzSGFuZGxlcik7XG5cbiAgICAvKlxuICAgICAqIEtlZXBzIHRoZSBsYW5lcyBvZiB0aGUgQ2hhbm5lbCBpbiB0aGUgZm9ybTpcbiAgICAgKiB7XG4gICAgICogIDxtb3RvcmNvcnRleC1pZD5fPGF0dHJpYnV0ZT46IFtcbiAgICAgKiAgICAgIHtcbiAgICAgKiAgICAgICAgICBpZDogdGhlIGlkIG9mIHRoZSBJbmNpZGVudFxuICAgICAqICAgICAgICAgIG1pbGxpc2Vjb25kOiB0aGUgbWlsbGlzZWNvbmQgb2YgdGhlIGNoYW5uZWwgdGhpcyBBbmltYXRpb24gKHRoYXQgYWZmZWN0cyB0aGUgc2VsZWN0b3IvYXR0cmlidXRlIHBhaXIpIHJ1bnNcbiAgICAgKiAgICAgIH1cbiAgICAgKiAgXVxuICAgICAqIH1cbiAgICAgLyoqIEB0eXBlIHt7fX1cbiAgICAgKi9cbiAgICB0aGlzLmxhbmVzID0gbmV3IENvbGxlY3Rpb24oe30pO1xuXG4gICAgaWYgKHByb3BzLmxhbmVzKSB7XG4gICAgICB0aGlzLmxhbmVzID0gcHJvcHMubGFuZXM7XG4gICAgfVxuXG4gICAgdGhpcy5jb21ib0F0dHJpYnV0ZXMgPSB7fTtcblxuICAgIGlmIChwcm9wcy5jb21ib0F0dHJpYnV0ZXMgIT0gbnVsbCkge1xuICAgICAgdGhpcy5jb21ib0F0dHJpYnV0ZXMgPSBwcm9wcy5jb21ib0F0dHJpYnV0ZXM7XG4gICAgfVxuXG4gICAgdGhpcy5ydW5UaW1lSW5mbyA9IHByb3BzLnJ1blRpbWVJbmZvO1xuICAgIC8qXG4gICAgS2VlcHMgYW4gaW5kZXhpbmcgb2YgdGhlIGxhbmVzIGVhY2ggQW5pbWF0aW9uIGJlbG9uZ3MgdG8uIFRoZSBmb3JtIGlzIHRoZSBmb2xsb3dpbmc6XG4gICAgYmVsb25naW5nTGFuZUtleXNCeUFuaW1hdGlvbklkOiB7XG4gICAgICAgIDxhbmltYXRpb25faWQ+OiBbbGFuZUtleTEsIGxhbmVLZXkyLCAuLi5dLFxuICAgICAgICA8YW5pbWF0aW9uX2lkPjogW2xhbmVLZXkyLCBsYW5lS2V5MywgLi4uXSxcbiAgICAgICAgLi4uXG4gICAgfVxuICAgICAqL1xuXG4gICAgdGhpcy5iZWxvbmdpbmdMYW5lS2V5c0J5QW5pbWF0aW9uSWQgPSBuZXcgQ29sbGVjdGlvbih7fSk7XG5cbiAgICBpZiAocHJvcHMuYmVsb25naW5nTGFuZUtleXNCeUFuaW1hdGlvbklkKSB7XG4gICAgICB0aGlzLmJlbG9uZ2luZ0xhbmVLZXlzQnlBbmltYXRpb25JZCA9IHByb3BzLmJlbG9uZ2luZ0xhbmVLZXlzQnlBbmltYXRpb25JZDtcbiAgICB9XG4gICAgLypcbiAgICBrZWVwcyBhbGwgSW5jaWRlbnRzICh0aGF0IGFwcGVhciBvbiB0aGUgbGFuZXMpIG1hcHBlZCBvbiBhIGtleSAtIHZhbHVlIHBhaXJcbiAgICBvYmplY3Qgb24gd2hpY2ggdGhlIGtleXMgYXJlIHRoZSBpZHMgYW5kIHRoZSB2YWx1ZXMgdGhlIGNvcnJlc3BvbmRpbmcgSW5jaWRlbnRzLlxuICAgIFRoZSBJbmNpZGVudHMgb2YgdGhpcyBvYmplY3QgYXJlIENvbnRleHRBd2FyZUluY2lkZW50c1xuICAgICovXG5cblxuICAgIHRoaXMuaW5jaWRlbnRzQnlJZCA9IG5ldyBDb2xsZWN0aW9uKHt9KTtcblxuICAgIGlmIChwcm9wcy5pbmNpZGVudHNCeUlkKSB7XG4gICAgICB0aGlzLmluY2lkZW50c0J5SWQgPSBwcm9wcy5pbmNpZGVudHNCeUlkO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVGhpcyBtZXRob2QgcmVzaXplcyBhbGwgdGhlIGxhbmVzIG9mIHRoZSBMYW5lcyBIYW5kbGVyIGJ5IHRoZSBkdXJhdGlvbkZyYWN0aW9uIHByb3ZpZGVkLlxuICAgKiBObyBjaGVja3MgYXJlIHBlcmZvcm1lZC5cbiAgICogVGhpcyBtZXRob2QgaXMgYmVlbiBpbnZva2VkIGluIGNhc2VzIHdoZXJlIGEgZnVsbCBDbGlwIGdldHMgcmVzaXplZCwgc28gbm8gY29uZmxpY3QgY2hlY2tzIG5lZWQgdG9cbiAgICogcnVuLlxuICAgKiBAcGFyYW0ge2Zsb2F0fSBkdXJhdGlvbkZyYXRpb246IHRoZSBmcmFjdGlvbiBiZXR3ZWVuIHRoZSBuZXcgZHVyYXRpb24gYW5kIHRoZSBjdXJyZW50XG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKExhbmVzSGFuZGxlciwgW3tcbiAgICBrZXk6IFwiX3Jlc2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVzaXplKGR1cmF0aW9uRnJhY3Rpb24pIHtcbiAgICAgIHZhciBrZXlzID0gdGhpcy5sYW5lcy5fa2V5cygpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgdmFyIHRoZUxhbmUgPSB0aGlzLmxhbmVzLl9nZXQoa2V5KTtcblxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgdGhlTGFuZS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICB0aGVMYW5lW19pXS5taWxsaXNlY29uZCA9IHRoZUxhbmVbX2ldLm1pbGxpc2Vjb25kICogZHVyYXRpb25GcmFjdGlvbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBpdCBjcmVhdGVzIGEgbmV3IExhbmVzSGFuZGxlciB0aGF0IGFjdHMgYXMgYSBzYW5ib3ggZm9yIHRlc3RpbmcgY2hhbmdlc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY3JlYXRlVGVzdExhbmVzU2FuYm94XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZVRlc3RMYW5lc1NhbmJveCgpIHtcbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgbGFuZXM6IG5ldyBTYW5kYm94TGFuZXModGhpcy5sYW5lcy5fZXhwb3J0KCkpLFxuICAgICAgICBiZWxvbmdpbmdMYW5lS2V5c0J5QW5pbWF0aW9uSWQ6IG5ldyBTYW5kYm94Q29sbGVjdGlvbih0aGlzLmJlbG9uZ2luZ0xhbmVLZXlzQnlBbmltYXRpb25JZC5fZXhwb3J0KCkpLFxuICAgICAgICBpbmNpZGVudHNCeUlkOiBuZXcgU2FuZGJveEluY2lkZW50c0J5SWQodGhpcy5pbmNpZGVudHNCeUlkLl9leHBvcnQoKSlcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLmNvbWJvQXR0cmlidXRlcykge1xuICAgICAgICBwcm9wcy5jb21ib0F0dHJpYnV0ZXMgPSB0aGlzLmNvbWJvQXR0cmlidXRlcztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBMYW5lc0hhbmRsZXIocHJvcHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRMYW5lc0NvcHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TGFuZXNDb3B5KGxhbmUpIHtcbiAgICAgIHZhciBsYW5lVG9SZXR1cm4gPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYW5lLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxhbmVUb1JldHVybi5wdXNoKHtcbiAgICAgICAgICBpZDogbGFuZVtpXS5pZCxcbiAgICAgICAgICBtaWxsaXNlY29uZDogbGFuZVtpXS5taWxsaXNlY29uZCAqIDFcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsYW5lVG9SZXR1cm47XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldExhbmVFbGVtZW50c0Nsb25lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldExhbmVFbGVtZW50c0Nsb25lKGxhbmVFbGVtZW50KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpZDogbGFuZUVsZW1lbnQuaWQsXG4gICAgICAgIG1pbGxpc2Vjb25kOiBsYW5lRWxlbWVudC5taWxsaXNlY29uZCAqIDFcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFwcGx5U2FuZGJveENoYW5nZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwbHlTYW5kYm94Q2hhbmdlcyhTYW5ib3hPYmplY3QpIHtcbiAgICAgIHRoaXMubGFuZXMgPSBuZXcgQ29sbGVjdGlvbihTYW5ib3hPYmplY3QubGFuZXMuX2V4cG9ydCgpKTtcbiAgICAgIHRoaXMuYmVsb25naW5nTGFuZUtleXNCeUFuaW1hdGlvbklkID0gbmV3IENvbGxlY3Rpb24oU2FuYm94T2JqZWN0LmJlbG9uZ2luZ0xhbmVLZXlzQnlBbmltYXRpb25JZC5fZXhwb3J0KCkpO1xuICAgICAgdGhpcy5pbmNpZGVudHNCeUlkID0gbmV3IENvbGxlY3Rpb24oU2FuYm94T2JqZWN0LmluY2lkZW50c0J5SWQuX2V4cG9ydCgpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TGFuZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMYW5lKG1jaWQsIGF0dHIpIHtcbiAgICAgIHJldHVybiB0aGlzLmxhbmVzLl9nZXQoaGVscGVyLmdldExhbmVLZXkobWNpZCwgYXR0cikpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiByZXR1cm4gdHJ1ZSBpZiBsYW5lIGV4aXN0cyBvciBmYWxzZSBvdGhlcndpc2VcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWNpZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpZk5vdENyZWF0ZUl0IC0gaWYgaXMgc2V0IHRvIHRydWUgYW5kIHRoZSBsYW5lIGRvZXNuJ3QgZXhpc3QgaXQgY3JlYXRlcyBpdCBidXQgc3RpbGwgcmV0dXJuaW5nIGZhbHNlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJsYW5lRXhpc3RzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxhbmVFeGlzdHMobWNpZCwgYXR0cikge1xuICAgICAgdmFyIGlmTm90Q3JlYXRlSXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuICAgICAgdmFyIGxhbmVLZXkgPSBoZWxwZXIuZ2V0TGFuZUtleShtY2lkLCBhdHRyKTtcblxuICAgICAgaWYgKCF0aGlzLmxhbmVzLl9oYXNPd25Qcm9wZXJ0eShsYW5lS2V5KSkge1xuICAgICAgICBpZiAoaWZOb3RDcmVhdGVJdCkge1xuICAgICAgICAgIHRoaXMubGFuZXMuX3NldChsYW5lS2V5LCBbXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG5ld0FuaW0gLSBhbiBvYmplY3Qgb2YgdGhlIGZvcm0gb2YgYSBsYW5lIGl0ZW0gKHdpdGgga2V5cyBcIm1pbGxpc2Vjb25kXCIgYW5kIFwiaW5jaWRlbnRcIlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtY2lkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGF0dHJcbiAgICAgKiBAcGFyYW0ge2FycmF5fSBleGNsdWRlSWRzRnJvbUNoZWNrIC0gb3B0aW9uYWwuIElmIGV4aXN0cyBpdCBleGNsdWRlcyBhbGwgdGhlIGlkcyBvZiB0aGlzIGFycmF5IGZyb20gY2hlY2suIFRoaXNcbiAgICAgKiAgcGFyYW1ldGVyIGhhcyBiZWVuIGFkZGVkIGZvciB0aGUgZWRpdCBjaGVja3Mgd2hlcmUgYW4gYW5pbWF0aW9uIG1pZ2h0IG92ZXJsYXAgYW5vdGhlciBhbmltYXRpb24gdGhhdCBwYXJ0aWNpcGF0ZXMgb25cbiAgICAgKiAgdGhlIG1vdmUsIHNvbWV0aGluZyB0aGF0IHNob3VsZCBub3QgaGFwcGVuIGFzIHRoZSBlZGl0ZWQgYW5pbWF0aW9ucyBwcmUtZXhpc3RlZCB3aXRob3V0IGNvbmZsaWN0cyBhbmQgdGhlIG1vdmUgb2YgYWxsXG4gICAgICogIG9mIHRoZW0gdG9nZXRoZXIgZ3VhcmFudGVlcyB0aGF0IHRoZXJlIGlzIGdvaW5nIHRvIGJlIG5vIGNvbmZsaWN0IGJldHdlZW4gdGhlbSBldmVuIGFmdGVyIHRoZSBlZGl0XG4gICAgICogQHBhcmFtIHtpbnR9IHRlc3REdXJhdGlvbiAtIG9wdGlvbmFsLiBUaGlzIHBhcmFtZXRlciBpcyB1c2VkIHdoZW4gdGhlIGNoYW5uZWwgbmVlZHMgdG8gYWRkY2hlY2sgb3ZlcmxhcHMgYWZ0ZXIgZHVyYXRpb25cbiAgICAgKiAgZWRpdHMsIHNvIHRoZSB0ZXN0RHVyYXRpb24gaXMgcGFzc2VkICh3ZSBkb24ndCB3YW50IHRvIHBvbHV0ZSB0aGUgb3JpZ2luYWwgYW5pbWF0aW9uIG9iamVjdCBhcyBpdCByZWZlcnMgdG8gdGhlIHJlYWwgb25lKVxuICAgICAqIEByZXR1bnMge2FycmF5fSAtIGEgbGlzdCBvZiBhbGwgb3ZlcmxhcHBpbmcgYW5pbWF0aW9ucyBvZiB0aGUgbGFuZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0T3ZlcmxhcHBpbmdBbmltc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRPdmVybGFwcGluZ0FuaW1zKG5ld0FuaW0sIG1jaWQsIGF0dHIpIHtcbiAgICAgIHZhciBleGNsdWRlSWRzRnJvbUNoZWNrID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBbXTtcbiAgICAgIHZhciB0ZXN0RHVyYXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IG51bGw7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgIHZhciBvdmVybGFwcGluZ0FuaW1zID0gX2ZpbHRlcih0aGlzLmxhbmVzLl9nZXQoaGVscGVyLmdldExhbmVLZXkobWNpZCwgYXR0cikpLCBmdW5jdGlvbiAoZXhpc3RpbmdBbmltKSB7XG4gICAgICAgIHZhciBkdXJhdGlvblRvVXNlT25DaGVja3MgPSBuZXdBbmltLmluY2lkZW50LmR1cmF0aW9uO1xuXG4gICAgICAgIGlmICh0ZXN0RHVyYXRpb24gIT0gbnVsbCkge1xuICAgICAgICAgIGR1cmF0aW9uVG9Vc2VPbkNoZWNrcyA9IHRlc3REdXJhdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBleGlzdGluZ0FuaW0uaWQgIT0gbmV3QW5pbS5pbmNpZGVudC5pZCAmJiBleGNsdWRlSWRzRnJvbUNoZWNrLmluZGV4T2YoZXhpc3RpbmdBbmltLmlkKSA8IDAgJiYgKCAvLyBleGlzdGluZyBhbmltIHN0YXJ0cyB3aXRoaW4gdGhlIG5ldyBhbmltJ3MgZXh0ZW5kXG4gICAgICAgIGV4aXN0aW5nQW5pbS5taWxsaXNlY29uZCA+PSBuZXdBbmltLm1pbGxpc2Vjb25kICYmIGV4aXN0aW5nQW5pbS5taWxsaXNlY29uZCA8IGR1cmF0aW9uVG9Vc2VPbkNoZWNrcyArIG5ld0FuaW0ubWlsbGlzZWNvbmQgfHwgLy8gb3IgZW5kcyB3aXRoaW4gdGhlIG5ldyBhbmltJ3MgZXh0ZW5kXG4gICAgICAgIGV4aXN0aW5nQW5pbS5taWxsaXNlY29uZCArIHRoYXQuaW5jaWRlbnRzQnlJZC5fZ2V0KGV4aXN0aW5nQW5pbS5pZCkuZHVyYXRpb24gPiBuZXdBbmltLm1pbGxpc2Vjb25kICYmIGV4aXN0aW5nQW5pbS5taWxsaXNlY29uZCArIHRoYXQuaW5jaWRlbnRzQnlJZC5fZ2V0KGV4aXN0aW5nQW5pbS5pZCkuZHVyYXRpb24gPD0gZHVyYXRpb25Ub1VzZU9uQ2hlY2tzICsgbmV3QW5pbS5taWxsaXNlY29uZCAvLyBvciBpdCBzdGFydHMgYmVmb3JlIGFuZCBlbmRzIGFmdGVyIHRoZSBuZXcgYW5pbSdzIGV4dGVuZFxuICAgICAgICB8fCBleGlzdGluZ0FuaW0ubWlsbGlzZWNvbmQgPCBuZXdBbmltLm1pbGxpc2Vjb25kICYmIGV4aXN0aW5nQW5pbS5taWxsaXNlY29uZCArIHRoYXQuaW5jaWRlbnRzQnlJZC5fZ2V0KGV4aXN0aW5nQW5pbS5pZCkuZHVyYXRpb24gPiBkdXJhdGlvblRvVXNlT25DaGVja3MgKyBuZXdBbmltLm1pbGxpc2Vjb25kKTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gb3ZlcmxhcHBpbmdBbmltcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogaXQganVzdHMgYWRkcyB0aGUgbGFuZSBpdGVtIHRvIHRoZSBsYW5lIGFuZCBhZGp1c3RzIHRoZSBpbml0aWFsIHZhbHVlcyBvZiB0aGUgQW5pbXMgaW4gc2VxdWVuY2VcbiAgICAgKiBObyBjaGVja3MgYXJlIHBlcmZvcm1lZCwganVzdCBleGVjdXRpb24uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1jaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0clxuICAgICAqIEBwYXJhbSB7aW50fSBtaWxsaXNlY29uZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbmNpZGVudFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkRWxlbWVudFRvTGFuZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRFbGVtZW50VG9MYW5lKG1jaWQsIGF0dHIsIG1pbGxpc2Vjb25kLCBpbmNpZGVudCkge1xuICAgICAgdmFyIGxhbmVLZXkgPSBoZWxwZXIuZ2V0TGFuZUtleShtY2lkLCBhdHRyKTtcblxuICAgICAgdGhpcy5pbmNpZGVudHNCeUlkLl9zZXQoaW5jaWRlbnQuaWQsIGluY2lkZW50KTtcblxuICAgICAgdmFyIGxhbmVFbGVtZW50ID0ge1xuICAgICAgICBtaWxsaXNlY29uZDogbWlsbGlzZWNvbmQsXG4gICAgICAgIGlkOiBpbmNpZGVudC5pZFxuICAgICAgfTtcbiAgICAgIHRoaXMubGFuZUV4aXN0cyhtY2lkLCBhdHRyLCB0cnVlKTtcblxuICAgICAgdmFyIHRoZUxhbmUgPSB0aGlzLmxhbmVzLl9nZXQobGFuZUtleSk7XG5cbiAgICAgIHRoZUxhbmUucHVzaChsYW5lRWxlbWVudCk7XG4gICAgICB0aGVMYW5lID0gX3NvcnRCeSh0aGVMYW5lLCBbJ21pbGxpc2Vjb25kJ10pO1xuXG4gICAgICB0aGlzLmxhbmVzLl9zZXQobGFuZUtleSwgdGhlTGFuZSk7IC8vIGluZGV4aW5nIHN0dWZmXG5cblxuICAgICAgaWYgKCF0aGlzLmJlbG9uZ2luZ0xhbmVLZXlzQnlBbmltYXRpb25JZC5faGFzT3duUHJvcGVydHkoaW5jaWRlbnQuaWQpKSB7XG4gICAgICAgIHRoaXMuYmVsb25naW5nTGFuZUtleXNCeUFuaW1hdGlvbklkLl9zZXQoaW5jaWRlbnQuaWQsIFtdKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5iZWxvbmdpbmdMYW5lS2V5c0J5QW5pbWF0aW9uSWQuX2dldChpbmNpZGVudC5pZCkucHVzaChsYW5lS2V5KTsgLy8gaW5kZXhpbmdcblxuXG4gICAgICB2YXIgbmV3QW5pbXNJbmRleCA9IF9maW5kSW5kZXgodGhlTGFuZSwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0uaWQgPT09IGluY2lkZW50LmlkO1xuICAgICAgfSk7IC8vIGhlbHBlci5sb2cobmV3QW5pbXNJbmRleCk7XG4gICAgICAvLyBzdGVwIDE6IHNldCB0aGUgaW50aWFsIHZhbHVlcyBvZiB0aGUgbmV3IEFuaW1hdGlvblxuXG5cbiAgICAgIGlmIChuZXdBbmltc0luZGV4ID09PSAwKSB7XG4gICAgICAgIC8vIGlmIHRoZSBuZXdseSBlbnRlcmVkIGFuaW1hdGlvbiBpcyB0aGUgZmlyc3Qgb2YgdGhlIGxhbmVcbiAgICAgICAgaWYgKHRoZUxhbmUubGVuZ3RoID4gMSkge1xuICAgICAgICAgIC8vIGFuZCBpdCBoYXMgb3RoZXIgYW5pbWF0aW9ucyB0b29cbiAgICAgICAgICBpZiAodGhpcy5pbmNpZGVudHNCeUlkLl9nZXQodGhlTGFuZVsxXS5pZCkuaGFzSW5pdGlhbFZhbHVlKCkpIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBpbml0aWFsIHZhbHVlIG9mIHRoZSBmb2xsb3dpbmcgYW5pbWF0aW9uXG4gICAgICAgICAgICAvLyB3aGljaCB1c2VkIHRvIGJlIGZpcnN0IGlzIGFscmVhZHkgY2FsY3VsYXRlZCBcInN0ZWFsXCIgaXRcbiAgICAgICAgICAgIGluY2lkZW50LnNldEluaXRpYWxWYWx1ZSh0aGlzLmluY2lkZW50c0J5SWQuX2dldCh0aGVMYW5lWzFdLmlkKS5nZXRJbml0aWFsVmFsdWUoKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGVsc2UgdGFrZSBpdCBkaXJlY3RseSBmcm9tIHRoZSBkb21cbiAgICAgICAgICBpbmNpZGVudC5zZXRJbml0aWFsVmFsdWUoaW5jaWRlbnQuZ2V0U2NyYXRjaFZhbHVlKCkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmNpZGVudC5zZXRJbml0aWFsVmFsdWUodGhpcy5pbmNpZGVudHNCeUlkLl9nZXQodGhlTGFuZVtuZXdBbmltc0luZGV4IC0gMV0uaWQpLmFuaW1hdGVkQXR0cmlidXRlVmFsdWUpO1xuICAgICAgfVxuICAgICAgLyogaWYgdGhlIGF0dHJpYnV0ZSBvZiB0aGUgbGFuZSBpcyBhIGNvbXBvIGF0dHJpYnV0ZSAqL1xuXG5cbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5jb21ib0F0dHJpYnV0ZXMsIGF0dHIpKSB7XG4gICAgICAgIHZhciBpbmNpZGVudEluaXRpYWxWYWx1ZXMgPSBpbmNpZGVudC5nZXRJbml0aWFsVmFsdWUoKTtcbiAgICAgICAgc2V0SW5pdGlhbFZhbHVlRm9yQ29tYm8odGhlTGFuZSwgdGhpcy5pbmNpZGVudHNCeUlkLCBpbmNpZGVudEluaXRpYWxWYWx1ZXMsIG5ld0FuaW1zSW5kZXgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgb25TdWNjZXNzQWN0aW9uID0gZnVuY3Rpb24gb25TdWNjZXNzQWN0aW9uKCkge307IC8vIHN0ZXAgMjogc2V0IHRoZSBpbml0YWwgdmFsdWVzIG9mIHRoZSBmb2xsb3dpbmcgQW5pbWF0aW9uIChpZiBhbnkpXG5cblxuICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICBpZiAobmV3QW5pbXNJbmRleCArIDEgPCB0aGVMYW5lLmxlbmd0aCkge1xuICAgICAgICBvblN1Y2Nlc3NBY3Rpb24gPSBmdW5jdGlvbiBvblN1Y2Nlc3NBY3Rpb24oKSB7XG4gICAgICAgICAgdGhhdC5pbmNpZGVudHNCeUlkLl9nZXQodGhlTGFuZVtuZXdBbmltc0luZGV4ICsgMV0uaWQpLnNldEluaXRpYWxWYWx1ZShpbmNpZGVudC5hbmltYXRlZEF0dHJpYnV0ZVZhbHVlKTtcblxuICAgICAgICAgIGlmICh0aGF0LmluY2lkZW50c0J5SWQuX2dldCh0aGVMYW5lW25ld0FuaW1zSW5kZXggKyAxXS5pZCkuZ290Q29udGV4dCkge1xuICAgICAgICAgICAgdGhhdC5pbmNpZGVudHNCeUlkLl9nZXQodGhlTGFuZVtuZXdBbmltc0luZGV4ICsgMV0uaWQpLmxhc3RXaXNoKCk7XG5cbiAgICAgICAgICAgIHRoYXQuaW5jaWRlbnRzQnlJZC5fZ2V0KHRoZUxhbmVbbmV3QW5pbXNJbmRleCArIDFdLmlkKS5vbkdldENvbnRleHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIG9uU3VjY2Vzc0FjdGlvbigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBpdCBqdXN0cyB1cGRhdGVzIHRoZSBsYW5lXG4gICAgICogTm8gY2hlY2tzIGFyZSBwZXJmb3JtZWQsIGp1c3QgZXhlY3V0aW9uXG4gICAgICogQHBhcmFtIHthcnJheX0gYWZmZWN0ZWRBbmltYXRpb25zSWRzXG4gICAgICogQHBhcmFtIHtpbnR9IG1pbGxpc2Vjb25kRGVsdGFcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZUxhbmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlTGFuZShhZmZlY3RlZEFuaW1hdGlvbnNJZHMsIG1pbGxpc2Vjb25kc0RlbHRhKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAvLyBmaXJzdCB3ZSBncm91cCB0aGUgYWZmZWN0ZWQgYW5pbWF0aW9ucyBieSBsYW5lc1xuICAgICAgdmFyIGFmZmVjdGVkTGFuZXMgPSB7fTtcbiAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhZmZlY3RlZEFuaW1hdGlvbnNJZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGJlbG9uZ2luZ0xhbmVzID0gdGhpcy5iZWxvbmdpbmdMYW5lS2V5c0J5QW5pbWF0aW9uSWQuX2dldChhZmZlY3RlZEFuaW1hdGlvbnNJZHNbaV0pO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYmVsb25naW5nTGFuZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICB2YXIgbGFuZUtleSA9IGJlbG9uZ2luZ0xhbmVzW2pdO1xuXG4gICAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYWZmZWN0ZWRMYW5lcywgbGFuZUtleSkpIHtcbiAgICAgICAgICAgIGFmZmVjdGVkTGFuZXNbbGFuZUtleV0gPSB7XG4gICAgICAgICAgICAgIGFuaW1hdGlvbnM6IFtdLFxuICAgICAgICAgICAgICBsYW5lOiB0aGF0LmxhbmVzLl9nZXQobGFuZUtleSksXG4gICAgICAgICAgICAgIGxhbmVEYXRhOiBoZWxwZXIuZ2V0TUNJRGFuZEF0dHJPdXRPZkxhbmVLZXkoYmVsb25naW5nTGFuZXNbal0pXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGFmZmVjdGVkTGFuZXNbbGFuZUtleV0uYW5pbWF0aW9ucy5wdXNoKGFmZmVjdGVkQW5pbWF0aW9uc0lkc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gZm9yIGVhY2ggb2YgdGhlIGFmZmVjdGVkIGxhbmVzXG5cblxuICAgICAgZm9yICh2YXIgX2xhbmVLZXkgaW4gYWZmZWN0ZWRMYW5lcykge1xuICAgICAgICB2YXIgYWZmZWN0ZWRMYW5lID0gYWZmZWN0ZWRMYW5lc1tfbGFuZUtleV07XG4gICAgICAgIHZhciBsYW5lID0gYWZmZWN0ZWRMYW5lLmxhbmU7XG4gICAgICAgIHZhciBsYW5lRGF0YSA9IGFmZmVjdGVkTGFuZS5sYW5lRGF0YTtcblxuICAgICAgICB2YXIgbGFuZUJlZm9yZUVkaXQgPSBfc29ydEJ5KHRoaXMuZ2V0TGFuZXNDb3B5KGxhbmUpLCBbJ21pbGxpc2Vjb25kJ10pO1xuXG4gICAgICAgIHZhciBpc0NvbWJvQXR0ciA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmNvbWJvQXR0cmlidXRlcywgbGFuZURhdGEuYXR0cmlidXRlKTsgLy8gZWRpdCBsYW5lIGl0ZW1zIG1pbGxpc2Vjb25kXG5cbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBsYW5lLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgaWYgKGFmZmVjdGVkTGFuZS5hbmltYXRpb25zLmluZGV4T2YobGFuZVtrXS5pZCkgPj0gMCkge1xuICAgICAgICAgICAgbGFuZVtrXS5taWxsaXNlY29uZCArPSBtaWxsaXNlY29uZHNEZWx0YTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gZW5kIGZvciBzZWFyY2hpbmcgZm9yIHRoZSBhbmltYXRpb25zIHdpdGhpbiB0aGUgbGFuZVxuXG5cbiAgICAgICAgdmFyIHNvcnRlZExhbmUgPSBfc29ydEJ5KGxhbmUsIFsnbWlsbGlzZWNvbmQnXSk7XG5cbiAgICAgICAgdGhpcy5sYW5lcy5fc2V0KF9sYW5lS2V5LCBzb3J0ZWRMYW5lKTtcblxuICAgICAgICBsYW5lID0gc29ydGVkTGFuZTtcblxuICAgICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChfaTIpIHtcbiAgICAgICAgICB2YXIgYW5pbWF0aW9uVG9DaGVjayA9IGFmZmVjdGVkTGFuZS5hbmltYXRpb25zW19pMl07XG5cbiAgICAgICAgICB2YXIgYW5pbWF0aW9uSW5kZXhCZWZvcmVFZGl0ID0gX2ZpbmRJbmRleChsYW5lQmVmb3JlRWRpdCwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtLmlkID09PSBhbmltYXRpb25Ub0NoZWNrO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIGFuaW1hdGlvbkluZGV4QWZ0ZXJFZGl0ID0gX2ZpbmRJbmRleChsYW5lLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW0uaWQgPT09IGFuaW1hdGlvblRvQ2hlY2s7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgYW5pbWF0aW9uID0gX3RoaXMuaW5jaWRlbnRzQnlJZC5fZ2V0KGxhbmVbYW5pbWF0aW9uSW5kZXhBZnRlckVkaXRdLmlkKTtcblxuICAgICAgICAgIGlmIChhbmltYXRpb25JbmRleEJlZm9yZUVkaXQgIT09IGFuaW1hdGlvbkluZGV4QWZ0ZXJFZGl0IHx8IGFuaW1hdGlvbkluZGV4QWZ0ZXJFZGl0ID4gMSkge1xuICAgICAgICAgICAgaWYgKGFuaW1hdGlvbkluZGV4QmVmb3JlRWRpdCArIDEgPCBsYW5lLmxlbmd0aCkge1xuICAgICAgICAgICAgICAvLyBpZiB0aGUgYW5pbWF0aW9uIHdhcyBub3QgdGhlIGxhc3QgYW5pbWF0aW9uIG9uIHRoZSBsYW5lIGJlZm9yZSB0aGUgZWRpdFxuICAgICAgICAgICAgICAvLyB3ZSBzaG91bGQgdGFrZSBjYXJlIG9mIHRoZSBpbml0aWFsIHZhbHVlcyBvZiB0aGUgYW5pbWF0aW9uJ3MgcHJldmlvdXMgc3VjY2Vzc29yXG4gICAgICAgICAgICAgIGlmIChhbmltYXRpb25JbmRleEJlZm9yZUVkaXQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgZWRpdGVkIGFuaW1hdGlvbiB3YXMgdGhlIGZpcnN0IG9uZSBiZWZvcmUgdGhlIGVkaXRcbiAgICAgICAgICAgICAgICAvLyBpZiBpdCBoYXMgaW5pdGlhbCB2YWx1ZXMsIHBhc3MgdGhlbSB0byBpdHMgcHJldmlvdXMgc3VjY2Vzc29yIGFzIGl0cyBuZXcgaW5pdGlhbCB2YWx1ZXNcbiAgICAgICAgICAgICAgICBpZiAoYW5pbWF0aW9uLmhhc0luaXRpYWxWYWx1ZSgpICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgLy8gZ2V0IHRoZSBpbml0aWFsIHZhbHVlIG9mIHRoZSBlZGl0ZWQgYW5pbWF0aW9uIGFuZCBzZXQgaXQgYXMgaW5pdGlhbCB2YWx1ZSBvZiB0aGUgbmV3IDAgaW5kZXhcbiAgICAgICAgICAgICAgICAgIGlmIChpc0NvbWJvQXR0cikge1xuICAgICAgICAgICAgICAgICAgICBzZXRJbml0aWFsVmFsdWVGb3JDb21ibyhsYW5lLCBfdGhpcy5pbmNpZGVudHNCeUlkLCBhbmltYXRpb24uZ2V0SW5pdGlhbFZhbHVlKCksIDApO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuaW5jaWRlbnRzQnlJZC5fZ2V0KGxhbmVCZWZvcmVFZGl0WzFdLmlkKS5zZXRJbml0aWFsVmFsdWUoYW5pbWF0aW9uLmdldEluaXRpYWxWYWx1ZSgpKTtcblxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5pbmNpZGVudHNCeUlkLl9nZXQobGFuZUJlZm9yZUVkaXRbMV0uaWQpLm9uR2V0Q29udGV4dCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UgY2FsY3VsYXRlIHRoZSBpbml0aWFsIHZhbHVlIG9uIHRoZSBmbHksIG91dCBvZiB0aGUgZG9tIGFuZCBzZXQgaXQgdG8gdGhlIG5ldyAwXG4gICAgICAgICAgICAgICAgICBpZiAoaXNDb21ib0F0dHIpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0SW5pdGlhbFZhbHVlRm9yQ29tYm8obGFuZSwgX3RoaXMuaW5jaWRlbnRzQnlJZCwgX3RoaXMuaW5jaWRlbnRzQnlJZC5fZ2V0KGxhbmVCZWZvcmVFZGl0WzFdLmlkKS5nZXRTY3JhdGNoVmFsdWUoKSwgMCk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5pbmNpZGVudHNCeUlkLl9nZXQobGFuZUJlZm9yZUVkaXRbMV0uaWQpLnNldEluaXRpYWxWYWx1ZShfdGhpcy5pbmNpZGVudHNCeUlkLl9nZXQobGFuZUJlZm9yZUVkaXRbMV0uaWQpLmdldFNjcmF0Y2hWYWx1ZSgpKTtcblxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5pbmNpZGVudHNCeUlkLl9nZXQobGFuZUJlZm9yZUVkaXRbMV0uaWQpLm9uR2V0Q29udGV4dCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBlbHNlIGlmIHRoZSBlZGl0ZWQgYW5pbWF0aW9uIHdhcyBub3QgdGhlIGZpcnN0IG9uZSBiZWZvcmUgdGhlIGVkaXRcbiAgICAgICAgICAgICAgICAvLyBtZWFuaW5nIGl0cyBwcmV2aW91cyBzdWNjZXNzb3IgaXMgbm90IHRoZSBmaXJzdCBvbmUgb24gdGhlIGxhbmUgYWZ0ZXIgdGhlIGVkaXRcbiAgICAgICAgICAgICAgICAvLyBqdXN0IGdyYWIgdGhlIHRhcmdldCB2YWx1ZSBvZiB0aGUgbmV3IHByZXZpb3VzIGFuaW1hdGlvbiBvZiB0aGUgYW5pbWF0aW9uJ3MgcHJldmlvdXMgc3VjY2Vzc29yIGFuZCBzZXQgaXQgYXMgaW5pdGlhbCB2YWx1ZVxuICAgICAgICAgICAgICAgIGlmIChpc0NvbWJvQXR0cikge1xuICAgICAgICAgICAgICAgICAgdmFyIGluZGV4VG9BZmZlY3QgPSBhbmltYXRpb25JbmRleEFmdGVyRWRpdCA+IGFuaW1hdGlvbkluZGV4QmVmb3JlRWRpdCA/IGFuaW1hdGlvbkluZGV4QmVmb3JlRWRpdCA6IGFuaW1hdGlvbkluZGV4QWZ0ZXJFZGl0O1xuICAgICAgICAgICAgICAgICAgc2V0SW5pdGlhbFZhbHVlRm9yQ29tYm8obGFuZSwgX3RoaXMuaW5jaWRlbnRzQnlJZCwgX3RoaXMuaW5jaWRlbnRzQnlJZC5fZ2V0KGxhbmVCZWZvcmVFZGl0W2FuaW1hdGlvbkluZGV4QmVmb3JlRWRpdCAtIDFdLmlkKS5hbmltYXRlZEF0dHJpYnV0ZVZhbHVlLCBpbmRleFRvQWZmZWN0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgX3RoaXMuaW5jaWRlbnRzQnlJZC5fZ2V0KGxhbmVCZWZvcmVFZGl0W2FuaW1hdGlvbkluZGV4QmVmb3JlRWRpdCArIDFdLmlkKS5zZXRJbml0aWFsVmFsdWUoX3RoaXMuaW5jaWRlbnRzQnlJZC5fZ2V0KGxhbmVCZWZvcmVFZGl0W2FuaW1hdGlvbkluZGV4QmVmb3JlRWRpdCAtIDFdLmlkKS5hbmltYXRlZEF0dHJpYnV0ZVZhbHVlKTtcblxuICAgICAgICAgICAgICAgICAgX3RoaXMuaW5jaWRlbnRzQnlJZC5fZ2V0KGxhbmVCZWZvcmVFZGl0W2FuaW1hdGlvbkluZGV4QmVmb3JlRWRpdCArIDFdLmlkKS5vbkdldENvbnRleHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gLy8gZm9yIHRoZSBlZGl0ZWQgYW5pbWF0aW9uIGl0c2VsZiBub3c6XG5cblxuICAgICAgICAgICAgaWYgKGFuaW1hdGlvbkluZGV4QWZ0ZXJFZGl0ID09PSAwKSB7XG4gICAgICAgICAgICAgIC8vIGlzIGl0IHRoZSBmaXJzdCBvbmUgKGFmdGVyIGVkaXQpP1xuICAgICAgICAgICAgICAvLyBkb2VzIHRoZSBwcmV2aW91c2x5IHplcm8gaW5kZXggYW5pbWF0aW9uIGhhcyBpbml0aWFsIHZhbHVlP1xuICAgICAgICAgICAgICBpZiAoX3RoaXMuaW5jaWRlbnRzQnlJZC5fZ2V0KGxhbmVCZWZvcmVFZGl0WzBdLmlkKS5oYXNJbml0aWFsVmFsdWUoKSkge1xuICAgICAgICAgICAgICAgIC8vIGdldCB0aGUgaW5pdGlhbCB2YWx1ZXMgb2YgdGhlIHByZXZpb3VzbHkgMCBpbmRleGVkIGFuaW1hdGlvbiBvZiB0aGUgbGFuZVxuICAgICAgICAgICAgICAgIGlmIChpc0NvbWJvQXR0cikge1xuICAgICAgICAgICAgICAgICAgc2V0SW5pdGlhbFZhbHVlRm9yQ29tYm8obGFuZSwgX3RoaXMuaW5jaWRlbnRzQnlJZCwgX3RoaXMuaW5jaWRlbnRzQnlJZC5fZ2V0KGxhbmVCZWZvcmVFZGl0WzBdLmlkKS5nZXRJbml0aWFsVmFsdWUoKSwgYW5pbWF0aW9uSW5kZXhBZnRlckVkaXQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBhbmltYXRpb24uc2V0SW5pdGlhbFZhbHVlKF90aGlzLmluY2lkZW50c0J5SWQuX2dldChsYW5lQmVmb3JlRWRpdFswXS5pZCkuZ2V0SW5pdGlhbFZhbHVlKCkpO1xuICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uLm9uR2V0Q29udGV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UgY2FsY3VsYXRlIHRoZSBpbml0aWFsIHZhbHVlIG9uIHRoZSBmbHksIG91ciBvZiB0aGUgZG9tXG4gICAgICAgICAgICAgICAgaWYgKGlzQ29tYm9BdHRyKSB7XG4gICAgICAgICAgICAgICAgICBzZXRJbml0aWFsVmFsdWVGb3JDb21ibyhsYW5lLCBfdGhpcy5pbmNpZGVudHNCeUlkLCBhbmltYXRpb24uZ2V0U2NyYXRjaFZhbHVlKCksIGFuaW1hdGlvbkluZGV4QWZ0ZXJFZGl0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uLnNldEluaXRpYWxWYWx1ZShhbmltYXRpb24uZ2V0U2NyYXRjaFZhbHVlKCkpO1xuICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uLm9uR2V0Q29udGV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gZWxzZSBpZiBpdCBpcyBub3QgdGhlIGZpcnN0IG9uZSBhZnRlciBlZGl0ZFxuICAgICAgICAgICAgICAvLyBqdXN0IGdyYWIgdGhlIHRhcmdldCB2YWx1ZSBvZiB0aGUgcHJldmlvdXMgYW5pbWF0aW9uIG9uIHRoZSB1cGRhdGVkIGxhbmUgYW5kIHNldCBpdCBhcyBpdHMgaW5pdGlhbCB2YWx1ZVxuICAgICAgICAgICAgICBpZiAoaXNDb21ib0F0dHIpIHtcbiAgICAgICAgICAgICAgICBzZXRJbml0aWFsVmFsdWVGb3JDb21ibyhsYW5lLCBfdGhpcy5pbmNpZGVudHNCeUlkLCBfdGhpcy5pbmNpZGVudHNCeUlkLl9nZXQobGFuZVthbmltYXRpb25JbmRleEFmdGVyRWRpdCAtIDFdLmlkKS5hbmltYXRlZEF0dHJpYnV0ZVZhbHVlLCBhbmltYXRpb25JbmRleEFmdGVyRWRpdCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uLnNldEluaXRpYWxWYWx1ZShfdGhpcy5pbmNpZGVudHNCeUlkLl9nZXQobGFuZVthbmltYXRpb25JbmRleEFmdGVyRWRpdCAtIDFdLmlkKS5hbmltYXRlZEF0dHJpYnV0ZVZhbHVlKTtcbiAgICAgICAgICAgICAgICBhbmltYXRpb24ub25HZXRDb250ZXh0KCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gLy8gZm9yIGl0cyBuZXcgbmV4dCBhbmltYXRpb24gKGlmIGl0IGhhcyBvbmUpXG5cblxuICAgICAgICAgICAgaWYgKGFuaW1hdGlvbkluZGV4QWZ0ZXJFZGl0ICsgMSA8IGxhbmUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIC8vIHNldCBpdHMgaW5pdGlhbCB2YWx1ZSB0byBlcXVhbCB0aGUgdGFyZ2V0IHZhbHVlIG9mIHRoZSBlZGl0ZWQgYW5pbWF0aW9uXG4gICAgICAgICAgICAgIGlmIChpc0NvbWJvQXR0cikge1xuICAgICAgICAgICAgICAgIHNldEluaXRpYWxWYWx1ZUZvckNvbWJvKGxhbmUsIF90aGlzLmluY2lkZW50c0J5SWQsIGFuaW1hdGlvbi5hbmltYXRlZEF0dHJpYnV0ZVZhbHVlLCBhbmltYXRpb25JbmRleEFmdGVyRWRpdCArIDEpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIF90aGlzLmluY2lkZW50c0J5SWQuX2dldChsYW5lW2FuaW1hdGlvbkluZGV4QWZ0ZXJFZGl0ICsgMV0uaWQpLnNldEluaXRpYWxWYWx1ZShhbmltYXRpb24uYW5pbWF0ZWRBdHRyaWJ1dGVWYWx1ZSk7XG5cbiAgICAgICAgICAgICAgICBfdGhpcy5pbmNpZGVudHNCeUlkLl9nZXQobGFuZVthbmltYXRpb25JbmRleEFmdGVyRWRpdCArIDFdLmlkKS5vbkdldENvbnRleHQoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBhZmZlY3RlZExhbmUuYW5pbWF0aW9ucy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgICAgX2xvb3AoX2kyKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBlbmQgZm9yIGVhY2ggb2YgdGhlIGJlbG9uZ2luZyBsYW5lcyBvZiB0aGUgYW5pbWF0aW9uXG5cbiAgICB9XG4gICAgLyoqXG4gICAgICogcmVtb3ZlcyB0aGUgbGlzdCBvZiBhbmltYXRpb25zIGFzIHByb3ZpZGVkXG4gICAgICogQHBhcmFtIHthcnJheX0gcmVtb3ZlZEFuaW1hdGlvbnMgLSBhbiBhcnJheSB3aXRoIHRoZSByZW1vdmVkIGFuaW1hdGlvbnMnIGlkc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGVsZXRlQW5pbWF0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWxldGVBbmltYXRpb25zKHJlbW92ZWRBbmltYXRpb25zKSB7XG4gICAgICB2YXIgYWZmZWN0ZWRMYW5lcyA9IHt9O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlbW92ZWRBbmltYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBpZCA9IHJlbW92ZWRBbmltYXRpb25zW2ldOyAvLyBmb3IgZWFjaCBsYW5lIHRoZSBhZmZlY3RlZCBBbmltYXRpb24gYXBwZWFycyBpblxuXG4gICAgICAgIHZhciBiZWxvbmdpbmdMYW5lcyA9IHRoaXMuYmVsb25naW5nTGFuZUtleXNCeUFuaW1hdGlvbklkLl9nZXQoaWQpO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYmVsb25naW5nTGFuZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICB2YXIgbGFuZSA9IHRoaXMubGFuZXMuX2dldChiZWxvbmdpbmdMYW5lc1tqXSk7XG5cbiAgICAgICAgICB2YXIgYW5pbWF0aW9uSW5kZXhCZWZvcmVFZGl0ID0gLTE7XG5cbiAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGxhbmUubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIGlmIChsYW5lW2tdLmlkID09PSBpZCkge1xuICAgICAgICAgICAgICBhbmltYXRpb25JbmRleEJlZm9yZUVkaXQgPSBrO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIGhlbHBlci5sb2coYW5pbWF0aW9uSW5kZXhCZWZvcmVFZGl0KTtcblxuXG4gICAgICAgICAgdmFyIGFuaW1hdGlvblRvRGVsZXRlID0gT2JqZWN0LmFzc2lnbih7fSwgbGFuZVthbmltYXRpb25JbmRleEJlZm9yZUVkaXRdKTtcblxuICAgICAgICAgIHZhciBhbmltYXRpb25PYmplY3RUb0RlbGV0ZSA9IHRoaXMuaW5jaWRlbnRzQnlJZC5fZ2V0KGFuaW1hdGlvblRvRGVsZXRlLmlkKTtcblxuICAgICAgICAgIHZhciBsYW5lRGF0YSA9IGhlbHBlci5nZXRNQ0lEYW5kQXR0ck91dE9mTGFuZUtleShiZWxvbmdpbmdMYW5lc1tqXSk7IC8vIGdldHMgdGhlIGxhbmUgd2l0aG91dCB0aGUgcmVtb3ZlZCBhbmltYXRpb25cblxuICAgICAgICAgIHZhciBuZXdMYW5lID0gW107XG5cbiAgICAgICAgICBmb3IgKHZhciBfayA9IDA7IF9rIDwgbGFuZS5sZW5ndGg7IF9rKyspIHtcbiAgICAgICAgICAgIGlmIChsYW5lW19rXS5pZCAhPSBpZCkge1xuICAgICAgICAgICAgICBuZXdMYW5lLnB1c2gobGFuZVtfa10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMubGFuZXMuX3NldChiZWxvbmdpbmdMYW5lc1tqXSwgbmV3TGFuZSk7XG5cbiAgICAgICAgICBsYW5lID0gdGhpcy5sYW5lcy5fZ2V0KGJlbG9uZ2luZ0xhbmVzW2pdKTtcblxuICAgICAgICAgIGlmIChsYW5lLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gaW4gY2FzZSB0aGVyZSBhcmUgbm8gbW9yZSBhbmltYXRpb25zIG9uIHRoZSBsYW5lIGFueSBtb3JlIHdlIHJlc2V0XG4gICAgICAgICAgICAvLyB0aGUgbGFuZSBieSBydW5uaW5nIHRoZSBwcm9ncmVzcygwLDApLCBzbyB0aGF0IHRoZSBhZmZlY3RlZCBlbGVtZW50c1xuICAgICAgICAgICAgLy8gd2lsbCBnZXQgYmFjayB0byB0aGVpciBvcmlnaW5hbCBhdHRyaWJ1dGUgdmFsdWVcbiAgICAgICAgICAgIGFuaW1hdGlvbk9iamVjdFRvRGVsZXRlLm9uUHJvZ3Jlc3MoMCwgMCk7XG5cbiAgICAgICAgICAgIHRoaXMubGFuZXMuX2RlbGV0ZShiZWxvbmdpbmdMYW5lc1tqXSk7XG5cbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYWZmZWN0ZWRMYW5lcywgYmVsb25naW5nTGFuZXNbal0pKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSBhZmZlY3RlZExhbmVzW2JlbG9uZ2luZ0xhbmVzW2pdXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWZmZWN0ZWRMYW5lc1tiZWxvbmdpbmdMYW5lc1tqXV0gPSBoZWxwZXIuZ2V0TUNJRGFuZEF0dHJPdXRPZkxhbmVLZXkoYmVsb25naW5nTGFuZXNbal0pO1xuXG4gICAgICAgICAgICBpZiAoYW5pbWF0aW9uSW5kZXhCZWZvcmVFZGl0IDwgbGFuZS5sZW5ndGggJiYgdGhpcy5pbmNpZGVudHNCeUlkLl9nZXQoYW5pbWF0aW9uVG9EZWxldGUuaWQpLmdldEluaXRpYWxWYWx1ZSgpICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuY29tYm9BdHRyaWJ1dGVzLCBsYW5lRGF0YS5hdHRyaWJ1dGUpKSB7XG4gICAgICAgICAgICAgICAgc2V0SW5pdGlhbFZhbHVlRm9yQ29tYm8obGFuZSwgdGhpcy5pbmNpZGVudHNCeUlkLCB0aGlzLmluY2lkZW50c0J5SWQuX2dldChhbmltYXRpb25Ub0RlbGV0ZS5pZCkuZ2V0SW5pdGlhbFZhbHVlKCksIGFuaW1hdGlvbkluZGV4QmVmb3JlRWRpdCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmNpZGVudHNCeUlkLl9nZXQobGFuZVthbmltYXRpb25JbmRleEJlZm9yZUVkaXRdLmlkKS5zZXRJbml0aWFsVmFsdWUodGhpcy5pbmNpZGVudHNCeUlkLl9nZXQoYW5pbWF0aW9uVG9EZWxldGUuaWQpLmdldEluaXRpYWxWYWx1ZSgpKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuaW5jaWRlbnRzQnlJZC5fZ2V0KGxhbmVbYW5pbWF0aW9uSW5kZXhCZWZvcmVFZGl0XS5pZCkub25HZXRDb250ZXh0KCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmJlbG9uZ2luZ0xhbmVLZXlzQnlBbmltYXRpb25JZC5fZGVsZXRlKHJlbW92ZWRBbmltYXRpb25zW2ldKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFmZmVjdGVkTGFuZXM7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIExhbmVzSGFuZGxlcjtcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBMYW5lc0hhbmRsZXI7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/_Channels/_Attribute/LanesHandler.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/_Channels/_Attribute/helpers/Collection.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/_Channels/_Attribute/helpers/Collection.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar Collection =\n/*#__PURE__*/\nfunction () {\n  function Collection() {\n    var initialArray = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n    _classCallCheck(this, Collection);\n\n    this.realArray = [];\n\n    if (initialArray != null) {\n      this.realArray = initialArray;\n    }\n  }\n\n  _createClass(Collection, [{\n    key: \"_hasOwnProperty\",\n    value: function _hasOwnProperty(key) {\n      return Object.prototype.hasOwnProperty.call(this.realArray, key);\n    }\n  }, {\n    key: \"_get\",\n    value: function _get(key) {\n      return this.realArray[key];\n    }\n  }, {\n    key: \"_set\",\n    value: function _set(key, value) {\n      this.realArray[key] = value;\n    }\n  }, {\n    key: \"_keys\",\n    value: function _keys() {\n      return Object.keys(this.realArray);\n    }\n  }, {\n    key: \"_delete\",\n    value: function _delete(key) {\n      return delete this.realArray[key];\n    }\n    /**\n     * exports a Collection object\n     */\n\n  }, {\n    key: \"_export\",\n    value: function _export() {\n      return this.realArray;\n    }\n  }]);\n\n  return Collection;\n}();\n\nmodule.exports = Collection;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19DaGFubmVscy9fQXR0cmlidXRlL2hlbHBlcnMvQ29sbGVjdGlvbi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Aa2lzc215YnV0dG9uL21vdG9yY29ydGV4L2Rpc3QvX0NoYW5uZWxzL19BdHRyaWJ1dGUvaGVscGVycy9Db2xsZWN0aW9uLmpzP2UzNzgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxudmFyIENvbGxlY3Rpb24gPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDb2xsZWN0aW9uKCkge1xuICAgIHZhciBpbml0aWFsQXJyYXkgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IG51bGw7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29sbGVjdGlvbik7XG5cbiAgICB0aGlzLnJlYWxBcnJheSA9IFtdO1xuXG4gICAgaWYgKGluaXRpYWxBcnJheSAhPSBudWxsKSB7XG4gICAgICB0aGlzLnJlYWxBcnJheSA9IGluaXRpYWxBcnJheTtcbiAgICB9XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQ29sbGVjdGlvbiwgW3tcbiAgICBrZXk6IFwiX2hhc093blByb3BlcnR5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9oYXNPd25Qcm9wZXJ0eShrZXkpIHtcbiAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5yZWFsQXJyYXksIGtleSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldChrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlYWxBcnJheVtrZXldO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfc2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgdGhpcy5yZWFsQXJyYXlba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfa2V5c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfa2V5cygpIHtcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnJlYWxBcnJheSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9kZWxldGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RlbGV0ZShrZXkpIHtcbiAgICAgIHJldHVybiBkZWxldGUgdGhpcy5yZWFsQXJyYXlba2V5XTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogZXhwb3J0cyBhIENvbGxlY3Rpb24gb2JqZWN0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZXhwb3J0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9leHBvcnQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWFsQXJyYXk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENvbGxlY3Rpb247XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ29sbGVjdGlvbjsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/_Channels/_Attribute/helpers/Collection.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/_Channels/_Attribute/helpers/ComboAttrsCascading.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/_Channels/_Attribute/helpers/ComboAttrsCascading.js ***!
  \*********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/*\nlane:\n     * [\n     *      {\n     *          id: the id of the Incident\n     *          millisecond: the millisecond of the channel this Animation (that affects the selector/attribute pair) runs\n     *      }\n     *  ]\n*/\nfunction updateFinalValues(initialValues, originalFinalValues, finalValues) {\n  // console.log(initialValues, originalFinalValues);\n  var change = false;\n\n  for (var key in initialValues) {\n    if (!Object.prototype.hasOwnProperty.call(originalFinalValues, key)) {\n      change = true;\n      finalValues[key] = initialValues[key];\n    }\n  }\n\n  return change;\n}\n/**\n * This function takes as input the index of the affected incident on the lane,\n * the lane and it re-calculates the\n * initial and final values of all the following incidents in the lane.\n * The function is used only in cases of combo attributes\n **/\n\n\nfunction setInitialValue(lane, incidentsById, newInitialValues, affectedIndex) {\n  var affectedItem = lane[affectedIndex];\n\n  var affectedIncident = incidentsById._get(affectedItem.id);\n\n  affectedIncident.setInitialValue(newInitialValues);\n  var change = updateFinalValues(affectedIncident.getInitialValue(), affectedIncident.originalAnimatedAttributeValue, affectedIncident.animatedAttributeValue); // if the final values have changed according to the new initial values and there is\n  // a following incident on the lane\n\n  if (change && affectedIndex < lane.length - 1) {\n    affectedIncident.lastWish();\n    affectedIncident.onGetContext();\n    setInitialValue(lane, incidentsById, affectedIncident.animatedAttributeValue, affectedIndex + 1);\n  }\n}\n\nmodule.exports = setInitialValue;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19DaGFubmVscy9fQXR0cmlidXRlL2hlbHBlcnMvQ29tYm9BdHRyc0Nhc2NhZGluZy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Aa2lzc215YnV0dG9uL21vdG9yY29ydGV4L2Rpc3QvX0NoYW5uZWxzL19BdHRyaWJ1dGUvaGVscGVycy9Db21ib0F0dHJzQ2FzY2FkaW5nLmpzPzE5NDYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qXG5sYW5lOlxuICAgICAqIFtcbiAgICAgKiAgICAgIHtcbiAgICAgKiAgICAgICAgICBpZDogdGhlIGlkIG9mIHRoZSBJbmNpZGVudFxuICAgICAqICAgICAgICAgIG1pbGxpc2Vjb25kOiB0aGUgbWlsbGlzZWNvbmQgb2YgdGhlIGNoYW5uZWwgdGhpcyBBbmltYXRpb24gKHRoYXQgYWZmZWN0cyB0aGUgc2VsZWN0b3IvYXR0cmlidXRlIHBhaXIpIHJ1bnNcbiAgICAgKiAgICAgIH1cbiAgICAgKiAgXVxuKi9cbmZ1bmN0aW9uIHVwZGF0ZUZpbmFsVmFsdWVzKGluaXRpYWxWYWx1ZXMsIG9yaWdpbmFsRmluYWxWYWx1ZXMsIGZpbmFsVmFsdWVzKSB7XG4gIC8vIGNvbnNvbGUubG9nKGluaXRpYWxWYWx1ZXMsIG9yaWdpbmFsRmluYWxWYWx1ZXMpO1xuICB2YXIgY2hhbmdlID0gZmFsc2U7XG5cbiAgZm9yICh2YXIga2V5IGluIGluaXRpYWxWYWx1ZXMpIHtcbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcmlnaW5hbEZpbmFsVmFsdWVzLCBrZXkpKSB7XG4gICAgICBjaGFuZ2UgPSB0cnVlO1xuICAgICAgZmluYWxWYWx1ZXNba2V5XSA9IGluaXRpYWxWYWx1ZXNba2V5XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2hhbmdlO1xufVxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIHRha2VzIGFzIGlucHV0IHRoZSBpbmRleCBvZiB0aGUgYWZmZWN0ZWQgaW5jaWRlbnQgb24gdGhlIGxhbmUsXG4gKiB0aGUgbGFuZSBhbmQgaXQgcmUtY2FsY3VsYXRlcyB0aGVcbiAqIGluaXRpYWwgYW5kIGZpbmFsIHZhbHVlcyBvZiBhbGwgdGhlIGZvbGxvd2luZyBpbmNpZGVudHMgaW4gdGhlIGxhbmUuXG4gKiBUaGUgZnVuY3Rpb24gaXMgdXNlZCBvbmx5IGluIGNhc2VzIG9mIGNvbWJvIGF0dHJpYnV0ZXNcbiAqKi9cblxuXG5mdW5jdGlvbiBzZXRJbml0aWFsVmFsdWUobGFuZSwgaW5jaWRlbnRzQnlJZCwgbmV3SW5pdGlhbFZhbHVlcywgYWZmZWN0ZWRJbmRleCkge1xuICB2YXIgYWZmZWN0ZWRJdGVtID0gbGFuZVthZmZlY3RlZEluZGV4XTtcblxuICB2YXIgYWZmZWN0ZWRJbmNpZGVudCA9IGluY2lkZW50c0J5SWQuX2dldChhZmZlY3RlZEl0ZW0uaWQpO1xuXG4gIGFmZmVjdGVkSW5jaWRlbnQuc2V0SW5pdGlhbFZhbHVlKG5ld0luaXRpYWxWYWx1ZXMpO1xuICB2YXIgY2hhbmdlID0gdXBkYXRlRmluYWxWYWx1ZXMoYWZmZWN0ZWRJbmNpZGVudC5nZXRJbml0aWFsVmFsdWUoKSwgYWZmZWN0ZWRJbmNpZGVudC5vcmlnaW5hbEFuaW1hdGVkQXR0cmlidXRlVmFsdWUsIGFmZmVjdGVkSW5jaWRlbnQuYW5pbWF0ZWRBdHRyaWJ1dGVWYWx1ZSk7IC8vIGlmIHRoZSBmaW5hbCB2YWx1ZXMgaGF2ZSBjaGFuZ2VkIGFjY29yZGluZyB0byB0aGUgbmV3IGluaXRpYWwgdmFsdWVzIGFuZCB0aGVyZSBpc1xuICAvLyBhIGZvbGxvd2luZyBpbmNpZGVudCBvbiB0aGUgbGFuZVxuXG4gIGlmIChjaGFuZ2UgJiYgYWZmZWN0ZWRJbmRleCA8IGxhbmUubGVuZ3RoIC0gMSkge1xuICAgIGFmZmVjdGVkSW5jaWRlbnQubGFzdFdpc2goKTtcbiAgICBhZmZlY3RlZEluY2lkZW50Lm9uR2V0Q29udGV4dCgpO1xuICAgIHNldEluaXRpYWxWYWx1ZShsYW5lLCBpbmNpZGVudHNCeUlkLCBhZmZlY3RlZEluY2lkZW50LmFuaW1hdGVkQXR0cmlidXRlVmFsdWUsIGFmZmVjdGVkSW5kZXggKyAxKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldEluaXRpYWxWYWx1ZTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/_Channels/_Attribute/helpers/ComboAttrsCascading.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/_Channels/_Attribute/helpers/SandboxCollection.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/_Channels/_Attribute/helpers/SandboxCollection.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * The goal of this class is to get an original array, provide all the functionality\n * of the Collection class but by keeping the originalArray clean as it was provided.\n */\nvar SandboxCollection =\n/*#__PURE__*/\nfunction () {\n  function SandboxCollection(originalArray) {\n    _classCallCheck(this, SandboxCollection);\n\n    this.originalArray = originalArray;\n    this.extraArray = {};\n    this.addedKeys = [];\n    this.removedKeys = [];\n  }\n\n  _createClass(SandboxCollection, [{\n    key: \"_hasOwnProperty\",\n    value: function _hasOwnProperty(key) {\n      return Object.prototype.hasOwnProperty.call(this.originalArray, key) || Object.prototype.hasOwnProperty.call(this.extraArray, key);\n    }\n  }, {\n    key: \"_get\",\n    value: function _get(key) {\n      if (Object.prototype.hasOwnProperty.call(this.extraArray, key)) {\n        return this.extraArray[key];\n      } else if (!Object.prototype.hasOwnProperty.call(this.originalArray, key)) {\n        return undefined;\n      } else {\n        this.extraArray[key] = Object.assign({}, this.originalArray[key]);\n        return this.extraArray[key];\n      }\n    }\n  }, {\n    key: \"_set\",\n    value: function _set(key, value) {\n      this.extraArray[key] = value;\n\n      if (!Object.prototype.hasOwnProperty.call(this.originalArray, key)) {\n        this.addedKeys.push(key);\n      }\n\n      var indexOnRemovedKeys = this.removedKeys.indexOf(key);\n\n      if (indexOnRemovedKeys > -1) {\n        this.removedKeys.splice(indexOnRemovedKeys, 1);\n      }\n    }\n  }, {\n    key: \"_keys\",\n    value: function _keys() {\n      var allKeys = Object.keys(this.originalArray).concat(this.addedKeys);\n\n      for (var i = 0; i < this.removedKeys.length; i++) {\n        var indexOnArray = this.removedKeys.indexOf(this.removedKeys[i]);\n        allKeys.splice(indexOnArray, 1);\n      }\n\n      return allKeys;\n    }\n  }, {\n    key: \"_delete\",\n    value: function _delete(key) {\n      var indexOnAddedKeys = this.addedKeys.indexOf(key);\n\n      if (indexOnAddedKeys > -1) {\n        this.addedKeys.splice(indexOnAddedKeys);\n        return delete this.extraArray[key];\n      } else {\n        return this.removedKeys.push(key);\n      }\n    }\n  }, {\n    key: \"_export\",\n    value: function _export() {\n      for (var key in this.extraArray) {\n        this.originalArray[key] = this.extraArray[key];\n      }\n\n      for (var i = 0; i < this.removedKeys.length; i++) {\n        delete this.originalArray[this.removedKeys[i]];\n      }\n\n      return this.originalArray;\n    }\n  }]);\n\n  return SandboxCollection;\n}();\n\nmodule.exports = SandboxCollection;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19DaGFubmVscy9fQXR0cmlidXRlL2hlbHBlcnMvU2FuZGJveENvbGxlY3Rpb24uanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19DaGFubmVscy9fQXR0cmlidXRlL2hlbHBlcnMvU2FuZGJveENvbGxlY3Rpb24uanM/ZWU4YiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG4vKipcbiAqIFRoZSBnb2FsIG9mIHRoaXMgY2xhc3MgaXMgdG8gZ2V0IGFuIG9yaWdpbmFsIGFycmF5LCBwcm92aWRlIGFsbCB0aGUgZnVuY3Rpb25hbGl0eVxuICogb2YgdGhlIENvbGxlY3Rpb24gY2xhc3MgYnV0IGJ5IGtlZXBpbmcgdGhlIG9yaWdpbmFsQXJyYXkgY2xlYW4gYXMgaXQgd2FzIHByb3ZpZGVkLlxuICovXG52YXIgU2FuZGJveENvbGxlY3Rpb24gPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTYW5kYm94Q29sbGVjdGlvbihvcmlnaW5hbEFycmF5KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNhbmRib3hDb2xsZWN0aW9uKTtcblxuICAgIHRoaXMub3JpZ2luYWxBcnJheSA9IG9yaWdpbmFsQXJyYXk7XG4gICAgdGhpcy5leHRyYUFycmF5ID0ge307XG4gICAgdGhpcy5hZGRlZEtleXMgPSBbXTtcbiAgICB0aGlzLnJlbW92ZWRLZXlzID0gW107XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoU2FuZGJveENvbGxlY3Rpb24sIFt7XG4gICAga2V5OiBcIl9oYXNPd25Qcm9wZXJ0eVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFzT3duUHJvcGVydHkoa2V5KSB7XG4gICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMub3JpZ2luYWxBcnJheSwga2V5KSB8fCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5leHRyYUFycmF5LCBrZXkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXQoa2V5KSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuZXh0cmFBcnJheSwga2V5KSkge1xuICAgICAgICByZXR1cm4gdGhpcy5leHRyYUFycmF5W2tleV07XG4gICAgICB9IGVsc2UgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5vcmlnaW5hbEFycmF5LCBrZXkpKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmV4dHJhQXJyYXlba2V5XSA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMub3JpZ2luYWxBcnJheVtrZXldKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXh0cmFBcnJheVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfc2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgdGhpcy5leHRyYUFycmF5W2tleV0gPSB2YWx1ZTtcblxuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5vcmlnaW5hbEFycmF5LCBrZXkpKSB7XG4gICAgICAgIHRoaXMuYWRkZWRLZXlzLnB1c2goa2V5KTtcbiAgICAgIH1cblxuICAgICAgdmFyIGluZGV4T25SZW1vdmVkS2V5cyA9IHRoaXMucmVtb3ZlZEtleXMuaW5kZXhPZihrZXkpO1xuXG4gICAgICBpZiAoaW5kZXhPblJlbW92ZWRLZXlzID4gLTEpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVkS2V5cy5zcGxpY2UoaW5kZXhPblJlbW92ZWRLZXlzLCAxKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2tleXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2tleXMoKSB7XG4gICAgICB2YXIgYWxsS2V5cyA9IE9iamVjdC5rZXlzKHRoaXMub3JpZ2luYWxBcnJheSkuY29uY2F0KHRoaXMuYWRkZWRLZXlzKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJlbW92ZWRLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBpbmRleE9uQXJyYXkgPSB0aGlzLnJlbW92ZWRLZXlzLmluZGV4T2YodGhpcy5yZW1vdmVkS2V5c1tpXSk7XG4gICAgICAgIGFsbEtleXMuc3BsaWNlKGluZGV4T25BcnJheSwgMSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhbGxLZXlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZGVsZXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZWxldGUoa2V5KSB7XG4gICAgICB2YXIgaW5kZXhPbkFkZGVkS2V5cyA9IHRoaXMuYWRkZWRLZXlzLmluZGV4T2Yoa2V5KTtcblxuICAgICAgaWYgKGluZGV4T25BZGRlZEtleXMgPiAtMSkge1xuICAgICAgICB0aGlzLmFkZGVkS2V5cy5zcGxpY2UoaW5kZXhPbkFkZGVkS2V5cyk7XG4gICAgICAgIHJldHVybiBkZWxldGUgdGhpcy5leHRyYUFycmF5W2tleV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmVkS2V5cy5wdXNoKGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9leHBvcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2V4cG9ydCgpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmV4dHJhQXJyYXkpIHtcbiAgICAgICAgdGhpcy5vcmlnaW5hbEFycmF5W2tleV0gPSB0aGlzLmV4dHJhQXJyYXlba2V5XTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJlbW92ZWRLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLm9yaWdpbmFsQXJyYXlbdGhpcy5yZW1vdmVkS2V5c1tpXV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLm9yaWdpbmFsQXJyYXk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFNhbmRib3hDb2xsZWN0aW9uO1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNhbmRib3hDb2xsZWN0aW9uOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/_Channels/_Attribute/helpers/SandboxCollection.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/_Channels/_Attribute/helpers/SandboxIncidentsById.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/_Channels/_Attribute/helpers/SandboxIncidentsById.js ***!
  \**********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar SandboxCollection = __webpack_require__(/*! ./SandboxCollection */ \"./node_modules/@kissmybutton/motorcortex/dist/_Channels/_Attribute/helpers/SandboxCollection.js\");\n\nvar SandboxIncidentsById =\n/*#__PURE__*/\nfunction (_SandboxCollection) {\n  _inherits(SandboxIncidentsById, _SandboxCollection);\n\n  function SandboxIncidentsById() {\n    _classCallCheck(this, SandboxIncidentsById);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(SandboxIncidentsById).apply(this, arguments));\n  }\n\n  _createClass(SandboxIncidentsById, [{\n    key: \"_get\",\n    value: function _get(key) {\n      if (Object.prototype.hasOwnProperty.call(this.extraArray, key)) {\n        return this.extraArray[key];\n      } else if (!Object.prototype.hasOwnProperty.call(this.originalArray, key)) {\n        return undefined;\n      } else {\n        return this.originalArray[key];\n      }\n    }\n  }]);\n\n  return SandboxIncidentsById;\n}(SandboxCollection);\n\nmodule.exports = SandboxIncidentsById;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19DaGFubmVscy9fQXR0cmlidXRlL2hlbHBlcnMvU2FuZGJveEluY2lkZW50c0J5SWQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19DaGFubmVscy9fQXR0cmlidXRlL2hlbHBlcnMvU2FuZGJveEluY2lkZW50c0J5SWQuanM/NjU2MSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbnZhciBTYW5kYm94Q29sbGVjdGlvbiA9IHJlcXVpcmUoJy4vU2FuZGJveENvbGxlY3Rpb24nKTtcblxudmFyIFNhbmRib3hJbmNpZGVudHNCeUlkID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfU2FuZGJveENvbGxlY3Rpb24pIHtcbiAgX2luaGVyaXRzKFNhbmRib3hJbmNpZGVudHNCeUlkLCBfU2FuZGJveENvbGxlY3Rpb24pO1xuXG4gIGZ1bmN0aW9uIFNhbmRib3hJbmNpZGVudHNCeUlkKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTYW5kYm94SW5jaWRlbnRzQnlJZCk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKFNhbmRib3hJbmNpZGVudHNCeUlkKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhTYW5kYm94SW5jaWRlbnRzQnlJZCwgW3tcbiAgICBrZXk6IFwiX2dldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0KGtleSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmV4dHJhQXJyYXksIGtleSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXh0cmFBcnJheVtrZXldO1xuICAgICAgfSBlbHNlIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMub3JpZ2luYWxBcnJheSwga2V5KSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3JpZ2luYWxBcnJheVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTYW5kYm94SW5jaWRlbnRzQnlJZDtcbn0oU2FuZGJveENvbGxlY3Rpb24pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNhbmRib3hJbmNpZGVudHNCeUlkOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/_Channels/_Attribute/helpers/SandboxIncidentsById.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/_Channels/_Attribute/helpers/SandboxLanes.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/_Channels/_Attribute/helpers/SandboxLanes.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar SandboxCollection = __webpack_require__(/*! ./SandboxCollection */ \"./node_modules/@kissmybutton/motorcortex/dist/_Channels/_Attribute/helpers/SandboxCollection.js\");\n\nvar SandboxLanes =\n/*#__PURE__*/\nfunction (_SandboxCollection) {\n  _inherits(SandboxLanes, _SandboxCollection);\n\n  function SandboxLanes() {\n    _classCallCheck(this, SandboxLanes);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(SandboxLanes).apply(this, arguments));\n  }\n\n  _createClass(SandboxLanes, [{\n    key: \"_get\",\n    value: function _get(key) {\n      if (Object.prototype.hasOwnProperty.call(this.extraArray, key)) {\n        return this.extraArray[key];\n      } else if (!Object.prototype.hasOwnProperty.call(this.originalArray, key)) {\n        return undefined;\n      } else {\n        this.extraArray[key] = [];\n\n        for (var i = 0; i < this.originalArray[key].length; i++) {\n          this.extraArray[key].push({\n            id: this.originalArray[key][i].id,\n            // incident: this.originalArray[key][i].incident,\n            millisecond: this.originalArray[key][i].millisecond * 1\n          });\n        }\n\n        return this.extraArray[key];\n      }\n    }\n  }]);\n\n  return SandboxLanes;\n}(SandboxCollection);\n\nmodule.exports = SandboxLanes;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19DaGFubmVscy9fQXR0cmlidXRlL2hlbHBlcnMvU2FuZGJveExhbmVzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvZGlzdC9fQ2hhbm5lbHMvX0F0dHJpYnV0ZS9oZWxwZXJzL1NhbmRib3hMYW5lcy5qcz9lZGM4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxudmFyIFNhbmRib3hDb2xsZWN0aW9uID0gcmVxdWlyZSgnLi9TYW5kYm94Q29sbGVjdGlvbicpO1xuXG52YXIgU2FuZGJveExhbmVzID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfU2FuZGJveENvbGxlY3Rpb24pIHtcbiAgX2luaGVyaXRzKFNhbmRib3hMYW5lcywgX1NhbmRib3hDb2xsZWN0aW9uKTtcblxuICBmdW5jdGlvbiBTYW5kYm94TGFuZXMoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNhbmRib3hMYW5lcyk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKFNhbmRib3hMYW5lcykuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoU2FuZGJveExhbmVzLCBbe1xuICAgIGtleTogXCJfZ2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXQoa2V5KSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuZXh0cmFBcnJheSwga2V5KSkge1xuICAgICAgICByZXR1cm4gdGhpcy5leHRyYUFycmF5W2tleV07XG4gICAgICB9IGVsc2UgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5vcmlnaW5hbEFycmF5LCBrZXkpKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmV4dHJhQXJyYXlba2V5XSA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5vcmlnaW5hbEFycmF5W2tleV0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0aGlzLmV4dHJhQXJyYXlba2V5XS5wdXNoKHtcbiAgICAgICAgICAgIGlkOiB0aGlzLm9yaWdpbmFsQXJyYXlba2V5XVtpXS5pZCxcbiAgICAgICAgICAgIC8vIGluY2lkZW50OiB0aGlzLm9yaWdpbmFsQXJyYXlba2V5XVtpXS5pbmNpZGVudCxcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kOiB0aGlzLm9yaWdpbmFsQXJyYXlba2V5XVtpXS5taWxsaXNlY29uZCAqIDFcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmV4dHJhQXJyYXlba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU2FuZGJveExhbmVzO1xufShTYW5kYm94Q29sbGVjdGlvbik7XG5cbm1vZHVsZS5leHBvcnRzID0gU2FuZGJveExhbmVzOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/_Channels/_Attribute/helpers/SandboxLanes.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/_Channels/_Clip/ClipsChannel.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/_Channels/_Clip/ClipsChannel.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar Helper = __webpack_require__(/*! ../../_coreUtils/Helper */ \"./node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\");\n\nvar helper = new Helper();\n\nvar Channel = __webpack_require__(/*! ../Channel */ \"./node_modules/@kissmybutton/motorcortex/dist/_Channels/Channel.js\");\n\nvar _sortBy = __webpack_require__(/*! ../../../lodash-custom-build/modularize/lodash.sortby/index.js */ \"./node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.sortby/index.js\");\n\nvar _filter = __webpack_require__(/*! ../../../lodash-custom-build/modularize/lodash.filter/index.js */ \"./node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.filter/index.js\");\n\nvar ClipChannel =\n/*#__PURE__*/\nfunction (_Channel) {\n  _inherits(ClipChannel, _Channel);\n\n  function ClipChannel() {\n    _classCallCheck(this, ClipChannel);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(ClipChannel).apply(this, arguments));\n  }\n\n  _createClass(ClipChannel, [{\n    key: \"onInitialise\",\n\n    /*\n    this.incidents is a collection of {incident, id, millisecond} objects always kept in order\n        from lower to higher millisecond\n    this.incidetnsById is an index of the incidents kept by id (this.incidents[incident-id] = Incident)\n    */\n    value: function onInitialise() {\n      this.runTimeInfo = {\n        currentMillisecond: 0\n      };\n      this.incidents = [];\n      this.incidentsById = {};\n    }\n  }, {\n    key: \"_incidentById\",\n    value: function _incidentById(id) {\n      return this.incidentsById[id];\n    }\n  }, {\n    key: \"_resize\",\n    value: function _resize(durationFraction) {\n      for (var i = 0; i < this.incidents.length; i++) {\n        this.incidents[i].millisecond = this.incidents[i].millisecond * durationFraction;\n      }\n    }\n    /**\n    * @param {array} incidents - a colleciton of all incidents to be added on the form:\n    *\n        {\n            id\n            millisecond\n            incident\n        }\n    * @returns {object} -\n    * either:\n        {\n            result:true,\n            execute: // a function that when executed it will add the Incidents on the Channels\n        }\n        or\n        {\n            result: false,\n            errors\n        }\n    */\n\n  }, {\n    key: \"checkAddition\",\n    value: function checkAddition(incidents) {\n      var errors = [];\n      var candidateIncidentsById = {};\n      var incidentsToConcat = [];\n\n      for (var i = 0; i < incidents.length; i++) {\n        candidateIncidentsById[incidents[i].id] = incidents[i].incident;\n        incidentsToConcat.push({\n          id: incidents[i].id,\n          millisecond: incidents[i].millisecond\n        });\n\n        if (Object.prototype.hasOwnProperty.call(this.incidentsById, incidents[i].id)) {\n          helper.error(\"Incident with the id \".concat(incidents[i].id, \" already exists. Addition is rejected.\"));\n          errors.push({\n            type: 'Already existing id',\n            meta: {\n              id: incidents[i].id\n            }\n          });\n        }\n      }\n\n      if (errors.length > 0) {\n        return {\n          result: false,\n          errors: errors\n        };\n      }\n\n      var that = this;\n\n      var exec = function exec() {\n        that.incidentsById = Object.assign(that.incidentsById, candidateIncidentsById);\n        that.incidents = that.incidents.concat(incidentsToConcat);\n        that.incidents = _sortBy(that.incidents, [function (laneItem) {\n          return laneItem.millisecond;\n        }]);\n\n        for (var _i = 0; _i < incidents.length; _i++) {\n          that._incidentById(incidents[_i].id)._onGetContextOnce();\n        }\n      };\n\n      return {\n        result: true,\n        execute: exec\n      };\n    }\n    /**\n    @param {array} incidentsArray - A collection of the Incidetns to get edited in the form:\n    {\n        id\n        millisecond\n        incident\n    }\n    @param {int} millisecondsDelta- the delta of the star point of the provided incidents\n    */\n\n  }, {\n    key: \"checkEdit\",\n    value: function checkEdit(incidentsArray, millisecondsDelta) {\n      var that = this;\n\n      var exec = function exec() {\n        for (var i = 0; i < incidentsArray.length; i++) {\n          for (var j = 0; j < that.incidents.length; j++) {\n            if (that.incidents[j].id === incidentsArray[i].id) {\n              that.incidents[j].millisecond += millisecondsDelta;\n              break;\n            }\n          }\n        }\n\n        that.incidents = _sortBy(that.incidents, [function (laneItem) {\n          return laneItem.millisecond;\n        }]);\n      };\n\n      return {\n        result: true,\n        execute: exec\n      };\n    }\n  }, {\n    key: \"checkDelete\",\n    value: function checkDelete(incidentsArray) {\n      var that = this;\n      var incidentIds = [];\n\n      for (var i = 0; i < incidentsArray.length; i++) {\n        incidentIds.push(incidentsArray[i].id);\n      }\n\n      var exec = function exec() {\n        var newIncidents = _filter(that.incidents, function (incident) {\n          return incidentIds.indexOf(incident.id) === -1;\n        });\n\n        that.incidents = newIncidents;\n\n        for (var _i2 = 0; _i2 < incidentIds.length; _i2++) {\n          delete that.incidentsById[incidentIds[_i2]];\n        }\n      };\n\n      return {\n        result: true,\n        execute: exec\n      };\n    }\n    /**\n     * @param {array} incidents - [{id, start, end, startDelta}]\n     */\n\n  }, {\n    key: \"checkResizedIncidents\",\n    value: function checkResizedIncidents(incidents) {\n      var that = this;\n\n      var exec = function exec() {\n        for (var i = 0; i < incidents.length; i++) {\n          for (var j = 0; j < that.incidents.length; j++) {\n            if (that.incidents[j].id === incidents[i].id) {\n              that.incidents[j].millisecond += incidents[i].startDelta;\n              break;\n            }\n          }\n        }\n\n        that.incidents = _sortBy(that.incidents, [function (laneItem) {\n          return laneItem.millisecond;\n        }]);\n      };\n\n      return {\n        result: true,\n        execute: exec\n      };\n    }\n    /**\n     @param {int} from - the millisecond to start from\n     @param {int} to - the millisecond to go to\n     @param {string} contextId - the context id to move\n     @param {boolean} forceReset - set to true when we want full flash\n     */\n\n  }, {\n    key: \"moveTo\",\n    value: function moveTo(from, to, contextId) {\n      var forceReset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n      if (forceReset === true) {\n        // incidents: [{id, millisecond}, {}, {}...]\n        for (var i = 0; i < this.incidents.length; i++) {\n          var laneItem = this.incidents[i];\n\n          var incident = this._incidentById(laneItem.id);\n\n          if (to < laneItem.millisecond) {\n            incident.onProgress(0, 0, contextId, true);\n          } else if (to > laneItem.millisecond + incident.duration) {\n            incident.onProgress(1, incident.duration, contextId, true);\n          } else {\n            incident.onProgress((to - laneItem.millisecond) / incident.duration, to - laneItem.millisecond, contextId, true);\n          }\n        }\n      } else {\n        var that = this;\n\n        var participatingItems = _filter(this.incidents, function (laneItem) {\n          return laneItem.millisecond + that._incidentById(laneItem.id).duration >= from && laneItem.millisecond + that._incidentById(laneItem.id).duration <= to || // it ends after from and before to millisecond\n          that._incidentById(laneItem.id).duration + laneItem.millisecond >= to && laneItem.millisecond <= to; // or it ends after the target millisecond but also starts before it\n        });\n\n        for (var _i3 = 0; _i3 < participatingItems.length; _i3++) {\n          var _laneItem = participatingItems[_i3];\n\n          var contextAwareClipIncident = this._incidentById(_laneItem.id); // onProgress(fraction, milliseconds, contextId, forceReset = false) {\n\n\n          var overcameEnd = (to - _laneItem.millisecond) / contextAwareClipIncident.duration >= 1;\n          var fraction = overcameEnd ? 1 : (to - _laneItem.millisecond) / contextAwareClipIncident.duration;\n          var millisecond = overcameEnd ? contextAwareClipIncident.duration : to - _laneItem.millisecond;\n          contextAwareClipIncident.onProgress(fraction, millisecond, contextId, false);\n        }\n      }\n    }\n  }]);\n\n  return ClipChannel;\n}(Channel);\n\nmodule.exports = ClipChannel;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19DaGFubmVscy9fQ2xpcC9DbGlwc0NoYW5uZWwuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19DaGFubmVscy9fQ2xpcC9DbGlwc0NoYW5uZWwuanM/MDQ1YyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbnZhciBIZWxwZXIgPSByZXF1aXJlKCcuLi8uLi9fY29yZVV0aWxzL0hlbHBlcicpO1xuXG52YXIgaGVscGVyID0gbmV3IEhlbHBlcigpO1xuXG52YXIgQ2hhbm5lbCA9IHJlcXVpcmUoJy4uL0NoYW5uZWwnKTtcblxudmFyIF9zb3J0QnkgPSByZXF1aXJlKCcuLi8uLi8uLi9sb2Rhc2gtY3VzdG9tLWJ1aWxkL21vZHVsYXJpemUvbG9kYXNoLnNvcnRieS9pbmRleC5qcycpO1xuXG52YXIgX2ZpbHRlciA9IHJlcXVpcmUoJy4uLy4uLy4uL2xvZGFzaC1jdXN0b20tYnVpbGQvbW9kdWxhcml6ZS9sb2Rhc2guZmlsdGVyL2luZGV4LmpzJyk7XG5cbnZhciBDbGlwQ2hhbm5lbCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0NoYW5uZWwpIHtcbiAgX2luaGVyaXRzKENsaXBDaGFubmVsLCBfQ2hhbm5lbCk7XG5cbiAgZnVuY3Rpb24gQ2xpcENoYW5uZWwoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENsaXBDaGFubmVsKTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoQ2xpcENoYW5uZWwpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKENsaXBDaGFubmVsLCBbe1xuICAgIGtleTogXCJvbkluaXRpYWxpc2VcIixcblxuICAgIC8qXG4gICAgdGhpcy5pbmNpZGVudHMgaXMgYSBjb2xsZWN0aW9uIG9mIHtpbmNpZGVudCwgaWQsIG1pbGxpc2Vjb25kfSBvYmplY3RzIGFsd2F5cyBrZXB0IGluIG9yZGVyXG4gICAgICAgIGZyb20gbG93ZXIgdG8gaGlnaGVyIG1pbGxpc2Vjb25kXG4gICAgdGhpcy5pbmNpZGV0bnNCeUlkIGlzIGFuIGluZGV4IG9mIHRoZSBpbmNpZGVudHMga2VwdCBieSBpZCAodGhpcy5pbmNpZGVudHNbaW5jaWRlbnQtaWRdID0gSW5jaWRlbnQpXG4gICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gb25Jbml0aWFsaXNlKCkge1xuICAgICAgdGhpcy5ydW5UaW1lSW5mbyA9IHtcbiAgICAgICAgY3VycmVudE1pbGxpc2Vjb25kOiAwXG4gICAgICB9O1xuICAgICAgdGhpcy5pbmNpZGVudHMgPSBbXTtcbiAgICAgIHRoaXMuaW5jaWRlbnRzQnlJZCA9IHt9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfaW5jaWRlbnRCeUlkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbmNpZGVudEJ5SWQoaWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmluY2lkZW50c0J5SWRbaWRdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfcmVzaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZXNpemUoZHVyYXRpb25GcmFjdGlvbikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmluY2lkZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLmluY2lkZW50c1tpXS5taWxsaXNlY29uZCA9IHRoaXMuaW5jaWRlbnRzW2ldLm1pbGxpc2Vjb25kICogZHVyYXRpb25GcmFjdGlvbjtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge2FycmF5fSBpbmNpZGVudHMgLSBhIGNvbGxlY2l0b24gb2YgYWxsIGluY2lkZW50cyB0byBiZSBhZGRlZCBvbiB0aGUgZm9ybTpcbiAgICAqXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlkXG4gICAgICAgICAgICBtaWxsaXNlY29uZFxuICAgICAgICAgICAgaW5jaWRlbnRcbiAgICAgICAgfVxuICAgICogQHJldHVybnMge29iamVjdH0gLVxuICAgICogZWl0aGVyOlxuICAgICAgICB7XG4gICAgICAgICAgICByZXN1bHQ6dHJ1ZSxcbiAgICAgICAgICAgIGV4ZWN1dGU6IC8vIGEgZnVuY3Rpb24gdGhhdCB3aGVuIGV4ZWN1dGVkIGl0IHdpbGwgYWRkIHRoZSBJbmNpZGVudHMgb24gdGhlIENoYW5uZWxzXG4gICAgICAgIH1cbiAgICAgICAgb3JcbiAgICAgICAge1xuICAgICAgICAgICAgcmVzdWx0OiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yc1xuICAgICAgICB9XG4gICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNoZWNrQWRkaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tBZGRpdGlvbihpbmNpZGVudHMpIHtcbiAgICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICAgIHZhciBjYW5kaWRhdGVJbmNpZGVudHNCeUlkID0ge307XG4gICAgICB2YXIgaW5jaWRlbnRzVG9Db25jYXQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmNpZGVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2FuZGlkYXRlSW5jaWRlbnRzQnlJZFtpbmNpZGVudHNbaV0uaWRdID0gaW5jaWRlbnRzW2ldLmluY2lkZW50O1xuICAgICAgICBpbmNpZGVudHNUb0NvbmNhdC5wdXNoKHtcbiAgICAgICAgICBpZDogaW5jaWRlbnRzW2ldLmlkLFxuICAgICAgICAgIG1pbGxpc2Vjb25kOiBpbmNpZGVudHNbaV0ubWlsbGlzZWNvbmRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmluY2lkZW50c0J5SWQsIGluY2lkZW50c1tpXS5pZCkpIHtcbiAgICAgICAgICBoZWxwZXIuZXJyb3IoXCJJbmNpZGVudCB3aXRoIHRoZSBpZCBcIi5jb25jYXQoaW5jaWRlbnRzW2ldLmlkLCBcIiBhbHJlYWR5IGV4aXN0cy4gQWRkaXRpb24gaXMgcmVqZWN0ZWQuXCIpKTtcbiAgICAgICAgICBlcnJvcnMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAnQWxyZWFkeSBleGlzdGluZyBpZCcsXG4gICAgICAgICAgICBtZXRhOiB7XG4gICAgICAgICAgICAgIGlkOiBpbmNpZGVudHNbaV0uaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZXN1bHQ6IGZhbHNlLFxuICAgICAgICAgIGVycm9yczogZXJyb3JzXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgdmFyIGV4ZWMgPSBmdW5jdGlvbiBleGVjKCkge1xuICAgICAgICB0aGF0LmluY2lkZW50c0J5SWQgPSBPYmplY3QuYXNzaWduKHRoYXQuaW5jaWRlbnRzQnlJZCwgY2FuZGlkYXRlSW5jaWRlbnRzQnlJZCk7XG4gICAgICAgIHRoYXQuaW5jaWRlbnRzID0gdGhhdC5pbmNpZGVudHMuY29uY2F0KGluY2lkZW50c1RvQ29uY2F0KTtcbiAgICAgICAgdGhhdC5pbmNpZGVudHMgPSBfc29ydEJ5KHRoYXQuaW5jaWRlbnRzLCBbZnVuY3Rpb24gKGxhbmVJdGVtKSB7XG4gICAgICAgICAgcmV0dXJuIGxhbmVJdGVtLm1pbGxpc2Vjb25kO1xuICAgICAgICB9XSk7XG5cbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGluY2lkZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICB0aGF0Ll9pbmNpZGVudEJ5SWQoaW5jaWRlbnRzW19pXS5pZCkuX29uR2V0Q29udGV4dE9uY2UoKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVzdWx0OiB0cnVlLFxuICAgICAgICBleGVjdXRlOiBleGVjXG4gICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICBAcGFyYW0ge2FycmF5fSBpbmNpZGVudHNBcnJheSAtIEEgY29sbGVjdGlvbiBvZiB0aGUgSW5jaWRldG5zIHRvIGdldCBlZGl0ZWQgaW4gdGhlIGZvcm06XG4gICAge1xuICAgICAgICBpZFxuICAgICAgICBtaWxsaXNlY29uZFxuICAgICAgICBpbmNpZGVudFxuICAgIH1cbiAgICBAcGFyYW0ge2ludH0gbWlsbGlzZWNvbmRzRGVsdGEtIHRoZSBkZWx0YSBvZiB0aGUgc3RhciBwb2ludCBvZiB0aGUgcHJvdmlkZWQgaW5jaWRlbnRzXG4gICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNoZWNrRWRpdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja0VkaXQoaW5jaWRlbnRzQXJyYXksIG1pbGxpc2Vjb25kc0RlbHRhKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgIHZhciBleGVjID0gZnVuY3Rpb24gZXhlYygpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmNpZGVudHNBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhhdC5pbmNpZGVudHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmICh0aGF0LmluY2lkZW50c1tqXS5pZCA9PT0gaW5jaWRlbnRzQXJyYXlbaV0uaWQpIHtcbiAgICAgICAgICAgICAgdGhhdC5pbmNpZGVudHNbal0ubWlsbGlzZWNvbmQgKz0gbWlsbGlzZWNvbmRzRGVsdGE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoYXQuaW5jaWRlbnRzID0gX3NvcnRCeSh0aGF0LmluY2lkZW50cywgW2Z1bmN0aW9uIChsYW5lSXRlbSkge1xuICAgICAgICAgIHJldHVybiBsYW5lSXRlbS5taWxsaXNlY29uZDtcbiAgICAgICAgfV0pO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVzdWx0OiB0cnVlLFxuICAgICAgICBleGVjdXRlOiBleGVjXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjaGVja0RlbGV0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja0RlbGV0ZShpbmNpZGVudHNBcnJheSkge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgdmFyIGluY2lkZW50SWRzID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5jaWRlbnRzQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaW5jaWRlbnRJZHMucHVzaChpbmNpZGVudHNBcnJheVtpXS5pZCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBleGVjID0gZnVuY3Rpb24gZXhlYygpIHtcbiAgICAgICAgdmFyIG5ld0luY2lkZW50cyA9IF9maWx0ZXIodGhhdC5pbmNpZGVudHMsIGZ1bmN0aW9uIChpbmNpZGVudCkge1xuICAgICAgICAgIHJldHVybiBpbmNpZGVudElkcy5pbmRleE9mKGluY2lkZW50LmlkKSA9PT0gLTE7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoYXQuaW5jaWRlbnRzID0gbmV3SW5jaWRlbnRzO1xuXG4gICAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IGluY2lkZW50SWRzLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgICBkZWxldGUgdGhhdC5pbmNpZGVudHNCeUlkW2luY2lkZW50SWRzW19pMl1dO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICByZXN1bHQ6IHRydWUsXG4gICAgICAgIGV4ZWN1dGU6IGV4ZWNcbiAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7YXJyYXl9IGluY2lkZW50cyAtIFt7aWQsIHN0YXJ0LCBlbmQsIHN0YXJ0RGVsdGF9XVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY2hlY2tSZXNpemVkSW5jaWRlbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrUmVzaXplZEluY2lkZW50cyhpbmNpZGVudHMpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgdmFyIGV4ZWMgPSBmdW5jdGlvbiBleGVjKCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluY2lkZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhhdC5pbmNpZGVudHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmICh0aGF0LmluY2lkZW50c1tqXS5pZCA9PT0gaW5jaWRlbnRzW2ldLmlkKSB7XG4gICAgICAgICAgICAgIHRoYXQuaW5jaWRlbnRzW2pdLm1pbGxpc2Vjb25kICs9IGluY2lkZW50c1tpXS5zdGFydERlbHRhO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGF0LmluY2lkZW50cyA9IF9zb3J0QnkodGhhdC5pbmNpZGVudHMsIFtmdW5jdGlvbiAobGFuZUl0ZW0pIHtcbiAgICAgICAgICByZXR1cm4gbGFuZUl0ZW0ubWlsbGlzZWNvbmQ7XG4gICAgICAgIH1dKTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlc3VsdDogdHJ1ZSxcbiAgICAgICAgZXhlY3V0ZTogZXhlY1xuICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgIEBwYXJhbSB7aW50fSBmcm9tIC0gdGhlIG1pbGxpc2Vjb25kIHRvIHN0YXJ0IGZyb21cbiAgICAgQHBhcmFtIHtpbnR9IHRvIC0gdGhlIG1pbGxpc2Vjb25kIHRvIGdvIHRvXG4gICAgIEBwYXJhbSB7c3RyaW5nfSBjb250ZXh0SWQgLSB0aGUgY29udGV4dCBpZCB0byBtb3ZlXG4gICAgIEBwYXJhbSB7Ym9vbGVhbn0gZm9yY2VSZXNldCAtIHNldCB0byB0cnVlIHdoZW4gd2Ugd2FudCBmdWxsIGZsYXNoXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJtb3ZlVG9cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW92ZVRvKGZyb20sIHRvLCBjb250ZXh0SWQpIHtcbiAgICAgIHZhciBmb3JjZVJlc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBmYWxzZTtcblxuICAgICAgaWYgKGZvcmNlUmVzZXQgPT09IHRydWUpIHtcbiAgICAgICAgLy8gaW5jaWRlbnRzOiBbe2lkLCBtaWxsaXNlY29uZH0sIHt9LCB7fS4uLl1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmluY2lkZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBsYW5lSXRlbSA9IHRoaXMuaW5jaWRlbnRzW2ldO1xuXG4gICAgICAgICAgdmFyIGluY2lkZW50ID0gdGhpcy5faW5jaWRlbnRCeUlkKGxhbmVJdGVtLmlkKTtcblxuICAgICAgICAgIGlmICh0byA8IGxhbmVJdGVtLm1pbGxpc2Vjb25kKSB7XG4gICAgICAgICAgICBpbmNpZGVudC5vblByb2dyZXNzKDAsIDAsIGNvbnRleHRJZCwgdHJ1ZSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0byA+IGxhbmVJdGVtLm1pbGxpc2Vjb25kICsgaW5jaWRlbnQuZHVyYXRpb24pIHtcbiAgICAgICAgICAgIGluY2lkZW50Lm9uUHJvZ3Jlc3MoMSwgaW5jaWRlbnQuZHVyYXRpb24sIGNvbnRleHRJZCwgdHJ1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluY2lkZW50Lm9uUHJvZ3Jlc3MoKHRvIC0gbGFuZUl0ZW0ubWlsbGlzZWNvbmQpIC8gaW5jaWRlbnQuZHVyYXRpb24sIHRvIC0gbGFuZUl0ZW0ubWlsbGlzZWNvbmQsIGNvbnRleHRJZCwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgdmFyIHBhcnRpY2lwYXRpbmdJdGVtcyA9IF9maWx0ZXIodGhpcy5pbmNpZGVudHMsIGZ1bmN0aW9uIChsYW5lSXRlbSkge1xuICAgICAgICAgIHJldHVybiBsYW5lSXRlbS5taWxsaXNlY29uZCArIHRoYXQuX2luY2lkZW50QnlJZChsYW5lSXRlbS5pZCkuZHVyYXRpb24gPj0gZnJvbSAmJiBsYW5lSXRlbS5taWxsaXNlY29uZCArIHRoYXQuX2luY2lkZW50QnlJZChsYW5lSXRlbS5pZCkuZHVyYXRpb24gPD0gdG8gfHwgLy8gaXQgZW5kcyBhZnRlciBmcm9tIGFuZCBiZWZvcmUgdG8gbWlsbGlzZWNvbmRcbiAgICAgICAgICB0aGF0Ll9pbmNpZGVudEJ5SWQobGFuZUl0ZW0uaWQpLmR1cmF0aW9uICsgbGFuZUl0ZW0ubWlsbGlzZWNvbmQgPj0gdG8gJiYgbGFuZUl0ZW0ubWlsbGlzZWNvbmQgPD0gdG87IC8vIG9yIGl0IGVuZHMgYWZ0ZXIgdGhlIHRhcmdldCBtaWxsaXNlY29uZCBidXQgYWxzbyBzdGFydHMgYmVmb3JlIGl0XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IHBhcnRpY2lwYXRpbmdJdGVtcy5sZW5ndGg7IF9pMysrKSB7XG4gICAgICAgICAgdmFyIF9sYW5lSXRlbSA9IHBhcnRpY2lwYXRpbmdJdGVtc1tfaTNdO1xuXG4gICAgICAgICAgdmFyIGNvbnRleHRBd2FyZUNsaXBJbmNpZGVudCA9IHRoaXMuX2luY2lkZW50QnlJZChfbGFuZUl0ZW0uaWQpOyAvLyBvblByb2dyZXNzKGZyYWN0aW9uLCBtaWxsaXNlY29uZHMsIGNvbnRleHRJZCwgZm9yY2VSZXNldCA9IGZhbHNlKSB7XG5cblxuICAgICAgICAgIHZhciBvdmVyY2FtZUVuZCA9ICh0byAtIF9sYW5lSXRlbS5taWxsaXNlY29uZCkgLyBjb250ZXh0QXdhcmVDbGlwSW5jaWRlbnQuZHVyYXRpb24gPj0gMTtcbiAgICAgICAgICB2YXIgZnJhY3Rpb24gPSBvdmVyY2FtZUVuZCA/IDEgOiAodG8gLSBfbGFuZUl0ZW0ubWlsbGlzZWNvbmQpIC8gY29udGV4dEF3YXJlQ2xpcEluY2lkZW50LmR1cmF0aW9uO1xuICAgICAgICAgIHZhciBtaWxsaXNlY29uZCA9IG92ZXJjYW1lRW5kID8gY29udGV4dEF3YXJlQ2xpcEluY2lkZW50LmR1cmF0aW9uIDogdG8gLSBfbGFuZUl0ZW0ubWlsbGlzZWNvbmQ7XG4gICAgICAgICAgY29udGV4dEF3YXJlQ2xpcEluY2lkZW50Lm9uUHJvZ3Jlc3MoZnJhY3Rpb24sIG1pbGxpc2Vjb25kLCBjb250ZXh0SWQsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDbGlwQ2hhbm5lbDtcbn0oQ2hhbm5lbCk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2xpcENoYW5uZWw7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/_Channels/_Clip/ClipsChannel.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/_Clip/ClipCopy.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/_Clip/ClipCopy.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar TimedIncident = __webpack_require__(/*! ../_BaseClasses/Incident */ \"./node_modules/@kissmybutton/motorcortex/dist/_BaseClasses/Incident.js\");\n\nvar Helper = __webpack_require__(/*! ../_coreUtils/Helper */ \"./node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\");\n\nvar helper = new Helper();\n\nvar ClipCopy =\n/*#__PURE__*/\nfunction (_TimedIncident) {\n  _inherits(ClipCopy, _TimedIncident);\n\n  function ClipCopy(attrs, props, dna) {\n    var _this;\n\n    _classCallCheck(this, ClipCopy);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ClipCopy).call(this, attrs, props, dna));\n    _this.realClip = dna.descriptiveIncident.realClip;\n    _this.runTimeInfo = {\n      currentMillisecond: 0\n    };\n    return _this;\n  }\n\n  _createClass(ClipCopy, [{\n    key: \"lastWish\",\n    value: function lastWish() {\n      this.ownClip.ownContext.unmount();\n    }\n  }, {\n    key: \"onGetContext\",\n    value: function onGetContext() {\n      // In order to render itself on the given element first it needs the props (including html and css)\n      // from the real Clip it copies\n      var constructionArgs = this.realClip.exportConstructionArguments(); // it properly sets its own host on the props to use to initialise its own clip\n\n      var host = helper.getElementByMCID(this.context, this.mcid);\n\n      var hostedProps = _objectSpread({}, constructionArgs.props, {\n        selector: undefined,\n        host: host\n      }); // we create a clip because Clips on creation render and thus have their own context\n\n\n      this.ownClip = new this.dna.descriptiveIncident.constructor.Incident(constructionArgs.attrs, hostedProps); // console.log(this.ownClip);\n      // flushes the realClip with its ownClip's context\n\n      this.realClip.addContext({\n        clipId: this.id,\n        context: this.ownClip.ownContext\n      }, true); // even though we have created an own clip, we have made no checks at all neither\n      // we added the incidents of the real clip to it. That is becuase playing and moving\n      // this clip copy means directly moving the real clip on the context of the own clip.\n      // So the only thing we need here is the context and nothing more.\n    }\n  }, {\n    key: \"onProgress\",\n    value: function onProgress(fraction, milliseconds) {\n      var forceReset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      for (var key in this.realClip.instantiatedChannels) {\n        var channel = this.realClip.instantiatedChannels[key];\n        channel.moveTo(this.runTimeInfo.currentMillisecond, milliseconds, this.id, forceReset);\n      }\n\n      this.runTimeInfo.currentMillisecond = milliseconds;\n    }\n  }, {\n    key: \"duration\",\n    get: function get() {\n      return this.realClip.duration;\n    },\n    set: function set(milliseconds) {\n      this.realClip._resize(milliseconds / this.realClip.duration);\n    }\n  }]);\n\n  return ClipCopy;\n}(TimedIncident);\n\nmodule.exports = ClipCopy;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19DbGlwL0NsaXBDb3B5LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvZGlzdC9fQ2xpcC9DbGlwQ29weS5qcz8xNzNmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgdmFyIG93bktleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpOyBpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09ICdmdW5jdGlvbicpIHsgb3duS2V5cyA9IG93bktleXMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKS5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIHN5bSkuZW51bWVyYWJsZTsgfSkpOyB9IG93bktleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG52YXIgVGltZWRJbmNpZGVudCA9IHJlcXVpcmUoJy4uL19CYXNlQ2xhc3Nlcy9JbmNpZGVudCcpO1xuXG52YXIgSGVscGVyID0gcmVxdWlyZSgnLi4vX2NvcmVVdGlscy9IZWxwZXInKTtcblxudmFyIGhlbHBlciA9IG5ldyBIZWxwZXIoKTtcblxudmFyIENsaXBDb3B5ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfVGltZWRJbmNpZGVudCkge1xuICBfaW5oZXJpdHMoQ2xpcENvcHksIF9UaW1lZEluY2lkZW50KTtcblxuICBmdW5jdGlvbiBDbGlwQ29weShhdHRycywgcHJvcHMsIGRuYSkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDbGlwQ29weSk7XG5cbiAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihDbGlwQ29weSkuY2FsbCh0aGlzLCBhdHRycywgcHJvcHMsIGRuYSkpO1xuICAgIF90aGlzLnJlYWxDbGlwID0gZG5hLmRlc2NyaXB0aXZlSW5jaWRlbnQucmVhbENsaXA7XG4gICAgX3RoaXMucnVuVGltZUluZm8gPSB7XG4gICAgICBjdXJyZW50TWlsbGlzZWNvbmQ6IDBcbiAgICB9O1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhDbGlwQ29weSwgW3tcbiAgICBrZXk6IFwibGFzdFdpc2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGFzdFdpc2goKSB7XG4gICAgICB0aGlzLm93bkNsaXAub3duQ29udGV4dC51bm1vdW50KCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm9uR2V0Q29udGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkdldENvbnRleHQoKSB7XG4gICAgICAvLyBJbiBvcmRlciB0byByZW5kZXIgaXRzZWxmIG9uIHRoZSBnaXZlbiBlbGVtZW50IGZpcnN0IGl0IG5lZWRzIHRoZSBwcm9wcyAoaW5jbHVkaW5nIGh0bWwgYW5kIGNzcylcbiAgICAgIC8vIGZyb20gdGhlIHJlYWwgQ2xpcCBpdCBjb3BpZXNcbiAgICAgIHZhciBjb25zdHJ1Y3Rpb25BcmdzID0gdGhpcy5yZWFsQ2xpcC5leHBvcnRDb25zdHJ1Y3Rpb25Bcmd1bWVudHMoKTsgLy8gaXQgcHJvcGVybHkgc2V0cyBpdHMgb3duIGhvc3Qgb24gdGhlIHByb3BzIHRvIHVzZSB0byBpbml0aWFsaXNlIGl0cyBvd24gY2xpcFxuXG4gICAgICB2YXIgaG9zdCA9IGhlbHBlci5nZXRFbGVtZW50QnlNQ0lEKHRoaXMuY29udGV4dCwgdGhpcy5tY2lkKTtcblxuICAgICAgdmFyIGhvc3RlZFByb3BzID0gX29iamVjdFNwcmVhZCh7fSwgY29uc3RydWN0aW9uQXJncy5wcm9wcywge1xuICAgICAgICBzZWxlY3RvcjogdW5kZWZpbmVkLFxuICAgICAgICBob3N0OiBob3N0XG4gICAgICB9KTsgLy8gd2UgY3JlYXRlIGEgY2xpcCBiZWNhdXNlIENsaXBzIG9uIGNyZWF0aW9uIHJlbmRlciBhbmQgdGh1cyBoYXZlIHRoZWlyIG93biBjb250ZXh0XG5cblxuICAgICAgdGhpcy5vd25DbGlwID0gbmV3IHRoaXMuZG5hLmRlc2NyaXB0aXZlSW5jaWRlbnQuY29uc3RydWN0b3IuSW5jaWRlbnQoY29uc3RydWN0aW9uQXJncy5hdHRycywgaG9zdGVkUHJvcHMpOyAvLyBjb25zb2xlLmxvZyh0aGlzLm93bkNsaXApO1xuICAgICAgLy8gZmx1c2hlcyB0aGUgcmVhbENsaXAgd2l0aCBpdHMgb3duQ2xpcCdzIGNvbnRleHRcblxuICAgICAgdGhpcy5yZWFsQ2xpcC5hZGRDb250ZXh0KHtcbiAgICAgICAgY2xpcElkOiB0aGlzLmlkLFxuICAgICAgICBjb250ZXh0OiB0aGlzLm93bkNsaXAub3duQ29udGV4dFxuICAgICAgfSwgdHJ1ZSk7IC8vIGV2ZW4gdGhvdWdoIHdlIGhhdmUgY3JlYXRlZCBhbiBvd24gY2xpcCwgd2UgaGF2ZSBtYWRlIG5vIGNoZWNrcyBhdCBhbGwgbmVpdGhlclxuICAgICAgLy8gd2UgYWRkZWQgdGhlIGluY2lkZW50cyBvZiB0aGUgcmVhbCBjbGlwIHRvIGl0LiBUaGF0IGlzIGJlY3Vhc2UgcGxheWluZyBhbmQgbW92aW5nXG4gICAgICAvLyB0aGlzIGNsaXAgY29weSBtZWFucyBkaXJlY3RseSBtb3ZpbmcgdGhlIHJlYWwgY2xpcCBvbiB0aGUgY29udGV4dCBvZiB0aGUgb3duIGNsaXAuXG4gICAgICAvLyBTbyB0aGUgb25seSB0aGluZyB3ZSBuZWVkIGhlcmUgaXMgdGhlIGNvbnRleHQgYW5kIG5vdGhpbmcgbW9yZS5cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib25Qcm9ncmVzc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvblByb2dyZXNzKGZyYWN0aW9uLCBtaWxsaXNlY29uZHMpIHtcbiAgICAgIHZhciBmb3JjZVJlc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMucmVhbENsaXAuaW5zdGFudGlhdGVkQ2hhbm5lbHMpIHtcbiAgICAgICAgdmFyIGNoYW5uZWwgPSB0aGlzLnJlYWxDbGlwLmluc3RhbnRpYXRlZENoYW5uZWxzW2tleV07XG4gICAgICAgIGNoYW5uZWwubW92ZVRvKHRoaXMucnVuVGltZUluZm8uY3VycmVudE1pbGxpc2Vjb25kLCBtaWxsaXNlY29uZHMsIHRoaXMuaWQsIGZvcmNlUmVzZXQpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnJ1blRpbWVJbmZvLmN1cnJlbnRNaWxsaXNlY29uZCA9IG1pbGxpc2Vjb25kcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHVyYXRpb25cIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlYWxDbGlwLmR1cmF0aW9uO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQobWlsbGlzZWNvbmRzKSB7XG4gICAgICB0aGlzLnJlYWxDbGlwLl9yZXNpemUobWlsbGlzZWNvbmRzIC8gdGhpcy5yZWFsQ2xpcC5kdXJhdGlvbik7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENsaXBDb3B5O1xufShUaW1lZEluY2lkZW50KTtcblxubW9kdWxlLmV4cG9ydHMgPSBDbGlwQ29weTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/_Clip/ClipCopy.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/_Clip/ExtendableClip.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/_Clip/ExtendableClip.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar Helper = __webpack_require__(/*! ../_coreUtils/Helper */ \"./node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\");\n\nvar helper = new Helper();\n\nvar Group = __webpack_require__(/*! ../_BaseClasses/Group */ \"./node_modules/@kissmybutton/motorcortex/dist/_BaseClasses/Group.js\");\n\nvar selfContainedIncidentsNpmName = '@kissmybutton/self-contained-incidents'; // TODO remove this\n\nvar _TREECONST = __webpack_require__(/*! ../_Tree/_CONST */ \"./node_modules/@kissmybutton/motorcortex/dist/_Tree/_CONST.js\");\n\nvar ExtendableClip =\n/*#__PURE__*/\nfunction (_Group) {\n  _inherits(ExtendableClip, _Group);\n\n  /**\n   * @param {object} props - an object that should contain all of the following keys:\n   * - html (the html template to render)\n   * - css (the css template of the isolated tree)\n   * - initParams (optional / the initialisation parameteres that will be passed both on the css and the html templates in order to render)\n   * - host (an Element object that will host the isolated tree)\n   * - containerParams (an object that holds parameters to affect the container of the isolated tree, e.g. width, height etc)\n   * - type (optional, defaults to \"iframe\") the type of the Clip. It can be one of the:\n   *  - iframe\n   *  - plain\n   */\n  function ExtendableClip(attrs, props) {\n    var _this;\n\n    _classCallCheck(this, ExtendableClip);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ExtendableClip).call(this, attrs, props));\n    _this.attrs = attrs;\n    _this.props = props;\n    _this.isTheClip = true;\n    _this.volume = 1;\n    _this.speed = 1;\n    _this.blockingWaitings = {};\n    /**\n     * The cnannels attribute holds a list of all intantiated Channels of the Incidents belonging to the clip\n     * this attribute is only valuable when the Group becomes the Clip\n     * The format of the attribute is:\n     *  key-value pairs in the manner:\n     * <mc_plugin_npm_name>: Channel object\n     */\n\n    _this.instantiatedChannels = {};\n    /**\n     * The instantiatedCopiesContexts is a key-value pairs colleciton holding the\n     * contexts of all instantiated ClipCopies\n     **/\n\n    _this.instantiatedCopiesContexts = {};\n\n    _this.onClipInitialise();\n\n    _this.durationSubs = [];\n    _this.runTimeInfo = {\n      currentMillisecond: 0,\n      state: 'idle' // supported states: idle, playing, paused, blocked\n\n      /**\n        @member {object} - listeners are functions to be executed on time change of the Clip.\n        It has the following format:\n       listeners: {\n          listener_id: {\n                   funct : the function to be executed\n                   threshold : the threshold of delta\n                   roundTo : round millisecond\n               },\n               listener_id: {\n                   funct : the function to be executed\n                   threshold : the threshold of delta\n                   roundTo : round millisecond\n               },\n               ...\n         }\n         */\n\n    };\n    _this.listeners = {}; // previousTimeStamp is a property holding the last timestamp that the\n    // requestAnimationFrame ran\n\n    _this.previousTimeStamp = -1;\n    return _this;\n  }\n\n  _createClass(ExtendableClip, [{\n    key: \"onClipInitialise\",\n    value: function onClipInitialise() {// called when group gets initialised\n    }\n  }, {\n    key: \"addContext\",\n\n    /**\n     * This method is been called when a new ClipCopy enters the real tree successfully.\n     * @param {object} contextData - keys: clipId, context\n     **/\n    value: function addContext(contextData) {\n      this.instantiatedCopiesContexts[contextData.clipId] = contextData.context;\n      contextData.instantiatedCopiesContexts = this.instantiatedCopiesContexts;\n      var res = this.putMessageOnPipe('addContext', contextData, {}, {\n        selfExecute: false,\n        direction: _TREECONST._DIRECTIONS._DOWN\n      });\n      return res;\n    }\n    /*\n    ExtendableClip (as its name implies) is a Class that should be extended by\n    any specific kind of Clip, such as Fragmented or SCGroup. This method must\n    be overitten by the new Classes. This definition here is just for reference / help\n    purposes\n    */\n\n  }, {\n    key: \"exportConstructionArguments\",\n    value: function exportConstructionArguments() {\n      return {\n        attrs: this.attrs,\n        props: this.props\n      };\n    }\n    /**\n     * completely resizes the Clip without any checks\n     */\n\n  }, {\n    key: \"_resize\",\n    value: function _resize(durationFraction) {\n      for (var key in this.instantiatedChannels) {\n        this.instantiatedChannels[key]._resize(durationFraction);\n      }\n\n      this.setNewDuration(this.duration * durationFraction);\n\n      for (var i = 0; i < this.durationSubs.length; i++) {\n        this.durationSubs[i](this.duration);\n      }\n    } // ************ PUB SUB ********************\n    // *****************************************\n\n    /**\n      By subscribing a module can get notified about changes on the Clip's time\n      subscribe method subscribes a function to the time change dispatcher. As Clip uses requestAnimationFrame for its timing\n      each cyrcle / step gets the current time and subtracts the previous time so it know how many milliseconds has elapsed\n      since last step. Subscribers can set to get informed about time changes only if the delta is greater than a given\n      number (e.g. greater than 300ms). That property is passed as the second argument \"threshold\".\n      Finally if any of the subscribers want the Scene to provide back a rounded number of the milliseconds. Options:\n        - 1 (round it on its actual units\n       - 10 (round it on tenths)\n       - 100 (round it on hundreds)\n       - 1000 (round it on thousands)\n      the first argument provides an id to the listener for future reference (deletion etc)\n      the second argument is a function that takes two arguments: millisecond, state (current millisecond of the Scene\n      and the state of it  */\n\n  }, {\n    key: \"subscribe\",\n    value: function subscribe(id, funct, threshold, roundTo) {\n      if (!threshold) {\n        threshold = 0;\n      }\n\n      if (!roundTo) {\n        roundTo = 1; // round second to its units, meaning leave it as it is\n      }\n\n      this.listeners[id] = {\n        funct: funct,\n        threshold: threshold,\n        roundTo: roundTo,\n        cavaDelta: 0\n      };\n    }\n  }, {\n    key: \"unsubscribe\",\n    value: function unsubscribe(id) {\n      if (Object.prototype.hasOwnProperty.call(this.listeners, id)) {\n        delete this.listeners[id];\n      }\n    }\n    /*********************************************************\n    Editing commands input methods\n    *********************************************************/\n\n    /**\n     * This command comes form the Clip's parent Descriptor class. The payload\n     * is identical to the payload that comes to the Description class:\n     * {\n     *  incident: the Descriptive Incident to be added\n     *  millisecond: the millisecond to add it\n     *  parentGroupId: the id of the Group to which we want to the Incident to\n     * }\n     */\n\n  }, {\n    key: \"addIncident\",\n    value: function addIncident(payload) {\n      var candidates = this.putMessageOnPipe('addIncident', {\n        incident: payload.incident,\n        millisecond: payload.millisecond,\n        parentGroupId: payload.parentGroupId,\n        contextData: {\n          clipId: this.id,\n          context: this.context\n        }\n      }, payload.parentGroupId, {\n        selfExecute: true,\n        direction: _TREECONST._DIRECTIONS._DOWN\n      }); // concatenate candidates\n      // console.log(candidates);\n\n      var totalIncidentsByPlugin = {};\n\n      for (var i = 0; i < candidates.length; i++) {\n        var incidentsByPlugin = candidates[i].response.getIncidentsByChannel(candidates[i].positionDelta + payload.millisecond);\n\n        for (var pluginName in incidentsByPlugin) {\n          var _totalIncidentsByPlug;\n\n          if (!Object.prototype.hasOwnProperty.call(totalIncidentsByPlugin, pluginName)) {\n            totalIncidentsByPlugin[pluginName] = [];\n          }\n\n          (_totalIncidentsByPlug = totalIncidentsByPlugin[pluginName]).push.apply(_totalIncidentsByPlug, _toConsumableArray(incidentsByPlugin[pluginName]));\n        }\n      }\n\n      var res = this.checkAddition(totalIncidentsByPlugin);\n\n      if (res.result === true) {\n        res.execute(); // up to that point the only context Incident that has been initialised on the\n        // ContextAwareIncidents of the candidates is the original context of the\n        // ExtendableClip.\n\n        for (var _i = 0; _i < candidates.length; _i++) {\n          candidates[_i].responder.addChild(candidates[_i].response, payload.millisecond); // recalculate duration the groups that we added\n          // the incidents to along with their parents\n\n\n          candidates[_i].responder.putMessageOnPipe('recalcDuration', {}, 'Groups', {\n            selfExecute: true,\n            direction: _TREECONST._DIRECTIONS._UP\n          }); // we also need to add every existing (copied) context to the ContextAwareIncidents\n          // created on the candidates process\n\n\n          for (var contextKey in this.instantiatedCopiesContexts) {\n            candidates[_i].responder.putMessageOnPipe('addContext', {\n              clipId: contextKey,\n              context: this.instantiatedCopiesContexts[contextKey]\n            }, 'ContextAwareIncidents', {\n              selfExecute: false,\n              direction: _TREECONST._DIRECTIONS._DOWN\n            });\n          }\n        }\n      }\n\n      return res;\n    } // *******************************************************\n    // INCIDENTS MANAGEMENT METHODS\n    // POLYMORPHISM APPLIED. IF THE GROUP HAS NO PARENT IT ACTS AS A SCENE. IF THE GROUP HAS PARENT IT ACTS AS\n    // A \"TRANSPARENT GROUP\"\n\n    /**\n     * The method returns either:\n        {\n            result:true,\n            execute: // an array of functions that when executed it will add the Incidents on the Channels\n        }\n        or\n        {\n            result: false,\n            errors\n        }\n    */\n\n  }, {\n    key: \"checkAddition\",\n    value: function checkAddition(incidentsById) {\n      var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"all-or-nothing\";\n      // prepare the return payload\n      var toReturnResult = true;\n      var toReturnErrors = [];\n      var toReturnExecutables = []; // for each key of the incidentsById object perform the check\n\n      for (var key in incidentsById) {\n        // if the clip had no channel instantiated for the specific key (plugin id) yet create it\n        if (!Object.prototype.hasOwnProperty.call(this.instantiatedChannels, key)) {\n          // intstantiate the channel of the plugin by using the reference to the class definition stored on\n          // the very first incident of the array\n          this.instantiatedChannels[key] = new incidentsById[key][0].incident.plugin_channel_class({\n            runTimeInfo: this.runTimeInfo,\n            context: this.context,\n            getIncidentById: this.getIncidentById\n          });\n        } // perform the check\n\n\n        var pluginResult = this.instantiatedChannels[key].addIncidents(incidentsById[key], type);\n        toReturnResult = toReturnResult && pluginResult.result;\n\n        if (pluginResult.result === false) {\n          toReturnErrors = toReturnErrors.concat(pluginResult.errors);\n        } else {\n          toReturnExecutables.push(pluginResult.execute);\n        }\n      } // enf of iteration on the incidentsById keys\n\n\n      var toReturnExecute = function toReturnExecute() {\n        for (var i = 0; i < toReturnExecutables.length; i++) {\n          toReturnExecutables[i]();\n        }\n      };\n\n      var additionResult = {\n        result: toReturnResult,\n        errors: toReturnErrors,\n        execute: toReturnExecute\n      };\n      return additionResult;\n    }\n    /**\n     * This command comes form the Clip's parent Descriptor class. The payload\n     * is identical to the payload that comes to the Description class:\n     * {\n     *  incident: the Descriptive Incident to be repositioned\n     *  millisecond: the new millisecond to put it\n     *  parentGroupId: the id of the\n     * }\n     */\n\n  }, {\n    key: \"moveIncident\",\n    value: function moveIncident(payload) {\n      var candidates = this.putMessageOnPipe('moveIncident', {\n        incidentId: payload.id,\n        millisecond: payload.millisecond,\n        parentGroupId: payload.parentGroupId,\n        contextData: {\n          clipId: this.id,\n          context: this.context\n        }\n      }, payload.parentGroupId, {\n        selfExecute: true,\n        direction: _TREECONST._DIRECTIONS._DOWN\n      });\n      var totalIncidentsByPlugin = {};\n\n      for (var i = 0; i < candidates.length; i++) {\n        var incidentsByPlugin = candidates[i].response.getIncidentsByChannel(candidates[i].positionDelta + payload.millisecond);\n\n        for (var pluginName in incidentsByPlugin) {\n          var _totalIncidentsByPlug2;\n\n          if (!Object.prototype.hasOwnProperty.call(totalIncidentsByPlugin, pluginName)) {\n            totalIncidentsByPlugin[pluginName] = [];\n          }\n\n          (_totalIncidentsByPlug2 = totalIncidentsByPlugin[pluginName]).push.apply(_totalIncidentsByPlug2, _toConsumableArray(incidentsByPlugin[pluginName]));\n        }\n      }\n\n      var res = this.checkMove(totalIncidentsByPlugin, payload.positionDelta);\n\n      if (res.result === true) {\n        res.execute();\n\n        for (var _i2 = 0; _i2 < candidates.length; _i2++) {\n          candidates[_i2].responder.editPosition(candidates[_i2].response.id, payload.millisecond); // recalculate duration the groups that we added\n          // the incidents to along with their parents\n\n\n          candidates[_i2].responder.putMessageOnPipe('recalcDuration', {}, 'Groups', {\n            selfExecute: true,\n            direction: _TREECONST._DIRECTIONS._UP\n          });\n        }\n      }\n\n      return res;\n    }\n    /**\n     * The checkEdit method serves exactly what its name implies. To check if the edit of an Incident (edit of Incident's position given in milliseconds delta)\n     * is valid and accepted, according to the rules defined on the channels.\n     * The method boobles up until it reaches the Clip.\n     * @param {object} incident - the incident to edit\n     * @param {int} millisecondsDelta - the milliseconds delta of the Incident's start time\n     The method should return either:\n        {\n            result:true,\n            execute: // an array of functions that when executed it will edit the Incidents on the Channels\n        }\n        or\n        {\n            result: false,\n            errors\n        }\n    */\n\n  }, {\n    key: \"checkMove\",\n    value: function checkMove(incidentsById, millisecondsDelta) {\n      // prepare the return payload\n      var toReturnResult = true;\n      var toReturnErrors = [];\n      var toReturnExecutables = []; // for each key of the incidentsById object perform the check\n\n      for (var key in incidentsById) {\n        // perform the check\n        var pluginResult = this.instantiatedChannels[key].editIncidents(incidentsById[key], millisecondsDelta);\n        toReturnResult = toReturnResult && pluginResult.result;\n\n        if (pluginResult.result === false) {\n          toReturnErrors = toReturnErrors.concat(pluginResult.errors);\n        } else {\n          toReturnExecutables.push(pluginResult.execute);\n        }\n      } // enf of iteration on the incidentsById keys\n\n\n      var toReturnExecute = function toReturnExecute() {\n        for (var i = 0; i < toReturnExecutables.length; i++) {\n          toReturnExecutables[i]();\n        }\n      };\n\n      var editResult = {\n        result: toReturnResult,\n        errors: toReturnErrors,\n        execute: toReturnExecute\n      };\n      return editResult;\n    }\n  }, {\n    key: \"removeIncident\",\n    value: function removeIncident(payload) {\n      var candidates = this.putMessageOnPipe('removeIncident', {\n        incidentId: payload.id,\n        parentGroupId: payload.parentGroupId,\n        contextData: {\n          clipId: this.id,\n          context: this.context\n        }\n      }, payload.parentGroupId, {\n        selfExecute: true,\n        direction: _TREECONST._DIRECTIONS._DOWN\n      });\n      var totalIncidentsByPlugin = {};\n\n      for (var i = 0; i < candidates.length; i++) {\n        var incidentsByPlugin = candidates[i].response.getIncidentsByChannel();\n\n        for (var pluginName in incidentsByPlugin) {\n          var _totalIncidentsByPlug3;\n\n          if (!Object.prototype.hasOwnProperty.call(totalIncidentsByPlugin, pluginName)) {\n            totalIncidentsByPlugin[pluginName] = [];\n          }\n\n          (_totalIncidentsByPlug3 = totalIncidentsByPlugin[pluginName]).push.apply(_totalIncidentsByPlug3, _toConsumableArray(incidentsByPlugin[pluginName]));\n        }\n      }\n\n      var res = this.checkDelete(totalIncidentsByPlugin);\n\n      if (res.result === true) {\n        res.execute();\n\n        for (var _i3 = 0; _i3 < candidates.length; _i3++) {\n          candidates[_i3].responder.removeChild(candidates[_i3].response.id); // recalculate duration the groups that we added\n          // the incidents to along with their parents\n\n\n          candidates[_i3].responder.putMessageOnPipe('recalcDuration', {}, 'Groups', {\n            selfExecute: true,\n            direction: _TREECONST._DIRECTIONS._UP\n          });\n        }\n      }\n\n      return res;\n    }\n    /**\n     * The checkDelete method serves exactly what its name implies. To check if the deletion of an Incident\n     * is valid and accepted, according to the rules defined on the channels.\n     * The method boobles up until it reaches the Clip.\n     * @param {object} incident - the incident to edit\n      The result might be either:\n        {\n            result:true,\n            execute: // an array of functions that when executed it will remove the Incident on the Channels\n        }\n        or\n        {\n            result: false,\n            errors\n        }\n    */\n\n  }, {\n    key: \"checkDelete\",\n    value: function checkDelete(incidentsById) {\n      // prepare the return payload\n      var toReturnResult = true;\n      var toReturnErrors = [];\n      var toReturnExecutables = []; // for each key of the incidentsById object perform the check\n\n      for (var key in incidentsById) {\n        // perform the check\n        var pluginResult = this.instantiatedChannels[key].removeIncidents(incidentsById[key]);\n        toReturnResult = toReturnResult && pluginResult.result;\n\n        if (pluginResult.result === false) {\n          toReturnErrors = toReturnErrors.concat(pluginResult.errors);\n        } else {\n          toReturnExecutables.push(pluginResult.execute);\n        }\n      } // enf of iteration on the incidentsById keys\n\n\n      var toReturnExecute = function toReturnExecute() {\n        for (var i = 0; i < toReturnExecutables.length; i++) {\n          toReturnExecutables[i]();\n        }\n      };\n\n      var removeResult = {\n        result: toReturnResult,\n        errors: toReturnErrors,\n        execute: toReturnExecute\n      };\n      return removeResult;\n    }\n    /**\n     * This command comes form the Clip's parent Descriptor class. The payload\n     * is identical to the payload that comes to the Description class:\n     * {\n     *  id: the id of the Incident to resize\n     *  newSize: the milliseconds of the new duration\n     *  fraction: the division of the new duration to the current\n     * }\n     */\n\n  }, {\n    key: \"resizeIncident\",\n    value: function resizeIncident(payload) {\n      var candidates = this.putMessageOnPipe('resize', {\n        incidentId: payload.id,\n        newSize: payload.newSize,\n        fraction: payload.fraction,\n        contextData: {\n          clipId: this.id,\n          context: this.context\n        }\n      }, payload.id, {\n        selfExecute: false,\n        direction: _TREECONST._DIRECTIONS._DOWN\n      });\n      var totalIncidentsByPlugin = {};\n\n      for (var i = 0; i < candidates.length; i++) {\n        var incidentsByPlugin = candidates[i].response.getIncidentsByChannel(candidates[i].positionDelta);\n\n        for (var pluginName in incidentsByPlugin) {\n          var _totalIncidentsByPlug4;\n\n          if (!Object.prototype.hasOwnProperty.call(totalIncidentsByPlugin, pluginName)) {\n            totalIncidentsByPlugin[pluginName] = [];\n          }\n\n          (_totalIncidentsByPlug4 = totalIncidentsByPlugin[pluginName]).push.apply(_totalIncidentsByPlug4, _toConsumableArray(incidentsByPlugin[pluginName]));\n        }\n      }\n\n      var res = this.checkResize(payload.fraction, totalIncidentsByPlugin, candidates[0].positionDelta);\n\n      if (res.result === true) {\n        res.execute();\n\n        for (var _i4 = 0; _i4 < candidates.length; _i4++) {\n          candidates[_i4].responder.setNewDuration(payload.newSize);\n        }\n      }\n\n      return res;\n    }\n    /**\n     * checks if a duration edit is feasible and doesn't cause conflicts\n     * @param {int} duration - the new duration\n     **/\n\n  }, {\n    key: \"checkResize\",\n    value: function checkResize(durationFraction, incidentsById) {\n      var adjustMillisecond = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      // prepare the return payload\n      var toReturnResult = true;\n      var toReturnErrors = [];\n      var toReturnExecutables = []; // for each key of the incidentsById object perform the check\n\n      for (var key in incidentsById) {\n        // perform the check\n        var adjustedIncidents = helper.systoleDiastoleProjections(incidentsById[key], durationFraction, adjustMillisecond);\n        var pluginResult = this.instantiatedChannels[key].checkResizedIncidents(adjustedIncidents);\n        toReturnResult = toReturnResult && pluginResult.result;\n\n        if (pluginResult.result === false) {\n          toReturnErrors = toReturnErrors.concat(pluginResult.errors);\n        } else {\n          toReturnExecutables.push(pluginResult.execute);\n        }\n      } // enf of iteration on the incidentsById keys\n\n\n      var toReturnExecute = function toReturnExecute() {\n        for (var i = 0; i < toReturnExecutables.length; i++) {\n          toReturnExecutables[i]();\n        }\n      };\n\n      var editResult = {\n        result: toReturnResult,\n        errors: toReturnErrors,\n        execute: toReturnExecute\n      };\n      return editResult;\n    }\n  }, {\n    key: \"getIncidentsByChannel\",\n\n    /**\n     * Returns an object with keys the keys of all the plugins Incidents of which appear in the\n     * tree of the Group. All Incidents are projected to the Group's timeline.\n     * The array includes the Group's projection too\n     */\n    value: function getIncidentsByChannel() {\n      var adjustMillisecond = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var incidentsByPlugin = {};\n      incidentsByPlugin[selfContainedIncidentsNpmName] = [{\n        millisecond: adjustMillisecond,\n        incident: this,\n        id: this.id\n      }];\n      return incidentsByPlugin;\n    }\n  }, {\n    key: \"setVolume\",\n    value: function setVolume(newVal) {\n      this.volume = parseFloat(newVal); // this.putMessageOnPipe(pipeMessages._GAIN_CHANGE, { gain: newVal }, false, \"down\");\n    }\n  }, {\n    key: \"_onGetContextOnce\",\n    value: function _onGetContextOnce() {\n      return; // Clips do not get context from noone\n    } // special recalcDuration handling so any potential clip copies update their trees\n\n  }, {\n    key: \"handleRecalcDuration\",\n    value: function handleRecalcDuration(target, payload) {\n      // eslint-disable-line no-unused-vars\n      if (this._calculateDuration()) {\n        for (var i = 0; i < this.durationSubs.length; i++) {\n          this.durationSubs[i](this.duration);\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: \"subscribeToDurationChange\",\n    value: function subscribeToDurationChange(method) {\n      this.durationSubs.push(method);\n    } // *******************************************************\n    // STEP FUNCTION\n\n  }, {\n    key: \"step\",\n    value: function step(timestamp) {\n      var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      if (this.runTimeInfo.state !== 'playing') {\n        return;\n      }\n\n      var that = this;\n\n      if (this.previousTimeStamp === -1) {\n        this.previousTimeStamp = timestamp;\n      } // progressStep is the progress made from previousTimeStamp both in milliseconds and in fraction [0 to 1]\n\n\n      var progress = {\n        milliseconds: Math.round(this.runTimeInfo.currentMillisecond + (timestamp - this.previousTimeStamp) * this.speed),\n        fraction: (this.runTimeInfo.currentMillisecond + (timestamp - this.previousTimeStamp) * this.speed) / this.duration\n      };\n\n      if (progress.fraction >= 1) {\n        this.onProgress(1, this.duration);\n        this.complete();\n        return;\n      } else if (progress.fraction < 0) {\n        this.onProgress(0, 0);\n        this.complete(); // this.broadcastEvent('state-change', { oldState: \"playing\", newState: \"idle\" });\n\n        return;\n      }\n\n      this.onProgress(progress.fraction, progress.milliseconds);\n      this.previousTimeStamp = timestamp;\n\n      if (debug === false) {\n        window.requestAnimationFrame(that.step.bind(that));\n      }\n    }\n    /**\n     * Method called on progress of the timed incident.\n     * @param {float} fraction - a number from 0 to 1 representing the fraction of duration covered\n     * @param {int} milliseconds - the number of milliseconds passed from start of the incident\n     * @param {string} contextId - defaults to the id of the realClip itself. Don't forget that a realClip\n     *      might belong to a selector Clip (so it's a Fragmented Clip), with many \"real\" ClipCopies. All ClipCopies hold\n     *      a reference to this Clip via their \"realClip\" property. Whenever any\n     *      of these ClipCopies progresses (via the onProgress method) calls\n     *      the \"onProgress\" of the realClip, passing their id so the ContextAwareIncidents\n     *      that will also progress via the Channels know which specific Incident to progress.\n     *      That's the result of keeping just one real tree, belonging always to the realClip\n     *      (either Fragmented or Hosted) ending to ContextAwareIncident leafs that\n     *      are the ones to hold the ClipCopies instances.\n     * @param {boolean} forceReset - set to true in cases we want full flash of the state\n     */\n\n  }, {\n    key: \"onProgress\",\n    value: function onProgress(fraction, milliseconds) {\n      var contextId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.id;\n      var forceReset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n      for (var key in this.instantiatedChannels) {\n        var channel = this.instantiatedChannels[key];\n        channel.moveTo(this.runTimeInfo.currentMillisecond, milliseconds, contextId, forceReset);\n      }\n\n      for (var _key in this.listeners) {\n        var listner = this.listeners[_key]; // console.log(`Math.abs(${milliseconds} + ${listner.cavaDelta} - ${this.runTimeInfo.currentMillisecond}) > ${listner.threshold}`);\n\n        if (Math.abs(milliseconds + listner.cavaDelta - this.runTimeInfo.currentMillisecond) > listner.threshold) {\n          listner.funct(helper.roundNumberTo(milliseconds, listner.roundTo), this.runTimeInfo.state);\n          listner.cavaDelta = 0;\n        } else {\n          listner.cavaDelta += Math.abs(milliseconds - this.runTimeInfo.currentMillisecond);\n        }\n      }\n\n      this.runTimeInfo.currentMillisecond = milliseconds;\n    }\n  }, {\n    key: \"_setState\",\n    value: function _setState(newState) {\n      if (newState != this.runTimeInfo.state) {\n        this.runTimeInfo.state = newState;\n\n        for (var key in this.listeners) {\n          var listner = this.listeners[key];\n          listner.funct(this.runTimeInfo.currentMillisecond, newState);\n        }\n      }\n    } // execution methods\n\n  }, {\n    key: \"play\",\n    value: function play() {\n      var _this2 = this;\n\n      var debug = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      if (this.runTimeInfo.state === 'idle' || this.runTimeInfo.state === 'paused' || this.runTimeInfo.state === 'transitional') {\n        if (this.runTimeInfo.state === 'paused') {\n          var delta = new Date().getTime() - this.pauseMoment;\n          this.previousTimeStamp += delta;\n        }\n\n        this._setState('playing');\n\n        this.onPlay();\n\n        if (debug === false) {\n          window.requestAnimationFrame(function (timestamp) {\n            _this2.step(timestamp);\n          });\n        }\n      }\n    }\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      if (this.runTimeInfo.state === 'playing') {\n        this._setState('paused');\n\n        this.pauseMoment = new Date().getTime();\n        this.onWait();\n      }\n    }\n  }, {\n    key: \"complete\",\n    value: function complete() {\n      this._setState('idle');\n\n      this.previousTimeStamp = -1;\n      this.runTimeInfo.currentMillisecond = 0;\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this._setState('transitional');\n\n      this.previousTimeStamp = -1;\n    }\n  }, {\n    key: \"flash\",\n    value: function flash() {\n      for (var key in this.instantiatedChannels) {\n        var channel = this.instantiatedChannels[key];\n        channel.moveTo(0, this.runTimeInfo.currentMillisecond, this.id, true);\n      }\n    }\n  }, {\n    key: \"onPlay\",\n    value: function onPlay() {}\n  }, {\n    key: \"onWait\",\n    value: function onWait() {}\n  }, {\n    key: \"executionSpeed\",\n    set: function set(speed) {\n      this.speed = parseFloat(speed);\n    }\n  }, {\n    key: \"context\",\n    get: function get() {\n      return this.ownContext;\n    }\n  }]);\n\n  return ExtendableClip;\n}(Group);\n\nmodule.exports = ExtendableClip;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19DbGlwL0V4dGVuZGFibGVDbGlwLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvZGlzdC9fQ2xpcC9FeHRlbmRhYmxlQ2xpcC5qcz84MTVkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7IH1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2VcIik7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7IGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGl0ZXIpIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpdGVyKSA9PT0gXCJbb2JqZWN0IEFyZ3VtZW50c11cIikgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7IH1cblxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH0gfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxudmFyIEhlbHBlciA9IHJlcXVpcmUoJy4uL19jb3JlVXRpbHMvSGVscGVyJyk7XG5cbnZhciBoZWxwZXIgPSBuZXcgSGVscGVyKCk7XG5cbnZhciBHcm91cCA9IHJlcXVpcmUoJy4uL19CYXNlQ2xhc3Nlcy9Hcm91cCcpO1xuXG52YXIgc2VsZkNvbnRhaW5lZEluY2lkZW50c05wbU5hbWUgPSAnQGtpc3NteWJ1dHRvbi9zZWxmLWNvbnRhaW5lZC1pbmNpZGVudHMnOyAvLyBUT0RPIHJlbW92ZSB0aGlzXG5cbnZhciBfVFJFRUNPTlNUID0gcmVxdWlyZSgnLi4vX1RyZWUvX0NPTlNUJyk7XG5cbnZhciBFeHRlbmRhYmxlQ2xpcCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0dyb3VwKSB7XG4gIF9pbmhlcml0cyhFeHRlbmRhYmxlQ2xpcCwgX0dyb3VwKTtcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IHByb3BzIC0gYW4gb2JqZWN0IHRoYXQgc2hvdWxkIGNvbnRhaW4gYWxsIG9mIHRoZSBmb2xsb3dpbmcga2V5czpcbiAgICogLSBodG1sICh0aGUgaHRtbCB0ZW1wbGF0ZSB0byByZW5kZXIpXG4gICAqIC0gY3NzICh0aGUgY3NzIHRlbXBsYXRlIG9mIHRoZSBpc29sYXRlZCB0cmVlKVxuICAgKiAtIGluaXRQYXJhbXMgKG9wdGlvbmFsIC8gdGhlIGluaXRpYWxpc2F0aW9uIHBhcmFtZXRlcmVzIHRoYXQgd2lsbCBiZSBwYXNzZWQgYm90aCBvbiB0aGUgY3NzIGFuZCB0aGUgaHRtbCB0ZW1wbGF0ZXMgaW4gb3JkZXIgdG8gcmVuZGVyKVxuICAgKiAtIGhvc3QgKGFuIEVsZW1lbnQgb2JqZWN0IHRoYXQgd2lsbCBob3N0IHRoZSBpc29sYXRlZCB0cmVlKVxuICAgKiAtIGNvbnRhaW5lclBhcmFtcyAoYW4gb2JqZWN0IHRoYXQgaG9sZHMgcGFyYW1ldGVycyB0byBhZmZlY3QgdGhlIGNvbnRhaW5lciBvZiB0aGUgaXNvbGF0ZWQgdHJlZSwgZS5nLiB3aWR0aCwgaGVpZ2h0IGV0YylcbiAgICogLSB0eXBlIChvcHRpb25hbCwgZGVmYXVsdHMgdG8gXCJpZnJhbWVcIikgdGhlIHR5cGUgb2YgdGhlIENsaXAuIEl0IGNhbiBiZSBvbmUgb2YgdGhlOlxuICAgKiAgLSBpZnJhbWVcbiAgICogIC0gcGxhaW5cbiAgICovXG4gIGZ1bmN0aW9uIEV4dGVuZGFibGVDbGlwKGF0dHJzLCBwcm9wcykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFeHRlbmRhYmxlQ2xpcCk7XG5cbiAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihFeHRlbmRhYmxlQ2xpcCkuY2FsbCh0aGlzLCBhdHRycywgcHJvcHMpKTtcbiAgICBfdGhpcy5hdHRycyA9IGF0dHJzO1xuICAgIF90aGlzLnByb3BzID0gcHJvcHM7XG4gICAgX3RoaXMuaXNUaGVDbGlwID0gdHJ1ZTtcbiAgICBfdGhpcy52b2x1bWUgPSAxO1xuICAgIF90aGlzLnNwZWVkID0gMTtcbiAgICBfdGhpcy5ibG9ja2luZ1dhaXRpbmdzID0ge307XG4gICAgLyoqXG4gICAgICogVGhlIGNuYW5uZWxzIGF0dHJpYnV0ZSBob2xkcyBhIGxpc3Qgb2YgYWxsIGludGFudGlhdGVkIENoYW5uZWxzIG9mIHRoZSBJbmNpZGVudHMgYmVsb25naW5nIHRvIHRoZSBjbGlwXG4gICAgICogdGhpcyBhdHRyaWJ1dGUgaXMgb25seSB2YWx1YWJsZSB3aGVuIHRoZSBHcm91cCBiZWNvbWVzIHRoZSBDbGlwXG4gICAgICogVGhlIGZvcm1hdCBvZiB0aGUgYXR0cmlidXRlIGlzOlxuICAgICAqICBrZXktdmFsdWUgcGFpcnMgaW4gdGhlIG1hbm5lcjpcbiAgICAgKiA8bWNfcGx1Z2luX25wbV9uYW1lPjogQ2hhbm5lbCBvYmplY3RcbiAgICAgKi9cblxuICAgIF90aGlzLmluc3RhbnRpYXRlZENoYW5uZWxzID0ge307XG4gICAgLyoqXG4gICAgICogVGhlIGluc3RhbnRpYXRlZENvcGllc0NvbnRleHRzIGlzIGEga2V5LXZhbHVlIHBhaXJzIGNvbGxlY2l0b24gaG9sZGluZyB0aGVcbiAgICAgKiBjb250ZXh0cyBvZiBhbGwgaW5zdGFudGlhdGVkIENsaXBDb3BpZXNcbiAgICAgKiovXG5cbiAgICBfdGhpcy5pbnN0YW50aWF0ZWRDb3BpZXNDb250ZXh0cyA9IHt9O1xuXG4gICAgX3RoaXMub25DbGlwSW5pdGlhbGlzZSgpO1xuXG4gICAgX3RoaXMuZHVyYXRpb25TdWJzID0gW107XG4gICAgX3RoaXMucnVuVGltZUluZm8gPSB7XG4gICAgICBjdXJyZW50TWlsbGlzZWNvbmQ6IDAsXG4gICAgICBzdGF0ZTogJ2lkbGUnIC8vIHN1cHBvcnRlZCBzdGF0ZXM6IGlkbGUsIHBsYXlpbmcsIHBhdXNlZCwgYmxvY2tlZFxuXG4gICAgICAvKipcbiAgICAgICAgQG1lbWJlciB7b2JqZWN0fSAtIGxpc3RlbmVycyBhcmUgZnVuY3Rpb25zIHRvIGJlIGV4ZWN1dGVkIG9uIHRpbWUgY2hhbmdlIG9mIHRoZSBDbGlwLlxuICAgICAgICBJdCBoYXMgdGhlIGZvbGxvd2luZyBmb3JtYXQ6XG4gICAgICAgbGlzdGVuZXJzOiB7XG4gICAgICAgICAgbGlzdGVuZXJfaWQ6IHtcbiAgICAgICAgICAgICAgICAgICBmdW5jdCA6IHRoZSBmdW5jdGlvbiB0byBiZSBleGVjdXRlZFxuICAgICAgICAgICAgICAgICAgIHRocmVzaG9sZCA6IHRoZSB0aHJlc2hvbGQgb2YgZGVsdGFcbiAgICAgICAgICAgICAgICAgICByb3VuZFRvIDogcm91bmQgbWlsbGlzZWNvbmRcbiAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICBsaXN0ZW5lcl9pZDoge1xuICAgICAgICAgICAgICAgICAgIGZ1bmN0IDogdGhlIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkXG4gICAgICAgICAgICAgICAgICAgdGhyZXNob2xkIDogdGhlIHRocmVzaG9sZCBvZiBkZWx0YVxuICAgICAgICAgICAgICAgICAgIHJvdW5kVG8gOiByb3VuZCBtaWxsaXNlY29uZFxuICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgIC4uLlxuICAgICAgICAgfVxuICAgICAgICAgKi9cblxuICAgIH07XG4gICAgX3RoaXMubGlzdGVuZXJzID0ge307IC8vIHByZXZpb3VzVGltZVN0YW1wIGlzIGEgcHJvcGVydHkgaG9sZGluZyB0aGUgbGFzdCB0aW1lc3RhbXAgdGhhdCB0aGVcbiAgICAvLyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgcmFuXG5cbiAgICBfdGhpcy5wcmV2aW91c1RpbWVTdGFtcCA9IC0xO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhFeHRlbmRhYmxlQ2xpcCwgW3tcbiAgICBrZXk6IFwib25DbGlwSW5pdGlhbGlzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkNsaXBJbml0aWFsaXNlKCkgey8vIGNhbGxlZCB3aGVuIGdyb3VwIGdldHMgaW5pdGlhbGlzZWRcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkQ29udGV4dFwiLFxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgYmVlbiBjYWxsZWQgd2hlbiBhIG5ldyBDbGlwQ29weSBlbnRlcnMgdGhlIHJlYWwgdHJlZSBzdWNjZXNzZnVsbHkuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHREYXRhIC0ga2V5czogY2xpcElkLCBjb250ZXh0XG4gICAgICoqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRDb250ZXh0KGNvbnRleHREYXRhKSB7XG4gICAgICB0aGlzLmluc3RhbnRpYXRlZENvcGllc0NvbnRleHRzW2NvbnRleHREYXRhLmNsaXBJZF0gPSBjb250ZXh0RGF0YS5jb250ZXh0O1xuICAgICAgY29udGV4dERhdGEuaW5zdGFudGlhdGVkQ29waWVzQ29udGV4dHMgPSB0aGlzLmluc3RhbnRpYXRlZENvcGllc0NvbnRleHRzO1xuICAgICAgdmFyIHJlcyA9IHRoaXMucHV0TWVzc2FnZU9uUGlwZSgnYWRkQ29udGV4dCcsIGNvbnRleHREYXRhLCB7fSwge1xuICAgICAgICBzZWxmRXhlY3V0ZTogZmFsc2UsXG4gICAgICAgIGRpcmVjdGlvbjogX1RSRUVDT05TVC5fRElSRUNUSU9OUy5fRE9XTlxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICAvKlxuICAgIEV4dGVuZGFibGVDbGlwIChhcyBpdHMgbmFtZSBpbXBsaWVzKSBpcyBhIENsYXNzIHRoYXQgc2hvdWxkIGJlIGV4dGVuZGVkIGJ5XG4gICAgYW55IHNwZWNpZmljIGtpbmQgb2YgQ2xpcCwgc3VjaCBhcyBGcmFnbWVudGVkIG9yIFNDR3JvdXAuIFRoaXMgbWV0aG9kIG11c3RcbiAgICBiZSBvdmVyaXR0ZW4gYnkgdGhlIG5ldyBDbGFzc2VzLiBUaGlzIGRlZmluaXRpb24gaGVyZSBpcyBqdXN0IGZvciByZWZlcmVuY2UgLyBoZWxwXG4gICAgcHVycG9zZXNcbiAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZXhwb3J0Q29uc3RydWN0aW9uQXJndW1lbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV4cG9ydENvbnN0cnVjdGlvbkFyZ3VtZW50cygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGF0dHJzOiB0aGlzLmF0dHJzLFxuICAgICAgICBwcm9wczogdGhpcy5wcm9wc1xuICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogY29tcGxldGVseSByZXNpemVzIHRoZSBDbGlwIHdpdGhvdXQgYW55IGNoZWNrc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3Jlc2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVzaXplKGR1cmF0aW9uRnJhY3Rpb24pIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmluc3RhbnRpYXRlZENoYW5uZWxzKSB7XG4gICAgICAgIHRoaXMuaW5zdGFudGlhdGVkQ2hhbm5lbHNba2V5XS5fcmVzaXplKGR1cmF0aW9uRnJhY3Rpb24pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNldE5ld0R1cmF0aW9uKHRoaXMuZHVyYXRpb24gKiBkdXJhdGlvbkZyYWN0aW9uKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmR1cmF0aW9uU3Vicy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLmR1cmF0aW9uU3Vic1tpXSh0aGlzLmR1cmF0aW9uKTtcbiAgICAgIH1cbiAgICB9IC8vICoqKioqKioqKioqKiBQVUIgU1VCICoqKioqKioqKioqKioqKioqKioqXG4gICAgLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuICAgIC8qKlxuICAgICAgQnkgc3Vic2NyaWJpbmcgYSBtb2R1bGUgY2FuIGdldCBub3RpZmllZCBhYm91dCBjaGFuZ2VzIG9uIHRoZSBDbGlwJ3MgdGltZVxuICAgICAgc3Vic2NyaWJlIG1ldGhvZCBzdWJzY3JpYmVzIGEgZnVuY3Rpb24gdG8gdGhlIHRpbWUgY2hhbmdlIGRpc3BhdGNoZXIuIEFzIENsaXAgdXNlcyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgZm9yIGl0cyB0aW1pbmdcbiAgICAgIGVhY2ggY3lyY2xlIC8gc3RlcCBnZXRzIHRoZSBjdXJyZW50IHRpbWUgYW5kIHN1YnRyYWN0cyB0aGUgcHJldmlvdXMgdGltZSBzbyBpdCBrbm93IGhvdyBtYW55IG1pbGxpc2Vjb25kcyBoYXMgZWxhcHNlZFxuICAgICAgc2luY2UgbGFzdCBzdGVwLiBTdWJzY3JpYmVycyBjYW4gc2V0IHRvIGdldCBpbmZvcm1lZCBhYm91dCB0aW1lIGNoYW5nZXMgb25seSBpZiB0aGUgZGVsdGEgaXMgZ3JlYXRlciB0aGFuIGEgZ2l2ZW5cbiAgICAgIG51bWJlciAoZS5nLiBncmVhdGVyIHRoYW4gMzAwbXMpLiBUaGF0IHByb3BlcnR5IGlzIHBhc3NlZCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IFwidGhyZXNob2xkXCIuXG4gICAgICBGaW5hbGx5IGlmIGFueSBvZiB0aGUgc3Vic2NyaWJlcnMgd2FudCB0aGUgU2NlbmUgdG8gcHJvdmlkZSBiYWNrIGEgcm91bmRlZCBudW1iZXIgb2YgdGhlIG1pbGxpc2Vjb25kcy4gT3B0aW9uczpcbiAgICAgICAgLSAxIChyb3VuZCBpdCBvbiBpdHMgYWN0dWFsIHVuaXRzXG4gICAgICAgLSAxMCAocm91bmQgaXQgb24gdGVudGhzKVxuICAgICAgIC0gMTAwIChyb3VuZCBpdCBvbiBodW5kcmVkcylcbiAgICAgICAtIDEwMDAgKHJvdW5kIGl0IG9uIHRob3VzYW5kcylcbiAgICAgIHRoZSBmaXJzdCBhcmd1bWVudCBwcm92aWRlcyBhbiBpZCB0byB0aGUgbGlzdGVuZXIgZm9yIGZ1dHVyZSByZWZlcmVuY2UgKGRlbGV0aW9uIGV0YylcbiAgICAgIHRoZSBzZWNvbmQgYXJndW1lbnQgaXMgYSBmdW5jdGlvbiB0aGF0IHRha2VzIHR3byBhcmd1bWVudHM6IG1pbGxpc2Vjb25kLCBzdGF0ZSAoY3VycmVudCBtaWxsaXNlY29uZCBvZiB0aGUgU2NlbmVcbiAgICAgIGFuZCB0aGUgc3RhdGUgb2YgaXQgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzdWJzY3JpYmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3Vic2NyaWJlKGlkLCBmdW5jdCwgdGhyZXNob2xkLCByb3VuZFRvKSB7XG4gICAgICBpZiAoIXRocmVzaG9sZCkge1xuICAgICAgICB0aHJlc2hvbGQgPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXJvdW5kVG8pIHtcbiAgICAgICAgcm91bmRUbyA9IDE7IC8vIHJvdW5kIHNlY29uZCB0byBpdHMgdW5pdHMsIG1lYW5pbmcgbGVhdmUgaXQgYXMgaXQgaXNcbiAgICAgIH1cblxuICAgICAgdGhpcy5saXN0ZW5lcnNbaWRdID0ge1xuICAgICAgICBmdW5jdDogZnVuY3QsXG4gICAgICAgIHRocmVzaG9sZDogdGhyZXNob2xkLFxuICAgICAgICByb3VuZFRvOiByb3VuZFRvLFxuICAgICAgICBjYXZhRGVsdGE6IDBcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVuc3Vic2NyaWJlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVuc3Vic2NyaWJlKGlkKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMubGlzdGVuZXJzLCBpZCkpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMubGlzdGVuZXJzW2lkXTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgIEVkaXRpbmcgY29tbWFuZHMgaW5wdXQgbWV0aG9kc1xuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgIC8qKlxuICAgICAqIFRoaXMgY29tbWFuZCBjb21lcyBmb3JtIHRoZSBDbGlwJ3MgcGFyZW50IERlc2NyaXB0b3IgY2xhc3MuIFRoZSBwYXlsb2FkXG4gICAgICogaXMgaWRlbnRpY2FsIHRvIHRoZSBwYXlsb2FkIHRoYXQgY29tZXMgdG8gdGhlIERlc2NyaXB0aW9uIGNsYXNzOlxuICAgICAqIHtcbiAgICAgKiAgaW5jaWRlbnQ6IHRoZSBEZXNjcmlwdGl2ZSBJbmNpZGVudCB0byBiZSBhZGRlZFxuICAgICAqICBtaWxsaXNlY29uZDogdGhlIG1pbGxpc2Vjb25kIHRvIGFkZCBpdFxuICAgICAqICBwYXJlbnRHcm91cElkOiB0aGUgaWQgb2YgdGhlIEdyb3VwIHRvIHdoaWNoIHdlIHdhbnQgdG8gdGhlIEluY2lkZW50IHRvXG4gICAgICogfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkSW5jaWRlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkSW5jaWRlbnQocGF5bG9hZCkge1xuICAgICAgdmFyIGNhbmRpZGF0ZXMgPSB0aGlzLnB1dE1lc3NhZ2VPblBpcGUoJ2FkZEluY2lkZW50Jywge1xuICAgICAgICBpbmNpZGVudDogcGF5bG9hZC5pbmNpZGVudCxcbiAgICAgICAgbWlsbGlzZWNvbmQ6IHBheWxvYWQubWlsbGlzZWNvbmQsXG4gICAgICAgIHBhcmVudEdyb3VwSWQ6IHBheWxvYWQucGFyZW50R3JvdXBJZCxcbiAgICAgICAgY29udGV4dERhdGE6IHtcbiAgICAgICAgICBjbGlwSWQ6IHRoaXMuaWQsXG4gICAgICAgICAgY29udGV4dDogdGhpcy5jb250ZXh0XG4gICAgICAgIH1cbiAgICAgIH0sIHBheWxvYWQucGFyZW50R3JvdXBJZCwge1xuICAgICAgICBzZWxmRXhlY3V0ZTogdHJ1ZSxcbiAgICAgICAgZGlyZWN0aW9uOiBfVFJFRUNPTlNULl9ESVJFQ1RJT05TLl9ET1dOXG4gICAgICB9KTsgLy8gY29uY2F0ZW5hdGUgY2FuZGlkYXRlc1xuICAgICAgLy8gY29uc29sZS5sb2coY2FuZGlkYXRlcyk7XG5cbiAgICAgIHZhciB0b3RhbEluY2lkZW50c0J5UGx1Z2luID0ge307XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2FuZGlkYXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgaW5jaWRlbnRzQnlQbHVnaW4gPSBjYW5kaWRhdGVzW2ldLnJlc3BvbnNlLmdldEluY2lkZW50c0J5Q2hhbm5lbChjYW5kaWRhdGVzW2ldLnBvc2l0aW9uRGVsdGEgKyBwYXlsb2FkLm1pbGxpc2Vjb25kKTtcblxuICAgICAgICBmb3IgKHZhciBwbHVnaW5OYW1lIGluIGluY2lkZW50c0J5UGx1Z2luKSB7XG4gICAgICAgICAgdmFyIF90b3RhbEluY2lkZW50c0J5UGx1ZztcblxuICAgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRvdGFsSW5jaWRlbnRzQnlQbHVnaW4sIHBsdWdpbk5hbWUpKSB7XG4gICAgICAgICAgICB0b3RhbEluY2lkZW50c0J5UGx1Z2luW3BsdWdpbk5hbWVdID0gW107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgKF90b3RhbEluY2lkZW50c0J5UGx1ZyA9IHRvdGFsSW5jaWRlbnRzQnlQbHVnaW5bcGx1Z2luTmFtZV0pLnB1c2guYXBwbHkoX3RvdGFsSW5jaWRlbnRzQnlQbHVnLCBfdG9Db25zdW1hYmxlQXJyYXkoaW5jaWRlbnRzQnlQbHVnaW5bcGx1Z2luTmFtZV0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgcmVzID0gdGhpcy5jaGVja0FkZGl0aW9uKHRvdGFsSW5jaWRlbnRzQnlQbHVnaW4pO1xuXG4gICAgICBpZiAocmVzLnJlc3VsdCA9PT0gdHJ1ZSkge1xuICAgICAgICByZXMuZXhlY3V0ZSgpOyAvLyB1cCB0byB0aGF0IHBvaW50IHRoZSBvbmx5IGNvbnRleHQgSW5jaWRlbnQgdGhhdCBoYXMgYmVlbiBpbml0aWFsaXNlZCBvbiB0aGVcbiAgICAgICAgLy8gQ29udGV4dEF3YXJlSW5jaWRlbnRzIG9mIHRoZSBjYW5kaWRhdGVzIGlzIHRoZSBvcmlnaW5hbCBjb250ZXh0IG9mIHRoZVxuICAgICAgICAvLyBFeHRlbmRhYmxlQ2xpcC5cblxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgY2FuZGlkYXRlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICBjYW5kaWRhdGVzW19pXS5yZXNwb25kZXIuYWRkQ2hpbGQoY2FuZGlkYXRlc1tfaV0ucmVzcG9uc2UsIHBheWxvYWQubWlsbGlzZWNvbmQpOyAvLyByZWNhbGN1bGF0ZSBkdXJhdGlvbiB0aGUgZ3JvdXBzIHRoYXQgd2UgYWRkZWRcbiAgICAgICAgICAvLyB0aGUgaW5jaWRlbnRzIHRvIGFsb25nIHdpdGggdGhlaXIgcGFyZW50c1xuXG5cbiAgICAgICAgICBjYW5kaWRhdGVzW19pXS5yZXNwb25kZXIucHV0TWVzc2FnZU9uUGlwZSgncmVjYWxjRHVyYXRpb24nLCB7fSwgJ0dyb3VwcycsIHtcbiAgICAgICAgICAgIHNlbGZFeGVjdXRlOiB0cnVlLFxuICAgICAgICAgICAgZGlyZWN0aW9uOiBfVFJFRUNPTlNULl9ESVJFQ1RJT05TLl9VUFxuICAgICAgICAgIH0pOyAvLyB3ZSBhbHNvIG5lZWQgdG8gYWRkIGV2ZXJ5IGV4aXN0aW5nIChjb3BpZWQpIGNvbnRleHQgdG8gdGhlIENvbnRleHRBd2FyZUluY2lkZW50c1xuICAgICAgICAgIC8vIGNyZWF0ZWQgb24gdGhlIGNhbmRpZGF0ZXMgcHJvY2Vzc1xuXG5cbiAgICAgICAgICBmb3IgKHZhciBjb250ZXh0S2V5IGluIHRoaXMuaW5zdGFudGlhdGVkQ29waWVzQ29udGV4dHMpIHtcbiAgICAgICAgICAgIGNhbmRpZGF0ZXNbX2ldLnJlc3BvbmRlci5wdXRNZXNzYWdlT25QaXBlKCdhZGRDb250ZXh0Jywge1xuICAgICAgICAgICAgICBjbGlwSWQ6IGNvbnRleHRLZXksXG4gICAgICAgICAgICAgIGNvbnRleHQ6IHRoaXMuaW5zdGFudGlhdGVkQ29waWVzQ29udGV4dHNbY29udGV4dEtleV1cbiAgICAgICAgICAgIH0sICdDb250ZXh0QXdhcmVJbmNpZGVudHMnLCB7XG4gICAgICAgICAgICAgIHNlbGZFeGVjdXRlOiBmYWxzZSxcbiAgICAgICAgICAgICAgZGlyZWN0aW9uOiBfVFJFRUNPTlNULl9ESVJFQ1RJT05TLl9ET1dOXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlcztcbiAgICB9IC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAvLyBJTkNJREVOVFMgTUFOQUdFTUVOVCBNRVRIT0RTXG4gICAgLy8gUE9MWU1PUlBISVNNIEFQUExJRUQuIElGIFRIRSBHUk9VUCBIQVMgTk8gUEFSRU5UIElUIEFDVFMgQVMgQSBTQ0VORS4gSUYgVEhFIEdST1VQIEhBUyBQQVJFTlQgSVQgQUNUUyBBU1xuICAgIC8vIEEgXCJUUkFOU1BBUkVOVCBHUk9VUFwiXG5cbiAgICAvKipcbiAgICAgKiBUaGUgbWV0aG9kIHJldHVybnMgZWl0aGVyOlxuICAgICAgICB7XG4gICAgICAgICAgICByZXN1bHQ6dHJ1ZSxcbiAgICAgICAgICAgIGV4ZWN1dGU6IC8vIGFuIGFycmF5IG9mIGZ1bmN0aW9ucyB0aGF0IHdoZW4gZXhlY3V0ZWQgaXQgd2lsbCBhZGQgdGhlIEluY2lkZW50cyBvbiB0aGUgQ2hhbm5lbHNcbiAgICAgICAgfVxuICAgICAgICBvclxuICAgICAgICB7XG4gICAgICAgICAgICByZXN1bHQ6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3JzXG4gICAgICAgIH1cbiAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY2hlY2tBZGRpdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja0FkZGl0aW9uKGluY2lkZW50c0J5SWQpIHtcbiAgICAgIHZhciB0eXBlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBcImFsbC1vci1ub3RoaW5nXCI7XG4gICAgICAvLyBwcmVwYXJlIHRoZSByZXR1cm4gcGF5bG9hZFxuICAgICAgdmFyIHRvUmV0dXJuUmVzdWx0ID0gdHJ1ZTtcbiAgICAgIHZhciB0b1JldHVybkVycm9ycyA9IFtdO1xuICAgICAgdmFyIHRvUmV0dXJuRXhlY3V0YWJsZXMgPSBbXTsgLy8gZm9yIGVhY2gga2V5IG9mIHRoZSBpbmNpZGVudHNCeUlkIG9iamVjdCBwZXJmb3JtIHRoZSBjaGVja1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gaW5jaWRlbnRzQnlJZCkge1xuICAgICAgICAvLyBpZiB0aGUgY2xpcCBoYWQgbm8gY2hhbm5lbCBpbnN0YW50aWF0ZWQgZm9yIHRoZSBzcGVjaWZpYyBrZXkgKHBsdWdpbiBpZCkgeWV0IGNyZWF0ZSBpdFxuICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmluc3RhbnRpYXRlZENoYW5uZWxzLCBrZXkpKSB7XG4gICAgICAgICAgLy8gaW50c3RhbnRpYXRlIHRoZSBjaGFubmVsIG9mIHRoZSBwbHVnaW4gYnkgdXNpbmcgdGhlIHJlZmVyZW5jZSB0byB0aGUgY2xhc3MgZGVmaW5pdGlvbiBzdG9yZWQgb25cbiAgICAgICAgICAvLyB0aGUgdmVyeSBmaXJzdCBpbmNpZGVudCBvZiB0aGUgYXJyYXlcbiAgICAgICAgICB0aGlzLmluc3RhbnRpYXRlZENoYW5uZWxzW2tleV0gPSBuZXcgaW5jaWRlbnRzQnlJZFtrZXldWzBdLmluY2lkZW50LnBsdWdpbl9jaGFubmVsX2NsYXNzKHtcbiAgICAgICAgICAgIHJ1blRpbWVJbmZvOiB0aGlzLnJ1blRpbWVJbmZvLFxuICAgICAgICAgICAgY29udGV4dDogdGhpcy5jb250ZXh0LFxuICAgICAgICAgICAgZ2V0SW5jaWRlbnRCeUlkOiB0aGlzLmdldEluY2lkZW50QnlJZFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IC8vIHBlcmZvcm0gdGhlIGNoZWNrXG5cblxuICAgICAgICB2YXIgcGx1Z2luUmVzdWx0ID0gdGhpcy5pbnN0YW50aWF0ZWRDaGFubmVsc1trZXldLmFkZEluY2lkZW50cyhpbmNpZGVudHNCeUlkW2tleV0sIHR5cGUpO1xuICAgICAgICB0b1JldHVyblJlc3VsdCA9IHRvUmV0dXJuUmVzdWx0ICYmIHBsdWdpblJlc3VsdC5yZXN1bHQ7XG5cbiAgICAgICAgaWYgKHBsdWdpblJlc3VsdC5yZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgdG9SZXR1cm5FcnJvcnMgPSB0b1JldHVybkVycm9ycy5jb25jYXQocGx1Z2luUmVzdWx0LmVycm9ycyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG9SZXR1cm5FeGVjdXRhYmxlcy5wdXNoKHBsdWdpblJlc3VsdC5leGVjdXRlKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBlbmYgb2YgaXRlcmF0aW9uIG9uIHRoZSBpbmNpZGVudHNCeUlkIGtleXNcblxuXG4gICAgICB2YXIgdG9SZXR1cm5FeGVjdXRlID0gZnVuY3Rpb24gdG9SZXR1cm5FeGVjdXRlKCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvUmV0dXJuRXhlY3V0YWJsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0b1JldHVybkV4ZWN1dGFibGVzW2ldKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhciBhZGRpdGlvblJlc3VsdCA9IHtcbiAgICAgICAgcmVzdWx0OiB0b1JldHVyblJlc3VsdCxcbiAgICAgICAgZXJyb3JzOiB0b1JldHVybkVycm9ycyxcbiAgICAgICAgZXhlY3V0ZTogdG9SZXR1cm5FeGVjdXRlXG4gICAgICB9O1xuICAgICAgcmV0dXJuIGFkZGl0aW9uUmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGNvbW1hbmQgY29tZXMgZm9ybSB0aGUgQ2xpcCdzIHBhcmVudCBEZXNjcmlwdG9yIGNsYXNzLiBUaGUgcGF5bG9hZFxuICAgICAqIGlzIGlkZW50aWNhbCB0byB0aGUgcGF5bG9hZCB0aGF0IGNvbWVzIHRvIHRoZSBEZXNjcmlwdGlvbiBjbGFzczpcbiAgICAgKiB7XG4gICAgICogIGluY2lkZW50OiB0aGUgRGVzY3JpcHRpdmUgSW5jaWRlbnQgdG8gYmUgcmVwb3NpdGlvbmVkXG4gICAgICogIG1pbGxpc2Vjb25kOiB0aGUgbmV3IG1pbGxpc2Vjb25kIHRvIHB1dCBpdFxuICAgICAqICBwYXJlbnRHcm91cElkOiB0aGUgaWQgb2YgdGhlXG4gICAgICogfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibW92ZUluY2lkZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1vdmVJbmNpZGVudChwYXlsb2FkKSB7XG4gICAgICB2YXIgY2FuZGlkYXRlcyA9IHRoaXMucHV0TWVzc2FnZU9uUGlwZSgnbW92ZUluY2lkZW50Jywge1xuICAgICAgICBpbmNpZGVudElkOiBwYXlsb2FkLmlkLFxuICAgICAgICBtaWxsaXNlY29uZDogcGF5bG9hZC5taWxsaXNlY29uZCxcbiAgICAgICAgcGFyZW50R3JvdXBJZDogcGF5bG9hZC5wYXJlbnRHcm91cElkLFxuICAgICAgICBjb250ZXh0RGF0YToge1xuICAgICAgICAgIGNsaXBJZDogdGhpcy5pZCxcbiAgICAgICAgICBjb250ZXh0OiB0aGlzLmNvbnRleHRcbiAgICAgICAgfVxuICAgICAgfSwgcGF5bG9hZC5wYXJlbnRHcm91cElkLCB7XG4gICAgICAgIHNlbGZFeGVjdXRlOiB0cnVlLFxuICAgICAgICBkaXJlY3Rpb246IF9UUkVFQ09OU1QuX0RJUkVDVElPTlMuX0RPV05cbiAgICAgIH0pO1xuICAgICAgdmFyIHRvdGFsSW5jaWRlbnRzQnlQbHVnaW4gPSB7fTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYW5kaWRhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBpbmNpZGVudHNCeVBsdWdpbiA9IGNhbmRpZGF0ZXNbaV0ucmVzcG9uc2UuZ2V0SW5jaWRlbnRzQnlDaGFubmVsKGNhbmRpZGF0ZXNbaV0ucG9zaXRpb25EZWx0YSArIHBheWxvYWQubWlsbGlzZWNvbmQpO1xuXG4gICAgICAgIGZvciAodmFyIHBsdWdpbk5hbWUgaW4gaW5jaWRlbnRzQnlQbHVnaW4pIHtcbiAgICAgICAgICB2YXIgX3RvdGFsSW5jaWRlbnRzQnlQbHVnMjtcblxuICAgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRvdGFsSW5jaWRlbnRzQnlQbHVnaW4sIHBsdWdpbk5hbWUpKSB7XG4gICAgICAgICAgICB0b3RhbEluY2lkZW50c0J5UGx1Z2luW3BsdWdpbk5hbWVdID0gW107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgKF90b3RhbEluY2lkZW50c0J5UGx1ZzIgPSB0b3RhbEluY2lkZW50c0J5UGx1Z2luW3BsdWdpbk5hbWVdKS5wdXNoLmFwcGx5KF90b3RhbEluY2lkZW50c0J5UGx1ZzIsIF90b0NvbnN1bWFibGVBcnJheShpbmNpZGVudHNCeVBsdWdpbltwbHVnaW5OYW1lXSkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciByZXMgPSB0aGlzLmNoZWNrTW92ZSh0b3RhbEluY2lkZW50c0J5UGx1Z2luLCBwYXlsb2FkLnBvc2l0aW9uRGVsdGEpO1xuXG4gICAgICBpZiAocmVzLnJlc3VsdCA9PT0gdHJ1ZSkge1xuICAgICAgICByZXMuZXhlY3V0ZSgpO1xuXG4gICAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IGNhbmRpZGF0ZXMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICAgIGNhbmRpZGF0ZXNbX2kyXS5yZXNwb25kZXIuZWRpdFBvc2l0aW9uKGNhbmRpZGF0ZXNbX2kyXS5yZXNwb25zZS5pZCwgcGF5bG9hZC5taWxsaXNlY29uZCk7IC8vIHJlY2FsY3VsYXRlIGR1cmF0aW9uIHRoZSBncm91cHMgdGhhdCB3ZSBhZGRlZFxuICAgICAgICAgIC8vIHRoZSBpbmNpZGVudHMgdG8gYWxvbmcgd2l0aCB0aGVpciBwYXJlbnRzXG5cblxuICAgICAgICAgIGNhbmRpZGF0ZXNbX2kyXS5yZXNwb25kZXIucHV0TWVzc2FnZU9uUGlwZSgncmVjYWxjRHVyYXRpb24nLCB7fSwgJ0dyb3VwcycsIHtcbiAgICAgICAgICAgIHNlbGZFeGVjdXRlOiB0cnVlLFxuICAgICAgICAgICAgZGlyZWN0aW9uOiBfVFJFRUNPTlNULl9ESVJFQ1RJT05TLl9VUFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBjaGVja0VkaXQgbWV0aG9kIHNlcnZlcyBleGFjdGx5IHdoYXQgaXRzIG5hbWUgaW1wbGllcy4gVG8gY2hlY2sgaWYgdGhlIGVkaXQgb2YgYW4gSW5jaWRlbnQgKGVkaXQgb2YgSW5jaWRlbnQncyBwb3NpdGlvbiBnaXZlbiBpbiBtaWxsaXNlY29uZHMgZGVsdGEpXG4gICAgICogaXMgdmFsaWQgYW5kIGFjY2VwdGVkLCBhY2NvcmRpbmcgdG8gdGhlIHJ1bGVzIGRlZmluZWQgb24gdGhlIGNoYW5uZWxzLlxuICAgICAqIFRoZSBtZXRob2QgYm9vYmxlcyB1cCB1bnRpbCBpdCByZWFjaGVzIHRoZSBDbGlwLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBpbmNpZGVudCAtIHRoZSBpbmNpZGVudCB0byBlZGl0XG4gICAgICogQHBhcmFtIHtpbnR9IG1pbGxpc2Vjb25kc0RlbHRhIC0gdGhlIG1pbGxpc2Vjb25kcyBkZWx0YSBvZiB0aGUgSW5jaWRlbnQncyBzdGFydCB0aW1lXG4gICAgIFRoZSBtZXRob2Qgc2hvdWxkIHJldHVybiBlaXRoZXI6XG4gICAgICAgIHtcbiAgICAgICAgICAgIHJlc3VsdDp0cnVlLFxuICAgICAgICAgICAgZXhlY3V0ZTogLy8gYW4gYXJyYXkgb2YgZnVuY3Rpb25zIHRoYXQgd2hlbiBleGVjdXRlZCBpdCB3aWxsIGVkaXQgdGhlIEluY2lkZW50cyBvbiB0aGUgQ2hhbm5lbHNcbiAgICAgICAgfVxuICAgICAgICBvclxuICAgICAgICB7XG4gICAgICAgICAgICByZXN1bHQ6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3JzXG4gICAgICAgIH1cbiAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY2hlY2tNb3ZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrTW92ZShpbmNpZGVudHNCeUlkLCBtaWxsaXNlY29uZHNEZWx0YSkge1xuICAgICAgLy8gcHJlcGFyZSB0aGUgcmV0dXJuIHBheWxvYWRcbiAgICAgIHZhciB0b1JldHVyblJlc3VsdCA9IHRydWU7XG4gICAgICB2YXIgdG9SZXR1cm5FcnJvcnMgPSBbXTtcbiAgICAgIHZhciB0b1JldHVybkV4ZWN1dGFibGVzID0gW107IC8vIGZvciBlYWNoIGtleSBvZiB0aGUgaW5jaWRlbnRzQnlJZCBvYmplY3QgcGVyZm9ybSB0aGUgY2hlY2tcblxuICAgICAgZm9yICh2YXIga2V5IGluIGluY2lkZW50c0J5SWQpIHtcbiAgICAgICAgLy8gcGVyZm9ybSB0aGUgY2hlY2tcbiAgICAgICAgdmFyIHBsdWdpblJlc3VsdCA9IHRoaXMuaW5zdGFudGlhdGVkQ2hhbm5lbHNba2V5XS5lZGl0SW5jaWRlbnRzKGluY2lkZW50c0J5SWRba2V5XSwgbWlsbGlzZWNvbmRzRGVsdGEpO1xuICAgICAgICB0b1JldHVyblJlc3VsdCA9IHRvUmV0dXJuUmVzdWx0ICYmIHBsdWdpblJlc3VsdC5yZXN1bHQ7XG5cbiAgICAgICAgaWYgKHBsdWdpblJlc3VsdC5yZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgdG9SZXR1cm5FcnJvcnMgPSB0b1JldHVybkVycm9ycy5jb25jYXQocGx1Z2luUmVzdWx0LmVycm9ycyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG9SZXR1cm5FeGVjdXRhYmxlcy5wdXNoKHBsdWdpblJlc3VsdC5leGVjdXRlKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBlbmYgb2YgaXRlcmF0aW9uIG9uIHRoZSBpbmNpZGVudHNCeUlkIGtleXNcblxuXG4gICAgICB2YXIgdG9SZXR1cm5FeGVjdXRlID0gZnVuY3Rpb24gdG9SZXR1cm5FeGVjdXRlKCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvUmV0dXJuRXhlY3V0YWJsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0b1JldHVybkV4ZWN1dGFibGVzW2ldKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhciBlZGl0UmVzdWx0ID0ge1xuICAgICAgICByZXN1bHQ6IHRvUmV0dXJuUmVzdWx0LFxuICAgICAgICBlcnJvcnM6IHRvUmV0dXJuRXJyb3JzLFxuICAgICAgICBleGVjdXRlOiB0b1JldHVybkV4ZWN1dGVcbiAgICAgIH07XG4gICAgICByZXR1cm4gZWRpdFJlc3VsdDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlSW5jaWRlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlSW5jaWRlbnQocGF5bG9hZCkge1xuICAgICAgdmFyIGNhbmRpZGF0ZXMgPSB0aGlzLnB1dE1lc3NhZ2VPblBpcGUoJ3JlbW92ZUluY2lkZW50Jywge1xuICAgICAgICBpbmNpZGVudElkOiBwYXlsb2FkLmlkLFxuICAgICAgICBwYXJlbnRHcm91cElkOiBwYXlsb2FkLnBhcmVudEdyb3VwSWQsXG4gICAgICAgIGNvbnRleHREYXRhOiB7XG4gICAgICAgICAgY2xpcElkOiB0aGlzLmlkLFxuICAgICAgICAgIGNvbnRleHQ6IHRoaXMuY29udGV4dFxuICAgICAgICB9XG4gICAgICB9LCBwYXlsb2FkLnBhcmVudEdyb3VwSWQsIHtcbiAgICAgICAgc2VsZkV4ZWN1dGU6IHRydWUsXG4gICAgICAgIGRpcmVjdGlvbjogX1RSRUVDT05TVC5fRElSRUNUSU9OUy5fRE9XTlxuICAgICAgfSk7XG4gICAgICB2YXIgdG90YWxJbmNpZGVudHNCeVBsdWdpbiA9IHt9O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbmRpZGF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGluY2lkZW50c0J5UGx1Z2luID0gY2FuZGlkYXRlc1tpXS5yZXNwb25zZS5nZXRJbmNpZGVudHNCeUNoYW5uZWwoKTtcblxuICAgICAgICBmb3IgKHZhciBwbHVnaW5OYW1lIGluIGluY2lkZW50c0J5UGx1Z2luKSB7XG4gICAgICAgICAgdmFyIF90b3RhbEluY2lkZW50c0J5UGx1ZzM7XG5cbiAgICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0b3RhbEluY2lkZW50c0J5UGx1Z2luLCBwbHVnaW5OYW1lKSkge1xuICAgICAgICAgICAgdG90YWxJbmNpZGVudHNCeVBsdWdpbltwbHVnaW5OYW1lXSA9IFtdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIChfdG90YWxJbmNpZGVudHNCeVBsdWczID0gdG90YWxJbmNpZGVudHNCeVBsdWdpbltwbHVnaW5OYW1lXSkucHVzaC5hcHBseShfdG90YWxJbmNpZGVudHNCeVBsdWczLCBfdG9Db25zdW1hYmxlQXJyYXkoaW5jaWRlbnRzQnlQbHVnaW5bcGx1Z2luTmFtZV0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgcmVzID0gdGhpcy5jaGVja0RlbGV0ZSh0b3RhbEluY2lkZW50c0J5UGx1Z2luKTtcblxuICAgICAgaWYgKHJlcy5yZXN1bHQgPT09IHRydWUpIHtcbiAgICAgICAgcmVzLmV4ZWN1dGUoKTtcblxuICAgICAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBjYW5kaWRhdGVzLmxlbmd0aDsgX2kzKyspIHtcbiAgICAgICAgICBjYW5kaWRhdGVzW19pM10ucmVzcG9uZGVyLnJlbW92ZUNoaWxkKGNhbmRpZGF0ZXNbX2kzXS5yZXNwb25zZS5pZCk7IC8vIHJlY2FsY3VsYXRlIGR1cmF0aW9uIHRoZSBncm91cHMgdGhhdCB3ZSBhZGRlZFxuICAgICAgICAgIC8vIHRoZSBpbmNpZGVudHMgdG8gYWxvbmcgd2l0aCB0aGVpciBwYXJlbnRzXG5cblxuICAgICAgICAgIGNhbmRpZGF0ZXNbX2kzXS5yZXNwb25kZXIucHV0TWVzc2FnZU9uUGlwZSgncmVjYWxjRHVyYXRpb24nLCB7fSwgJ0dyb3VwcycsIHtcbiAgICAgICAgICAgIHNlbGZFeGVjdXRlOiB0cnVlLFxuICAgICAgICAgICAgZGlyZWN0aW9uOiBfVFJFRUNPTlNULl9ESVJFQ1RJT05TLl9VUFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBjaGVja0RlbGV0ZSBtZXRob2Qgc2VydmVzIGV4YWN0bHkgd2hhdCBpdHMgbmFtZSBpbXBsaWVzLiBUbyBjaGVjayBpZiB0aGUgZGVsZXRpb24gb2YgYW4gSW5jaWRlbnRcbiAgICAgKiBpcyB2YWxpZCBhbmQgYWNjZXB0ZWQsIGFjY29yZGluZyB0byB0aGUgcnVsZXMgZGVmaW5lZCBvbiB0aGUgY2hhbm5lbHMuXG4gICAgICogVGhlIG1ldGhvZCBib29ibGVzIHVwIHVudGlsIGl0IHJlYWNoZXMgdGhlIENsaXAuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGluY2lkZW50IC0gdGhlIGluY2lkZW50IHRvIGVkaXRcbiAgICAgIFRoZSByZXN1bHQgbWlnaHQgYmUgZWl0aGVyOlxuICAgICAgICB7XG4gICAgICAgICAgICByZXN1bHQ6dHJ1ZSxcbiAgICAgICAgICAgIGV4ZWN1dGU6IC8vIGFuIGFycmF5IG9mIGZ1bmN0aW9ucyB0aGF0IHdoZW4gZXhlY3V0ZWQgaXQgd2lsbCByZW1vdmUgdGhlIEluY2lkZW50IG9uIHRoZSBDaGFubmVsc1xuICAgICAgICB9XG4gICAgICAgIG9yXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJlc3VsdDogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcnNcbiAgICAgICAgfVxuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjaGVja0RlbGV0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja0RlbGV0ZShpbmNpZGVudHNCeUlkKSB7XG4gICAgICAvLyBwcmVwYXJlIHRoZSByZXR1cm4gcGF5bG9hZFxuICAgICAgdmFyIHRvUmV0dXJuUmVzdWx0ID0gdHJ1ZTtcbiAgICAgIHZhciB0b1JldHVybkVycm9ycyA9IFtdO1xuICAgICAgdmFyIHRvUmV0dXJuRXhlY3V0YWJsZXMgPSBbXTsgLy8gZm9yIGVhY2gga2V5IG9mIHRoZSBpbmNpZGVudHNCeUlkIG9iamVjdCBwZXJmb3JtIHRoZSBjaGVja1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gaW5jaWRlbnRzQnlJZCkge1xuICAgICAgICAvLyBwZXJmb3JtIHRoZSBjaGVja1xuICAgICAgICB2YXIgcGx1Z2luUmVzdWx0ID0gdGhpcy5pbnN0YW50aWF0ZWRDaGFubmVsc1trZXldLnJlbW92ZUluY2lkZW50cyhpbmNpZGVudHNCeUlkW2tleV0pO1xuICAgICAgICB0b1JldHVyblJlc3VsdCA9IHRvUmV0dXJuUmVzdWx0ICYmIHBsdWdpblJlc3VsdC5yZXN1bHQ7XG5cbiAgICAgICAgaWYgKHBsdWdpblJlc3VsdC5yZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgdG9SZXR1cm5FcnJvcnMgPSB0b1JldHVybkVycm9ycy5jb25jYXQocGx1Z2luUmVzdWx0LmVycm9ycyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG9SZXR1cm5FeGVjdXRhYmxlcy5wdXNoKHBsdWdpblJlc3VsdC5leGVjdXRlKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBlbmYgb2YgaXRlcmF0aW9uIG9uIHRoZSBpbmNpZGVudHNCeUlkIGtleXNcblxuXG4gICAgICB2YXIgdG9SZXR1cm5FeGVjdXRlID0gZnVuY3Rpb24gdG9SZXR1cm5FeGVjdXRlKCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvUmV0dXJuRXhlY3V0YWJsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0b1JldHVybkV4ZWN1dGFibGVzW2ldKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhciByZW1vdmVSZXN1bHQgPSB7XG4gICAgICAgIHJlc3VsdDogdG9SZXR1cm5SZXN1bHQsXG4gICAgICAgIGVycm9yczogdG9SZXR1cm5FcnJvcnMsXG4gICAgICAgIGV4ZWN1dGU6IHRvUmV0dXJuRXhlY3V0ZVxuICAgICAgfTtcbiAgICAgIHJldHVybiByZW1vdmVSZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgY29tbWFuZCBjb21lcyBmb3JtIHRoZSBDbGlwJ3MgcGFyZW50IERlc2NyaXB0b3IgY2xhc3MuIFRoZSBwYXlsb2FkXG4gICAgICogaXMgaWRlbnRpY2FsIHRvIHRoZSBwYXlsb2FkIHRoYXQgY29tZXMgdG8gdGhlIERlc2NyaXB0aW9uIGNsYXNzOlxuICAgICAqIHtcbiAgICAgKiAgaWQ6IHRoZSBpZCBvZiB0aGUgSW5jaWRlbnQgdG8gcmVzaXplXG4gICAgICogIG5ld1NpemU6IHRoZSBtaWxsaXNlY29uZHMgb2YgdGhlIG5ldyBkdXJhdGlvblxuICAgICAqICBmcmFjdGlvbjogdGhlIGRpdmlzaW9uIG9mIHRoZSBuZXcgZHVyYXRpb24gdG8gdGhlIGN1cnJlbnRcbiAgICAgKiB9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZXNpemVJbmNpZGVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNpemVJbmNpZGVudChwYXlsb2FkKSB7XG4gICAgICB2YXIgY2FuZGlkYXRlcyA9IHRoaXMucHV0TWVzc2FnZU9uUGlwZSgncmVzaXplJywge1xuICAgICAgICBpbmNpZGVudElkOiBwYXlsb2FkLmlkLFxuICAgICAgICBuZXdTaXplOiBwYXlsb2FkLm5ld1NpemUsXG4gICAgICAgIGZyYWN0aW9uOiBwYXlsb2FkLmZyYWN0aW9uLFxuICAgICAgICBjb250ZXh0RGF0YToge1xuICAgICAgICAgIGNsaXBJZDogdGhpcy5pZCxcbiAgICAgICAgICBjb250ZXh0OiB0aGlzLmNvbnRleHRcbiAgICAgICAgfVxuICAgICAgfSwgcGF5bG9hZC5pZCwge1xuICAgICAgICBzZWxmRXhlY3V0ZTogZmFsc2UsXG4gICAgICAgIGRpcmVjdGlvbjogX1RSRUVDT05TVC5fRElSRUNUSU9OUy5fRE9XTlxuICAgICAgfSk7XG4gICAgICB2YXIgdG90YWxJbmNpZGVudHNCeVBsdWdpbiA9IHt9O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbmRpZGF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGluY2lkZW50c0J5UGx1Z2luID0gY2FuZGlkYXRlc1tpXS5yZXNwb25zZS5nZXRJbmNpZGVudHNCeUNoYW5uZWwoY2FuZGlkYXRlc1tpXS5wb3NpdGlvbkRlbHRhKTtcblxuICAgICAgICBmb3IgKHZhciBwbHVnaW5OYW1lIGluIGluY2lkZW50c0J5UGx1Z2luKSB7XG4gICAgICAgICAgdmFyIF90b3RhbEluY2lkZW50c0J5UGx1ZzQ7XG5cbiAgICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0b3RhbEluY2lkZW50c0J5UGx1Z2luLCBwbHVnaW5OYW1lKSkge1xuICAgICAgICAgICAgdG90YWxJbmNpZGVudHNCeVBsdWdpbltwbHVnaW5OYW1lXSA9IFtdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIChfdG90YWxJbmNpZGVudHNCeVBsdWc0ID0gdG90YWxJbmNpZGVudHNCeVBsdWdpbltwbHVnaW5OYW1lXSkucHVzaC5hcHBseShfdG90YWxJbmNpZGVudHNCeVBsdWc0LCBfdG9Db25zdW1hYmxlQXJyYXkoaW5jaWRlbnRzQnlQbHVnaW5bcGx1Z2luTmFtZV0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgcmVzID0gdGhpcy5jaGVja1Jlc2l6ZShwYXlsb2FkLmZyYWN0aW9uLCB0b3RhbEluY2lkZW50c0J5UGx1Z2luLCBjYW5kaWRhdGVzWzBdLnBvc2l0aW9uRGVsdGEpO1xuXG4gICAgICBpZiAocmVzLnJlc3VsdCA9PT0gdHJ1ZSkge1xuICAgICAgICByZXMuZXhlY3V0ZSgpO1xuXG4gICAgICAgIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IGNhbmRpZGF0ZXMubGVuZ3RoOyBfaTQrKykge1xuICAgICAgICAgIGNhbmRpZGF0ZXNbX2k0XS5yZXNwb25kZXIuc2V0TmV3RHVyYXRpb24ocGF5bG9hZC5uZXdTaXplKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBjaGVja3MgaWYgYSBkdXJhdGlvbiBlZGl0IGlzIGZlYXNpYmxlIGFuZCBkb2Vzbid0IGNhdXNlIGNvbmZsaWN0c1xuICAgICAqIEBwYXJhbSB7aW50fSBkdXJhdGlvbiAtIHRoZSBuZXcgZHVyYXRpb25cbiAgICAgKiovXG5cbiAgfSwge1xuICAgIGtleTogXCJjaGVja1Jlc2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja1Jlc2l6ZShkdXJhdGlvbkZyYWN0aW9uLCBpbmNpZGVudHNCeUlkKSB7XG4gICAgICB2YXIgYWRqdXN0TWlsbGlzZWNvbmQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDA7XG4gICAgICAvLyBwcmVwYXJlIHRoZSByZXR1cm4gcGF5bG9hZFxuICAgICAgdmFyIHRvUmV0dXJuUmVzdWx0ID0gdHJ1ZTtcbiAgICAgIHZhciB0b1JldHVybkVycm9ycyA9IFtdO1xuICAgICAgdmFyIHRvUmV0dXJuRXhlY3V0YWJsZXMgPSBbXTsgLy8gZm9yIGVhY2gga2V5IG9mIHRoZSBpbmNpZGVudHNCeUlkIG9iamVjdCBwZXJmb3JtIHRoZSBjaGVja1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gaW5jaWRlbnRzQnlJZCkge1xuICAgICAgICAvLyBwZXJmb3JtIHRoZSBjaGVja1xuICAgICAgICB2YXIgYWRqdXN0ZWRJbmNpZGVudHMgPSBoZWxwZXIuc3lzdG9sZURpYXN0b2xlUHJvamVjdGlvbnMoaW5jaWRlbnRzQnlJZFtrZXldLCBkdXJhdGlvbkZyYWN0aW9uLCBhZGp1c3RNaWxsaXNlY29uZCk7XG4gICAgICAgIHZhciBwbHVnaW5SZXN1bHQgPSB0aGlzLmluc3RhbnRpYXRlZENoYW5uZWxzW2tleV0uY2hlY2tSZXNpemVkSW5jaWRlbnRzKGFkanVzdGVkSW5jaWRlbnRzKTtcbiAgICAgICAgdG9SZXR1cm5SZXN1bHQgPSB0b1JldHVyblJlc3VsdCAmJiBwbHVnaW5SZXN1bHQucmVzdWx0O1xuXG4gICAgICAgIGlmIChwbHVnaW5SZXN1bHQucmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICAgIHRvUmV0dXJuRXJyb3JzID0gdG9SZXR1cm5FcnJvcnMuY29uY2F0KHBsdWdpblJlc3VsdC5lcnJvcnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRvUmV0dXJuRXhlY3V0YWJsZXMucHVzaChwbHVnaW5SZXN1bHQuZXhlY3V0ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gZW5mIG9mIGl0ZXJhdGlvbiBvbiB0aGUgaW5jaWRlbnRzQnlJZCBrZXlzXG5cblxuICAgICAgdmFyIHRvUmV0dXJuRXhlY3V0ZSA9IGZ1bmN0aW9uIHRvUmV0dXJuRXhlY3V0ZSgpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b1JldHVybkV4ZWN1dGFibGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdG9SZXR1cm5FeGVjdXRhYmxlc1tpXSgpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB2YXIgZWRpdFJlc3VsdCA9IHtcbiAgICAgICAgcmVzdWx0OiB0b1JldHVyblJlc3VsdCxcbiAgICAgICAgZXJyb3JzOiB0b1JldHVybkVycm9ycyxcbiAgICAgICAgZXhlY3V0ZTogdG9SZXR1cm5FeGVjdXRlXG4gICAgICB9O1xuICAgICAgcmV0dXJuIGVkaXRSZXN1bHQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEluY2lkZW50c0J5Q2hhbm5lbFwiLFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBvYmplY3Qgd2l0aCBrZXlzIHRoZSBrZXlzIG9mIGFsbCB0aGUgcGx1Z2lucyBJbmNpZGVudHMgb2Ygd2hpY2ggYXBwZWFyIGluIHRoZVxuICAgICAqIHRyZWUgb2YgdGhlIEdyb3VwLiBBbGwgSW5jaWRlbnRzIGFyZSBwcm9qZWN0ZWQgdG8gdGhlIEdyb3VwJ3MgdGltZWxpbmUuXG4gICAgICogVGhlIGFycmF5IGluY2x1ZGVzIHRoZSBHcm91cCdzIHByb2plY3Rpb24gdG9vXG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEluY2lkZW50c0J5Q2hhbm5lbCgpIHtcbiAgICAgIHZhciBhZGp1c3RNaWxsaXNlY29uZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcbiAgICAgIHZhciBpbmNpZGVudHNCeVBsdWdpbiA9IHt9O1xuICAgICAgaW5jaWRlbnRzQnlQbHVnaW5bc2VsZkNvbnRhaW5lZEluY2lkZW50c05wbU5hbWVdID0gW3tcbiAgICAgICAgbWlsbGlzZWNvbmQ6IGFkanVzdE1pbGxpc2Vjb25kLFxuICAgICAgICBpbmNpZGVudDogdGhpcyxcbiAgICAgICAgaWQ6IHRoaXMuaWRcbiAgICAgIH1dO1xuICAgICAgcmV0dXJuIGluY2lkZW50c0J5UGx1Z2luO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRWb2x1bWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Vm9sdW1lKG5ld1ZhbCkge1xuICAgICAgdGhpcy52b2x1bWUgPSBwYXJzZUZsb2F0KG5ld1ZhbCk7IC8vIHRoaXMucHV0TWVzc2FnZU9uUGlwZShwaXBlTWVzc2FnZXMuX0dBSU5fQ0hBTkdFLCB7IGdhaW46IG5ld1ZhbCB9LCBmYWxzZSwgXCJkb3duXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfb25HZXRDb250ZXh0T25jZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25HZXRDb250ZXh0T25jZSgpIHtcbiAgICAgIHJldHVybjsgLy8gQ2xpcHMgZG8gbm90IGdldCBjb250ZXh0IGZyb20gbm9vbmVcbiAgICB9IC8vIHNwZWNpYWwgcmVjYWxjRHVyYXRpb24gaGFuZGxpbmcgc28gYW55IHBvdGVudGlhbCBjbGlwIGNvcGllcyB1cGRhdGUgdGhlaXIgdHJlZXNcblxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZVJlY2FsY0R1cmF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZVJlY2FsY0R1cmF0aW9uKHRhcmdldCwgcGF5bG9hZCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgaWYgKHRoaXMuX2NhbGN1bGF0ZUR1cmF0aW9uKCkpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmR1cmF0aW9uU3Vicy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRoaXMuZHVyYXRpb25TdWJzW2ldKHRoaXMuZHVyYXRpb24pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdWJzY3JpYmVUb0R1cmF0aW9uQ2hhbmdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN1YnNjcmliZVRvRHVyYXRpb25DaGFuZ2UobWV0aG9kKSB7XG4gICAgICB0aGlzLmR1cmF0aW9uU3Vicy5wdXNoKG1ldGhvZCk7XG4gICAgfSAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgLy8gU1RFUCBGVU5DVElPTlxuXG4gIH0sIHtcbiAgICBrZXk6IFwic3RlcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdGVwKHRpbWVzdGFtcCkge1xuICAgICAgdmFyIGRlYnVnID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICAgICAgaWYgKHRoaXMucnVuVGltZUluZm8uc3RhdGUgIT09ICdwbGF5aW5nJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMucHJldmlvdXNUaW1lU3RhbXAgPT09IC0xKSB7XG4gICAgICAgIHRoaXMucHJldmlvdXNUaW1lU3RhbXAgPSB0aW1lc3RhbXA7XG4gICAgICB9IC8vIHByb2dyZXNzU3RlcCBpcyB0aGUgcHJvZ3Jlc3MgbWFkZSBmcm9tIHByZXZpb3VzVGltZVN0YW1wIGJvdGggaW4gbWlsbGlzZWNvbmRzIGFuZCBpbiBmcmFjdGlvbiBbMCB0byAxXVxuXG5cbiAgICAgIHZhciBwcm9ncmVzcyA9IHtcbiAgICAgICAgbWlsbGlzZWNvbmRzOiBNYXRoLnJvdW5kKHRoaXMucnVuVGltZUluZm8uY3VycmVudE1pbGxpc2Vjb25kICsgKHRpbWVzdGFtcCAtIHRoaXMucHJldmlvdXNUaW1lU3RhbXApICogdGhpcy5zcGVlZCksXG4gICAgICAgIGZyYWN0aW9uOiAodGhpcy5ydW5UaW1lSW5mby5jdXJyZW50TWlsbGlzZWNvbmQgKyAodGltZXN0YW1wIC0gdGhpcy5wcmV2aW91c1RpbWVTdGFtcCkgKiB0aGlzLnNwZWVkKSAvIHRoaXMuZHVyYXRpb25cbiAgICAgIH07XG5cbiAgICAgIGlmIChwcm9ncmVzcy5mcmFjdGlvbiA+PSAxKSB7XG4gICAgICAgIHRoaXMub25Qcm9ncmVzcygxLCB0aGlzLmR1cmF0aW9uKTtcbiAgICAgICAgdGhpcy5jb21wbGV0ZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKHByb2dyZXNzLmZyYWN0aW9uIDwgMCkge1xuICAgICAgICB0aGlzLm9uUHJvZ3Jlc3MoMCwgMCk7XG4gICAgICAgIHRoaXMuY29tcGxldGUoKTsgLy8gdGhpcy5icm9hZGNhc3RFdmVudCgnc3RhdGUtY2hhbmdlJywgeyBvbGRTdGF0ZTogXCJwbGF5aW5nXCIsIG5ld1N0YXRlOiBcImlkbGVcIiB9KTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMub25Qcm9ncmVzcyhwcm9ncmVzcy5mcmFjdGlvbiwgcHJvZ3Jlc3MubWlsbGlzZWNvbmRzKTtcbiAgICAgIHRoaXMucHJldmlvdXNUaW1lU3RhbXAgPSB0aW1lc3RhbXA7XG5cbiAgICAgIGlmIChkZWJ1ZyA9PT0gZmFsc2UpIHtcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGF0LnN0ZXAuYmluZCh0aGF0KSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ldGhvZCBjYWxsZWQgb24gcHJvZ3Jlc3Mgb2YgdGhlIHRpbWVkIGluY2lkZW50LlxuICAgICAqIEBwYXJhbSB7ZmxvYXR9IGZyYWN0aW9uIC0gYSBudW1iZXIgZnJvbSAwIHRvIDEgcmVwcmVzZW50aW5nIHRoZSBmcmFjdGlvbiBvZiBkdXJhdGlvbiBjb3ZlcmVkXG4gICAgICogQHBhcmFtIHtpbnR9IG1pbGxpc2Vjb25kcyAtIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHBhc3NlZCBmcm9tIHN0YXJ0IG9mIHRoZSBpbmNpZGVudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZXh0SWQgLSBkZWZhdWx0cyB0byB0aGUgaWQgb2YgdGhlIHJlYWxDbGlwIGl0c2VsZi4gRG9uJ3QgZm9yZ2V0IHRoYXQgYSByZWFsQ2xpcFxuICAgICAqICAgICAgbWlnaHQgYmVsb25nIHRvIGEgc2VsZWN0b3IgQ2xpcCAoc28gaXQncyBhIEZyYWdtZW50ZWQgQ2xpcCksIHdpdGggbWFueSBcInJlYWxcIiBDbGlwQ29waWVzLiBBbGwgQ2xpcENvcGllcyBob2xkXG4gICAgICogICAgICBhIHJlZmVyZW5jZSB0byB0aGlzIENsaXAgdmlhIHRoZWlyIFwicmVhbENsaXBcIiBwcm9wZXJ0eS4gV2hlbmV2ZXIgYW55XG4gICAgICogICAgICBvZiB0aGVzZSBDbGlwQ29waWVzIHByb2dyZXNzZXMgKHZpYSB0aGUgb25Qcm9ncmVzcyBtZXRob2QpIGNhbGxzXG4gICAgICogICAgICB0aGUgXCJvblByb2dyZXNzXCIgb2YgdGhlIHJlYWxDbGlwLCBwYXNzaW5nIHRoZWlyIGlkIHNvIHRoZSBDb250ZXh0QXdhcmVJbmNpZGVudHNcbiAgICAgKiAgICAgIHRoYXQgd2lsbCBhbHNvIHByb2dyZXNzIHZpYSB0aGUgQ2hhbm5lbHMga25vdyB3aGljaCBzcGVjaWZpYyBJbmNpZGVudCB0byBwcm9ncmVzcy5cbiAgICAgKiAgICAgIFRoYXQncyB0aGUgcmVzdWx0IG9mIGtlZXBpbmcganVzdCBvbmUgcmVhbCB0cmVlLCBiZWxvbmdpbmcgYWx3YXlzIHRvIHRoZSByZWFsQ2xpcFxuICAgICAqICAgICAgKGVpdGhlciBGcmFnbWVudGVkIG9yIEhvc3RlZCkgZW5kaW5nIHRvIENvbnRleHRBd2FyZUluY2lkZW50IGxlYWZzIHRoYXRcbiAgICAgKiAgICAgIGFyZSB0aGUgb25lcyB0byBob2xkIHRoZSBDbGlwQ29waWVzIGluc3RhbmNlcy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZvcmNlUmVzZXQgLSBzZXQgdG8gdHJ1ZSBpbiBjYXNlcyB3ZSB3YW50IGZ1bGwgZmxhc2ggb2YgdGhlIHN0YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJvblByb2dyZXNzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uUHJvZ3Jlc3MoZnJhY3Rpb24sIG1pbGxpc2Vjb25kcykge1xuICAgICAgdmFyIGNvbnRleHRJZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdGhpcy5pZDtcbiAgICAgIHZhciBmb3JjZVJlc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBmYWxzZTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuaW5zdGFudGlhdGVkQ2hhbm5lbHMpIHtcbiAgICAgICAgdmFyIGNoYW5uZWwgPSB0aGlzLmluc3RhbnRpYXRlZENoYW5uZWxzW2tleV07XG4gICAgICAgIGNoYW5uZWwubW92ZVRvKHRoaXMucnVuVGltZUluZm8uY3VycmVudE1pbGxpc2Vjb25kLCBtaWxsaXNlY29uZHMsIGNvbnRleHRJZCwgZm9yY2VSZXNldCk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIF9rZXkgaW4gdGhpcy5saXN0ZW5lcnMpIHtcbiAgICAgICAgdmFyIGxpc3RuZXIgPSB0aGlzLmxpc3RlbmVyc1tfa2V5XTsgLy8gY29uc29sZS5sb2coYE1hdGguYWJzKCR7bWlsbGlzZWNvbmRzfSArICR7bGlzdG5lci5jYXZhRGVsdGF9IC0gJHt0aGlzLnJ1blRpbWVJbmZvLmN1cnJlbnRNaWxsaXNlY29uZH0pID4gJHtsaXN0bmVyLnRocmVzaG9sZH1gKTtcblxuICAgICAgICBpZiAoTWF0aC5hYnMobWlsbGlzZWNvbmRzICsgbGlzdG5lci5jYXZhRGVsdGEgLSB0aGlzLnJ1blRpbWVJbmZvLmN1cnJlbnRNaWxsaXNlY29uZCkgPiBsaXN0bmVyLnRocmVzaG9sZCkge1xuICAgICAgICAgIGxpc3RuZXIuZnVuY3QoaGVscGVyLnJvdW5kTnVtYmVyVG8obWlsbGlzZWNvbmRzLCBsaXN0bmVyLnJvdW5kVG8pLCB0aGlzLnJ1blRpbWVJbmZvLnN0YXRlKTtcbiAgICAgICAgICBsaXN0bmVyLmNhdmFEZWx0YSA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGlzdG5lci5jYXZhRGVsdGEgKz0gTWF0aC5hYnMobWlsbGlzZWNvbmRzIC0gdGhpcy5ydW5UaW1lSW5mby5jdXJyZW50TWlsbGlzZWNvbmQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMucnVuVGltZUluZm8uY3VycmVudE1pbGxpc2Vjb25kID0gbWlsbGlzZWNvbmRzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfc2V0U3RhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldFN0YXRlKG5ld1N0YXRlKSB7XG4gICAgICBpZiAobmV3U3RhdGUgIT0gdGhpcy5ydW5UaW1lSW5mby5zdGF0ZSkge1xuICAgICAgICB0aGlzLnJ1blRpbWVJbmZvLnN0YXRlID0gbmV3U3RhdGU7XG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMubGlzdGVuZXJzKSB7XG4gICAgICAgICAgdmFyIGxpc3RuZXIgPSB0aGlzLmxpc3RlbmVyc1trZXldO1xuICAgICAgICAgIGxpc3RuZXIuZnVuY3QodGhpcy5ydW5UaW1lSW5mby5jdXJyZW50TWlsbGlzZWNvbmQsIG5ld1N0YXRlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gZXhlY3V0aW9uIG1ldGhvZHNcblxuICB9LCB7XG4gICAga2V5OiBcInBsYXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGxheSgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgZGVidWcgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuXG4gICAgICBpZiAodGhpcy5ydW5UaW1lSW5mby5zdGF0ZSA9PT0gJ2lkbGUnIHx8IHRoaXMucnVuVGltZUluZm8uc3RhdGUgPT09ICdwYXVzZWQnIHx8IHRoaXMucnVuVGltZUluZm8uc3RhdGUgPT09ICd0cmFuc2l0aW9uYWwnKSB7XG4gICAgICAgIGlmICh0aGlzLnJ1blRpbWVJbmZvLnN0YXRlID09PSAncGF1c2VkJykge1xuICAgICAgICAgIHZhciBkZWx0YSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gdGhpcy5wYXVzZU1vbWVudDtcbiAgICAgICAgICB0aGlzLnByZXZpb3VzVGltZVN0YW1wICs9IGRlbHRhO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc2V0U3RhdGUoJ3BsYXlpbmcnKTtcblxuICAgICAgICB0aGlzLm9uUGxheSgpO1xuXG4gICAgICAgIGlmIChkZWJ1ZyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICh0aW1lc3RhbXApIHtcbiAgICAgICAgICAgIF90aGlzMi5zdGVwKHRpbWVzdGFtcCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGF1c2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGF1c2UoKSB7XG4gICAgICBpZiAodGhpcy5ydW5UaW1lSW5mby5zdGF0ZSA9PT0gJ3BsYXlpbmcnKSB7XG4gICAgICAgIHRoaXMuX3NldFN0YXRlKCdwYXVzZWQnKTtcblxuICAgICAgICB0aGlzLnBhdXNlTW9tZW50ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIHRoaXMub25XYWl0KCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbXBsZXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBsZXRlKCkge1xuICAgICAgdGhpcy5fc2V0U3RhdGUoJ2lkbGUnKTtcblxuICAgICAgdGhpcy5wcmV2aW91c1RpbWVTdGFtcCA9IC0xO1xuICAgICAgdGhpcy5ydW5UaW1lSW5mby5jdXJyZW50TWlsbGlzZWNvbmQgPSAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdG9wXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgICB0aGlzLl9zZXRTdGF0ZSgndHJhbnNpdGlvbmFsJyk7XG5cbiAgICAgIHRoaXMucHJldmlvdXNUaW1lU3RhbXAgPSAtMTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZmxhc2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmxhc2goKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5pbnN0YW50aWF0ZWRDaGFubmVscykge1xuICAgICAgICB2YXIgY2hhbm5lbCA9IHRoaXMuaW5zdGFudGlhdGVkQ2hhbm5lbHNba2V5XTtcbiAgICAgICAgY2hhbm5lbC5tb3ZlVG8oMCwgdGhpcy5ydW5UaW1lSW5mby5jdXJyZW50TWlsbGlzZWNvbmQsIHRoaXMuaWQsIHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvblBsYXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25QbGF5KCkge31cbiAgfSwge1xuICAgIGtleTogXCJvbldhaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25XYWl0KCkge31cbiAgfSwge1xuICAgIGtleTogXCJleGVjdXRpb25TcGVlZFwiLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHNwZWVkKSB7XG4gICAgICB0aGlzLnNwZWVkID0gcGFyc2VGbG9hdChzcGVlZCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbnRleHRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLm93bkNvbnRleHQ7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEV4dGVuZGFibGVDbGlwO1xufShHcm91cCk7XG5cbm1vZHVsZS5leHBvcnRzID0gRXh0ZW5kYWJsZUNsaXA7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/_Clip/ExtendableClip.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/_Clip/FragmentedClip.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/_Clip/FragmentedClip.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar HTMLFragmentContextHandler = __webpack_require__(/*! ./helpers/HTMLFragmentContextHandler */ \"./node_modules/@kissmybutton/motorcortex/dist/_Clip/helpers/HTMLFragmentContextHandler.js\");\n\nvar ExtendableClip = __webpack_require__(/*! ./ExtendableClip */ \"./node_modules/@kissmybutton/motorcortex/dist/_Clip/ExtendableClip.js\");\n\nvar FragmentedClip =\n/*#__PURE__*/\nfunction (_ExtendableClip) {\n  _inherits(FragmentedClip, _ExtendableClip);\n\n  function FragmentedClip() {\n    var _this;\n\n    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var oldProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n    _classCallCheck(this, FragmentedClip);\n\n    var attrsToPass, propsToUse;\n    /*\n    backwards compatibility. If the user doesn't pass a second argument on the constructor then this is\n    the new way of initialising a Group (only props).\n    */\n\n    if (oldProps === null) {\n      attrsToPass = {};\n      propsToUse = props;\n    } else {\n      // else, in case the user has passed two arguments then both should be used\n      attrsToPass = props;\n      propsToUse = oldProps;\n    }\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(FragmentedClip).call(this, attrsToPass, propsToUse));\n    var contextHanlder = new HTMLFragmentContextHandler(_objectSpread({}, propsToUse, {\n      html: Object.prototype.hasOwnProperty.call(propsToUse, \"html\") ? propsToUse.html : _this.html,\n      css: Object.prototype.hasOwnProperty.call(propsToUse, \"css\") ? propsToUse.css : _this.css,\n      fonts: Object.prototype.hasOwnProperty.call(propsToUse, \"fonts\") ? propsToUse.fonts : _this.fonts\n    }));\n    _this.ownContext = contextHanlder.context;\n    _this.iframe = contextHanlder.iframeElement;\n    _this.forceExportIncidents = true;\n\n    _this.onDOMCLipInitialise(); // as soon as a Fragmented Clip is been intialised that means the Descriptive\n    // Clip has a selector and not a host. Thus is not a hosted clip\n\n\n    _this.isHostedClip = false;\n    return _this;\n  }\n\n  _createClass(FragmentedClip, [{\n    key: \"exportConstructionArguments\",\n    value: function exportConstructionArguments() {\n      // TODO also export CSS and fonts taking in account the potential existance\n      // of them on the get methods\n      // console.log(this.ownContext.rootElement.innerHTML);\n      return {\n        attrs: this.attrs,\n        props: _objectSpread({}, this.props, {\n          html: this.ownContext.rootElement.innerHTML\n        })\n      };\n    }\n  }, {\n    key: \"onDOMCLipInitialise\",\n    value: function onDOMCLipInitialise() {// implement here\n    }\n  }, {\n    key: \"rootElement\",\n    get: function get() {\n      return this.ownContext.clipContainer;\n    }\n  }]);\n\n  return FragmentedClip;\n}(ExtendableClip);\n\nmodule.exports = FragmentedClip;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19DbGlwL0ZyYWdtZW50ZWRDbGlwLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvZGlzdC9fQ2xpcC9GcmFnbWVudGVkQ2xpcC5qcz82MWIyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgdmFyIG93bktleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpOyBpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09ICdmdW5jdGlvbicpIHsgb3duS2V5cyA9IG93bktleXMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKS5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIHN5bSkuZW51bWVyYWJsZTsgfSkpOyB9IG93bktleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG52YXIgSFRNTEZyYWdtZW50Q29udGV4dEhhbmRsZXIgPSByZXF1aXJlKCcuL2hlbHBlcnMvSFRNTEZyYWdtZW50Q29udGV4dEhhbmRsZXInKTtcblxudmFyIEV4dGVuZGFibGVDbGlwID0gcmVxdWlyZSgnLi9FeHRlbmRhYmxlQ2xpcCcpO1xuXG52YXIgRnJhZ21lbnRlZENsaXAgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9FeHRlbmRhYmxlQ2xpcCkge1xuICBfaW5oZXJpdHMoRnJhZ21lbnRlZENsaXAsIF9FeHRlbmRhYmxlQ2xpcCk7XG5cbiAgZnVuY3Rpb24gRnJhZ21lbnRlZENsaXAoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICB2YXIgb2xkUHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG51bGw7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRnJhZ21lbnRlZENsaXApO1xuXG4gICAgdmFyIGF0dHJzVG9QYXNzLCBwcm9wc1RvVXNlO1xuICAgIC8qXG4gICAgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuIElmIHRoZSB1c2VyIGRvZXNuJ3QgcGFzcyBhIHNlY29uZCBhcmd1bWVudCBvbiB0aGUgY29uc3RydWN0b3IgdGhlbiB0aGlzIGlzXG4gICAgdGhlIG5ldyB3YXkgb2YgaW5pdGlhbGlzaW5nIGEgR3JvdXAgKG9ubHkgcHJvcHMpLlxuICAgICovXG5cbiAgICBpZiAob2xkUHJvcHMgPT09IG51bGwpIHtcbiAgICAgIGF0dHJzVG9QYXNzID0ge307XG4gICAgICBwcm9wc1RvVXNlID0gcHJvcHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVsc2UsIGluIGNhc2UgdGhlIHVzZXIgaGFzIHBhc3NlZCB0d28gYXJndW1lbnRzIHRoZW4gYm90aCBzaG91bGQgYmUgdXNlZFxuICAgICAgYXR0cnNUb1Bhc3MgPSBwcm9wcztcbiAgICAgIHByb3BzVG9Vc2UgPSBvbGRQcm9wcztcbiAgICB9XG5cbiAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihGcmFnbWVudGVkQ2xpcCkuY2FsbCh0aGlzLCBhdHRyc1RvUGFzcywgcHJvcHNUb1VzZSkpO1xuICAgIHZhciBjb250ZXh0SGFubGRlciA9IG5ldyBIVE1MRnJhZ21lbnRDb250ZXh0SGFuZGxlcihfb2JqZWN0U3ByZWFkKHt9LCBwcm9wc1RvVXNlLCB7XG4gICAgICBodG1sOiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocHJvcHNUb1VzZSwgXCJodG1sXCIpID8gcHJvcHNUb1VzZS5odG1sIDogX3RoaXMuaHRtbCxcbiAgICAgIGNzczogT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzVG9Vc2UsIFwiY3NzXCIpID8gcHJvcHNUb1VzZS5jc3MgOiBfdGhpcy5jc3MsXG4gICAgICBmb250czogT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzVG9Vc2UsIFwiZm9udHNcIikgPyBwcm9wc1RvVXNlLmZvbnRzIDogX3RoaXMuZm9udHNcbiAgICB9KSk7XG4gICAgX3RoaXMub3duQ29udGV4dCA9IGNvbnRleHRIYW5sZGVyLmNvbnRleHQ7XG4gICAgX3RoaXMuaWZyYW1lID0gY29udGV4dEhhbmxkZXIuaWZyYW1lRWxlbWVudDtcbiAgICBfdGhpcy5mb3JjZUV4cG9ydEluY2lkZW50cyA9IHRydWU7XG5cbiAgICBfdGhpcy5vbkRPTUNMaXBJbml0aWFsaXNlKCk7IC8vIGFzIHNvb24gYXMgYSBGcmFnbWVudGVkIENsaXAgaXMgYmVlbiBpbnRpYWxpc2VkIHRoYXQgbWVhbnMgdGhlIERlc2NyaXB0aXZlXG4gICAgLy8gQ2xpcCBoYXMgYSBzZWxlY3RvciBhbmQgbm90IGEgaG9zdC4gVGh1cyBpcyBub3QgYSBob3N0ZWQgY2xpcFxuXG5cbiAgICBfdGhpcy5pc0hvc3RlZENsaXAgPSBmYWxzZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRnJhZ21lbnRlZENsaXAsIFt7XG4gICAga2V5OiBcImV4cG9ydENvbnN0cnVjdGlvbkFyZ3VtZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBleHBvcnRDb25zdHJ1Y3Rpb25Bcmd1bWVudHMoKSB7XG4gICAgICAvLyBUT0RPIGFsc28gZXhwb3J0IENTUyBhbmQgZm9udHMgdGFraW5nIGluIGFjY291bnQgdGhlIHBvdGVudGlhbCBleGlzdGFuY2VcbiAgICAgIC8vIG9mIHRoZW0gb24gdGhlIGdldCBtZXRob2RzXG4gICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLm93bkNvbnRleHQucm9vdEVsZW1lbnQuaW5uZXJIVE1MKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGF0dHJzOiB0aGlzLmF0dHJzLFxuICAgICAgICBwcm9wczogX29iamVjdFNwcmVhZCh7fSwgdGhpcy5wcm9wcywge1xuICAgICAgICAgIGh0bWw6IHRoaXMub3duQ29udGV4dC5yb290RWxlbWVudC5pbm5lckhUTUxcbiAgICAgICAgfSlcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm9uRE9NQ0xpcEluaXRpYWxpc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25ET01DTGlwSW5pdGlhbGlzZSgpIHsvLyBpbXBsZW1lbnQgaGVyZVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyb290RWxlbWVudFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMub3duQ29udGV4dC5jbGlwQ29udGFpbmVyO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBGcmFnbWVudGVkQ2xpcDtcbn0oRXh0ZW5kYWJsZUNsaXApO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZyYWdtZW50ZWRDbGlwOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/_Clip/FragmentedClip.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/_Clip/RootClipClone.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/_Clip/RootClipClone.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar Helper = __webpack_require__(/*! ../_coreUtils/Helper */ \"./node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\");\n\nvar helper = new Helper();\n/*\ndna: {\n    host\n    descriptiveIncident\n}\n*/\n\nvar ClipClone =\n/*#__PURE__*/\nfunction () {\n  function ClipClone(dna) {\n    _classCallCheck(this, ClipClone);\n\n    this.runTimeInfo = {\n      currentMillisecond: 0\n    };\n    this.id = helper.getAnId();\n    this.realClip = dna.descriptiveIncident.realClip; // In order to render itself on the given element first it needs the props (including html and css)\n    // from the real Clip it copies\n\n    var constructionArgs = dna.descriptiveIncident.realClip.exportConstructionArguments(); // it properly sets its own host on the props to use to initialise its own clip\n\n    var hostedProps = _objectSpread({}, constructionArgs.props, {\n      selector: undefined,\n      host: dna.host,\n      id: this.id\n    }); // we create a clip because Clips on creation render and thus have their own context\n\n\n    this.ownClip = new dna.descriptiveIncident.constructor.Incident(constructionArgs.attrs, hostedProps); // flushes the realClip with its ownClip's context\n\n    dna.descriptiveIncident.realClip.addContext({\n      clipId: this.id,\n      context: this.ownClip.ownContext,\n      synchronize: dna.synchronize\n    }, true);\n  }\n\n  _createClass(ClipClone, [{\n    key: \"onProgress\",\n    value: function onProgress(fraction, milliseconds) {\n      var forceReset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      for (var key in this.realClip.instantiatedChannels) {\n        var channel = this.realClip.instantiatedChannels[key];\n        channel.moveTo(this.runTimeInfo.currentMillisecond, milliseconds, this.id, forceReset);\n      }\n\n      this.runTimeInfo.currentMillisecond = milliseconds;\n    }\n  }]);\n\n  return ClipClone;\n}();\n\nmodule.exports = ClipClone;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19DbGlwL1Jvb3RDbGlwQ2xvbmUuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19DbGlwL1Jvb3RDbGlwQ2xvbmUuanM/NjJmYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IHZhciBvd25LZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTsgaWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSAnZnVuY3Rpb24nKSB7IG93bktleXMgPSBvd25LZXlzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSkuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBzeW0pLmVudW1lcmFibGU7IH0pKTsgfSBvd25LZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbnZhciBIZWxwZXIgPSByZXF1aXJlKCcuLi9fY29yZVV0aWxzL0hlbHBlcicpO1xuXG52YXIgaGVscGVyID0gbmV3IEhlbHBlcigpO1xuLypcbmRuYToge1xuICAgIGhvc3RcbiAgICBkZXNjcmlwdGl2ZUluY2lkZW50XG59XG4qL1xuXG52YXIgQ2xpcENsb25lID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ2xpcENsb25lKGRuYSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDbGlwQ2xvbmUpO1xuXG4gICAgdGhpcy5ydW5UaW1lSW5mbyA9IHtcbiAgICAgIGN1cnJlbnRNaWxsaXNlY29uZDogMFxuICAgIH07XG4gICAgdGhpcy5pZCA9IGhlbHBlci5nZXRBbklkKCk7XG4gICAgdGhpcy5yZWFsQ2xpcCA9IGRuYS5kZXNjcmlwdGl2ZUluY2lkZW50LnJlYWxDbGlwOyAvLyBJbiBvcmRlciB0byByZW5kZXIgaXRzZWxmIG9uIHRoZSBnaXZlbiBlbGVtZW50IGZpcnN0IGl0IG5lZWRzIHRoZSBwcm9wcyAoaW5jbHVkaW5nIGh0bWwgYW5kIGNzcylcbiAgICAvLyBmcm9tIHRoZSByZWFsIENsaXAgaXQgY29waWVzXG5cbiAgICB2YXIgY29uc3RydWN0aW9uQXJncyA9IGRuYS5kZXNjcmlwdGl2ZUluY2lkZW50LnJlYWxDbGlwLmV4cG9ydENvbnN0cnVjdGlvbkFyZ3VtZW50cygpOyAvLyBpdCBwcm9wZXJseSBzZXRzIGl0cyBvd24gaG9zdCBvbiB0aGUgcHJvcHMgdG8gdXNlIHRvIGluaXRpYWxpc2UgaXRzIG93biBjbGlwXG5cbiAgICB2YXIgaG9zdGVkUHJvcHMgPSBfb2JqZWN0U3ByZWFkKHt9LCBjb25zdHJ1Y3Rpb25BcmdzLnByb3BzLCB7XG4gICAgICBzZWxlY3RvcjogdW5kZWZpbmVkLFxuICAgICAgaG9zdDogZG5hLmhvc3QsXG4gICAgICBpZDogdGhpcy5pZFxuICAgIH0pOyAvLyB3ZSBjcmVhdGUgYSBjbGlwIGJlY2F1c2UgQ2xpcHMgb24gY3JlYXRpb24gcmVuZGVyIGFuZCB0aHVzIGhhdmUgdGhlaXIgb3duIGNvbnRleHRcblxuXG4gICAgdGhpcy5vd25DbGlwID0gbmV3IGRuYS5kZXNjcmlwdGl2ZUluY2lkZW50LmNvbnN0cnVjdG9yLkluY2lkZW50KGNvbnN0cnVjdGlvbkFyZ3MuYXR0cnMsIGhvc3RlZFByb3BzKTsgLy8gZmx1c2hlcyB0aGUgcmVhbENsaXAgd2l0aCBpdHMgb3duQ2xpcCdzIGNvbnRleHRcblxuICAgIGRuYS5kZXNjcmlwdGl2ZUluY2lkZW50LnJlYWxDbGlwLmFkZENvbnRleHQoe1xuICAgICAgY2xpcElkOiB0aGlzLmlkLFxuICAgICAgY29udGV4dDogdGhpcy5vd25DbGlwLm93bkNvbnRleHQsXG4gICAgICBzeW5jaHJvbml6ZTogZG5hLnN5bmNocm9uaXplXG4gICAgfSwgdHJ1ZSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQ2xpcENsb25lLCBbe1xuICAgIGtleTogXCJvblByb2dyZXNzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uUHJvZ3Jlc3MoZnJhY3Rpb24sIG1pbGxpc2Vjb25kcykge1xuICAgICAgdmFyIGZvcmNlUmVzZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5yZWFsQ2xpcC5pbnN0YW50aWF0ZWRDaGFubmVscykge1xuICAgICAgICB2YXIgY2hhbm5lbCA9IHRoaXMucmVhbENsaXAuaW5zdGFudGlhdGVkQ2hhbm5lbHNba2V5XTtcbiAgICAgICAgY2hhbm5lbC5tb3ZlVG8odGhpcy5ydW5UaW1lSW5mby5jdXJyZW50TWlsbGlzZWNvbmQsIG1pbGxpc2Vjb25kcywgdGhpcy5pZCwgZm9yY2VSZXNldCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucnVuVGltZUluZm8uY3VycmVudE1pbGxpc2Vjb25kID0gbWlsbGlzZWNvbmRzO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDbGlwQ2xvbmU7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2xpcENsb25lOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/_Clip/RootClipClone.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/_Clip/SCGroup.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/_Clip/SCGroup.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar conf = __webpack_require__(/*! ../configuration/generalConf */ \"./node_modules/@kissmybutton/motorcortex/dist/configuration/generalConf.js\"); // context handlers\n\n\nvar IframeContextHandler = __webpack_require__(/*! ./helpers/IframeContextHandler */ \"./node_modules/@kissmybutton/motorcortex/dist/_Clip/helpers/IframeContextHandler.js\");\n\nvar WebComponentContextHandler = __webpack_require__(/*! ./helpers/WebComponentContextHandler */ \"./node_modules/@kissmybutton/motorcortex/dist/_Clip/helpers/WebComponentContextHandler.js\");\n\nvar ExtendableClip = __webpack_require__(/*! ./ExtendableClip */ \"./node_modules/@kissmybutton/motorcortex/dist/_Clip/ExtendableClip.js\");\n\nvar Clip =\n/*#__PURE__*/\nfunction (_ExtendableClip) {\n  _inherits(Clip, _ExtendableClip);\n\n  /**\n   * @param {object} props - an object that should contain all of the following keys:\n   * - html (the html template to render)\n   * - css (the css template of the isolated tree)\n   * - initParams (optional / the initialisation parameteres that will be passed both on the css and the html templates in order to render)\n   * - host (an Element object that will host the isolated tree)\n   * - containerParams (an object that holds parameters to affect the container of the isolated tree, e.g. width, height etc)\n   */\n  function Clip() {\n    var _this;\n\n    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var oldProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n    _classCallCheck(this, Clip);\n\n    var attrsToPass, propsToUse;\n    /*\n    backwards compatibility. If the user doesn't pass a second argument on the constructor then this is\n    the new way of initialising a Group (only props).\n    */\n\n    if (oldProps === null) {\n      attrsToPass = {};\n      propsToUse = props;\n    } else {\n      // else, in case the user has passed two arguments then both should be used\n      attrsToPass = props;\n      propsToUse = oldProps;\n    }\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Clip).call(this, attrsToPass, propsToUse)); // that means the Clip is hosted or, in other words a host has been\n    // provided on the props (and not a selector)\n\n    _this.isHostedClip = true;\n    var clipType = conf.selfContainedContextHandler;\n    _this.clipType = clipType;\n    var ContextHanlder = null;\n\n    if (document.head.createShadowRoot || document.head.attachShadow) {\n      ContextHanlder = WebComponentContextHandler;\n    } else {\n      ContextHanlder = IframeContextHandler;\n    } // console.log(`this.id: ${this.id}, Class: ${this.constructor.name}, this.html: ${this.html}`)\n\n\n    var contextHanlder = new ContextHanlder(propsToUse);\n    _this.ownContext = contextHanlder.context;\n    _this.iframe = contextHanlder.iframeElement;\n    _this.forceExportIncidents = true;\n\n    _this.onDOMCLipInitialise();\n\n    return _this;\n  }\n\n  _createClass(Clip, [{\n    key: \"onDOMCLipInitialise\",\n    value: function onDOMCLipInitialise() {// implement here\n    }\n  }, {\n    key: \"rootElement\",\n    get: function get() {\n      return this.ownContext.clipContainer;\n    }\n  }]);\n\n  return Clip;\n}(ExtendableClip);\n\nmodule.exports = Clip;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19DbGlwL1NDR3JvdXAuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19DbGlwL1NDR3JvdXAuanM/NTVkOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbnZhciBjb25mID0gcmVxdWlyZSgnLi4vY29uZmlndXJhdGlvbi9nZW5lcmFsQ29uZicpOyAvLyBjb250ZXh0IGhhbmRsZXJzXG5cblxudmFyIElmcmFtZUNvbnRleHRIYW5kbGVyID0gcmVxdWlyZSgnLi9oZWxwZXJzL0lmcmFtZUNvbnRleHRIYW5kbGVyJyk7XG5cbnZhciBXZWJDb21wb25lbnRDb250ZXh0SGFuZGxlciA9IHJlcXVpcmUoJy4vaGVscGVycy9XZWJDb21wb25lbnRDb250ZXh0SGFuZGxlcicpO1xuXG52YXIgRXh0ZW5kYWJsZUNsaXAgPSByZXF1aXJlKCcuL0V4dGVuZGFibGVDbGlwJyk7XG5cbnZhciBDbGlwID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfRXh0ZW5kYWJsZUNsaXApIHtcbiAgX2luaGVyaXRzKENsaXAsIF9FeHRlbmRhYmxlQ2xpcCk7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wcyAtIGFuIG9iamVjdCB0aGF0IHNob3VsZCBjb250YWluIGFsbCBvZiB0aGUgZm9sbG93aW5nIGtleXM6XG4gICAqIC0gaHRtbCAodGhlIGh0bWwgdGVtcGxhdGUgdG8gcmVuZGVyKVxuICAgKiAtIGNzcyAodGhlIGNzcyB0ZW1wbGF0ZSBvZiB0aGUgaXNvbGF0ZWQgdHJlZSlcbiAgICogLSBpbml0UGFyYW1zIChvcHRpb25hbCAvIHRoZSBpbml0aWFsaXNhdGlvbiBwYXJhbWV0ZXJlcyB0aGF0IHdpbGwgYmUgcGFzc2VkIGJvdGggb24gdGhlIGNzcyBhbmQgdGhlIGh0bWwgdGVtcGxhdGVzIGluIG9yZGVyIHRvIHJlbmRlcilcbiAgICogLSBob3N0IChhbiBFbGVtZW50IG9iamVjdCB0aGF0IHdpbGwgaG9zdCB0aGUgaXNvbGF0ZWQgdHJlZSlcbiAgICogLSBjb250YWluZXJQYXJhbXMgKGFuIG9iamVjdCB0aGF0IGhvbGRzIHBhcmFtZXRlcnMgdG8gYWZmZWN0IHRoZSBjb250YWluZXIgb2YgdGhlIGlzb2xhdGVkIHRyZWUsIGUuZy4gd2lkdGgsIGhlaWdodCBldGMpXG4gICAqL1xuICBmdW5jdGlvbiBDbGlwKCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgdmFyIG9sZFByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBudWxsO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENsaXApO1xuXG4gICAgdmFyIGF0dHJzVG9QYXNzLCBwcm9wc1RvVXNlO1xuICAgIC8qXG4gICAgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuIElmIHRoZSB1c2VyIGRvZXNuJ3QgcGFzcyBhIHNlY29uZCBhcmd1bWVudCBvbiB0aGUgY29uc3RydWN0b3IgdGhlbiB0aGlzIGlzXG4gICAgdGhlIG5ldyB3YXkgb2YgaW5pdGlhbGlzaW5nIGEgR3JvdXAgKG9ubHkgcHJvcHMpLlxuICAgICovXG5cbiAgICBpZiAob2xkUHJvcHMgPT09IG51bGwpIHtcbiAgICAgIGF0dHJzVG9QYXNzID0ge307XG4gICAgICBwcm9wc1RvVXNlID0gcHJvcHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVsc2UsIGluIGNhc2UgdGhlIHVzZXIgaGFzIHBhc3NlZCB0d28gYXJndW1lbnRzIHRoZW4gYm90aCBzaG91bGQgYmUgdXNlZFxuICAgICAgYXR0cnNUb1Bhc3MgPSBwcm9wcztcbiAgICAgIHByb3BzVG9Vc2UgPSBvbGRQcm9wcztcbiAgICB9XG5cbiAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihDbGlwKS5jYWxsKHRoaXMsIGF0dHJzVG9QYXNzLCBwcm9wc1RvVXNlKSk7IC8vIHRoYXQgbWVhbnMgdGhlIENsaXAgaXMgaG9zdGVkIG9yLCBpbiBvdGhlciB3b3JkcyBhIGhvc3QgaGFzIGJlZW5cbiAgICAvLyBwcm92aWRlZCBvbiB0aGUgcHJvcHMgKGFuZCBub3QgYSBzZWxlY3RvcilcblxuICAgIF90aGlzLmlzSG9zdGVkQ2xpcCA9IHRydWU7XG4gICAgdmFyIGNsaXBUeXBlID0gY29uZi5zZWxmQ29udGFpbmVkQ29udGV4dEhhbmRsZXI7XG4gICAgX3RoaXMuY2xpcFR5cGUgPSBjbGlwVHlwZTtcbiAgICB2YXIgQ29udGV4dEhhbmxkZXIgPSBudWxsO1xuXG4gICAgaWYgKGRvY3VtZW50LmhlYWQuY3JlYXRlU2hhZG93Um9vdCB8fCBkb2N1bWVudC5oZWFkLmF0dGFjaFNoYWRvdykge1xuICAgICAgQ29udGV4dEhhbmxkZXIgPSBXZWJDb21wb25lbnRDb250ZXh0SGFuZGxlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgQ29udGV4dEhhbmxkZXIgPSBJZnJhbWVDb250ZXh0SGFuZGxlcjtcbiAgICB9IC8vIGNvbnNvbGUubG9nKGB0aGlzLmlkOiAke3RoaXMuaWR9LCBDbGFzczogJHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9LCB0aGlzLmh0bWw6ICR7dGhpcy5odG1sfWApXG5cblxuICAgIHZhciBjb250ZXh0SGFubGRlciA9IG5ldyBDb250ZXh0SGFubGRlcihwcm9wc1RvVXNlKTtcbiAgICBfdGhpcy5vd25Db250ZXh0ID0gY29udGV4dEhhbmxkZXIuY29udGV4dDtcbiAgICBfdGhpcy5pZnJhbWUgPSBjb250ZXh0SGFubGRlci5pZnJhbWVFbGVtZW50O1xuICAgIF90aGlzLmZvcmNlRXhwb3J0SW5jaWRlbnRzID0gdHJ1ZTtcblxuICAgIF90aGlzLm9uRE9NQ0xpcEluaXRpYWxpc2UoKTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhDbGlwLCBbe1xuICAgIGtleTogXCJvbkRPTUNMaXBJbml0aWFsaXNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uRE9NQ0xpcEluaXRpYWxpc2UoKSB7Ly8gaW1wbGVtZW50IGhlcmVcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicm9vdEVsZW1lbnRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLm93bkNvbnRleHQuY2xpcENvbnRhaW5lcjtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ2xpcDtcbn0oRXh0ZW5kYWJsZUNsaXApO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENsaXA7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/_Clip/SCGroup.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/_Clip/helpers/HTMLFragmentContextHandler.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/_Clip/helpers/HTMLFragmentContextHandler.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar Helper = __webpack_require__(/*! ../../_coreUtils/Helper */ \"./node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\");\n\nvar helper = new Helper();\n\nvar conf = __webpack_require__(/*! ../../configuration/generalConf */ \"./node_modules/@kissmybutton/motorcortex/dist/configuration/generalConf.js\");\n\nvar HTMLFragmentContextHandler =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @param {object} props - an object that should contain all of the following keys:\n   * - html (the html template to render)\n   * - css (the css template of the isolated tree)\n   * - initParams (optional / the initialisation parameteres that will be passed both on the css and the html templates in order to render)\n   * - host (an Element object that will host the isolated tree)\n   * - containerParams (an object that holds parameters to affect the container of the isolated tree, e.g. width, height etc)\n   */\n  function HTMLFragmentContextHandler() {\n    var originalProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, HTMLFragmentContextHandler);\n\n    var props = Object.assign({}, originalProps);\n\n    if (!helper.isObject(props)) {\n      helper.error(\"HTMLFragmentContextHandler expects an object on its constructor. \".concat(_typeof(props), \" passed\"));\n      return false;\n    }\n\n    if (!Object.prototype.hasOwnProperty.call(props, \"html\")) {\n      props.html = '';\n    }\n\n    this.isDOM = true;\n    var fragment = document.createDocumentFragment();\n    var wrapper = document.createElement('div');\n\n    if (Object.prototype.hasOwnProperty.call(props, \"containerParams\")) {\n      if (Object.prototype.hasOwnProperty.call(props, \"width\")) {\n        wrapper.style.width = props.containerParams.width;\n      }\n\n      if (Object.prototype.hasOwnProperty.call(props, \"height\")) {\n        wrapper.style.height = props.containerParams.height;\n      }\n    }\n\n    wrapper.innerHTML = helper.renderTemplate(props.html, {\n      params: props.initParams\n    });\n    fragment.appendChild(wrapper);\n    wrapper.style.overflow = \"hidden\";\n    this.rootElement = wrapper;\n    this.context = {\n      document: document,\n      window: window,\n      clipContainer: this.rootElement,\n      rootElement: wrapper,\n      unmount: function unmount() {\n        props.host.removeChild(fragment);\n      },\n      getElements: this.getElements.bind(this),\n      getMCID: this.getMCID.bind(this),\n      setMCID: this.setMCID.bind(this),\n      getElementSelectorByMCID: this.getElementSelectorByMCID.bind(this),\n      getElementByMCID: this.getElementByMCID.bind(this),\n      fragment: true\n    };\n    this.elementsByMCID = {};\n  }\n\n  _createClass(HTMLFragmentContextHandler, [{\n    key: \"getElementByMCID\",\n    value: function getElementByMCID(mcid) {\n      if (Object.prototype.hasOwnProperty.call(this.elementsByMCID, mcid)) {\n        return this.elementsByMCID[mcid];\n      } else {\n        var element = this.context.rootElement.querySelector(this.getElementSelectorByMCID(mcid));\n        this.elementsByMCID[mcid] = element;\n        return element;\n      }\n    }\n  }, {\n    key: \"getElements\",\n    value: function getElements(selector) {\n      return Array.from(this.context.rootElement.querySelectorAll(selector));\n    }\n  }, {\n    key: \"getMCID\",\n    value: function getMCID(element) {\n      return element.getAttribute(conf.elements_data_attribute_name);\n    }\n  }, {\n    key: \"setMCID\",\n    value: function setMCID(element, mcid) {\n      element.setAttribute(conf.elements_data_attribute_name, mcid);\n    }\n  }, {\n    key: \"getElementSelectorByMCID\",\n    value: function getElementSelectorByMCID(mcid) {\n      return '[' + conf.elements_data_attribute_name + '=\"' + mcid + '\"]';\n    }\n  }]);\n\n  return HTMLFragmentContextHandler;\n}();\n\nmodule.exports = HTMLFragmentContextHandler;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19DbGlwL2hlbHBlcnMvSFRNTEZyYWdtZW50Q29udGV4dEhhbmRsZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19DbGlwL2hlbHBlcnMvSFRNTEZyYWdtZW50Q29udGV4dEhhbmRsZXIuanM/NjYyOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG52YXIgSGVscGVyID0gcmVxdWlyZSgnLi4vLi4vX2NvcmVVdGlscy9IZWxwZXInKTtcblxudmFyIGhlbHBlciA9IG5ldyBIZWxwZXIoKTtcblxudmFyIGNvbmYgPSByZXF1aXJlKCcuLi8uLi9jb25maWd1cmF0aW9uL2dlbmVyYWxDb25mJyk7XG5cbnZhciBIVE1MRnJhZ21lbnRDb250ZXh0SGFuZGxlciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcHMgLSBhbiBvYmplY3QgdGhhdCBzaG91bGQgY29udGFpbiBhbGwgb2YgdGhlIGZvbGxvd2luZyBrZXlzOlxuICAgKiAtIGh0bWwgKHRoZSBodG1sIHRlbXBsYXRlIHRvIHJlbmRlcilcbiAgICogLSBjc3MgKHRoZSBjc3MgdGVtcGxhdGUgb2YgdGhlIGlzb2xhdGVkIHRyZWUpXG4gICAqIC0gaW5pdFBhcmFtcyAob3B0aW9uYWwgLyB0aGUgaW5pdGlhbGlzYXRpb24gcGFyYW1ldGVyZXMgdGhhdCB3aWxsIGJlIHBhc3NlZCBib3RoIG9uIHRoZSBjc3MgYW5kIHRoZSBodG1sIHRlbXBsYXRlcyBpbiBvcmRlciB0byByZW5kZXIpXG4gICAqIC0gaG9zdCAoYW4gRWxlbWVudCBvYmplY3QgdGhhdCB3aWxsIGhvc3QgdGhlIGlzb2xhdGVkIHRyZWUpXG4gICAqIC0gY29udGFpbmVyUGFyYW1zIChhbiBvYmplY3QgdGhhdCBob2xkcyBwYXJhbWV0ZXJzIHRvIGFmZmVjdCB0aGUgY29udGFpbmVyIG9mIHRoZSBpc29sYXRlZCB0cmVlLCBlLmcuIHdpZHRoLCBoZWlnaHQgZXRjKVxuICAgKi9cbiAgZnVuY3Rpb24gSFRNTEZyYWdtZW50Q29udGV4dEhhbmRsZXIoKSB7XG4gICAgdmFyIG9yaWdpbmFsUHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEhUTUxGcmFnbWVudENvbnRleHRIYW5kbGVyKTtcblxuICAgIHZhciBwcm9wcyA9IE9iamVjdC5hc3NpZ24oe30sIG9yaWdpbmFsUHJvcHMpO1xuXG4gICAgaWYgKCFoZWxwZXIuaXNPYmplY3QocHJvcHMpKSB7XG4gICAgICBoZWxwZXIuZXJyb3IoXCJIVE1MRnJhZ21lbnRDb250ZXh0SGFuZGxlciBleHBlY3RzIGFuIG9iamVjdCBvbiBpdHMgY29uc3RydWN0b3IuIFwiLmNvbmNhdChfdHlwZW9mKHByb3BzKSwgXCIgcGFzc2VkXCIpKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgXCJodG1sXCIpKSB7XG4gICAgICBwcm9wcy5odG1sID0gJyc7XG4gICAgfVxuXG4gICAgdGhpcy5pc0RPTSA9IHRydWU7XG4gICAgdmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgIHZhciB3cmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBcImNvbnRhaW5lclBhcmFtc1wiKSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgXCJ3aWR0aFwiKSkge1xuICAgICAgICB3cmFwcGVyLnN0eWxlLndpZHRoID0gcHJvcHMuY29udGFpbmVyUGFyYW1zLndpZHRoO1xuICAgICAgfVxuXG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBcImhlaWdodFwiKSkge1xuICAgICAgICB3cmFwcGVyLnN0eWxlLmhlaWdodCA9IHByb3BzLmNvbnRhaW5lclBhcmFtcy5oZWlnaHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgd3JhcHBlci5pbm5lckhUTUwgPSBoZWxwZXIucmVuZGVyVGVtcGxhdGUocHJvcHMuaHRtbCwge1xuICAgICAgcGFyYW1zOiBwcm9wcy5pbml0UGFyYW1zXG4gICAgfSk7XG4gICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQod3JhcHBlcik7XG4gICAgd3JhcHBlci5zdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG4gICAgdGhpcy5yb290RWxlbWVudCA9IHdyYXBwZXI7XG4gICAgdGhpcy5jb250ZXh0ID0ge1xuICAgICAgZG9jdW1lbnQ6IGRvY3VtZW50LFxuICAgICAgd2luZG93OiB3aW5kb3csXG4gICAgICBjbGlwQ29udGFpbmVyOiB0aGlzLnJvb3RFbGVtZW50LFxuICAgICAgcm9vdEVsZW1lbnQ6IHdyYXBwZXIsXG4gICAgICB1bm1vdW50OiBmdW5jdGlvbiB1bm1vdW50KCkge1xuICAgICAgICBwcm9wcy5ob3N0LnJlbW92ZUNoaWxkKGZyYWdtZW50KTtcbiAgICAgIH0sXG4gICAgICBnZXRFbGVtZW50czogdGhpcy5nZXRFbGVtZW50cy5iaW5kKHRoaXMpLFxuICAgICAgZ2V0TUNJRDogdGhpcy5nZXRNQ0lELmJpbmQodGhpcyksXG4gICAgICBzZXRNQ0lEOiB0aGlzLnNldE1DSUQuYmluZCh0aGlzKSxcbiAgICAgIGdldEVsZW1lbnRTZWxlY3RvckJ5TUNJRDogdGhpcy5nZXRFbGVtZW50U2VsZWN0b3JCeU1DSUQuYmluZCh0aGlzKSxcbiAgICAgIGdldEVsZW1lbnRCeU1DSUQ6IHRoaXMuZ2V0RWxlbWVudEJ5TUNJRC5iaW5kKHRoaXMpLFxuICAgICAgZnJhZ21lbnQ6IHRydWVcbiAgICB9O1xuICAgIHRoaXMuZWxlbWVudHNCeU1DSUQgPSB7fTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhIVE1MRnJhZ21lbnRDb250ZXh0SGFuZGxlciwgW3tcbiAgICBrZXk6IFwiZ2V0RWxlbWVudEJ5TUNJRFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRFbGVtZW50QnlNQ0lEKG1jaWQpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5lbGVtZW50c0J5TUNJRCwgbWNpZCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudHNCeU1DSURbbWNpZF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuY29udGV4dC5yb290RWxlbWVudC5xdWVyeVNlbGVjdG9yKHRoaXMuZ2V0RWxlbWVudFNlbGVjdG9yQnlNQ0lEKG1jaWQpKTtcbiAgICAgICAgdGhpcy5lbGVtZW50c0J5TUNJRFttY2lkXSA9IGVsZW1lbnQ7XG4gICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRFbGVtZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRFbGVtZW50cyhzZWxlY3Rvcikge1xuICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5jb250ZXh0LnJvb3RFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TUNJRFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNQ0lEKGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBlbGVtZW50LmdldEF0dHJpYnV0ZShjb25mLmVsZW1lbnRzX2RhdGFfYXR0cmlidXRlX25hbWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRNQ0lEXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE1DSUQoZWxlbWVudCwgbWNpZCkge1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoY29uZi5lbGVtZW50c19kYXRhX2F0dHJpYnV0ZV9uYW1lLCBtY2lkKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RWxlbWVudFNlbGVjdG9yQnlNQ0lEXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEVsZW1lbnRTZWxlY3RvckJ5TUNJRChtY2lkKSB7XG4gICAgICByZXR1cm4gJ1snICsgY29uZi5lbGVtZW50c19kYXRhX2F0dHJpYnV0ZV9uYW1lICsgJz1cIicgKyBtY2lkICsgJ1wiXSc7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEhUTUxGcmFnbWVudENvbnRleHRIYW5kbGVyO1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhUTUxGcmFnbWVudENvbnRleHRIYW5kbGVyOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/_Clip/helpers/HTMLFragmentContextHandler.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/_Clip/helpers/IframeContextHandler.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/_Clip/helpers/IframeContextHandler.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/*\niframe[seamless]{\n    background-color: transparent;\n    border: 0px none transparent;\n    padding: 0px;\n    overflow: hidden;\n}\n\nmight need more work for IE. See here: https://stackoverflow.com/a/29209248\n*/\nvar Helper = __webpack_require__(/*! ../../_coreUtils/Helper */ \"./node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\");\n\nvar helper = new Helper();\n\nvar conf = __webpack_require__(/*! ../../configuration/generalConf */ \"./node_modules/@kissmybutton/motorcortex/dist/configuration/generalConf.js\");\n\nvar IframeContextHandler =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @param {object} props - an object that should contain all of the following keys:\n   * - html (the html template to render)\n   * - css (the css template of the isolated tree)\n   * - initParams (optional / the initialisation parameteres that will be passed both on the css and the html templates in order to render)\n   * - host (an Element object that will host the isolated tree)\n   * - containerParams (an object that holds parameters to affect the container of the isolated tree, e.g. width, height etc)\n   */\n  function IframeContextHandler() {\n    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, IframeContextHandler);\n\n    if (!helper.isObject(props)) {\n      helper.error(\"ContextHandler expects an object on its constructor. \".concat(_typeof(props), \" passed\"));\n      return false;\n    }\n\n    if (!Object.prototype.hasOwnProperty.call(props, 'html')) {\n      helper.error(\"ContextHandler expects the html key on its constructor properties which is missing\");\n      return false;\n    }\n\n    if (!Object.prototype.hasOwnProperty.call(props, 'css')) {\n      helper.error(\"ContextHandler expects the css key on its constructor properties which is missing\");\n      return false;\n    }\n\n    if (!Object.prototype.hasOwnProperty.call(props, 'initParams')) {\n      helper.info(\"ContextHandler got null initParams\");\n    }\n\n    if (!Object.prototype.hasOwnProperty.call(props, 'host')) {\n      helper.error(\"ContextHandler expects the host key on its constructor properties which is missing\");\n      return false;\n    }\n\n    this.isDOM = true;\n    var ownerDocument = props.host.ownerDocument;\n\n    if (!ownerDocument.getElementById(\"@kissmybutton/motorcortex/iframeContextHandler/css\")) {\n      var seamlessCSS = \"\\n            iframe[seamless]{\\n                background-color: transparent;\\n                border: 0px none transparent;\\n                padding: 0px;\\n                overflow: hidden;\\n            }\\n            \";\n      var iframesCSS = ownerDocument.createElement('style');\n      iframesCSS.id = \"@kissmybutton/motorcortex/iframeContextHandler/css\";\n      iframesCSS.type = 'text/css';\n      var Head = ownerDocument.head || ownerDocument.getElementsByTagName('head')[0];\n\n      if (iframesCSS.styleSheet) {\n        iframesCSS.styleSheet.cssText = seamlessCSS;\n      } else {\n        iframesCSS.appendChild(ownerDocument.createTextNode(seamlessCSS));\n      }\n\n      Head.appendChild(iframesCSS);\n    } // Create an iframe:\n\n\n    var iframe = ownerDocument.createElement('iframe');\n    props.host.appendChild(iframe);\n    iframe.setAttribute(\"seamless\", \"seamless\");\n\n    if (Object.prototype.hasOwnProperty.call(props, 'containerParams')) {\n      if (Object.prototype.hasOwnProperty.call(props.containerParams, 'width')) {\n        iframe.setAttribute('width', props.containerParams.width);\n      }\n\n      if (Object.prototype.hasOwnProperty.call(props.containerParams, 'height')) {\n        iframe.setAttribute('height', props.containerParams.height);\n      }\n    } // Initialise the iframe\n\n\n    iframe.src = ''; // Put it in the document (but hidden):\n\n    var iframeDocument = iframe.contentWindow || iframe.contentDocument;\n\n    if (iframeDocument.document) {\n      iframeDocument = iframeDocument.document;\n    }\n\n    iframeDocument.write(helper.renderTemplate(props.html, {\n      params: props.initParams\n    }));\n    var bodyFixCSS = \"\\n        body{\\n            padding:0;\\n            margin:0;\\n        }\\n        \";\n    var styleTag = iframeDocument.createElement('style');\n    styleTag.type = 'text/css';\n\n    if (styleTag.styleSheet) {\n      styleTag.styleSheet.cssText = helper.renderTemplate(props.css, {\n        params: props.initParams\n      }) + bodyFixCSS;\n    } else {\n      styleTag.appendChild(ownerDocument.createTextNode(props.css + bodyFixCSS));\n    }\n\n    var head = iframeDocument.head || iframeDocument.getElementsByTagName('head')[0];\n    head.appendChild(styleTag);\n\n    if (Object.prototype.hasOwnProperty.call(props, 'fonts')) {\n      for (var i = 0; i < props.fonts.length; i++) {\n        var theFont = props.fonts[i];\n\n        if (theFont.type === \"google-font\") {\n          var fontTag = iframeDocument.createElement('link');\n          fontTag.setAttribute('rel', 'stylesheet');\n          fontTag.setAttribute('src', theFont.src);\n          head.appendChild(fontTag);\n        }\n      }\n    }\n\n    this.rootElement = iframe;\n    this.context = {\n      document: iframeDocument,\n      window: iframe.contentWindow || iframe,\n      clipContainer: iframe,\n      rootElement: iframeDocument.body,\n      unmount: function unmount() {\n        props.host.removeChild(iframe);\n      },\n      getElements: this.getElements.bind(this),\n      getMCID: this.getMCID.bind(this),\n      setMCID: this.setMCID.bind(this),\n      getElementSelectorByMCID: this.getElementSelectorByMCID.bind(this),\n      getElementByMCID: this.getElementByMCID.bind(this)\n    };\n    iframeDocument.close();\n    this.elementsByMCID = {};\n  }\n\n  _createClass(IframeContextHandler, [{\n    key: \"getElementByMCID\",\n    value: function getElementByMCID(mcid) {\n      if (Object.prototype.hasOwnProperty.call(this.elementsByMCID, mcid)) {\n        return this.elementsByMCID[mcid];\n      } else {\n        var element = this.context.rootElement.querySelector(this.getElementSelectorByMCID(mcid));\n        this.elementsByMCID[mcid] = element;\n        return element;\n      }\n    }\n  }, {\n    key: \"getElements\",\n    value: function getElements(selector) {\n      return Array.from(this.context.rootElement.querySelectorAll(selector));\n    }\n  }, {\n    key: \"getMCID\",\n    value: function getMCID(element) {\n      return element.getAttribute(conf.elements_data_attribute_name);\n    }\n  }, {\n    key: \"setMCID\",\n    value: function setMCID(element, mcid) {\n      element.setAttribute(conf.elements_data_attribute_name, mcid);\n    }\n  }, {\n    key: \"getElementSelectorByMCID\",\n    value: function getElementSelectorByMCID(mcid) {\n      return '[' + conf.elements_data_attribute_name + '=\"' + mcid + '\"]';\n    }\n  }]);\n\n  return IframeContextHandler;\n}();\n\nmodule.exports = IframeContextHandler;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19DbGlwL2hlbHBlcnMvSWZyYW1lQ29udGV4dEhhbmRsZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19DbGlwL2hlbHBlcnMvSWZyYW1lQ29udGV4dEhhbmRsZXIuanM/OWNlNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG4vKlxuaWZyYW1lW3NlYW1sZXNzXXtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcbiAgICBib3JkZXI6IDBweCBub25lIHRyYW5zcGFyZW50O1xuICAgIHBhZGRpbmc6IDBweDtcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xufVxuXG5taWdodCBuZWVkIG1vcmUgd29yayBmb3IgSUUuIFNlZSBoZXJlOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjkyMDkyNDhcbiovXG52YXIgSGVscGVyID0gcmVxdWlyZSgnLi4vLi4vX2NvcmVVdGlscy9IZWxwZXInKTtcblxudmFyIGhlbHBlciA9IG5ldyBIZWxwZXIoKTtcblxudmFyIGNvbmYgPSByZXF1aXJlKCcuLi8uLi9jb25maWd1cmF0aW9uL2dlbmVyYWxDb25mJyk7XG5cbnZhciBJZnJhbWVDb250ZXh0SGFuZGxlciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcHMgLSBhbiBvYmplY3QgdGhhdCBzaG91bGQgY29udGFpbiBhbGwgb2YgdGhlIGZvbGxvd2luZyBrZXlzOlxuICAgKiAtIGh0bWwgKHRoZSBodG1sIHRlbXBsYXRlIHRvIHJlbmRlcilcbiAgICogLSBjc3MgKHRoZSBjc3MgdGVtcGxhdGUgb2YgdGhlIGlzb2xhdGVkIHRyZWUpXG4gICAqIC0gaW5pdFBhcmFtcyAob3B0aW9uYWwgLyB0aGUgaW5pdGlhbGlzYXRpb24gcGFyYW1ldGVyZXMgdGhhdCB3aWxsIGJlIHBhc3NlZCBib3RoIG9uIHRoZSBjc3MgYW5kIHRoZSBodG1sIHRlbXBsYXRlcyBpbiBvcmRlciB0byByZW5kZXIpXG4gICAqIC0gaG9zdCAoYW4gRWxlbWVudCBvYmplY3QgdGhhdCB3aWxsIGhvc3QgdGhlIGlzb2xhdGVkIHRyZWUpXG4gICAqIC0gY29udGFpbmVyUGFyYW1zIChhbiBvYmplY3QgdGhhdCBob2xkcyBwYXJhbWV0ZXJzIHRvIGFmZmVjdCB0aGUgY29udGFpbmVyIG9mIHRoZSBpc29sYXRlZCB0cmVlLCBlLmcuIHdpZHRoLCBoZWlnaHQgZXRjKVxuICAgKi9cbiAgZnVuY3Rpb24gSWZyYW1lQ29udGV4dEhhbmRsZXIoKSB7XG4gICAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJZnJhbWVDb250ZXh0SGFuZGxlcik7XG5cbiAgICBpZiAoIWhlbHBlci5pc09iamVjdChwcm9wcykpIHtcbiAgICAgIGhlbHBlci5lcnJvcihcIkNvbnRleHRIYW5kbGVyIGV4cGVjdHMgYW4gb2JqZWN0IG9uIGl0cyBjb25zdHJ1Y3Rvci4gXCIuY29uY2F0KF90eXBlb2YocHJvcHMpLCBcIiBwYXNzZWRcIikpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCAnaHRtbCcpKSB7XG4gICAgICBoZWxwZXIuZXJyb3IoXCJDb250ZXh0SGFuZGxlciBleHBlY3RzIHRoZSBodG1sIGtleSBvbiBpdHMgY29uc3RydWN0b3IgcHJvcGVydGllcyB3aGljaCBpcyBtaXNzaW5nXCIpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCAnY3NzJykpIHtcbiAgICAgIGhlbHBlci5lcnJvcihcIkNvbnRleHRIYW5kbGVyIGV4cGVjdHMgdGhlIGNzcyBrZXkgb24gaXRzIGNvbnN0cnVjdG9yIHByb3BlcnRpZXMgd2hpY2ggaXMgbWlzc2luZ1wiKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgJ2luaXRQYXJhbXMnKSkge1xuICAgICAgaGVscGVyLmluZm8oXCJDb250ZXh0SGFuZGxlciBnb3QgbnVsbCBpbml0UGFyYW1zXCIpO1xuICAgIH1cblxuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCAnaG9zdCcpKSB7XG4gICAgICBoZWxwZXIuZXJyb3IoXCJDb250ZXh0SGFuZGxlciBleHBlY3RzIHRoZSBob3N0IGtleSBvbiBpdHMgY29uc3RydWN0b3IgcHJvcGVydGllcyB3aGljaCBpcyBtaXNzaW5nXCIpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuaXNET00gPSB0cnVlO1xuICAgIHZhciBvd25lckRvY3VtZW50ID0gcHJvcHMuaG9zdC5vd25lckRvY3VtZW50O1xuXG4gICAgaWYgKCFvd25lckRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9pZnJhbWVDb250ZXh0SGFuZGxlci9jc3NcIikpIHtcbiAgICAgIHZhciBzZWFtbGVzc0NTUyA9IFwiXFxuICAgICAgICAgICAgaWZyYW1lW3NlYW1sZXNzXXtcXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICAgICAgICAgICAgICAgIGJvcmRlcjogMHB4IG5vbmUgdHJhbnNwYXJlbnQ7XFxuICAgICAgICAgICAgICAgIHBhZGRpbmc6IDBweDtcXG4gICAgICAgICAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgXCI7XG4gICAgICB2YXIgaWZyYW1lc0NTUyA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICAgIGlmcmFtZXNDU1MuaWQgPSBcIkBraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvaWZyYW1lQ29udGV4dEhhbmRsZXIvY3NzXCI7XG4gICAgICBpZnJhbWVzQ1NTLnR5cGUgPSAndGV4dC9jc3MnO1xuICAgICAgdmFyIEhlYWQgPSBvd25lckRvY3VtZW50LmhlYWQgfHwgb3duZXJEb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO1xuXG4gICAgICBpZiAoaWZyYW1lc0NTUy5zdHlsZVNoZWV0KSB7XG4gICAgICAgIGlmcmFtZXNDU1Muc3R5bGVTaGVldC5jc3NUZXh0ID0gc2VhbWxlc3NDU1M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZnJhbWVzQ1NTLmFwcGVuZENoaWxkKG93bmVyRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoc2VhbWxlc3NDU1MpKTtcbiAgICAgIH1cblxuICAgICAgSGVhZC5hcHBlbmRDaGlsZChpZnJhbWVzQ1NTKTtcbiAgICB9IC8vIENyZWF0ZSBhbiBpZnJhbWU6XG5cblxuICAgIHZhciBpZnJhbWUgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgIHByb3BzLmhvc3QuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgICBpZnJhbWUuc2V0QXR0cmlidXRlKFwic2VhbWxlc3NcIiwgXCJzZWFtbGVzc1wiKTtcblxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocHJvcHMsICdjb250YWluZXJQYXJhbXMnKSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcy5jb250YWluZXJQYXJhbXMsICd3aWR0aCcpKSB7XG4gICAgICAgIGlmcmFtZS5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgcHJvcHMuY29udGFpbmVyUGFyYW1zLndpZHRoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcy5jb250YWluZXJQYXJhbXMsICdoZWlnaHQnKSkge1xuICAgICAgICBpZnJhbWUuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBwcm9wcy5jb250YWluZXJQYXJhbXMuaGVpZ2h0KTtcbiAgICAgIH1cbiAgICB9IC8vIEluaXRpYWxpc2UgdGhlIGlmcmFtZVxuXG5cbiAgICBpZnJhbWUuc3JjID0gJyc7IC8vIFB1dCBpdCBpbiB0aGUgZG9jdW1lbnQgKGJ1dCBoaWRkZW4pOlxuXG4gICAgdmFyIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cgfHwgaWZyYW1lLmNvbnRlbnREb2N1bWVudDtcblxuICAgIGlmIChpZnJhbWVEb2N1bWVudC5kb2N1bWVudCkge1xuICAgICAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWVEb2N1bWVudC5kb2N1bWVudDtcbiAgICB9XG5cbiAgICBpZnJhbWVEb2N1bWVudC53cml0ZShoZWxwZXIucmVuZGVyVGVtcGxhdGUocHJvcHMuaHRtbCwge1xuICAgICAgcGFyYW1zOiBwcm9wcy5pbml0UGFyYW1zXG4gICAgfSkpO1xuICAgIHZhciBib2R5Rml4Q1NTID0gXCJcXG4gICAgICAgIGJvZHl7XFxuICAgICAgICAgICAgcGFkZGluZzowO1xcbiAgICAgICAgICAgIG1hcmdpbjowO1xcbiAgICAgICAgfVxcbiAgICAgICAgXCI7XG4gICAgdmFyIHN0eWxlVGFnID0gaWZyYW1lRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICBzdHlsZVRhZy50eXBlID0gJ3RleHQvY3NzJztcblxuICAgIGlmIChzdHlsZVRhZy5zdHlsZVNoZWV0KSB7XG4gICAgICBzdHlsZVRhZy5zdHlsZVNoZWV0LmNzc1RleHQgPSBoZWxwZXIucmVuZGVyVGVtcGxhdGUocHJvcHMuY3NzLCB7XG4gICAgICAgIHBhcmFtczogcHJvcHMuaW5pdFBhcmFtc1xuICAgICAgfSkgKyBib2R5Rml4Q1NTO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZVRhZy5hcHBlbmRDaGlsZChvd25lckRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHByb3BzLmNzcyArIGJvZHlGaXhDU1MpKTtcbiAgICB9XG5cbiAgICB2YXIgaGVhZCA9IGlmcmFtZURvY3VtZW50LmhlYWQgfHwgaWZyYW1lRG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcbiAgICBoZWFkLmFwcGVuZENoaWxkKHN0eWxlVGFnKTtcblxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocHJvcHMsICdmb250cycpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmZvbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB0aGVGb250ID0gcHJvcHMuZm9udHNbaV07XG5cbiAgICAgICAgaWYgKHRoZUZvbnQudHlwZSA9PT0gXCJnb29nbGUtZm9udFwiKSB7XG4gICAgICAgICAgdmFyIGZvbnRUYWcgPSBpZnJhbWVEb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaW5rJyk7XG4gICAgICAgICAgZm9udFRhZy5zZXRBdHRyaWJ1dGUoJ3JlbCcsICdzdHlsZXNoZWV0Jyk7XG4gICAgICAgICAgZm9udFRhZy5zZXRBdHRyaWJ1dGUoJ3NyYycsIHRoZUZvbnQuc3JjKTtcbiAgICAgICAgICBoZWFkLmFwcGVuZENoaWxkKGZvbnRUYWcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5yb290RWxlbWVudCA9IGlmcmFtZTtcbiAgICB0aGlzLmNvbnRleHQgPSB7XG4gICAgICBkb2N1bWVudDogaWZyYW1lRG9jdW1lbnQsXG4gICAgICB3aW5kb3c6IGlmcmFtZS5jb250ZW50V2luZG93IHx8IGlmcmFtZSxcbiAgICAgIGNsaXBDb250YWluZXI6IGlmcmFtZSxcbiAgICAgIHJvb3RFbGVtZW50OiBpZnJhbWVEb2N1bWVudC5ib2R5LFxuICAgICAgdW5tb3VudDogZnVuY3Rpb24gdW5tb3VudCgpIHtcbiAgICAgICAgcHJvcHMuaG9zdC5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICAgICAgfSxcbiAgICAgIGdldEVsZW1lbnRzOiB0aGlzLmdldEVsZW1lbnRzLmJpbmQodGhpcyksXG4gICAgICBnZXRNQ0lEOiB0aGlzLmdldE1DSUQuYmluZCh0aGlzKSxcbiAgICAgIHNldE1DSUQ6IHRoaXMuc2V0TUNJRC5iaW5kKHRoaXMpLFxuICAgICAgZ2V0RWxlbWVudFNlbGVjdG9yQnlNQ0lEOiB0aGlzLmdldEVsZW1lbnRTZWxlY3RvckJ5TUNJRC5iaW5kKHRoaXMpLFxuICAgICAgZ2V0RWxlbWVudEJ5TUNJRDogdGhpcy5nZXRFbGVtZW50QnlNQ0lELmJpbmQodGhpcylcbiAgICB9O1xuICAgIGlmcmFtZURvY3VtZW50LmNsb3NlKCk7XG4gICAgdGhpcy5lbGVtZW50c0J5TUNJRCA9IHt9O1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKElmcmFtZUNvbnRleHRIYW5kbGVyLCBbe1xuICAgIGtleTogXCJnZXRFbGVtZW50QnlNQ0lEXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEVsZW1lbnRCeU1DSUQobWNpZCkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmVsZW1lbnRzQnlNQ0lELCBtY2lkKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50c0J5TUNJRFttY2lkXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5jb250ZXh0LnJvb3RFbGVtZW50LnF1ZXJ5U2VsZWN0b3IodGhpcy5nZXRFbGVtZW50U2VsZWN0b3JCeU1DSUQobWNpZCkpO1xuICAgICAgICB0aGlzLmVsZW1lbnRzQnlNQ0lEW21jaWRdID0gZWxlbWVudDtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEVsZW1lbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEVsZW1lbnRzKHNlbGVjdG9yKSB7XG4gICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmNvbnRleHQucm9vdEVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRNQ0lEXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE1DSUQoZWxlbWVudCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQuZ2V0QXR0cmlidXRlKGNvbmYuZWxlbWVudHNfZGF0YV9hdHRyaWJ1dGVfbmFtZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldE1DSURcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0TUNJRChlbGVtZW50LCBtY2lkKSB7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShjb25mLmVsZW1lbnRzX2RhdGFfYXR0cmlidXRlX25hbWUsIG1jaWQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRFbGVtZW50U2VsZWN0b3JCeU1DSURcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RWxlbWVudFNlbGVjdG9yQnlNQ0lEKG1jaWQpIHtcbiAgICAgIHJldHVybiAnWycgKyBjb25mLmVsZW1lbnRzX2RhdGFfYXR0cmlidXRlX25hbWUgKyAnPVwiJyArIG1jaWQgKyAnXCJdJztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSWZyYW1lQ29udGV4dEhhbmRsZXI7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gSWZyYW1lQ29udGV4dEhhbmRsZXI7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/_Clip/helpers/IframeContextHandler.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/_Clip/helpers/WebComponentContextHandler.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/_Clip/helpers/WebComponentContextHandler.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/*\niframe[seamless]{\n    background-color: transparent;\n    border: 0px none transparent;\n    padding: 0px;\n    overflow: hidden;\n}\n\nmight need more work for IE. See here: https://stackoverflow.com/a/29209248\n*/\nvar Helper = __webpack_require__(/*! ../../_coreUtils/Helper */ \"./node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\");\n\nvar helper = new Helper();\n\nvar conf = __webpack_require__(/*! ../../configuration/generalConf */ \"./node_modules/@kissmybutton/motorcortex/dist/configuration/generalConf.js\");\n\nvar WebComponentContextHandler =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @param {object} props - an object that should contain all of the following keys:\n   * - html (the html template to render)\n   * - css (the css template of the isolated tree)\n   * - initParams (optional / the initialisation parameteres that will be passed both on the css and the html templates in order to render)\n   * - host (an Element object that will host the isolated tree)\n   * - containerParams (an object that holds parameters to affect the container of the isolated tree, e.g. width, height etc)\n   */\n  function WebComponentContextHandler() {\n    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, WebComponentContextHandler);\n\n    if (!helper.isObject(props)) {\n      helper.error(\"ContextHandler expects an object on its constructor. \".concat(_typeof(props), \" passed\"));\n      return false;\n    }\n\n    if (!Object.prototype.hasOwnProperty.call(props, \"html\")) {\n      helper.error(\"ContextHandler expects the html key on its constructor properties which is missing\");\n      return false;\n    }\n\n    if (!Object.prototype.hasOwnProperty.call(props, \"css\")) {\n      helper.error(\"ContextHandler expects the css key on its constructor properties which is missing\");\n      return false;\n    }\n\n    if (!Object.prototype.hasOwnProperty.call(props, \"host\")) {\n      helper.error(\"ContextHandler expects the host key on its constructor properties which is missing\");\n      return false;\n    }\n\n    this.isDOM = true;\n    var shadow = props.host.attachShadow({\n      mode: 'closed'\n    });\n    var wrapper = document.createElement('div');\n\n    if (Object.prototype.hasOwnProperty.call(props, \"containerParams\")) {\n      if (Object.prototype.hasOwnProperty.call(props.containerParams, \"width\")) {\n        wrapper.style.width = props.containerParams.width;\n      }\n\n      if (Object.prototype.hasOwnProperty.call(props.containerParams, \"height\")) {\n        wrapper.style.height = props.containerParams.height;\n      }\n    }\n\n    wrapper.innerHTML = helper.renderTemplate(props.html + '<slot></slot>', {\n      params: props.initParams\n    });\n    shadow.appendChild(wrapper);\n    var styleTag = document.createElement('style');\n    styleTag.type = 'text/css';\n\n    if (styleTag.styleSheet) {\n      styleTag.styleSheet.cssText = helper.renderTemplate(props.css, {\n        params: props.initParams\n      });\n    } else {\n      styleTag.appendChild(document.createTextNode(props.css));\n    }\n\n    shadow.appendChild(styleTag);\n\n    if (Object.prototype.hasOwnProperty.call(props, \"fonts\")) {\n      for (var i = 0; i < props.fonts.length; i++) {\n        var theFont = props.fonts[i];\n\n        if (theFont.type === \"google-font\") {\n          var fontTag = document.createElement('link');\n          fontTag.setAttribute('rel', 'stylesheet');\n          fontTag.setAttribute('src', theFont.src);\n          shadow.appendChild(fontTag);\n        }\n      }\n    }\n\n    wrapper.style.overflow = \"hidden\";\n    this.rootElement = wrapper;\n    this.context = {\n      document: document,\n      window: window,\n      clipContainer: this.rootElement,\n      rootElement: wrapper,\n      unmount: function unmount() {\n        try {\n          props.host.removeChild(shadow);\n        } catch (er) {\n          helper.warning('The element of the Clip to be removed seems not to exist any more');\n        }\n      },\n      getElements: this.getElements.bind(this),\n      getMCID: this.getMCID.bind(this),\n      setMCID: this.setMCID.bind(this),\n      getElementSelectorByMCID: this.getElementSelectorByMCID.bind(this),\n      getElementByMCID: this.getElementByMCID.bind(this)\n    };\n    this.elementsByMCID = {};\n  }\n\n  _createClass(WebComponentContextHandler, [{\n    key: \"getElementByMCID\",\n    value: function getElementByMCID(mcid) {\n      if (Object.prototype.hasOwnProperty.call(this.elementsByMCID, mcid)) {\n        return this.elementsByMCID[mcid];\n      } else {\n        var element = this.context.rootElement.querySelector(this.getElementSelectorByMCID(mcid));\n        this.elementsByMCID[mcid] = element;\n        return element;\n      }\n    }\n  }, {\n    key: \"getElements\",\n    value: function getElements(selector) {\n      return Array.from(this.context.rootElement.querySelectorAll(selector));\n    }\n  }, {\n    key: \"getMCID\",\n    value: function getMCID(element) {\n      return element.getAttribute(conf.elements_data_attribute_name);\n    }\n  }, {\n    key: \"setMCID\",\n    value: function setMCID(element, mcid) {\n      element.setAttribute(conf.elements_data_attribute_name, mcid);\n    }\n  }, {\n    key: \"getElementSelectorByMCID\",\n    value: function getElementSelectorByMCID(mcid) {\n      return '[' + conf.elements_data_attribute_name + '=\"' + mcid + '\"]';\n    }\n  }]);\n\n  return WebComponentContextHandler;\n}();\n\nmodule.exports = WebComponentContextHandler;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19DbGlwL2hlbHBlcnMvV2ViQ29tcG9uZW50Q29udGV4dEhhbmRsZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19DbGlwL2hlbHBlcnMvV2ViQ29tcG9uZW50Q29udGV4dEhhbmRsZXIuanM/NDU5YSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG4vKlxuaWZyYW1lW3NlYW1sZXNzXXtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcbiAgICBib3JkZXI6IDBweCBub25lIHRyYW5zcGFyZW50O1xuICAgIHBhZGRpbmc6IDBweDtcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xufVxuXG5taWdodCBuZWVkIG1vcmUgd29yayBmb3IgSUUuIFNlZSBoZXJlOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjkyMDkyNDhcbiovXG52YXIgSGVscGVyID0gcmVxdWlyZSgnLi4vLi4vX2NvcmVVdGlscy9IZWxwZXInKTtcblxudmFyIGhlbHBlciA9IG5ldyBIZWxwZXIoKTtcblxudmFyIGNvbmYgPSByZXF1aXJlKCcuLi8uLi9jb25maWd1cmF0aW9uL2dlbmVyYWxDb25mJyk7XG5cbnZhciBXZWJDb21wb25lbnRDb250ZXh0SGFuZGxlciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcHMgLSBhbiBvYmplY3QgdGhhdCBzaG91bGQgY29udGFpbiBhbGwgb2YgdGhlIGZvbGxvd2luZyBrZXlzOlxuICAgKiAtIGh0bWwgKHRoZSBodG1sIHRlbXBsYXRlIHRvIHJlbmRlcilcbiAgICogLSBjc3MgKHRoZSBjc3MgdGVtcGxhdGUgb2YgdGhlIGlzb2xhdGVkIHRyZWUpXG4gICAqIC0gaW5pdFBhcmFtcyAob3B0aW9uYWwgLyB0aGUgaW5pdGlhbGlzYXRpb24gcGFyYW1ldGVyZXMgdGhhdCB3aWxsIGJlIHBhc3NlZCBib3RoIG9uIHRoZSBjc3MgYW5kIHRoZSBodG1sIHRlbXBsYXRlcyBpbiBvcmRlciB0byByZW5kZXIpXG4gICAqIC0gaG9zdCAoYW4gRWxlbWVudCBvYmplY3QgdGhhdCB3aWxsIGhvc3QgdGhlIGlzb2xhdGVkIHRyZWUpXG4gICAqIC0gY29udGFpbmVyUGFyYW1zIChhbiBvYmplY3QgdGhhdCBob2xkcyBwYXJhbWV0ZXJzIHRvIGFmZmVjdCB0aGUgY29udGFpbmVyIG9mIHRoZSBpc29sYXRlZCB0cmVlLCBlLmcuIHdpZHRoLCBoZWlnaHQgZXRjKVxuICAgKi9cbiAgZnVuY3Rpb24gV2ViQ29tcG9uZW50Q29udGV4dEhhbmRsZXIoKSB7XG4gICAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBXZWJDb21wb25lbnRDb250ZXh0SGFuZGxlcik7XG5cbiAgICBpZiAoIWhlbHBlci5pc09iamVjdChwcm9wcykpIHtcbiAgICAgIGhlbHBlci5lcnJvcihcIkNvbnRleHRIYW5kbGVyIGV4cGVjdHMgYW4gb2JqZWN0IG9uIGl0cyBjb25zdHJ1Y3Rvci4gXCIuY29uY2F0KF90eXBlb2YocHJvcHMpLCBcIiBwYXNzZWRcIikpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBcImh0bWxcIikpIHtcbiAgICAgIGhlbHBlci5lcnJvcihcIkNvbnRleHRIYW5kbGVyIGV4cGVjdHMgdGhlIGh0bWwga2V5IG9uIGl0cyBjb25zdHJ1Y3RvciBwcm9wZXJ0aWVzIHdoaWNoIGlzIG1pc3NpbmdcIik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIFwiY3NzXCIpKSB7XG4gICAgICBoZWxwZXIuZXJyb3IoXCJDb250ZXh0SGFuZGxlciBleHBlY3RzIHRoZSBjc3Mga2V5IG9uIGl0cyBjb25zdHJ1Y3RvciBwcm9wZXJ0aWVzIHdoaWNoIGlzIG1pc3NpbmdcIik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIFwiaG9zdFwiKSkge1xuICAgICAgaGVscGVyLmVycm9yKFwiQ29udGV4dEhhbmRsZXIgZXhwZWN0cyB0aGUgaG9zdCBrZXkgb24gaXRzIGNvbnN0cnVjdG9yIHByb3BlcnRpZXMgd2hpY2ggaXMgbWlzc2luZ1wiKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLmlzRE9NID0gdHJ1ZTtcbiAgICB2YXIgc2hhZG93ID0gcHJvcHMuaG9zdC5hdHRhY2hTaGFkb3coe1xuICAgICAgbW9kZTogJ2Nsb3NlZCdcbiAgICB9KTtcbiAgICB2YXIgd3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgXCJjb250YWluZXJQYXJhbXNcIikpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocHJvcHMuY29udGFpbmVyUGFyYW1zLCBcIndpZHRoXCIpKSB7XG4gICAgICAgIHdyYXBwZXIuc3R5bGUud2lkdGggPSBwcm9wcy5jb250YWluZXJQYXJhbXMud2lkdGg7XG4gICAgICB9XG5cbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocHJvcHMuY29udGFpbmVyUGFyYW1zLCBcImhlaWdodFwiKSkge1xuICAgICAgICB3cmFwcGVyLnN0eWxlLmhlaWdodCA9IHByb3BzLmNvbnRhaW5lclBhcmFtcy5oZWlnaHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgd3JhcHBlci5pbm5lckhUTUwgPSBoZWxwZXIucmVuZGVyVGVtcGxhdGUocHJvcHMuaHRtbCArICc8c2xvdD48L3Nsb3Q+Jywge1xuICAgICAgcGFyYW1zOiBwcm9wcy5pbml0UGFyYW1zXG4gICAgfSk7XG4gICAgc2hhZG93LmFwcGVuZENoaWxkKHdyYXBwZXIpO1xuICAgIHZhciBzdHlsZVRhZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgc3R5bGVUYWcudHlwZSA9ICd0ZXh0L2Nzcyc7XG5cbiAgICBpZiAoc3R5bGVUYWcuc3R5bGVTaGVldCkge1xuICAgICAgc3R5bGVUYWcuc3R5bGVTaGVldC5jc3NUZXh0ID0gaGVscGVyLnJlbmRlclRlbXBsYXRlKHByb3BzLmNzcywge1xuICAgICAgICBwYXJhbXM6IHByb3BzLmluaXRQYXJhbXNcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZVRhZy5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShwcm9wcy5jc3MpKTtcbiAgICB9XG5cbiAgICBzaGFkb3cuYXBwZW5kQ2hpbGQoc3R5bGVUYWcpO1xuXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgXCJmb250c1wiKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5mb250cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdGhlRm9udCA9IHByb3BzLmZvbnRzW2ldO1xuXG4gICAgICAgIGlmICh0aGVGb250LnR5cGUgPT09IFwiZ29vZ2xlLWZvbnRcIikge1xuICAgICAgICAgIHZhciBmb250VGFnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGluaycpO1xuICAgICAgICAgIGZvbnRUYWcuc2V0QXR0cmlidXRlKCdyZWwnLCAnc3R5bGVzaGVldCcpO1xuICAgICAgICAgIGZvbnRUYWcuc2V0QXR0cmlidXRlKCdzcmMnLCB0aGVGb250LnNyYyk7XG4gICAgICAgICAgc2hhZG93LmFwcGVuZENoaWxkKGZvbnRUYWcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgd3JhcHBlci5zdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG4gICAgdGhpcy5yb290RWxlbWVudCA9IHdyYXBwZXI7XG4gICAgdGhpcy5jb250ZXh0ID0ge1xuICAgICAgZG9jdW1lbnQ6IGRvY3VtZW50LFxuICAgICAgd2luZG93OiB3aW5kb3csXG4gICAgICBjbGlwQ29udGFpbmVyOiB0aGlzLnJvb3RFbGVtZW50LFxuICAgICAgcm9vdEVsZW1lbnQ6IHdyYXBwZXIsXG4gICAgICB1bm1vdW50OiBmdW5jdGlvbiB1bm1vdW50KCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHByb3BzLmhvc3QucmVtb3ZlQ2hpbGQoc2hhZG93KTtcbiAgICAgICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgICAgICBoZWxwZXIud2FybmluZygnVGhlIGVsZW1lbnQgb2YgdGhlIENsaXAgdG8gYmUgcmVtb3ZlZCBzZWVtcyBub3QgdG8gZXhpc3QgYW55IG1vcmUnKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGdldEVsZW1lbnRzOiB0aGlzLmdldEVsZW1lbnRzLmJpbmQodGhpcyksXG4gICAgICBnZXRNQ0lEOiB0aGlzLmdldE1DSUQuYmluZCh0aGlzKSxcbiAgICAgIHNldE1DSUQ6IHRoaXMuc2V0TUNJRC5iaW5kKHRoaXMpLFxuICAgICAgZ2V0RWxlbWVudFNlbGVjdG9yQnlNQ0lEOiB0aGlzLmdldEVsZW1lbnRTZWxlY3RvckJ5TUNJRC5iaW5kKHRoaXMpLFxuICAgICAgZ2V0RWxlbWVudEJ5TUNJRDogdGhpcy5nZXRFbGVtZW50QnlNQ0lELmJpbmQodGhpcylcbiAgICB9O1xuICAgIHRoaXMuZWxlbWVudHNCeU1DSUQgPSB7fTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhXZWJDb21wb25lbnRDb250ZXh0SGFuZGxlciwgW3tcbiAgICBrZXk6IFwiZ2V0RWxlbWVudEJ5TUNJRFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRFbGVtZW50QnlNQ0lEKG1jaWQpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5lbGVtZW50c0J5TUNJRCwgbWNpZCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudHNCeU1DSURbbWNpZF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuY29udGV4dC5yb290RWxlbWVudC5xdWVyeVNlbGVjdG9yKHRoaXMuZ2V0RWxlbWVudFNlbGVjdG9yQnlNQ0lEKG1jaWQpKTtcbiAgICAgICAgdGhpcy5lbGVtZW50c0J5TUNJRFttY2lkXSA9IGVsZW1lbnQ7XG4gICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRFbGVtZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRFbGVtZW50cyhzZWxlY3Rvcikge1xuICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5jb250ZXh0LnJvb3RFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TUNJRFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNQ0lEKGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBlbGVtZW50LmdldEF0dHJpYnV0ZShjb25mLmVsZW1lbnRzX2RhdGFfYXR0cmlidXRlX25hbWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRNQ0lEXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE1DSUQoZWxlbWVudCwgbWNpZCkge1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoY29uZi5lbGVtZW50c19kYXRhX2F0dHJpYnV0ZV9uYW1lLCBtY2lkKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RWxlbWVudFNlbGVjdG9yQnlNQ0lEXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEVsZW1lbnRTZWxlY3RvckJ5TUNJRChtY2lkKSB7XG4gICAgICByZXR1cm4gJ1snICsgY29uZi5lbGVtZW50c19kYXRhX2F0dHJpYnV0ZV9uYW1lICsgJz1cIicgKyBtY2lkICsgJ1wiXSc7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFdlYkNvbXBvbmVudENvbnRleHRIYW5kbGVyO1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYkNvbXBvbmVudENvbnRleHRIYW5kbGVyOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/_Clip/helpers/WebComponentContextHandler.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/_DescriptiveIncidents/DescriptiveClip.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/_DescriptiveIncidents/DescriptiveClip.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar DescriptiveGroup = __webpack_require__(/*! ./DescriptiveGroup */ \"./node_modules/@kissmybutton/motorcortex/dist/_DescriptiveIncidents/DescriptiveGroup.js\");\n\nvar _TREECONST = __webpack_require__(/*! ../_Tree/_CONST */ \"./node_modules/@kissmybutton/motorcortex/dist/_Tree/_CONST.js\");\n\nvar FragmentedClip = __webpack_require__(/*! ../_Clip/FragmentedClip */ \"./node_modules/@kissmybutton/motorcortex/dist/_Clip/FragmentedClip.js\");\n\nvar Clip = __webpack_require__(/*! ../_Clip/SCGroup */ \"./node_modules/@kissmybutton/motorcortex/dist/_Clip/SCGroup.js\");\n\nvar Channel = __webpack_require__(/*! ../_Channels/_Clip/ClipsChannel */ \"./node_modules/@kissmybutton/motorcortex/dist/_Channels/_Clip/ClipsChannel.js\");\n\nvar incidentFromIngredients = __webpack_require__(/*! ../IncidentFromDefinition/incidentFromIngredients */ \"./node_modules/@kissmybutton/motorcortex/dist/IncidentFromDefinition/incidentFromIngredients.js\");\n\nvar ClipClone = __webpack_require__(/*! ../_Clip/RootClipClone */ \"./node_modules/@kissmybutton/motorcortex/dist/_Clip/RootClipClone.js\");\n\nvar DescriptiveClip =\n/*#__PURE__*/\nfunction (_DescriptiveGroup) {\n  _inherits(DescriptiveClip, _DescriptiveGroup);\n\n  function DescriptiveClip(attrs) {\n    var _this;\n\n    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n    _classCallCheck(this, DescriptiveClip);\n\n    var attrsToPass, propsToUse;\n\n    if (props === null) {\n      attrsToPass = {};\n      propsToUse = attrs;\n    } else {\n      // else, in case the user has passed two arguments then both should be used\n      attrsToPass = attrs;\n      propsToUse = props;\n    }\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(DescriptiveClip).call(this, attrsToPass, propsToUse)); // isTheRootClip defines whether the Clip is the root or not. It depends on\n    // the host or selector parameter passed on props (if host is present then\n    // the Clip is the root Clip while if the Clip gets initialised by a selector\n    // is not)\n\n    _this.isTheRootClip = false; // check if\n\n    var ingredients = {\n      id: _this.id,\n      attrs: attrsToPass,\n      props: _objectSpread({}, propsToUse, {\n        html: Object.prototype.hasOwnProperty.call(propsToUse, \"html\") ? propsToUse.html : _this.html,\n        css: Object.prototype.hasOwnProperty.call(propsToUse, \"css\") ? propsToUse.css : _this.css,\n        fonts: Object.prototype.hasOwnProperty.call(propsToUse, \"fonts\") ? propsToUse.fonts : _this.fonts\n      }),\n      plugin_npm_name: _this.constructor.plugin_npm_name,\n      Channel: _this.constructor.Channel\n    };\n\n    if (Object.prototype.hasOwnProperty.call(propsToUse, \"selector\") && propsToUse.selector !== undefined) {\n      ingredients.Incident = FragmentedClip; // TODO it doesn't take in account the get html and get css of the Descriptive Clip\n    } else {\n      _this.isTheRootClip = true;\n      ingredients.Incident = _this.constructor.Incident;\n    }\n\n    _this.realClip = incidentFromIngredients(ingredients);\n\n    if (_this.isTheRootClip) {\n      _this.realClip.subscribeToDurationChange(function (newDuration) {// TODO this.informForDurationChange();\n      });\n    } // passiveAddition is a flag property indicating that any Incident to be\n    // added to the Clip will be passive. It initialises with value = false\n    // on DescriptiveGroup where it's originaly defined.\n    // Here we change its value just before the buildTree method execution\n    // so all Incidents added on it get the \"passive\" flag and don't get\n    // exported on the exportDefinition method. Once the buildTree method\n    // finishes we set it back to its original value (false)\n\n\n    _this.passiveAddition = true;\n\n    _this._buildTree();\n\n    _this.passiveAddition = false;\n    return _this;\n  }\n\n  _createClass(DescriptiveClip, [{\n    key: \"_buildTree\",\n\n    /*\n    the _buildTree method acts as a proxy to the buildTree method defined by the\n    developers. The reason for this is that the actual buildTree method should\n    be executed in different order on Groups and on Clips (that extend Groups).\n    Calling the super on constructor fires the _buildTree execution on the\n    Group's constructor but this breaks on Clip as the realClip has not been\n    initialised yet.\n    */\n    value: function _buildTree() {\n      if (this.realClip === undefined) {\n        return;\n      }\n\n      this.buildTree();\n    }\n  }, {\n    key: \"resize\",\n\n    /**\n     * When the resize command is given directly to a DescriptiveClip no checks\n     * need to be performed.\n     * DescriptiveClip directly invokes the _resize method of ExtendableClip which\n     * resizes the full clip\n     */\n    value: function resize(newSize) {\n      this.realClip._resize(newSize / this.duration);\n\n      this.duration = newSize;\n      this.putMessageOnPipe('recalcDuration', {}, 'Groups', {\n        selfExecute: false,\n        direction: _TREECONST._DIRECTIONS._UP\n      });\n      this.putMessageOnPipe('flash', {}, 'RootClip', {\n        selfExecute: true,\n        direction: _TREECONST._DIRECTIONS._UP\n      });\n      return {\n        result: true\n      };\n    }\n    /*************************** HANDLING METHODS *******************************/\n\n  }, {\n    key: \"handleCheckForClip\",\n    value: function handleCheckForClip(target, payload) {\n      // eslint-disable-line no-unused-vars\n      return true;\n    }\n  }, {\n    key: \"handleCheckAddition\",\n    value: function handleCheckAddition(target, payload) {\n      /* Is the responsibility of the DescriptiveClip to pass the addition request\n      to its real clip and expect for a response. */\n      var res = this.realClip.addIncident(payload);\n\n      if (res.result === true) {\n        this.putMessageOnPipe('flash', {}, 'RootClip', {\n          selfExecute: true,\n          direction: _TREECONST._DIRECTIONS._UP\n        });\n      }\n\n      return res;\n    }\n  }, {\n    key: \"handleCheckMove\",\n    value: function handleCheckMove(target, payload) {\n      var res = this.realClip.moveIncident(payload);\n\n      if (res.result === true) {\n        this.putMessageOnPipe('flash', {}, 'RootClip', {\n          selfExecute: true,\n          direction: _TREECONST._DIRECTIONS._UP\n        });\n      }\n\n      return res;\n    }\n  }, {\n    key: \"handleCheckDeletion\",\n    value: function handleCheckDeletion(target, payload) {\n      var res = this.realClip.removeIncident(payload);\n\n      if (res.result === true) {\n        this.putMessageOnPipe('flash', {}, 'RootClip', {\n          selfExecute: true,\n          direction: _TREECONST._DIRECTIONS._UP\n        });\n      }\n\n      return res;\n    }\n  }, {\n    key: \"handleCheckResize\",\n    value: function handleCheckResize(target, payload) {\n      var res = this.realClip.resizeIncident(payload);\n\n      if (res.result === true) {\n        this.putMessageOnPipe('flash', {}, 'RootClip', {\n          selfExecute: true,\n          direction: _TREECONST._DIRECTIONS._UP\n        });\n      }\n\n      return res;\n    }\n  }, {\n    key: \"handleCheckEditAttributes\",\n    value: function handleCheckEditAttributes(target, payload) {\n      // eslint-disable-line no-unused-vars\n      return {\n        result: true\n      };\n    }\n  }, {\n    key: \"handleCheckEditProperties\",\n    value: function handleCheckEditProperties(target, payload) {\n      // eslint-disable-line no-unused-vars\n      return {\n        result: true\n      };\n    }\n  }, {\n    key: \"handleFlash\",\n    value: function handleFlash(target, payload) {\n      // eslint-disable-line no-unused-vars\n      if (this.isTheRootClip) {\n        this.flash();\n      } else {\n        return this.bypass();\n      }\n    }\n    /*********************** execution methods proxy *****************\n     ****************************************************************/\n\n  }, {\n    key: \"play\",\n    value: function play() {\n      var debug = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      if (this.isTheRootClip) {\n        this.realClip.play(debug);\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      if (this.isTheRootClip) {\n        this.realClip.pause();\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"complete\",\n    value: function complete() {\n      if (this.isTheRootClip) {\n        this.realClip.complete();\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      if (this.isTheRootClip) {\n        this.realClip.stop();\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"flash\",\n    value: function flash() {\n      if (this.isTheRootClip) {\n        this.realClip.flash();\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"onProgress\",\n    value: function onProgress(fraction, millisecond) {\n      if (this.isTheRootClip) {\n        this.realClip.onProgress(fraction, millisecond);\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"subscribe\",\n\n    /*********************** pub-sube methods proxy *******************\n     ****************************************************************/\n    value: function subscribe(id, funct, threshold, roundTo) {\n      if (this.isTheRootClip) {\n        this.realClip.subscribe(id, funct, threshold, roundTo);\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"unsubscribe\",\n    value: function unsubscribe(id) {\n      return this.realClip.unsubscribe(id);\n    }\n  }, {\n    key: \"subscribeToDurationChange\",\n    value: function subscribeToDurationChange(funct) {\n      if (this.isTheRootClip) {\n        this.realClip.subscribeToDurationChange(funct);\n        return true;\n      }\n\n      return false;\n    }\n    /*************************************************************/\n\n  }, {\n    key: \"paste\",\n    value: function paste(host) {\n      if (this.isTheRootClip) {\n        var clipClone = new ClipClone({\n          host: host,\n          descriptiveIncident: this\n        });\n        return clipClone;\n      }\n\n      return null;\n    }\n  }, {\n    key: \"selectorToPassToChildren\",\n    get: function get() {\n      return null; // the Clip (any Clip) resets the selection cascading\n    }\n  }, {\n    key: \"inheritedSelector\",\n    get: function get() {\n      return this._inheritedSelector;\n    },\n    set: function set(value) {\n      this._inheritedSelector = value;\n    }\n  }, {\n    key: \"html\",\n    get: function get() {\n      return '';\n    }\n  }, {\n    key: \"css\",\n    get: function get() {\n      return '';\n    }\n  }, {\n    key: \"fonts\",\n    get: function get() {\n      return [];\n    }\n  }, {\n    key: \"runTimeInfo\",\n    get: function get() {\n      return this.realClip.runTimeInfo;\n    }\n  }, {\n    key: \"executionSpeed\",\n    set: function set(speed) {\n      if (this.isTheRootClip) {\n        this.realClip.executionSpeed = speed;\n        return true;\n      }\n\n      return false;\n    }\n  }]);\n\n  return DescriptiveClip;\n}(DescriptiveGroup);\n\n_defineProperty(DescriptiveClip, \"isClip\", true);\n\n_defineProperty(DescriptiveClip, \"Incident\", Clip);\n\n_defineProperty(DescriptiveClip, \"plugin_npm_name\", \"@kissmybutton/self-contained-incidents\");\n\n_defineProperty(DescriptiveClip, \"Channel\", Channel);\n\n_defineProperty(DescriptiveClip, \"ClassName\", \"Clip\");\n\nmodule.exports = DescriptiveClip;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19EZXNjcmlwdGl2ZUluY2lkZW50cy9EZXNjcmlwdGl2ZUNsaXAuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19EZXNjcmlwdGl2ZUluY2lkZW50cy9EZXNjcmlwdGl2ZUNsaXAuanM/ZDNkYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IHZhciBvd25LZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTsgaWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSAnZnVuY3Rpb24nKSB7IG93bktleXMgPSBvd25LZXlzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSkuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBzeW0pLmVudW1lcmFibGU7IH0pKTsgfSBvd25LZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxudmFyIERlc2NyaXB0aXZlR3JvdXAgPSByZXF1aXJlKCcuL0Rlc2NyaXB0aXZlR3JvdXAnKTtcblxudmFyIF9UUkVFQ09OU1QgPSByZXF1aXJlKCcuLi9fVHJlZS9fQ09OU1QnKTtcblxudmFyIEZyYWdtZW50ZWRDbGlwID0gcmVxdWlyZSgnLi4vX0NsaXAvRnJhZ21lbnRlZENsaXAnKTtcblxudmFyIENsaXAgPSByZXF1aXJlKCcuLi9fQ2xpcC9TQ0dyb3VwJyk7XG5cbnZhciBDaGFubmVsID0gcmVxdWlyZSgnLi4vX0NoYW5uZWxzL19DbGlwL0NsaXBzQ2hhbm5lbCcpO1xuXG52YXIgaW5jaWRlbnRGcm9tSW5ncmVkaWVudHMgPSByZXF1aXJlKCcuLi9JbmNpZGVudEZyb21EZWZpbml0aW9uL2luY2lkZW50RnJvbUluZ3JlZGllbnRzJyk7XG5cbnZhciBDbGlwQ2xvbmUgPSByZXF1aXJlKCcuLi9fQ2xpcC9Sb290Q2xpcENsb25lJyk7XG5cbnZhciBEZXNjcmlwdGl2ZUNsaXAgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9EZXNjcmlwdGl2ZUdyb3VwKSB7XG4gIF9pbmhlcml0cyhEZXNjcmlwdGl2ZUNsaXAsIF9EZXNjcmlwdGl2ZUdyb3VwKTtcblxuICBmdW5jdGlvbiBEZXNjcmlwdGl2ZUNsaXAoYXR0cnMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG51bGw7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRGVzY3JpcHRpdmVDbGlwKTtcblxuICAgIHZhciBhdHRyc1RvUGFzcywgcHJvcHNUb1VzZTtcblxuICAgIGlmIChwcm9wcyA9PT0gbnVsbCkge1xuICAgICAgYXR0cnNUb1Bhc3MgPSB7fTtcbiAgICAgIHByb3BzVG9Vc2UgPSBhdHRycztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZWxzZSwgaW4gY2FzZSB0aGUgdXNlciBoYXMgcGFzc2VkIHR3byBhcmd1bWVudHMgdGhlbiBib3RoIHNob3VsZCBiZSB1c2VkXG4gICAgICBhdHRyc1RvUGFzcyA9IGF0dHJzO1xuICAgICAgcHJvcHNUb1VzZSA9IHByb3BzO1xuICAgIH1cblxuICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKERlc2NyaXB0aXZlQ2xpcCkuY2FsbCh0aGlzLCBhdHRyc1RvUGFzcywgcHJvcHNUb1VzZSkpOyAvLyBpc1RoZVJvb3RDbGlwIGRlZmluZXMgd2hldGhlciB0aGUgQ2xpcCBpcyB0aGUgcm9vdCBvciBub3QuIEl0IGRlcGVuZHMgb25cbiAgICAvLyB0aGUgaG9zdCBvciBzZWxlY3RvciBwYXJhbWV0ZXIgcGFzc2VkIG9uIHByb3BzIChpZiBob3N0IGlzIHByZXNlbnQgdGhlblxuICAgIC8vIHRoZSBDbGlwIGlzIHRoZSByb290IENsaXAgd2hpbGUgaWYgdGhlIENsaXAgZ2V0cyBpbml0aWFsaXNlZCBieSBhIHNlbGVjdG9yXG4gICAgLy8gaXMgbm90KVxuXG4gICAgX3RoaXMuaXNUaGVSb290Q2xpcCA9IGZhbHNlOyAvLyBjaGVjayBpZlxuXG4gICAgdmFyIGluZ3JlZGllbnRzID0ge1xuICAgICAgaWQ6IF90aGlzLmlkLFxuICAgICAgYXR0cnM6IGF0dHJzVG9QYXNzLFxuICAgICAgcHJvcHM6IF9vYmplY3RTcHJlYWQoe30sIHByb3BzVG9Vc2UsIHtcbiAgICAgICAgaHRtbDogT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzVG9Vc2UsIFwiaHRtbFwiKSA/IHByb3BzVG9Vc2UuaHRtbCA6IF90aGlzLmh0bWwsXG4gICAgICAgIGNzczogT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzVG9Vc2UsIFwiY3NzXCIpID8gcHJvcHNUb1VzZS5jc3MgOiBfdGhpcy5jc3MsXG4gICAgICAgIGZvbnRzOiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocHJvcHNUb1VzZSwgXCJmb250c1wiKSA/IHByb3BzVG9Vc2UuZm9udHMgOiBfdGhpcy5mb250c1xuICAgICAgfSksXG4gICAgICBwbHVnaW5fbnBtX25hbWU6IF90aGlzLmNvbnN0cnVjdG9yLnBsdWdpbl9ucG1fbmFtZSxcbiAgICAgIENoYW5uZWw6IF90aGlzLmNvbnN0cnVjdG9yLkNoYW5uZWxcbiAgICB9O1xuXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwcm9wc1RvVXNlLCBcInNlbGVjdG9yXCIpICYmIHByb3BzVG9Vc2Uuc2VsZWN0b3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaW5ncmVkaWVudHMuSW5jaWRlbnQgPSBGcmFnbWVudGVkQ2xpcDsgLy8gVE9ETyBpdCBkb2Vzbid0IHRha2UgaW4gYWNjb3VudCB0aGUgZ2V0IGh0bWwgYW5kIGdldCBjc3Mgb2YgdGhlIERlc2NyaXB0aXZlIENsaXBcbiAgICB9IGVsc2Uge1xuICAgICAgX3RoaXMuaXNUaGVSb290Q2xpcCA9IHRydWU7XG4gICAgICBpbmdyZWRpZW50cy5JbmNpZGVudCA9IF90aGlzLmNvbnN0cnVjdG9yLkluY2lkZW50O1xuICAgIH1cblxuICAgIF90aGlzLnJlYWxDbGlwID0gaW5jaWRlbnRGcm9tSW5ncmVkaWVudHMoaW5ncmVkaWVudHMpO1xuXG4gICAgaWYgKF90aGlzLmlzVGhlUm9vdENsaXApIHtcbiAgICAgIF90aGlzLnJlYWxDbGlwLnN1YnNjcmliZVRvRHVyYXRpb25DaGFuZ2UoZnVuY3Rpb24gKG5ld0R1cmF0aW9uKSB7Ly8gVE9ETyB0aGlzLmluZm9ybUZvckR1cmF0aW9uQ2hhbmdlKCk7XG4gICAgICB9KTtcbiAgICB9IC8vIHBhc3NpdmVBZGRpdGlvbiBpcyBhIGZsYWcgcHJvcGVydHkgaW5kaWNhdGluZyB0aGF0IGFueSBJbmNpZGVudCB0byBiZVxuICAgIC8vIGFkZGVkIHRvIHRoZSBDbGlwIHdpbGwgYmUgcGFzc2l2ZS4gSXQgaW5pdGlhbGlzZXMgd2l0aCB2YWx1ZSA9IGZhbHNlXG4gICAgLy8gb24gRGVzY3JpcHRpdmVHcm91cCB3aGVyZSBpdCdzIG9yaWdpbmFseSBkZWZpbmVkLlxuICAgIC8vIEhlcmUgd2UgY2hhbmdlIGl0cyB2YWx1ZSBqdXN0IGJlZm9yZSB0aGUgYnVpbGRUcmVlIG1ldGhvZCBleGVjdXRpb25cbiAgICAvLyBzbyBhbGwgSW5jaWRlbnRzIGFkZGVkIG9uIGl0IGdldCB0aGUgXCJwYXNzaXZlXCIgZmxhZyBhbmQgZG9uJ3QgZ2V0XG4gICAgLy8gZXhwb3J0ZWQgb24gdGhlIGV4cG9ydERlZmluaXRpb24gbWV0aG9kLiBPbmNlIHRoZSBidWlsZFRyZWUgbWV0aG9kXG4gICAgLy8gZmluaXNoZXMgd2Ugc2V0IGl0IGJhY2sgdG8gaXRzIG9yaWdpbmFsIHZhbHVlIChmYWxzZSlcblxuXG4gICAgX3RoaXMucGFzc2l2ZUFkZGl0aW9uID0gdHJ1ZTtcblxuICAgIF90aGlzLl9idWlsZFRyZWUoKTtcblxuICAgIF90aGlzLnBhc3NpdmVBZGRpdGlvbiA9IGZhbHNlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhEZXNjcmlwdGl2ZUNsaXAsIFt7XG4gICAga2V5OiBcIl9idWlsZFRyZWVcIixcblxuICAgIC8qXG4gICAgdGhlIF9idWlsZFRyZWUgbWV0aG9kIGFjdHMgYXMgYSBwcm94eSB0byB0aGUgYnVpbGRUcmVlIG1ldGhvZCBkZWZpbmVkIGJ5IHRoZVxuICAgIGRldmVsb3BlcnMuIFRoZSByZWFzb24gZm9yIHRoaXMgaXMgdGhhdCB0aGUgYWN0dWFsIGJ1aWxkVHJlZSBtZXRob2Qgc2hvdWxkXG4gICAgYmUgZXhlY3V0ZWQgaW4gZGlmZmVyZW50IG9yZGVyIG9uIEdyb3VwcyBhbmQgb24gQ2xpcHMgKHRoYXQgZXh0ZW5kIEdyb3VwcykuXG4gICAgQ2FsbGluZyB0aGUgc3VwZXIgb24gY29uc3RydWN0b3IgZmlyZXMgdGhlIF9idWlsZFRyZWUgZXhlY3V0aW9uIG9uIHRoZVxuICAgIEdyb3VwJ3MgY29uc3RydWN0b3IgYnV0IHRoaXMgYnJlYWtzIG9uIENsaXAgYXMgdGhlIHJlYWxDbGlwIGhhcyBub3QgYmVlblxuICAgIGluaXRpYWxpc2VkIHlldC5cbiAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBfYnVpbGRUcmVlKCkge1xuICAgICAgaWYgKHRoaXMucmVhbENsaXAgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYnVpbGRUcmVlKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlc2l6ZVwiLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiB0aGUgcmVzaXplIGNvbW1hbmQgaXMgZ2l2ZW4gZGlyZWN0bHkgdG8gYSBEZXNjcmlwdGl2ZUNsaXAgbm8gY2hlY2tzXG4gICAgICogbmVlZCB0byBiZSBwZXJmb3JtZWQuXG4gICAgICogRGVzY3JpcHRpdmVDbGlwIGRpcmVjdGx5IGludm9rZXMgdGhlIF9yZXNpemUgbWV0aG9kIG9mIEV4dGVuZGFibGVDbGlwIHdoaWNoXG4gICAgICogcmVzaXplcyB0aGUgZnVsbCBjbGlwXG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2l6ZShuZXdTaXplKSB7XG4gICAgICB0aGlzLnJlYWxDbGlwLl9yZXNpemUobmV3U2l6ZSAvIHRoaXMuZHVyYXRpb24pO1xuXG4gICAgICB0aGlzLmR1cmF0aW9uID0gbmV3U2l6ZTtcbiAgICAgIHRoaXMucHV0TWVzc2FnZU9uUGlwZSgncmVjYWxjRHVyYXRpb24nLCB7fSwgJ0dyb3VwcycsIHtcbiAgICAgICAgc2VsZkV4ZWN1dGU6IGZhbHNlLFxuICAgICAgICBkaXJlY3Rpb246IF9UUkVFQ09OU1QuX0RJUkVDVElPTlMuX1VQXG4gICAgICB9KTtcbiAgICAgIHRoaXMucHV0TWVzc2FnZU9uUGlwZSgnZmxhc2gnLCB7fSwgJ1Jvb3RDbGlwJywge1xuICAgICAgICBzZWxmRXhlY3V0ZTogdHJ1ZSxcbiAgICAgICAgZGlyZWN0aW9uOiBfVFJFRUNPTlNULl9ESVJFQ1RJT05TLl9VUFxuICAgICAgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZXN1bHQ6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKiogSEFORExJTkcgTUVUSE9EUyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlQ2hlY2tGb3JDbGlwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZUNoZWNrRm9yQ2xpcCh0YXJnZXQsIHBheWxvYWQpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYW5kbGVDaGVja0FkZGl0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZUNoZWNrQWRkaXRpb24odGFyZ2V0LCBwYXlsb2FkKSB7XG4gICAgICAvKiBJcyB0aGUgcmVzcG9uc2liaWxpdHkgb2YgdGhlIERlc2NyaXB0aXZlQ2xpcCB0byBwYXNzIHRoZSBhZGRpdGlvbiByZXF1ZXN0XG4gICAgICB0byBpdHMgcmVhbCBjbGlwIGFuZCBleHBlY3QgZm9yIGEgcmVzcG9uc2UuICovXG4gICAgICB2YXIgcmVzID0gdGhpcy5yZWFsQ2xpcC5hZGRJbmNpZGVudChwYXlsb2FkKTtcblxuICAgICAgaWYgKHJlcy5yZXN1bHQgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5wdXRNZXNzYWdlT25QaXBlKCdmbGFzaCcsIHt9LCAnUm9vdENsaXAnLCB7XG4gICAgICAgICAgc2VsZkV4ZWN1dGU6IHRydWUsXG4gICAgICAgICAgZGlyZWN0aW9uOiBfVFJFRUNPTlNULl9ESVJFQ1RJT05TLl9VUFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlQ2hlY2tNb3ZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZUNoZWNrTW92ZSh0YXJnZXQsIHBheWxvYWQpIHtcbiAgICAgIHZhciByZXMgPSB0aGlzLnJlYWxDbGlwLm1vdmVJbmNpZGVudChwYXlsb2FkKTtcblxuICAgICAgaWYgKHJlcy5yZXN1bHQgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5wdXRNZXNzYWdlT25QaXBlKCdmbGFzaCcsIHt9LCAnUm9vdENsaXAnLCB7XG4gICAgICAgICAgc2VsZkV4ZWN1dGU6IHRydWUsXG4gICAgICAgICAgZGlyZWN0aW9uOiBfVFJFRUNPTlNULl9ESVJFQ1RJT05TLl9VUFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlQ2hlY2tEZWxldGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVDaGVja0RlbGV0aW9uKHRhcmdldCwgcGF5bG9hZCkge1xuICAgICAgdmFyIHJlcyA9IHRoaXMucmVhbENsaXAucmVtb3ZlSW5jaWRlbnQocGF5bG9hZCk7XG5cbiAgICAgIGlmIChyZXMucmVzdWx0ID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMucHV0TWVzc2FnZU9uUGlwZSgnZmxhc2gnLCB7fSwgJ1Jvb3RDbGlwJywge1xuICAgICAgICAgIHNlbGZFeGVjdXRlOiB0cnVlLFxuICAgICAgICAgIGRpcmVjdGlvbjogX1RSRUVDT05TVC5fRElSRUNUSU9OUy5fVVBcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZUNoZWNrUmVzaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZUNoZWNrUmVzaXplKHRhcmdldCwgcGF5bG9hZCkge1xuICAgICAgdmFyIHJlcyA9IHRoaXMucmVhbENsaXAucmVzaXplSW5jaWRlbnQocGF5bG9hZCk7XG5cbiAgICAgIGlmIChyZXMucmVzdWx0ID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMucHV0TWVzc2FnZU9uUGlwZSgnZmxhc2gnLCB7fSwgJ1Jvb3RDbGlwJywge1xuICAgICAgICAgIHNlbGZFeGVjdXRlOiB0cnVlLFxuICAgICAgICAgIGRpcmVjdGlvbjogX1RSRUVDT05TVC5fRElSRUNUSU9OUy5fVVBcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZUNoZWNrRWRpdEF0dHJpYnV0ZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlQ2hlY2tFZGl0QXR0cmlidXRlcyh0YXJnZXQsIHBheWxvYWQpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlc3VsdDogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlQ2hlY2tFZGl0UHJvcGVydGllc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVDaGVja0VkaXRQcm9wZXJ0aWVzKHRhcmdldCwgcGF5bG9hZCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVzdWx0OiB0cnVlXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYW5kbGVGbGFzaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVGbGFzaCh0YXJnZXQsIHBheWxvYWQpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIGlmICh0aGlzLmlzVGhlUm9vdENsaXApIHtcbiAgICAgICAgdGhpcy5mbGFzaCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnlwYXNzKCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKiBleGVjdXRpb24gbWV0aG9kcyBwcm94eSAqKioqKioqKioqKioqKioqKlxuICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicGxheVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwbGF5KCkge1xuICAgICAgdmFyIGRlYnVnID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcblxuICAgICAgaWYgKHRoaXMuaXNUaGVSb290Q2xpcCkge1xuICAgICAgICB0aGlzLnJlYWxDbGlwLnBsYXkoZGVidWcpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYXVzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXVzZSgpIHtcbiAgICAgIGlmICh0aGlzLmlzVGhlUm9vdENsaXApIHtcbiAgICAgICAgdGhpcy5yZWFsQ2xpcC5wYXVzZSgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb21wbGV0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wbGV0ZSgpIHtcbiAgICAgIGlmICh0aGlzLmlzVGhlUm9vdENsaXApIHtcbiAgICAgICAgdGhpcy5yZWFsQ2xpcC5jb21wbGV0ZSgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdG9wXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgICBpZiAodGhpcy5pc1RoZVJvb3RDbGlwKSB7XG4gICAgICAgIHRoaXMucmVhbENsaXAuc3RvcCgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmbGFzaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmbGFzaCgpIHtcbiAgICAgIGlmICh0aGlzLmlzVGhlUm9vdENsaXApIHtcbiAgICAgICAgdGhpcy5yZWFsQ2xpcC5mbGFzaCgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvblByb2dyZXNzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uUHJvZ3Jlc3MoZnJhY3Rpb24sIG1pbGxpc2Vjb25kKSB7XG4gICAgICBpZiAodGhpcy5pc1RoZVJvb3RDbGlwKSB7XG4gICAgICAgIHRoaXMucmVhbENsaXAub25Qcm9ncmVzcyhmcmFjdGlvbiwgbWlsbGlzZWNvbmQpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdWJzY3JpYmVcIixcblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKiBwdWItc3ViZSBtZXRob2RzIHByb3h5ICoqKioqKioqKioqKioqKioqKipcbiAgICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gc3Vic2NyaWJlKGlkLCBmdW5jdCwgdGhyZXNob2xkLCByb3VuZFRvKSB7XG4gICAgICBpZiAodGhpcy5pc1RoZVJvb3RDbGlwKSB7XG4gICAgICAgIHRoaXMucmVhbENsaXAuc3Vic2NyaWJlKGlkLCBmdW5jdCwgdGhyZXNob2xkLCByb3VuZFRvKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidW5zdWJzY3JpYmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW5zdWJzY3JpYmUoaWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlYWxDbGlwLnVuc3Vic2NyaWJlKGlkKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3Vic2NyaWJlVG9EdXJhdGlvbkNoYW5nZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdWJzY3JpYmVUb0R1cmF0aW9uQ2hhbmdlKGZ1bmN0KSB7XG4gICAgICBpZiAodGhpcy5pc1RoZVJvb3RDbGlwKSB7XG4gICAgICAgIHRoaXMucmVhbENsaXAuc3Vic2NyaWJlVG9EdXJhdGlvbkNoYW5nZShmdW5jdCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicGFzdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFzdGUoaG9zdCkge1xuICAgICAgaWYgKHRoaXMuaXNUaGVSb290Q2xpcCkge1xuICAgICAgICB2YXIgY2xpcENsb25lID0gbmV3IENsaXBDbG9uZSh7XG4gICAgICAgICAgaG9zdDogaG9zdCxcbiAgICAgICAgICBkZXNjcmlwdGl2ZUluY2lkZW50OiB0aGlzXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY2xpcENsb25lO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2VsZWN0b3JUb1Bhc3NUb0NoaWxkcmVuXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gbnVsbDsgLy8gdGhlIENsaXAgKGFueSBDbGlwKSByZXNldHMgdGhlIHNlbGVjdGlvbiBjYXNjYWRpbmdcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5oZXJpdGVkU2VsZWN0b3JcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pbmhlcml0ZWRTZWxlY3RvcjtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICB0aGlzLl9pbmhlcml0ZWRTZWxlY3RvciA9IHZhbHVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJodG1sXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNzc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmb250c1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJydW5UaW1lSW5mb1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMucmVhbENsaXAucnVuVGltZUluZm87XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImV4ZWN1dGlvblNwZWVkXCIsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQoc3BlZWQpIHtcbiAgICAgIGlmICh0aGlzLmlzVGhlUm9vdENsaXApIHtcbiAgICAgICAgdGhpcy5yZWFsQ2xpcC5leGVjdXRpb25TcGVlZCA9IHNwZWVkO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBEZXNjcmlwdGl2ZUNsaXA7XG59KERlc2NyaXB0aXZlR3JvdXApO1xuXG5fZGVmaW5lUHJvcGVydHkoRGVzY3JpcHRpdmVDbGlwLCBcImlzQ2xpcFwiLCB0cnVlKTtcblxuX2RlZmluZVByb3BlcnR5KERlc2NyaXB0aXZlQ2xpcCwgXCJJbmNpZGVudFwiLCBDbGlwKTtcblxuX2RlZmluZVByb3BlcnR5KERlc2NyaXB0aXZlQ2xpcCwgXCJwbHVnaW5fbnBtX25hbWVcIiwgXCJAa2lzc215YnV0dG9uL3NlbGYtY29udGFpbmVkLWluY2lkZW50c1wiKTtcblxuX2RlZmluZVByb3BlcnR5KERlc2NyaXB0aXZlQ2xpcCwgXCJDaGFubmVsXCIsIENoYW5uZWwpO1xuXG5fZGVmaW5lUHJvcGVydHkoRGVzY3JpcHRpdmVDbGlwLCBcIkNsYXNzTmFtZVwiLCBcIkNsaXBcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gRGVzY3JpcHRpdmVDbGlwOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/_DescriptiveIncidents/DescriptiveClip.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/_DescriptiveIncidents/DescriptiveGroup.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/_DescriptiveIncidents/DescriptiveGroup.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _decorate(decorators, factory, superClass, mixins) { var api = _getDecoratorsApi(); if (mixins) { for (var i = 0; i < mixins.length; i++) { api = mixins[i](api); } } var r = factory(function initialize(O) { api.initializeInstanceElements(O, decorated.elements); }, superClass); var decorated = api.decorateClass(_coalesceClassElements(r.d.map(_createElementDescriptor)), decorators); api.initializeClassElements(r.F, decorated.elements); return api.runClassFinishers(r.F, decorated.finishers); }\n\nfunction _getDecoratorsApi() { _getDecoratorsApi = function _getDecoratorsApi() { return api; }; var api = { elementsDefinitionOrder: [[\"method\"], [\"field\"]], initializeInstanceElements: function initializeInstanceElements(O, elements) { [\"method\", \"field\"].forEach(function (kind) { elements.forEach(function (element) { if (element.kind === kind && element.placement === \"own\") { this.defineClassElement(O, element); } }, this); }, this); }, initializeClassElements: function initializeClassElements(F, elements) { var proto = F.prototype; [\"method\", \"field\"].forEach(function (kind) { elements.forEach(function (element) { var placement = element.placement; if (element.kind === kind && (placement === \"static\" || placement === \"prototype\")) { var receiver = placement === \"static\" ? F : proto; this.defineClassElement(receiver, element); } }, this); }, this); }, defineClassElement: function defineClassElement(receiver, element) { var descriptor = element.descriptor; if (element.kind === \"field\") { var initializer = element.initializer; descriptor = { enumerable: descriptor.enumerable, writable: descriptor.writable, configurable: descriptor.configurable, value: initializer === void 0 ? void 0 : initializer.call(receiver) }; } Object.defineProperty(receiver, element.key, descriptor); }, decorateClass: function decorateClass(elements, decorators) { var newElements = []; var finishers = []; var placements = { \"static\": [], prototype: [], own: [] }; elements.forEach(function (element) { this.addElementPlacement(element, placements); }, this); elements.forEach(function (element) { if (!_hasDecorators(element)) return newElements.push(element); var elementFinishersExtras = this.decorateElement(element, placements); newElements.push(elementFinishersExtras.element); newElements.push.apply(newElements, elementFinishersExtras.extras); finishers.push.apply(finishers, elementFinishersExtras.finishers); }, this); if (!decorators) { return { elements: newElements, finishers: finishers }; } var result = this.decorateConstructor(newElements, decorators); finishers.push.apply(finishers, result.finishers); result.finishers = finishers; return result; }, addElementPlacement: function addElementPlacement(element, placements, silent) { var keys = placements[element.placement]; if (!silent && keys.indexOf(element.key) !== -1) { throw new TypeError(\"Duplicated element (\" + element.key + \")\"); } keys.push(element.key); }, decorateElement: function decorateElement(element, placements) { var extras = []; var finishers = []; for (var decorators = element.decorators, i = decorators.length - 1; i >= 0; i--) { var keys = placements[element.placement]; keys.splice(keys.indexOf(element.key), 1); var elementObject = this.fromElementDescriptor(element); var elementFinisherExtras = this.toElementFinisherExtras((0, decorators[i])(elementObject) || elementObject); element = elementFinisherExtras.element; this.addElementPlacement(element, placements); if (elementFinisherExtras.finisher) { finishers.push(elementFinisherExtras.finisher); } var newExtras = elementFinisherExtras.extras; if (newExtras) { for (var j = 0; j < newExtras.length; j++) { this.addElementPlacement(newExtras[j], placements); } extras.push.apply(extras, newExtras); } } return { element: element, finishers: finishers, extras: extras }; }, decorateConstructor: function decorateConstructor(elements, decorators) { var finishers = []; for (var i = decorators.length - 1; i >= 0; i--) { var obj = this.fromClassDescriptor(elements); var elementsAndFinisher = this.toClassDescriptor((0, decorators[i])(obj) || obj); if (elementsAndFinisher.finisher !== undefined) { finishers.push(elementsAndFinisher.finisher); } if (elementsAndFinisher.elements !== undefined) { elements = elementsAndFinisher.elements; for (var j = 0; j < elements.length - 1; j++) { for (var k = j + 1; k < elements.length; k++) { if (elements[j].key === elements[k].key && elements[j].placement === elements[k].placement) { throw new TypeError(\"Duplicated element (\" + elements[j].key + \")\"); } } } } } return { elements: elements, finishers: finishers }; }, fromElementDescriptor: function fromElementDescriptor(element) { var obj = { kind: element.kind, key: element.key, placement: element.placement, descriptor: element.descriptor }; var desc = { value: \"Descriptor\", configurable: true }; Object.defineProperty(obj, Symbol.toStringTag, desc); if (element.kind === \"field\") obj.initializer = element.initializer; return obj; }, toElementDescriptors: function toElementDescriptors(elementObjects) { if (elementObjects === undefined) return; return _toArray(elementObjects).map(function (elementObject) { var element = this.toElementDescriptor(elementObject); this.disallowProperty(elementObject, \"finisher\", \"An element descriptor\"); this.disallowProperty(elementObject, \"extras\", \"An element descriptor\"); return element; }, this); }, toElementDescriptor: function toElementDescriptor(elementObject) { var kind = String(elementObject.kind); if (kind !== \"method\" && kind !== \"field\") { throw new TypeError('An element descriptor\\'s .kind property must be either \"method\" or' + ' \"field\", but a decorator created an element descriptor with' + ' .kind \"' + kind + '\"'); } var key = _toPropertyKey(elementObject.key); var placement = String(elementObject.placement); if (placement !== \"static\" && placement !== \"prototype\" && placement !== \"own\") { throw new TypeError('An element descriptor\\'s .placement property must be one of \"static\",' + ' \"prototype\" or \"own\", but a decorator created an element descriptor' + ' with .placement \"' + placement + '\"'); } var descriptor = elementObject.descriptor; this.disallowProperty(elementObject, \"elements\", \"An element descriptor\"); var element = { kind: kind, key: key, placement: placement, descriptor: Object.assign({}, descriptor) }; if (kind !== \"field\") { this.disallowProperty(elementObject, \"initializer\", \"A method descriptor\"); } else { this.disallowProperty(descriptor, \"get\", \"The property descriptor of a field descriptor\"); this.disallowProperty(descriptor, \"set\", \"The property descriptor of a field descriptor\"); this.disallowProperty(descriptor, \"value\", \"The property descriptor of a field descriptor\"); element.initializer = elementObject.initializer; } return element; }, toElementFinisherExtras: function toElementFinisherExtras(elementObject) { var element = this.toElementDescriptor(elementObject); var finisher = _optionalCallableProperty(elementObject, \"finisher\"); var extras = this.toElementDescriptors(elementObject.extras); return { element: element, finisher: finisher, extras: extras }; }, fromClassDescriptor: function fromClassDescriptor(elements) { var obj = { kind: \"class\", elements: elements.map(this.fromElementDescriptor, this) }; var desc = { value: \"Descriptor\", configurable: true }; Object.defineProperty(obj, Symbol.toStringTag, desc); return obj; }, toClassDescriptor: function toClassDescriptor(obj) { var kind = String(obj.kind); if (kind !== \"class\") { throw new TypeError('A class descriptor\\'s .kind property must be \"class\", but a decorator' + ' created a class descriptor with .kind \"' + kind + '\"'); } this.disallowProperty(obj, \"key\", \"A class descriptor\"); this.disallowProperty(obj, \"placement\", \"A class descriptor\"); this.disallowProperty(obj, \"descriptor\", \"A class descriptor\"); this.disallowProperty(obj, \"initializer\", \"A class descriptor\"); this.disallowProperty(obj, \"extras\", \"A class descriptor\"); var finisher = _optionalCallableProperty(obj, \"finisher\"); var elements = this.toElementDescriptors(obj.elements); return { elements: elements, finisher: finisher }; }, runClassFinishers: function runClassFinishers(constructor, finishers) { for (var i = 0; i < finishers.length; i++) { var newConstructor = (0, finishers[i])(constructor); if (newConstructor !== undefined) { if (typeof newConstructor !== \"function\") { throw new TypeError(\"Finishers must return a constructor.\"); } constructor = newConstructor; } } return constructor; }, disallowProperty: function disallowProperty(obj, name, objectType) { if (obj[name] !== undefined) { throw new TypeError(objectType + \" can't have a .\" + name + \" property.\"); } } }; return api; }\n\nfunction _createElementDescriptor(def) { var key = _toPropertyKey(def.key); var descriptor; if (def.kind === \"method\") { descriptor = { value: def.value, writable: true, configurable: true, enumerable: false }; } else if (def.kind === \"get\") { descriptor = { get: def.value, configurable: true, enumerable: false }; } else if (def.kind === \"set\") { descriptor = { set: def.value, configurable: true, enumerable: false }; } else if (def.kind === \"field\") { descriptor = { configurable: true, writable: true, enumerable: true }; } var element = { kind: def.kind === \"field\" ? \"field\" : \"method\", key: key, placement: def[\"static\"] ? \"static\" : def.kind === \"field\" ? \"own\" : \"prototype\", descriptor: descriptor }; if (def.decorators) element.decorators = def.decorators; if (def.kind === \"field\") element.initializer = def.value; return element; }\n\nfunction _coalesceGetterSetter(element, other) { if (element.descriptor.get !== undefined) { other.descriptor.get = element.descriptor.get; } else { other.descriptor.set = element.descriptor.set; } }\n\nfunction _coalesceClassElements(elements) { var newElements = []; var isSameElement = function isSameElement(other) { return other.kind === \"method\" && other.key === element.key && other.placement === element.placement; }; for (var i = 0; i < elements.length; i++) { var element = elements[i]; var other; if (element.kind === \"method\" && (other = newElements.find(isSameElement))) { if (_isDataDescriptor(element.descriptor) || _isDataDescriptor(other.descriptor)) { if (_hasDecorators(element) || _hasDecorators(other)) { throw new ReferenceError(\"Duplicated methods (\" + element.key + \") can't be decorated.\"); } other.descriptor = element.descriptor; } else { if (_hasDecorators(element)) { if (_hasDecorators(other)) { throw new ReferenceError(\"Decorators can't be placed on different accessors with for \" + \"the same property (\" + element.key + \").\"); } other.decorators = element.decorators; } _coalesceGetterSetter(element, other); } } else { newElements.push(element); } } return newElements; }\n\nfunction _hasDecorators(element) { return element.decorators && element.decorators.length; }\n\nfunction _isDataDescriptor(desc) { return desc !== undefined && !(desc.value === undefined && desc.writable === undefined); }\n\nfunction _optionalCallableProperty(obj, name) { var value = obj[name]; if (value !== undefined && typeof value !== \"function\") { throw new TypeError(\"Expected '\" + name + \"' to be a function\"); } return value; }\n\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\n\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\nfunction _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nvar _CONST = __webpack_require__(/*! ./_CONST */ \"./node_modules/@kissmybutton/motorcortex/dist/_DescriptiveIncidents/_CONST.js\");\n\nvar _TREECONST = __webpack_require__(/*! ../_Tree/_CONST */ \"./node_modules/@kissmybutton/motorcortex/dist/_Tree/_CONST.js\");\n\nvar Node = __webpack_require__(/*! ../_Tree/Node */ \"./node_modules/@kissmybutton/motorcortex/dist/_Tree/Node.js\");\n\nvar resize = __webpack_require__(/*! ./decorators/resize */ \"./node_modules/@kissmybutton/motorcortex/dist/_DescriptiveIncidents/decorators/resize.js\");\n\nvar editAttributes = __webpack_require__(/*! ./decorators/editAttributes */ \"./node_modules/@kissmybutton/motorcortex/dist/_DescriptiveIncidents/decorators/editAttributes.js\");\n\nvar editProperties = __webpack_require__(/*! ./decorators/editProperties */ \"./node_modules/@kissmybutton/motorcortex/dist/_DescriptiveIncidents/decorators/editProperties.js\");\n\nvar selectorGetter = __webpack_require__(/*! ./decorators/selector */ \"./node_modules/@kissmybutton/motorcortex/dist/_DescriptiveIncidents/decorators/selector.js\");\n\nvar Group = __webpack_require__(/*! ../_BaseClasses/Group */ \"./node_modules/@kissmybutton/motorcortex/dist/_BaseClasses/Group.js\");\n\nvar Channel = __webpack_require__(/*! ../_Channels/Channel */ \"./node_modules/@kissmybutton/motorcortex/dist/_Channels/Channel.js\");\n\nvar DescriptiveGroup = _decorate(null, function (_initialize, _Node) {\n  var DescriptiveGroup =\n  /*#__PURE__*/\n  function (_Node2) {\n    _inherits(DescriptiveGroup, _Node2);\n\n    function DescriptiveGroup() {\n      var _this;\n\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      _classCallCheck(this, DescriptiveGroup);\n\n      if (props === null) {\n        _this = _possibleConstructorReturn(this, _getPrototypeOf(DescriptiveGroup).call(this, attrs));\n\n        _initialize(_assertThisInitialized(_this));\n\n        _this.attrs = {};\n        _this.props = attrs;\n      } else {\n        _this = _possibleConstructorReturn(this, _getPrototypeOf(DescriptiveGroup).call(this, props));\n\n        _initialize(_assertThisInitialized(_this));\n\n        _this.attrs = attrs;\n        _this.props = props;\n      }\n\n      _this._inheritedSelector = null; // passiveAddition is a flag property indicating that any Incident to be\n      // added to the Clip will be passive. It initialises with value = false\n      // on DescriptiveGroup where it's originaly defined.\n      // Here we change its value just before the buildTree method execution\n      // so all Incidents added on it get the \"passive\" flag and don't get\n      // exported on the exportDefinition method. Once the buildTree method\n      // finishes we set it back to its original value (false)\n\n      _this.passiveAddition = true;\n\n      _this._buildTree();\n\n      _this.passiveAddition = false;\n      return _possibleConstructorReturn(_this);\n    }\n\n    return DescriptiveGroup;\n  }(_Node);\n\n  return {\n    F: DescriptiveGroup,\n    d: [{\n      kind: \"field\",\n      \"static\": true,\n      key: \"Incident\",\n      value: function value() {\n        return Group;\n      }\n    }, {\n      kind: \"field\",\n      \"static\": true,\n      key: \"plugin_npm_name\",\n      value: function value() {\n        return \"motor-cortex-js\";\n      }\n    }, {\n      kind: \"field\",\n      \"static\": true,\n      key: \"Channel\",\n      value: function value() {\n        return Channel;\n      }\n    }, {\n      kind: \"field\",\n      \"static\": true,\n      key: \"ClassName\",\n      value: function value() {\n        return \"Group\";\n      }\n    }, {\n      kind: \"method\",\n      decorators: [editAttributes],\n      key: \"editAttributes\",\n      value: function editAttributes() {}\n    }, {\n      kind: \"method\",\n      decorators: [editProperties],\n      key: \"editProperties\",\n      value: function editProperties() {}\n    }, {\n      kind: \"method\",\n      decorators: [resize],\n      key: \"resize\",\n      value: function resize() {}\n    }, {\n      kind: \"method\",\n      decorators: [selectorGetter],\n      key: \"selector\",\n      value: function selector() {}\n    }, {\n      kind: \"method\",\n      key: \"_buildTree\",\n      value: function _buildTree() {\n        this.buildTree();\n      }\n    }, {\n      kind: \"method\",\n      key: \"_rebuildTree\",\n      value: function _rebuildTree() {\n        // remove all direct passive incidents as they might be dependent on the edited attrs/props\n        for (var id in this.children) {\n          var theChild = this.children[id];\n\n          if (theChild.leaf.passive === true) {\n            this.removeIncident(theChild.id);\n          }\n        } // run buildTree again\n\n\n        this.passiveAddition = true;\n        this.buildTree();\n        this.passiveAddition = false;\n      }\n    }, {\n      kind: \"method\",\n      key: \"buildTree\",\n      value: function buildTree() {}\n    }, {\n      kind: \"method\",\n      key: \"manageEditAttrProps\",\n      value: function manageEditAttrProps(newAttrs, type) {\n        // get a permanent reference to its parent node\n        var parentNode = this.parentNode; // get the position of the Incident within its parent\n\n        var position = parentNode.getLeafPosition(this.id); // keep a backup of the current attrs / props\n\n        var oldAttrs = JSON.parse(JSON.stringify(this[type]));\n        this[type] = newAttrs; // first detach the Incident from its parent\n\n        parentNode.removeIncident(this.id); // remove all direct passive incidents as they might be dependent on the edited attrs/props\n\n        this._rebuildTree(); // try to add the altered Group\n\n\n        var res = parentNode.addIncident(this, position);\n\n        if (res.result === false) {\n          this[type] = oldAttrs;\n\n          this._rebuildTree();\n\n          parentNode.addIncident(this, position);\n          return res;\n        }\n\n        return res;\n      }\n    }, {\n      kind: \"method\",\n      key: \"detachFromParent\",\n      value: function detachFromParent() {\n        _get(_getPrototypeOf(DescriptiveGroup.prototype), \"detachFromParent\", this).call(this);\n\n        this.inheritedSelector = null;\n      }\n    }, {\n      kind: \"get\",\n      key: \"inheritedSelector\",\n      value: function inheritedSelector() {\n        return this._inheritedSelector;\n      }\n    }, {\n      kind: \"set\",\n      key: \"inheritedSelector\",\n      value: function inheritedSelector(value) {\n        this._inheritedSelector = value;\n\n        for (var id in this.children) {\n          var theChild = this.children[id].leaf;\n          theChild.inheritedSelector = this.selector();\n        }\n      }\n    }, {\n      kind: \"get\",\n      key: \"selectorToPassToChildren\",\n      value: function selectorToPassToChildren() {\n        return this.selector();\n      }\n      /**\n       * The purpose of this method is to export a portable definition that can be\n       * later used in order to rebuild the Inicdent at any time\n       */\n\n    }, {\n      kind: \"method\",\n      key: \"exportDefinition\",\n      value: function exportDefinition() {\n        var toReturn = {\n          ClassName: this.constructor.ClassName,\n          plugin_npm_name: this.constructor.plugin_npm_name,\n          attrs: this.attrs,\n          props: this.props,\n          incidents: {}\n        };\n\n        for (var id in this.children) {\n          var theChild = this.children[id];\n\n          if (theChild.leaf.passive === true) {\n            continue;\n          }\n\n          toReturn.incidents[id] = {\n            id: theChild.id,\n            position: theChild.position,\n            leaf: theChild.leaf.exportDefinition()\n          };\n        }\n\n        return toReturn;\n      }\n    }, {\n      kind: \"method\",\n      key: \"addIncident\",\n      value: function addIncident(descriptiveIncident, position) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n          check: true\n        };\n        descriptiveIncident.inheritedSelector = this.selectorToPassToChildren;\n\n        if (options.check === true) {\n          var initialCheck = _get(_getPrototypeOf(DescriptiveGroup.prototype), \"checkAddition\", this).call(this, descriptiveIncident, position);\n\n          if (initialCheck.result === false) {\n            descriptiveIncident.inheritedSelector = null;\n            return initialCheck;\n          }\n          /* Check for null or relative selector Incidents with no inherited selector */\n\n\n          var checkIfBelongsToClip = this.putMessageOnPipe('checkForClip', {}, _CONST._TARGETTYPES._DECISIONAUTHORITY, {\n            selfExecute: true,\n            direction: _TREECONST._DIRECTIONS._UP\n          });\n\n          if (checkIfBelongsToClip.response === true) {\n            // if the Group belongs on a Clip\n            var selectorsCheck = descriptiveIncident.putMessageOnPipe('checkForInvalidSelectors', {}, null, {\n              selfExecute: true,\n              direction: _TREECONST._DIRECTIONS._DOWN\n            });\n\n            if (selectorsCheck.length > 0) {\n              var errors = [];\n\n              for (var i = 0; i < selectorsCheck.length; i++) {\n                errors.push(selectorsCheck[i].response);\n              }\n\n              return {\n                result: false,\n                errors: errors\n              };\n            }\n          } // sends the check request to its root, either a headless root or a Descriptive Clip\n\n\n          var mcCheck = this.putMessageOnPipe('checkAddition', {\n            incident: descriptiveIncident,\n            millisecond: position,\n            parentGroupId: this.id\n          }, _CONST._TARGETTYPES._DECISIONAUTHORITY, {\n            selfExecute: true,\n            direction: _TREECONST._DIRECTIONS._UP\n          });\n\n          if (mcCheck.response.result === false) {\n            descriptiveIncident.inheritedSelector = null;\n            return mcCheck.response;\n          }\n        } // if the passiveAddition flag is true we set the passive flag of the Incident\n        // to true before adding it to our Group\n\n\n        if (this.passiveAddition === true) {\n          descriptiveIncident.passive = true;\n        }\n\n        var res = this.addChild(descriptiveIncident, position);\n\n        if (res.result === false) {\n          descriptiveIncident.inheritedSelector = null;\n        }\n\n        return res;\n      }\n      /**\n       * @param input - can either be object or id\n       **/\n\n    }, {\n      kind: \"method\",\n      key: \"moveIncident\",\n      value: function moveIncident(input, position) {\n        var id = input;\n\n        if (_typeof(input) === \"object\") {\n          id = input.id;\n        }\n\n        var initialCheck = _get(_getPrototypeOf(DescriptiveGroup.prototype), \"checkEditPosition\", this).call(this, id, position);\n\n        if (initialCheck.result === false) {\n          return initialCheck;\n        }\n\n        var originalPosition = this.getLeafPosition(id);\n        var positionDelta = position - originalPosition;\n\n        if (positionDelta === 0) {\n          return {\n            result: true\n          };\n        }\n\n        var mcCheck = this.putMessageOnPipe('checkMove', {\n          id: id,\n          millisecond: position,\n          positionDelta: positionDelta,\n          parentGroupId: this.id\n        }, _CONST._TARGETTYPES._DECISIONAUTHORITY, {\n          selfExecute: true,\n          direction: _TREECONST._DIRECTIONS._UP\n        });\n\n        if (mcCheck.response.result === false) {\n          return mcCheck.response;\n        }\n\n        var res = this.editPosition(id, position);\n        return res;\n      }\n    }, {\n      kind: \"method\",\n      key: \"removeIncident\",\n      value: function removeIncident(input) {\n        var id = input;\n\n        if (_typeof(input) === \"object\") {\n          id = input.id;\n        }\n\n        var initialCheck = _get(_getPrototypeOf(DescriptiveGroup.prototype), \"checkRemoveChild\", this).call(this, id);\n\n        if (initialCheck.result === false) {\n          return initialCheck;\n        }\n\n        var mcCheck = this.putMessageOnPipe('checkDeletion', {\n          id: id,\n          parentGroupId: this.id\n        }, _CONST._TARGETTYPES._DECISIONAUTHORITY, {\n          selfExecute: true,\n          direction: _TREECONST._DIRECTIONS._UP\n        });\n\n        if (mcCheck.response.result === false) {\n          return mcCheck.response;\n        }\n\n        var res = this.removeChild(id);\n        return res;\n      }\n      /*************************** HANDLING METHODS *******************************/\n\n    }, {\n      kind: \"method\",\n      key: \"handleCheckForClip\",\n      value: function handleCheckForClip(target, payload) {\n        // eslint-disable-line no-unused-vars\n        if (this.hasParent) {\n          return this.bypass();\n        }\n\n        return false;\n      }\n    }, {\n      kind: \"method\",\n      key: \"handleCheckAddition\",\n      value: function handleCheckAddition(target, payload) {\n        // eslint-disable-line no-unused-vars\n\n        /*\n        The DescriptiveGroup handles the checkAddition command which has the UP\n        direction. If the DG has a parent it forwards the command to it. If not\n        it just returns true, as it is a deadless tree\n        */\n        if (this.hasParent) {\n          return this.bypass();\n        }\n\n        return {\n          result: true\n        };\n      }\n    }, {\n      kind: \"method\",\n      key: \"handleCheckMove\",\n      value: function handleCheckMove(target, payload) {\n        // eslint-disable-line no-unused-vars\n        if (this.hasParent) {\n          return this.bypass();\n        }\n\n        return {\n          result: true\n        };\n      }\n    }, {\n      kind: \"method\",\n      key: \"handleCheckDeletion\",\n      value: function handleCheckDeletion(target, payload) {\n        // eslint-disable-line no-unused-vars\n        if (this.hasParent) {\n          return this.bypass();\n        }\n\n        return {\n          result: true\n        };\n      }\n    }, {\n      kind: \"method\",\n      key: \"handleCheckResize\",\n      value: function handleCheckResize(target, payload) {\n        // eslint-disable-line no-unused-vars\n        if (this.hasParent) {\n          return this.bypass();\n        }\n\n        return {\n          result: true\n        };\n      }\n    }]\n  };\n}, Node);\n\nmodule.exports = DescriptiveGroup;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19EZXNjcmlwdGl2ZUluY2lkZW50cy9EZXNjcmlwdGl2ZUdyb3VwLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvZGlzdC9fRGVzY3JpcHRpdmVJbmNpZGVudHMvRGVzY3JpcHRpdmVHcm91cC5qcz9jMjdlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfZGVjb3JhdGUoZGVjb3JhdG9ycywgZmFjdG9yeSwgc3VwZXJDbGFzcywgbWl4aW5zKSB7IHZhciBhcGkgPSBfZ2V0RGVjb3JhdG9yc0FwaSgpOyBpZiAobWl4aW5zKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgbWl4aW5zLmxlbmd0aDsgaSsrKSB7IGFwaSA9IG1peGluc1tpXShhcGkpOyB9IH0gdmFyIHIgPSBmYWN0b3J5KGZ1bmN0aW9uIGluaXRpYWxpemUoTykgeyBhcGkuaW5pdGlhbGl6ZUluc3RhbmNlRWxlbWVudHMoTywgZGVjb3JhdGVkLmVsZW1lbnRzKTsgfSwgc3VwZXJDbGFzcyk7IHZhciBkZWNvcmF0ZWQgPSBhcGkuZGVjb3JhdGVDbGFzcyhfY29hbGVzY2VDbGFzc0VsZW1lbnRzKHIuZC5tYXAoX2NyZWF0ZUVsZW1lbnREZXNjcmlwdG9yKSksIGRlY29yYXRvcnMpOyBhcGkuaW5pdGlhbGl6ZUNsYXNzRWxlbWVudHMoci5GLCBkZWNvcmF0ZWQuZWxlbWVudHMpOyByZXR1cm4gYXBpLnJ1bkNsYXNzRmluaXNoZXJzKHIuRiwgZGVjb3JhdGVkLmZpbmlzaGVycyk7IH1cblxuZnVuY3Rpb24gX2dldERlY29yYXRvcnNBcGkoKSB7IF9nZXREZWNvcmF0b3JzQXBpID0gZnVuY3Rpb24gX2dldERlY29yYXRvcnNBcGkoKSB7IHJldHVybiBhcGk7IH07IHZhciBhcGkgPSB7IGVsZW1lbnRzRGVmaW5pdGlvbk9yZGVyOiBbW1wibWV0aG9kXCJdLCBbXCJmaWVsZFwiXV0sIGluaXRpYWxpemVJbnN0YW5jZUVsZW1lbnRzOiBmdW5jdGlvbiBpbml0aWFsaXplSW5zdGFuY2VFbGVtZW50cyhPLCBlbGVtZW50cykgeyBbXCJtZXRob2RcIiwgXCJmaWVsZFwiXS5mb3JFYWNoKGZ1bmN0aW9uIChraW5kKSB7IGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHsgaWYgKGVsZW1lbnQua2luZCA9PT0ga2luZCAmJiBlbGVtZW50LnBsYWNlbWVudCA9PT0gXCJvd25cIikgeyB0aGlzLmRlZmluZUNsYXNzRWxlbWVudChPLCBlbGVtZW50KTsgfSB9LCB0aGlzKTsgfSwgdGhpcyk7IH0sIGluaXRpYWxpemVDbGFzc0VsZW1lbnRzOiBmdW5jdGlvbiBpbml0aWFsaXplQ2xhc3NFbGVtZW50cyhGLCBlbGVtZW50cykgeyB2YXIgcHJvdG8gPSBGLnByb3RvdHlwZTsgW1wibWV0aG9kXCIsIFwiZmllbGRcIl0uZm9yRWFjaChmdW5jdGlvbiAoa2luZCkgeyBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7IHZhciBwbGFjZW1lbnQgPSBlbGVtZW50LnBsYWNlbWVudDsgaWYgKGVsZW1lbnQua2luZCA9PT0ga2luZCAmJiAocGxhY2VtZW50ID09PSBcInN0YXRpY1wiIHx8IHBsYWNlbWVudCA9PT0gXCJwcm90b3R5cGVcIikpIHsgdmFyIHJlY2VpdmVyID0gcGxhY2VtZW50ID09PSBcInN0YXRpY1wiID8gRiA6IHByb3RvOyB0aGlzLmRlZmluZUNsYXNzRWxlbWVudChyZWNlaXZlciwgZWxlbWVudCk7IH0gfSwgdGhpcyk7IH0sIHRoaXMpOyB9LCBkZWZpbmVDbGFzc0VsZW1lbnQ6IGZ1bmN0aW9uIGRlZmluZUNsYXNzRWxlbWVudChyZWNlaXZlciwgZWxlbWVudCkgeyB2YXIgZGVzY3JpcHRvciA9IGVsZW1lbnQuZGVzY3JpcHRvcjsgaWYgKGVsZW1lbnQua2luZCA9PT0gXCJmaWVsZFwiKSB7IHZhciBpbml0aWFsaXplciA9IGVsZW1lbnQuaW5pdGlhbGl6ZXI7IGRlc2NyaXB0b3IgPSB7IGVudW1lcmFibGU6IGRlc2NyaXB0b3IuZW51bWVyYWJsZSwgd3JpdGFibGU6IGRlc2NyaXB0b3Iud3JpdGFibGUsIGNvbmZpZ3VyYWJsZTogZGVzY3JpcHRvci5jb25maWd1cmFibGUsIHZhbHVlOiBpbml0aWFsaXplciA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5pdGlhbGl6ZXIuY2FsbChyZWNlaXZlcikgfTsgfSBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVjZWl2ZXIsIGVsZW1lbnQua2V5LCBkZXNjcmlwdG9yKTsgfSwgZGVjb3JhdGVDbGFzczogZnVuY3Rpb24gZGVjb3JhdGVDbGFzcyhlbGVtZW50cywgZGVjb3JhdG9ycykgeyB2YXIgbmV3RWxlbWVudHMgPSBbXTsgdmFyIGZpbmlzaGVycyA9IFtdOyB2YXIgcGxhY2VtZW50cyA9IHsgXCJzdGF0aWNcIjogW10sIHByb3RvdHlwZTogW10sIG93bjogW10gfTsgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkgeyB0aGlzLmFkZEVsZW1lbnRQbGFjZW1lbnQoZWxlbWVudCwgcGxhY2VtZW50cyk7IH0sIHRoaXMpOyBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7IGlmICghX2hhc0RlY29yYXRvcnMoZWxlbWVudCkpIHJldHVybiBuZXdFbGVtZW50cy5wdXNoKGVsZW1lbnQpOyB2YXIgZWxlbWVudEZpbmlzaGVyc0V4dHJhcyA9IHRoaXMuZGVjb3JhdGVFbGVtZW50KGVsZW1lbnQsIHBsYWNlbWVudHMpOyBuZXdFbGVtZW50cy5wdXNoKGVsZW1lbnRGaW5pc2hlcnNFeHRyYXMuZWxlbWVudCk7IG5ld0VsZW1lbnRzLnB1c2guYXBwbHkobmV3RWxlbWVudHMsIGVsZW1lbnRGaW5pc2hlcnNFeHRyYXMuZXh0cmFzKTsgZmluaXNoZXJzLnB1c2guYXBwbHkoZmluaXNoZXJzLCBlbGVtZW50RmluaXNoZXJzRXh0cmFzLmZpbmlzaGVycyk7IH0sIHRoaXMpOyBpZiAoIWRlY29yYXRvcnMpIHsgcmV0dXJuIHsgZWxlbWVudHM6IG5ld0VsZW1lbnRzLCBmaW5pc2hlcnM6IGZpbmlzaGVycyB9OyB9IHZhciByZXN1bHQgPSB0aGlzLmRlY29yYXRlQ29uc3RydWN0b3IobmV3RWxlbWVudHMsIGRlY29yYXRvcnMpOyBmaW5pc2hlcnMucHVzaC5hcHBseShmaW5pc2hlcnMsIHJlc3VsdC5maW5pc2hlcnMpOyByZXN1bHQuZmluaXNoZXJzID0gZmluaXNoZXJzOyByZXR1cm4gcmVzdWx0OyB9LCBhZGRFbGVtZW50UGxhY2VtZW50OiBmdW5jdGlvbiBhZGRFbGVtZW50UGxhY2VtZW50KGVsZW1lbnQsIHBsYWNlbWVudHMsIHNpbGVudCkgeyB2YXIga2V5cyA9IHBsYWNlbWVudHNbZWxlbWVudC5wbGFjZW1lbnRdOyBpZiAoIXNpbGVudCAmJiBrZXlzLmluZGV4T2YoZWxlbWVudC5rZXkpICE9PSAtMSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRHVwbGljYXRlZCBlbGVtZW50IChcIiArIGVsZW1lbnQua2V5ICsgXCIpXCIpOyB9IGtleXMucHVzaChlbGVtZW50LmtleSk7IH0sIGRlY29yYXRlRWxlbWVudDogZnVuY3Rpb24gZGVjb3JhdGVFbGVtZW50KGVsZW1lbnQsIHBsYWNlbWVudHMpIHsgdmFyIGV4dHJhcyA9IFtdOyB2YXIgZmluaXNoZXJzID0gW107IGZvciAodmFyIGRlY29yYXRvcnMgPSBlbGVtZW50LmRlY29yYXRvcnMsIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7IHZhciBrZXlzID0gcGxhY2VtZW50c1tlbGVtZW50LnBsYWNlbWVudF07IGtleXMuc3BsaWNlKGtleXMuaW5kZXhPZihlbGVtZW50LmtleSksIDEpOyB2YXIgZWxlbWVudE9iamVjdCA9IHRoaXMuZnJvbUVsZW1lbnREZXNjcmlwdG9yKGVsZW1lbnQpOyB2YXIgZWxlbWVudEZpbmlzaGVyRXh0cmFzID0gdGhpcy50b0VsZW1lbnRGaW5pc2hlckV4dHJhcygoMCwgZGVjb3JhdG9yc1tpXSkoZWxlbWVudE9iamVjdCkgfHwgZWxlbWVudE9iamVjdCk7IGVsZW1lbnQgPSBlbGVtZW50RmluaXNoZXJFeHRyYXMuZWxlbWVudDsgdGhpcy5hZGRFbGVtZW50UGxhY2VtZW50KGVsZW1lbnQsIHBsYWNlbWVudHMpOyBpZiAoZWxlbWVudEZpbmlzaGVyRXh0cmFzLmZpbmlzaGVyKSB7IGZpbmlzaGVycy5wdXNoKGVsZW1lbnRGaW5pc2hlckV4dHJhcy5maW5pc2hlcik7IH0gdmFyIG5ld0V4dHJhcyA9IGVsZW1lbnRGaW5pc2hlckV4dHJhcy5leHRyYXM7IGlmIChuZXdFeHRyYXMpIHsgZm9yICh2YXIgaiA9IDA7IGogPCBuZXdFeHRyYXMubGVuZ3RoOyBqKyspIHsgdGhpcy5hZGRFbGVtZW50UGxhY2VtZW50KG5ld0V4dHJhc1tqXSwgcGxhY2VtZW50cyk7IH0gZXh0cmFzLnB1c2guYXBwbHkoZXh0cmFzLCBuZXdFeHRyYXMpOyB9IH0gcmV0dXJuIHsgZWxlbWVudDogZWxlbWVudCwgZmluaXNoZXJzOiBmaW5pc2hlcnMsIGV4dHJhczogZXh0cmFzIH07IH0sIGRlY29yYXRlQ29uc3RydWN0b3I6IGZ1bmN0aW9uIGRlY29yYXRlQ29uc3RydWN0b3IoZWxlbWVudHMsIGRlY29yYXRvcnMpIHsgdmFyIGZpbmlzaGVycyA9IFtdOyBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgeyB2YXIgb2JqID0gdGhpcy5mcm9tQ2xhc3NEZXNjcmlwdG9yKGVsZW1lbnRzKTsgdmFyIGVsZW1lbnRzQW5kRmluaXNoZXIgPSB0aGlzLnRvQ2xhc3NEZXNjcmlwdG9yKCgwLCBkZWNvcmF0b3JzW2ldKShvYmopIHx8IG9iaik7IGlmIChlbGVtZW50c0FuZEZpbmlzaGVyLmZpbmlzaGVyICE9PSB1bmRlZmluZWQpIHsgZmluaXNoZXJzLnB1c2goZWxlbWVudHNBbmRGaW5pc2hlci5maW5pc2hlcik7IH0gaWYgKGVsZW1lbnRzQW5kRmluaXNoZXIuZWxlbWVudHMgIT09IHVuZGVmaW5lZCkgeyBlbGVtZW50cyA9IGVsZW1lbnRzQW5kRmluaXNoZXIuZWxlbWVudHM7IGZvciAodmFyIGogPSAwOyBqIDwgZWxlbWVudHMubGVuZ3RoIC0gMTsgaisrKSB7IGZvciAodmFyIGsgPSBqICsgMTsgayA8IGVsZW1lbnRzLmxlbmd0aDsgaysrKSB7IGlmIChlbGVtZW50c1tqXS5rZXkgPT09IGVsZW1lbnRzW2tdLmtleSAmJiBlbGVtZW50c1tqXS5wbGFjZW1lbnQgPT09IGVsZW1lbnRzW2tdLnBsYWNlbWVudCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRHVwbGljYXRlZCBlbGVtZW50IChcIiArIGVsZW1lbnRzW2pdLmtleSArIFwiKVwiKTsgfSB9IH0gfSB9IHJldHVybiB7IGVsZW1lbnRzOiBlbGVtZW50cywgZmluaXNoZXJzOiBmaW5pc2hlcnMgfTsgfSwgZnJvbUVsZW1lbnREZXNjcmlwdG9yOiBmdW5jdGlvbiBmcm9tRWxlbWVudERlc2NyaXB0b3IoZWxlbWVudCkgeyB2YXIgb2JqID0geyBraW5kOiBlbGVtZW50LmtpbmQsIGtleTogZWxlbWVudC5rZXksIHBsYWNlbWVudDogZWxlbWVudC5wbGFjZW1lbnQsIGRlc2NyaXB0b3I6IGVsZW1lbnQuZGVzY3JpcHRvciB9OyB2YXIgZGVzYyA9IHsgdmFsdWU6IFwiRGVzY3JpcHRvclwiLCBjb25maWd1cmFibGU6IHRydWUgfTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgU3ltYm9sLnRvU3RyaW5nVGFnLCBkZXNjKTsgaWYgKGVsZW1lbnQua2luZCA9PT0gXCJmaWVsZFwiKSBvYmouaW5pdGlhbGl6ZXIgPSBlbGVtZW50LmluaXRpYWxpemVyOyByZXR1cm4gb2JqOyB9LCB0b0VsZW1lbnREZXNjcmlwdG9yczogZnVuY3Rpb24gdG9FbGVtZW50RGVzY3JpcHRvcnMoZWxlbWVudE9iamVjdHMpIHsgaWYgKGVsZW1lbnRPYmplY3RzID09PSB1bmRlZmluZWQpIHJldHVybjsgcmV0dXJuIF90b0FycmF5KGVsZW1lbnRPYmplY3RzKS5tYXAoZnVuY3Rpb24gKGVsZW1lbnRPYmplY3QpIHsgdmFyIGVsZW1lbnQgPSB0aGlzLnRvRWxlbWVudERlc2NyaXB0b3IoZWxlbWVudE9iamVjdCk7IHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShlbGVtZW50T2JqZWN0LCBcImZpbmlzaGVyXCIsIFwiQW4gZWxlbWVudCBkZXNjcmlwdG9yXCIpOyB0aGlzLmRpc2FsbG93UHJvcGVydHkoZWxlbWVudE9iamVjdCwgXCJleHRyYXNcIiwgXCJBbiBlbGVtZW50IGRlc2NyaXB0b3JcIik7IHJldHVybiBlbGVtZW50OyB9LCB0aGlzKTsgfSwgdG9FbGVtZW50RGVzY3JpcHRvcjogZnVuY3Rpb24gdG9FbGVtZW50RGVzY3JpcHRvcihlbGVtZW50T2JqZWN0KSB7IHZhciBraW5kID0gU3RyaW5nKGVsZW1lbnRPYmplY3Qua2luZCk7IGlmIChraW5kICE9PSBcIm1ldGhvZFwiICYmIGtpbmQgIT09IFwiZmllbGRcIikgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdBbiBlbGVtZW50IGRlc2NyaXB0b3JcXCdzIC5raW5kIHByb3BlcnR5IG11c3QgYmUgZWl0aGVyIFwibWV0aG9kXCIgb3InICsgJyBcImZpZWxkXCIsIGJ1dCBhIGRlY29yYXRvciBjcmVhdGVkIGFuIGVsZW1lbnQgZGVzY3JpcHRvciB3aXRoJyArICcgLmtpbmQgXCInICsga2luZCArICdcIicpOyB9IHZhciBrZXkgPSBfdG9Qcm9wZXJ0eUtleShlbGVtZW50T2JqZWN0LmtleSk7IHZhciBwbGFjZW1lbnQgPSBTdHJpbmcoZWxlbWVudE9iamVjdC5wbGFjZW1lbnQpOyBpZiAocGxhY2VtZW50ICE9PSBcInN0YXRpY1wiICYmIHBsYWNlbWVudCAhPT0gXCJwcm90b3R5cGVcIiAmJiBwbGFjZW1lbnQgIT09IFwib3duXCIpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQW4gZWxlbWVudCBkZXNjcmlwdG9yXFwncyAucGxhY2VtZW50IHByb3BlcnR5IG11c3QgYmUgb25lIG9mIFwic3RhdGljXCIsJyArICcgXCJwcm90b3R5cGVcIiBvciBcIm93blwiLCBidXQgYSBkZWNvcmF0b3IgY3JlYXRlZCBhbiBlbGVtZW50IGRlc2NyaXB0b3InICsgJyB3aXRoIC5wbGFjZW1lbnQgXCInICsgcGxhY2VtZW50ICsgJ1wiJyk7IH0gdmFyIGRlc2NyaXB0b3IgPSBlbGVtZW50T2JqZWN0LmRlc2NyaXB0b3I7IHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShlbGVtZW50T2JqZWN0LCBcImVsZW1lbnRzXCIsIFwiQW4gZWxlbWVudCBkZXNjcmlwdG9yXCIpOyB2YXIgZWxlbWVudCA9IHsga2luZDoga2luZCwga2V5OiBrZXksIHBsYWNlbWVudDogcGxhY2VtZW50LCBkZXNjcmlwdG9yOiBPYmplY3QuYXNzaWduKHt9LCBkZXNjcmlwdG9yKSB9OyBpZiAoa2luZCAhPT0gXCJmaWVsZFwiKSB7IHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShlbGVtZW50T2JqZWN0LCBcImluaXRpYWxpemVyXCIsIFwiQSBtZXRob2QgZGVzY3JpcHRvclwiKTsgfSBlbHNlIHsgdGhpcy5kaXNhbGxvd1Byb3BlcnR5KGRlc2NyaXB0b3IsIFwiZ2V0XCIsIFwiVGhlIHByb3BlcnR5IGRlc2NyaXB0b3Igb2YgYSBmaWVsZCBkZXNjcmlwdG9yXCIpOyB0aGlzLmRpc2FsbG93UHJvcGVydHkoZGVzY3JpcHRvciwgXCJzZXRcIiwgXCJUaGUgcHJvcGVydHkgZGVzY3JpcHRvciBvZiBhIGZpZWxkIGRlc2NyaXB0b3JcIik7IHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShkZXNjcmlwdG9yLCBcInZhbHVlXCIsIFwiVGhlIHByb3BlcnR5IGRlc2NyaXB0b3Igb2YgYSBmaWVsZCBkZXNjcmlwdG9yXCIpOyBlbGVtZW50LmluaXRpYWxpemVyID0gZWxlbWVudE9iamVjdC5pbml0aWFsaXplcjsgfSByZXR1cm4gZWxlbWVudDsgfSwgdG9FbGVtZW50RmluaXNoZXJFeHRyYXM6IGZ1bmN0aW9uIHRvRWxlbWVudEZpbmlzaGVyRXh0cmFzKGVsZW1lbnRPYmplY3QpIHsgdmFyIGVsZW1lbnQgPSB0aGlzLnRvRWxlbWVudERlc2NyaXB0b3IoZWxlbWVudE9iamVjdCk7IHZhciBmaW5pc2hlciA9IF9vcHRpb25hbENhbGxhYmxlUHJvcGVydHkoZWxlbWVudE9iamVjdCwgXCJmaW5pc2hlclwiKTsgdmFyIGV4dHJhcyA9IHRoaXMudG9FbGVtZW50RGVzY3JpcHRvcnMoZWxlbWVudE9iamVjdC5leHRyYXMpOyByZXR1cm4geyBlbGVtZW50OiBlbGVtZW50LCBmaW5pc2hlcjogZmluaXNoZXIsIGV4dHJhczogZXh0cmFzIH07IH0sIGZyb21DbGFzc0Rlc2NyaXB0b3I6IGZ1bmN0aW9uIGZyb21DbGFzc0Rlc2NyaXB0b3IoZWxlbWVudHMpIHsgdmFyIG9iaiA9IHsga2luZDogXCJjbGFzc1wiLCBlbGVtZW50czogZWxlbWVudHMubWFwKHRoaXMuZnJvbUVsZW1lbnREZXNjcmlwdG9yLCB0aGlzKSB9OyB2YXIgZGVzYyA9IHsgdmFsdWU6IFwiRGVzY3JpcHRvclwiLCBjb25maWd1cmFibGU6IHRydWUgfTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgU3ltYm9sLnRvU3RyaW5nVGFnLCBkZXNjKTsgcmV0dXJuIG9iajsgfSwgdG9DbGFzc0Rlc2NyaXB0b3I6IGZ1bmN0aW9uIHRvQ2xhc3NEZXNjcmlwdG9yKG9iaikgeyB2YXIga2luZCA9IFN0cmluZyhvYmoua2luZCk7IGlmIChraW5kICE9PSBcImNsYXNzXCIpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQSBjbGFzcyBkZXNjcmlwdG9yXFwncyAua2luZCBwcm9wZXJ0eSBtdXN0IGJlIFwiY2xhc3NcIiwgYnV0IGEgZGVjb3JhdG9yJyArICcgY3JlYXRlZCBhIGNsYXNzIGRlc2NyaXB0b3Igd2l0aCAua2luZCBcIicgKyBraW5kICsgJ1wiJyk7IH0gdGhpcy5kaXNhbGxvd1Byb3BlcnR5KG9iaiwgXCJrZXlcIiwgXCJBIGNsYXNzIGRlc2NyaXB0b3JcIik7IHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShvYmosIFwicGxhY2VtZW50XCIsIFwiQSBjbGFzcyBkZXNjcmlwdG9yXCIpOyB0aGlzLmRpc2FsbG93UHJvcGVydHkob2JqLCBcImRlc2NyaXB0b3JcIiwgXCJBIGNsYXNzIGRlc2NyaXB0b3JcIik7IHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShvYmosIFwiaW5pdGlhbGl6ZXJcIiwgXCJBIGNsYXNzIGRlc2NyaXB0b3JcIik7IHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShvYmosIFwiZXh0cmFzXCIsIFwiQSBjbGFzcyBkZXNjcmlwdG9yXCIpOyB2YXIgZmluaXNoZXIgPSBfb3B0aW9uYWxDYWxsYWJsZVByb3BlcnR5KG9iaiwgXCJmaW5pc2hlclwiKTsgdmFyIGVsZW1lbnRzID0gdGhpcy50b0VsZW1lbnREZXNjcmlwdG9ycyhvYmouZWxlbWVudHMpOyByZXR1cm4geyBlbGVtZW50czogZWxlbWVudHMsIGZpbmlzaGVyOiBmaW5pc2hlciB9OyB9LCBydW5DbGFzc0ZpbmlzaGVyczogZnVuY3Rpb24gcnVuQ2xhc3NGaW5pc2hlcnMoY29uc3RydWN0b3IsIGZpbmlzaGVycykgeyBmb3IgKHZhciBpID0gMDsgaSA8IGZpbmlzaGVycy5sZW5ndGg7IGkrKykgeyB2YXIgbmV3Q29uc3RydWN0b3IgPSAoMCwgZmluaXNoZXJzW2ldKShjb25zdHJ1Y3Rvcik7IGlmIChuZXdDb25zdHJ1Y3RvciAhPT0gdW5kZWZpbmVkKSB7IGlmICh0eXBlb2YgbmV3Q29uc3RydWN0b3IgIT09IFwiZnVuY3Rpb25cIikgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmluaXNoZXJzIG11c3QgcmV0dXJuIGEgY29uc3RydWN0b3IuXCIpOyB9IGNvbnN0cnVjdG9yID0gbmV3Q29uc3RydWN0b3I7IH0gfSByZXR1cm4gY29uc3RydWN0b3I7IH0sIGRpc2FsbG93UHJvcGVydHk6IGZ1bmN0aW9uIGRpc2FsbG93UHJvcGVydHkob2JqLCBuYW1lLCBvYmplY3RUeXBlKSB7IGlmIChvYmpbbmFtZV0gIT09IHVuZGVmaW5lZCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKG9iamVjdFR5cGUgKyBcIiBjYW4ndCBoYXZlIGEgLlwiICsgbmFtZSArIFwiIHByb3BlcnR5LlwiKTsgfSB9IH07IHJldHVybiBhcGk7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUVsZW1lbnREZXNjcmlwdG9yKGRlZikgeyB2YXIga2V5ID0gX3RvUHJvcGVydHlLZXkoZGVmLmtleSk7IHZhciBkZXNjcmlwdG9yOyBpZiAoZGVmLmtpbmQgPT09IFwibWV0aG9kXCIpIHsgZGVzY3JpcHRvciA9IHsgdmFsdWU6IGRlZi52YWx1ZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZW51bWVyYWJsZTogZmFsc2UgfTsgfSBlbHNlIGlmIChkZWYua2luZCA9PT0gXCJnZXRcIikgeyBkZXNjcmlwdG9yID0geyBnZXQ6IGRlZi52YWx1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCBlbnVtZXJhYmxlOiBmYWxzZSB9OyB9IGVsc2UgaWYgKGRlZi5raW5kID09PSBcInNldFwiKSB7IGRlc2NyaXB0b3IgPSB7IHNldDogZGVmLnZhbHVlLCBjb25maWd1cmFibGU6IHRydWUsIGVudW1lcmFibGU6IGZhbHNlIH07IH0gZWxzZSBpZiAoZGVmLmtpbmQgPT09IFwiZmllbGRcIikgeyBkZXNjcmlwdG9yID0geyBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCBlbnVtZXJhYmxlOiB0cnVlIH07IH0gdmFyIGVsZW1lbnQgPSB7IGtpbmQ6IGRlZi5raW5kID09PSBcImZpZWxkXCIgPyBcImZpZWxkXCIgOiBcIm1ldGhvZFwiLCBrZXk6IGtleSwgcGxhY2VtZW50OiBkZWZbXCJzdGF0aWNcIl0gPyBcInN0YXRpY1wiIDogZGVmLmtpbmQgPT09IFwiZmllbGRcIiA/IFwib3duXCIgOiBcInByb3RvdHlwZVwiLCBkZXNjcmlwdG9yOiBkZXNjcmlwdG9yIH07IGlmIChkZWYuZGVjb3JhdG9ycykgZWxlbWVudC5kZWNvcmF0b3JzID0gZGVmLmRlY29yYXRvcnM7IGlmIChkZWYua2luZCA9PT0gXCJmaWVsZFwiKSBlbGVtZW50LmluaXRpYWxpemVyID0gZGVmLnZhbHVlOyByZXR1cm4gZWxlbWVudDsgfVxuXG5mdW5jdGlvbiBfY29hbGVzY2VHZXR0ZXJTZXR0ZXIoZWxlbWVudCwgb3RoZXIpIHsgaWYgKGVsZW1lbnQuZGVzY3JpcHRvci5nZXQgIT09IHVuZGVmaW5lZCkgeyBvdGhlci5kZXNjcmlwdG9yLmdldCA9IGVsZW1lbnQuZGVzY3JpcHRvci5nZXQ7IH0gZWxzZSB7IG90aGVyLmRlc2NyaXB0b3Iuc2V0ID0gZWxlbWVudC5kZXNjcmlwdG9yLnNldDsgfSB9XG5cbmZ1bmN0aW9uIF9jb2FsZXNjZUNsYXNzRWxlbWVudHMoZWxlbWVudHMpIHsgdmFyIG5ld0VsZW1lbnRzID0gW107IHZhciBpc1NhbWVFbGVtZW50ID0gZnVuY3Rpb24gaXNTYW1lRWxlbWVudChvdGhlcikgeyByZXR1cm4gb3RoZXIua2luZCA9PT0gXCJtZXRob2RcIiAmJiBvdGhlci5rZXkgPT09IGVsZW1lbnQua2V5ICYmIG90aGVyLnBsYWNlbWVudCA9PT0gZWxlbWVudC5wbGFjZW1lbnQ7IH07IGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIGVsZW1lbnQgPSBlbGVtZW50c1tpXTsgdmFyIG90aGVyOyBpZiAoZWxlbWVudC5raW5kID09PSBcIm1ldGhvZFwiICYmIChvdGhlciA9IG5ld0VsZW1lbnRzLmZpbmQoaXNTYW1lRWxlbWVudCkpKSB7IGlmIChfaXNEYXRhRGVzY3JpcHRvcihlbGVtZW50LmRlc2NyaXB0b3IpIHx8IF9pc0RhdGFEZXNjcmlwdG9yKG90aGVyLmRlc2NyaXB0b3IpKSB7IGlmIChfaGFzRGVjb3JhdG9ycyhlbGVtZW50KSB8fCBfaGFzRGVjb3JhdG9ycyhvdGhlcikpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwiRHVwbGljYXRlZCBtZXRob2RzIChcIiArIGVsZW1lbnQua2V5ICsgXCIpIGNhbid0IGJlIGRlY29yYXRlZC5cIik7IH0gb3RoZXIuZGVzY3JpcHRvciA9IGVsZW1lbnQuZGVzY3JpcHRvcjsgfSBlbHNlIHsgaWYgKF9oYXNEZWNvcmF0b3JzKGVsZW1lbnQpKSB7IGlmIChfaGFzRGVjb3JhdG9ycyhvdGhlcikpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwiRGVjb3JhdG9ycyBjYW4ndCBiZSBwbGFjZWQgb24gZGlmZmVyZW50IGFjY2Vzc29ycyB3aXRoIGZvciBcIiArIFwidGhlIHNhbWUgcHJvcGVydHkgKFwiICsgZWxlbWVudC5rZXkgKyBcIikuXCIpOyB9IG90aGVyLmRlY29yYXRvcnMgPSBlbGVtZW50LmRlY29yYXRvcnM7IH0gX2NvYWxlc2NlR2V0dGVyU2V0dGVyKGVsZW1lbnQsIG90aGVyKTsgfSB9IGVsc2UgeyBuZXdFbGVtZW50cy5wdXNoKGVsZW1lbnQpOyB9IH0gcmV0dXJuIG5ld0VsZW1lbnRzOyB9XG5cbmZ1bmN0aW9uIF9oYXNEZWNvcmF0b3JzKGVsZW1lbnQpIHsgcmV0dXJuIGVsZW1lbnQuZGVjb3JhdG9ycyAmJiBlbGVtZW50LmRlY29yYXRvcnMubGVuZ3RoOyB9XG5cbmZ1bmN0aW9uIF9pc0RhdGFEZXNjcmlwdG9yKGRlc2MpIHsgcmV0dXJuIGRlc2MgIT09IHVuZGVmaW5lZCAmJiAhKGRlc2MudmFsdWUgPT09IHVuZGVmaW5lZCAmJiBkZXNjLndyaXRhYmxlID09PSB1bmRlZmluZWQpOyB9XG5cbmZ1bmN0aW9uIF9vcHRpb25hbENhbGxhYmxlUHJvcGVydHkob2JqLCBuYW1lKSB7IHZhciB2YWx1ZSA9IG9ialtuYW1lXTsgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkICdcIiArIG5hbWUgKyBcIicgdG8gYmUgYSBmdW5jdGlvblwiKTsgfSByZXR1cm4gdmFsdWU7IH1cblxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkoYXJnKSB7IHZhciBrZXkgPSBfdG9QcmltaXRpdmUoYXJnLCBcInN0cmluZ1wiKTsgcmV0dXJuIF90eXBlb2Yoa2V5KSA9PT0gXCJzeW1ib2xcIiA/IGtleSA6IFN0cmluZyhrZXkpOyB9XG5cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZShpbnB1dCwgaGludCkgeyBpZiAoX3R5cGVvZihpbnB1dCkgIT09IFwib2JqZWN0XCIgfHwgaW5wdXQgPT09IG51bGwpIHJldHVybiBpbnB1dDsgdmFyIHByaW0gPSBpbnB1dFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAocHJpbSAhPT0gdW5kZWZpbmVkKSB7IHZhciByZXMgPSBwcmltLmNhbGwoaW5wdXQsIGhpbnQgfHwgXCJkZWZhdWx0XCIpOyBpZiAoX3R5cGVvZihyZXMpICE9PSBcIm9iamVjdFwiKSByZXR1cm4gcmVzOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChoaW50ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShpbnB1dCk7IH1cblxuZnVuY3Rpb24gX3RvQXJyYXkoYXJyKSB7IHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlUmVzdCgpOyB9XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpOyB9XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikgeyBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChpdGVyKSB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaXRlcikgPT09IFwiW29iamVjdCBBcmd1bWVudHNdXCIpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpOyB9XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjsgfVxuXG5mdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LmdldCkgeyBfZ2V0ID0gUmVmbGVjdC5nZXQ7IH0gZWxzZSB7IF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IHZhciBiYXNlID0gX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7IGlmICghYmFzZSkgcmV0dXJuOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpOyBpZiAoZGVzYy5nZXQpIHsgcmV0dXJuIGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpOyB9IHJldHVybiBkZXNjLnZhbHVlOyB9OyB9IHJldHVybiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyIHx8IHRhcmdldCk7IH1cblxuZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkgeyB3aGlsZSAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkgeyBvYmplY3QgPSBfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7IH0gcmV0dXJuIG9iamVjdDsgfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbnZhciBfQ09OU1QgPSByZXF1aXJlKCcuL19DT05TVCcpO1xuXG52YXIgX1RSRUVDT05TVCA9IHJlcXVpcmUoJy4uL19UcmVlL19DT05TVCcpO1xuXG52YXIgTm9kZSA9IHJlcXVpcmUoJy4uL19UcmVlL05vZGUnKTtcblxudmFyIHJlc2l6ZSA9IHJlcXVpcmUoJy4vZGVjb3JhdG9ycy9yZXNpemUnKTtcblxudmFyIGVkaXRBdHRyaWJ1dGVzID0gcmVxdWlyZSgnLi9kZWNvcmF0b3JzL2VkaXRBdHRyaWJ1dGVzJyk7XG5cbnZhciBlZGl0UHJvcGVydGllcyA9IHJlcXVpcmUoJy4vZGVjb3JhdG9ycy9lZGl0UHJvcGVydGllcycpO1xuXG52YXIgc2VsZWN0b3JHZXR0ZXIgPSByZXF1aXJlKCcuL2RlY29yYXRvcnMvc2VsZWN0b3InKTtcblxudmFyIEdyb3VwID0gcmVxdWlyZSgnLi4vX0Jhc2VDbGFzc2VzL0dyb3VwJyk7XG5cbnZhciBDaGFubmVsID0gcmVxdWlyZSgnLi4vX0NoYW5uZWxzL0NoYW5uZWwnKTtcblxudmFyIERlc2NyaXB0aXZlR3JvdXAgPSBfZGVjb3JhdGUobnVsbCwgZnVuY3Rpb24gKF9pbml0aWFsaXplLCBfTm9kZSkge1xuICB2YXIgRGVzY3JpcHRpdmVHcm91cCA9XG4gIC8qI19fUFVSRV9fKi9cbiAgZnVuY3Rpb24gKF9Ob2RlMikge1xuICAgIF9pbmhlcml0cyhEZXNjcmlwdGl2ZUdyb3VwLCBfTm9kZTIpO1xuXG4gICAgZnVuY3Rpb24gRGVzY3JpcHRpdmVHcm91cCgpIHtcbiAgICAgIHZhciBfdGhpcztcblxuICAgICAgdmFyIGF0dHJzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAgIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbnVsbDtcblxuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERlc2NyaXB0aXZlR3JvdXApO1xuXG4gICAgICBpZiAocHJvcHMgPT09IG51bGwpIHtcbiAgICAgICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoRGVzY3JpcHRpdmVHcm91cCkuY2FsbCh0aGlzLCBhdHRycykpO1xuXG4gICAgICAgIF9pbml0aWFsaXplKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgICAgICBfdGhpcy5hdHRycyA9IHt9O1xuICAgICAgICBfdGhpcy5wcm9wcyA9IGF0dHJzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoRGVzY3JpcHRpdmVHcm91cCkuY2FsbCh0aGlzLCBwcm9wcykpO1xuXG4gICAgICAgIF9pbml0aWFsaXplKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgICAgICBfdGhpcy5hdHRycyA9IGF0dHJzO1xuICAgICAgICBfdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5faW5oZXJpdGVkU2VsZWN0b3IgPSBudWxsOyAvLyBwYXNzaXZlQWRkaXRpb24gaXMgYSBmbGFnIHByb3BlcnR5IGluZGljYXRpbmcgdGhhdCBhbnkgSW5jaWRlbnQgdG8gYmVcbiAgICAgIC8vIGFkZGVkIHRvIHRoZSBDbGlwIHdpbGwgYmUgcGFzc2l2ZS4gSXQgaW5pdGlhbGlzZXMgd2l0aCB2YWx1ZSA9IGZhbHNlXG4gICAgICAvLyBvbiBEZXNjcmlwdGl2ZUdyb3VwIHdoZXJlIGl0J3Mgb3JpZ2luYWx5IGRlZmluZWQuXG4gICAgICAvLyBIZXJlIHdlIGNoYW5nZSBpdHMgdmFsdWUganVzdCBiZWZvcmUgdGhlIGJ1aWxkVHJlZSBtZXRob2QgZXhlY3V0aW9uXG4gICAgICAvLyBzbyBhbGwgSW5jaWRlbnRzIGFkZGVkIG9uIGl0IGdldCB0aGUgXCJwYXNzaXZlXCIgZmxhZyBhbmQgZG9uJ3QgZ2V0XG4gICAgICAvLyBleHBvcnRlZCBvbiB0aGUgZXhwb3J0RGVmaW5pdGlvbiBtZXRob2QuIE9uY2UgdGhlIGJ1aWxkVHJlZSBtZXRob2RcbiAgICAgIC8vIGZpbmlzaGVzIHdlIHNldCBpdCBiYWNrIHRvIGl0cyBvcmlnaW5hbCB2YWx1ZSAoZmFsc2UpXG5cbiAgICAgIF90aGlzLnBhc3NpdmVBZGRpdGlvbiA9IHRydWU7XG5cbiAgICAgIF90aGlzLl9idWlsZFRyZWUoKTtcblxuICAgICAgX3RoaXMucGFzc2l2ZUFkZGl0aW9uID0gZmFsc2U7XG4gICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMpO1xuICAgIH1cblxuICAgIHJldHVybiBEZXNjcmlwdGl2ZUdyb3VwO1xuICB9KF9Ob2RlKTtcblxuICByZXR1cm4ge1xuICAgIEY6IERlc2NyaXB0aXZlR3JvdXAsXG4gICAgZDogW3tcbiAgICAgIGtpbmQ6IFwiZmllbGRcIixcbiAgICAgIFwic3RhdGljXCI6IHRydWUsXG4gICAgICBrZXk6IFwiSW5jaWRlbnRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIEdyb3VwO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtpbmQ6IFwiZmllbGRcIixcbiAgICAgIFwic3RhdGljXCI6IHRydWUsXG4gICAgICBrZXk6IFwicGx1Z2luX25wbV9uYW1lXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XG4gICAgICAgIHJldHVybiBcIm1vdG9yLWNvcnRleC1qc1wiO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtpbmQ6IFwiZmllbGRcIixcbiAgICAgIFwic3RhdGljXCI6IHRydWUsXG4gICAgICBrZXk6IFwiQ2hhbm5lbFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xuICAgICAgICByZXR1cm4gQ2hhbm5lbDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBraW5kOiBcImZpZWxkXCIsXG4gICAgICBcInN0YXRpY1wiOiB0cnVlLFxuICAgICAga2V5OiBcIkNsYXNzTmFtZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xuICAgICAgICByZXR1cm4gXCJHcm91cFwiO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtpbmQ6IFwibWV0aG9kXCIsXG4gICAgICBkZWNvcmF0b3JzOiBbZWRpdEF0dHJpYnV0ZXNdLFxuICAgICAga2V5OiBcImVkaXRBdHRyaWJ1dGVzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZWRpdEF0dHJpYnV0ZXMoKSB7fVxuICAgIH0sIHtcbiAgICAgIGtpbmQ6IFwibWV0aG9kXCIsXG4gICAgICBkZWNvcmF0b3JzOiBbZWRpdFByb3BlcnRpZXNdLFxuICAgICAga2V5OiBcImVkaXRQcm9wZXJ0aWVzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZWRpdFByb3BlcnRpZXMoKSB7fVxuICAgIH0sIHtcbiAgICAgIGtpbmQ6IFwibWV0aG9kXCIsXG4gICAgICBkZWNvcmF0b3JzOiBbcmVzaXplXSxcbiAgICAgIGtleTogXCJyZXNpemVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZXNpemUoKSB7fVxuICAgIH0sIHtcbiAgICAgIGtpbmQ6IFwibWV0aG9kXCIsXG4gICAgICBkZWNvcmF0b3JzOiBbc2VsZWN0b3JHZXR0ZXJdLFxuICAgICAga2V5OiBcInNlbGVjdG9yXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2VsZWN0b3IoKSB7fVxuICAgIH0sIHtcbiAgICAgIGtpbmQ6IFwibWV0aG9kXCIsXG4gICAgICBrZXk6IFwiX2J1aWxkVHJlZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9idWlsZFRyZWUoKSB7XG4gICAgICAgIHRoaXMuYnVpbGRUcmVlKCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2luZDogXCJtZXRob2RcIixcbiAgICAgIGtleTogXCJfcmVidWlsZFRyZWVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVidWlsZFRyZWUoKSB7XG4gICAgICAgIC8vIHJlbW92ZSBhbGwgZGlyZWN0IHBhc3NpdmUgaW5jaWRlbnRzIGFzIHRoZXkgbWlnaHQgYmUgZGVwZW5kZW50IG9uIHRoZSBlZGl0ZWQgYXR0cnMvcHJvcHNcbiAgICAgICAgZm9yICh2YXIgaWQgaW4gdGhpcy5jaGlsZHJlbikge1xuICAgICAgICAgIHZhciB0aGVDaGlsZCA9IHRoaXMuY2hpbGRyZW5baWRdO1xuXG4gICAgICAgICAgaWYgKHRoZUNoaWxkLmxlYWYucGFzc2l2ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVJbmNpZGVudCh0aGVDaGlsZC5pZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIHJ1biBidWlsZFRyZWUgYWdhaW5cblxuXG4gICAgICAgIHRoaXMucGFzc2l2ZUFkZGl0aW9uID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5idWlsZFRyZWUoKTtcbiAgICAgICAgdGhpcy5wYXNzaXZlQWRkaXRpb24gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBraW5kOiBcIm1ldGhvZFwiLFxuICAgICAga2V5OiBcImJ1aWxkVHJlZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGJ1aWxkVHJlZSgpIHt9XG4gICAgfSwge1xuICAgICAga2luZDogXCJtZXRob2RcIixcbiAgICAgIGtleTogXCJtYW5hZ2VFZGl0QXR0clByb3BzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gbWFuYWdlRWRpdEF0dHJQcm9wcyhuZXdBdHRycywgdHlwZSkge1xuICAgICAgICAvLyBnZXQgYSBwZXJtYW5lbnQgcmVmZXJlbmNlIHRvIGl0cyBwYXJlbnQgbm9kZVxuICAgICAgICB2YXIgcGFyZW50Tm9kZSA9IHRoaXMucGFyZW50Tm9kZTsgLy8gZ2V0IHRoZSBwb3NpdGlvbiBvZiB0aGUgSW5jaWRlbnQgd2l0aGluIGl0cyBwYXJlbnRcblxuICAgICAgICB2YXIgcG9zaXRpb24gPSBwYXJlbnROb2RlLmdldExlYWZQb3NpdGlvbih0aGlzLmlkKTsgLy8ga2VlcCBhIGJhY2t1cCBvZiB0aGUgY3VycmVudCBhdHRycyAvIHByb3BzXG5cbiAgICAgICAgdmFyIG9sZEF0dHJzID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzW3R5cGVdKSk7XG4gICAgICAgIHRoaXNbdHlwZV0gPSBuZXdBdHRyczsgLy8gZmlyc3QgZGV0YWNoIHRoZSBJbmNpZGVudCBmcm9tIGl0cyBwYXJlbnRcblxuICAgICAgICBwYXJlbnROb2RlLnJlbW92ZUluY2lkZW50KHRoaXMuaWQpOyAvLyByZW1vdmUgYWxsIGRpcmVjdCBwYXNzaXZlIGluY2lkZW50cyBhcyB0aGV5IG1pZ2h0IGJlIGRlcGVuZGVudCBvbiB0aGUgZWRpdGVkIGF0dHJzL3Byb3BzXG5cbiAgICAgICAgdGhpcy5fcmVidWlsZFRyZWUoKTsgLy8gdHJ5IHRvIGFkZCB0aGUgYWx0ZXJlZCBHcm91cFxuXG5cbiAgICAgICAgdmFyIHJlcyA9IHBhcmVudE5vZGUuYWRkSW5jaWRlbnQodGhpcywgcG9zaXRpb24pO1xuXG4gICAgICAgIGlmIChyZXMucmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICAgIHRoaXNbdHlwZV0gPSBvbGRBdHRycztcblxuICAgICAgICAgIHRoaXMuX3JlYnVpbGRUcmVlKCk7XG5cbiAgICAgICAgICBwYXJlbnROb2RlLmFkZEluY2lkZW50KHRoaXMsIHBvc2l0aW9uKTtcbiAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBraW5kOiBcIm1ldGhvZFwiLFxuICAgICAga2V5OiBcImRldGFjaEZyb21QYXJlbnRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZXRhY2hGcm9tUGFyZW50KCkge1xuICAgICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihEZXNjcmlwdGl2ZUdyb3VwLnByb3RvdHlwZSksIFwiZGV0YWNoRnJvbVBhcmVudFwiLCB0aGlzKS5jYWxsKHRoaXMpO1xuXG4gICAgICAgIHRoaXMuaW5oZXJpdGVkU2VsZWN0b3IgPSBudWxsO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtpbmQ6IFwiZ2V0XCIsXG4gICAgICBrZXk6IFwiaW5oZXJpdGVkU2VsZWN0b3JcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBpbmhlcml0ZWRTZWxlY3RvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luaGVyaXRlZFNlbGVjdG9yO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtpbmQ6IFwic2V0XCIsXG4gICAgICBrZXk6IFwiaW5oZXJpdGVkU2VsZWN0b3JcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBpbmhlcml0ZWRTZWxlY3Rvcih2YWx1ZSkge1xuICAgICAgICB0aGlzLl9pbmhlcml0ZWRTZWxlY3RvciA9IHZhbHVlO1xuXG4gICAgICAgIGZvciAodmFyIGlkIGluIHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgICAgICB2YXIgdGhlQ2hpbGQgPSB0aGlzLmNoaWxkcmVuW2lkXS5sZWFmO1xuICAgICAgICAgIHRoZUNoaWxkLmluaGVyaXRlZFNlbGVjdG9yID0gdGhpcy5zZWxlY3RvcigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2luZDogXCJnZXRcIixcbiAgICAgIGtleTogXCJzZWxlY3RvclRvUGFzc1RvQ2hpbGRyZW5cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZWxlY3RvclRvUGFzc1RvQ2hpbGRyZW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdG9yKCk7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBwdXJwb3NlIG9mIHRoaXMgbWV0aG9kIGlzIHRvIGV4cG9ydCBhIHBvcnRhYmxlIGRlZmluaXRpb24gdGhhdCBjYW4gYmVcbiAgICAgICAqIGxhdGVyIHVzZWQgaW4gb3JkZXIgdG8gcmVidWlsZCB0aGUgSW5pY2RlbnQgYXQgYW55IHRpbWVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2luZDogXCJtZXRob2RcIixcbiAgICAgIGtleTogXCJleHBvcnREZWZpbml0aW9uXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZXhwb3J0RGVmaW5pdGlvbigpIHtcbiAgICAgICAgdmFyIHRvUmV0dXJuID0ge1xuICAgICAgICAgIENsYXNzTmFtZTogdGhpcy5jb25zdHJ1Y3Rvci5DbGFzc05hbWUsXG4gICAgICAgICAgcGx1Z2luX25wbV9uYW1lOiB0aGlzLmNvbnN0cnVjdG9yLnBsdWdpbl9ucG1fbmFtZSxcbiAgICAgICAgICBhdHRyczogdGhpcy5hdHRycyxcbiAgICAgICAgICBwcm9wczogdGhpcy5wcm9wcyxcbiAgICAgICAgICBpbmNpZGVudHM6IHt9XG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yICh2YXIgaWQgaW4gdGhpcy5jaGlsZHJlbikge1xuICAgICAgICAgIHZhciB0aGVDaGlsZCA9IHRoaXMuY2hpbGRyZW5baWRdO1xuXG4gICAgICAgICAgaWYgKHRoZUNoaWxkLmxlYWYucGFzc2l2ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdG9SZXR1cm4uaW5jaWRlbnRzW2lkXSA9IHtcbiAgICAgICAgICAgIGlkOiB0aGVDaGlsZC5pZCxcbiAgICAgICAgICAgIHBvc2l0aW9uOiB0aGVDaGlsZC5wb3NpdGlvbixcbiAgICAgICAgICAgIGxlYWY6IHRoZUNoaWxkLmxlYWYuZXhwb3J0RGVmaW5pdGlvbigpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0b1JldHVybjtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBraW5kOiBcIm1ldGhvZFwiLFxuICAgICAga2V5OiBcImFkZEluY2lkZW50XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkSW5jaWRlbnQoZGVzY3JpcHRpdmVJbmNpZGVudCwgcG9zaXRpb24pIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHtcbiAgICAgICAgICBjaGVjazogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICBkZXNjcmlwdGl2ZUluY2lkZW50LmluaGVyaXRlZFNlbGVjdG9yID0gdGhpcy5zZWxlY3RvclRvUGFzc1RvQ2hpbGRyZW47XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuY2hlY2sgPT09IHRydWUpIHtcbiAgICAgICAgICB2YXIgaW5pdGlhbENoZWNrID0gX2dldChfZ2V0UHJvdG90eXBlT2YoRGVzY3JpcHRpdmVHcm91cC5wcm90b3R5cGUpLCBcImNoZWNrQWRkaXRpb25cIiwgdGhpcykuY2FsbCh0aGlzLCBkZXNjcmlwdGl2ZUluY2lkZW50LCBwb3NpdGlvbik7XG5cbiAgICAgICAgICBpZiAoaW5pdGlhbENoZWNrLnJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGRlc2NyaXB0aXZlSW5jaWRlbnQuaW5oZXJpdGVkU2VsZWN0b3IgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIGluaXRpYWxDaGVjaztcbiAgICAgICAgICB9XG4gICAgICAgICAgLyogQ2hlY2sgZm9yIG51bGwgb3IgcmVsYXRpdmUgc2VsZWN0b3IgSW5jaWRlbnRzIHdpdGggbm8gaW5oZXJpdGVkIHNlbGVjdG9yICovXG5cblxuICAgICAgICAgIHZhciBjaGVja0lmQmVsb25nc1RvQ2xpcCA9IHRoaXMucHV0TWVzc2FnZU9uUGlwZSgnY2hlY2tGb3JDbGlwJywge30sIF9DT05TVC5fVEFSR0VUVFlQRVMuX0RFQ0lTSU9OQVVUSE9SSVRZLCB7XG4gICAgICAgICAgICBzZWxmRXhlY3V0ZTogdHJ1ZSxcbiAgICAgICAgICAgIGRpcmVjdGlvbjogX1RSRUVDT05TVC5fRElSRUNUSU9OUy5fVVBcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmIChjaGVja0lmQmVsb25nc1RvQ2xpcC5yZXNwb25zZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgLy8gaWYgdGhlIEdyb3VwIGJlbG9uZ3Mgb24gYSBDbGlwXG4gICAgICAgICAgICB2YXIgc2VsZWN0b3JzQ2hlY2sgPSBkZXNjcmlwdGl2ZUluY2lkZW50LnB1dE1lc3NhZ2VPblBpcGUoJ2NoZWNrRm9ySW52YWxpZFNlbGVjdG9ycycsIHt9LCBudWxsLCB7XG4gICAgICAgICAgICAgIHNlbGZFeGVjdXRlOiB0cnVlLFxuICAgICAgICAgICAgICBkaXJlY3Rpb246IF9UUkVFQ09OU1QuX0RJUkVDVElPTlMuX0RPV05cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoc2VsZWN0b3JzQ2hlY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICB2YXIgZXJyb3JzID0gW107XG5cbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxlY3RvcnNDaGVjay5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHNlbGVjdG9yc0NoZWNrW2ldLnJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcmVzdWx0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvcnM6IGVycm9yc1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gLy8gc2VuZHMgdGhlIGNoZWNrIHJlcXVlc3QgdG8gaXRzIHJvb3QsIGVpdGhlciBhIGhlYWRsZXNzIHJvb3Qgb3IgYSBEZXNjcmlwdGl2ZSBDbGlwXG5cblxuICAgICAgICAgIHZhciBtY0NoZWNrID0gdGhpcy5wdXRNZXNzYWdlT25QaXBlKCdjaGVja0FkZGl0aW9uJywge1xuICAgICAgICAgICAgaW5jaWRlbnQ6IGRlc2NyaXB0aXZlSW5jaWRlbnQsXG4gICAgICAgICAgICBtaWxsaXNlY29uZDogcG9zaXRpb24sXG4gICAgICAgICAgICBwYXJlbnRHcm91cElkOiB0aGlzLmlkXG4gICAgICAgICAgfSwgX0NPTlNULl9UQVJHRVRUWVBFUy5fREVDSVNJT05BVVRIT1JJVFksIHtcbiAgICAgICAgICAgIHNlbGZFeGVjdXRlOiB0cnVlLFxuICAgICAgICAgICAgZGlyZWN0aW9uOiBfVFJFRUNPTlNULl9ESVJFQ1RJT05TLl9VUFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKG1jQ2hlY2sucmVzcG9uc2UucmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgZGVzY3JpcHRpdmVJbmNpZGVudC5pbmhlcml0ZWRTZWxlY3RvciA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gbWNDaGVjay5yZXNwb25zZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gaWYgdGhlIHBhc3NpdmVBZGRpdGlvbiBmbGFnIGlzIHRydWUgd2Ugc2V0IHRoZSBwYXNzaXZlIGZsYWcgb2YgdGhlIEluY2lkZW50XG4gICAgICAgIC8vIHRvIHRydWUgYmVmb3JlIGFkZGluZyBpdCB0byBvdXIgR3JvdXBcblxuXG4gICAgICAgIGlmICh0aGlzLnBhc3NpdmVBZGRpdGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGRlc2NyaXB0aXZlSW5jaWRlbnQucGFzc2l2ZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzID0gdGhpcy5hZGRDaGlsZChkZXNjcmlwdGl2ZUluY2lkZW50LCBwb3NpdGlvbik7XG5cbiAgICAgICAgaWYgKHJlcy5yZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgZGVzY3JpcHRpdmVJbmNpZGVudC5pbmhlcml0ZWRTZWxlY3RvciA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0gaW5wdXQgLSBjYW4gZWl0aGVyIGJlIG9iamVjdCBvciBpZFxuICAgICAgICoqL1xuXG4gICAgfSwge1xuICAgICAga2luZDogXCJtZXRob2RcIixcbiAgICAgIGtleTogXCJtb3ZlSW5jaWRlbnRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBtb3ZlSW5jaWRlbnQoaW5wdXQsIHBvc2l0aW9uKSB7XG4gICAgICAgIHZhciBpZCA9IGlucHV0O1xuXG4gICAgICAgIGlmIChfdHlwZW9mKGlucHV0KSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIGlkID0gaW5wdXQuaWQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaW5pdGlhbENoZWNrID0gX2dldChfZ2V0UHJvdG90eXBlT2YoRGVzY3JpcHRpdmVHcm91cC5wcm90b3R5cGUpLCBcImNoZWNrRWRpdFBvc2l0aW9uXCIsIHRoaXMpLmNhbGwodGhpcywgaWQsIHBvc2l0aW9uKTtcblxuICAgICAgICBpZiAoaW5pdGlhbENoZWNrLnJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gaW5pdGlhbENoZWNrO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9yaWdpbmFsUG9zaXRpb24gPSB0aGlzLmdldExlYWZQb3NpdGlvbihpZCk7XG4gICAgICAgIHZhciBwb3NpdGlvbkRlbHRhID0gcG9zaXRpb24gLSBvcmlnaW5hbFBvc2l0aW9uO1xuXG4gICAgICAgIGlmIChwb3NpdGlvbkRlbHRhID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3VsdDogdHJ1ZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWNDaGVjayA9IHRoaXMucHV0TWVzc2FnZU9uUGlwZSgnY2hlY2tNb3ZlJywge1xuICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICBtaWxsaXNlY29uZDogcG9zaXRpb24sXG4gICAgICAgICAgcG9zaXRpb25EZWx0YTogcG9zaXRpb25EZWx0YSxcbiAgICAgICAgICBwYXJlbnRHcm91cElkOiB0aGlzLmlkXG4gICAgICAgIH0sIF9DT05TVC5fVEFSR0VUVFlQRVMuX0RFQ0lTSU9OQVVUSE9SSVRZLCB7XG4gICAgICAgICAgc2VsZkV4ZWN1dGU6IHRydWUsXG4gICAgICAgICAgZGlyZWN0aW9uOiBfVFJFRUNPTlNULl9ESVJFQ1RJT05TLl9VUFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAobWNDaGVjay5yZXNwb25zZS5yZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuIG1jQ2hlY2sucmVzcG9uc2U7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzID0gdGhpcy5lZGl0UG9zaXRpb24oaWQsIHBvc2l0aW9uKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBraW5kOiBcIm1ldGhvZFwiLFxuICAgICAga2V5OiBcInJlbW92ZUluY2lkZW50XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlSW5jaWRlbnQoaW5wdXQpIHtcbiAgICAgICAgdmFyIGlkID0gaW5wdXQ7XG5cbiAgICAgICAgaWYgKF90eXBlb2YoaW5wdXQpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgaWQgPSBpbnB1dC5pZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpbml0aWFsQ2hlY2sgPSBfZ2V0KF9nZXRQcm90b3R5cGVPZihEZXNjcmlwdGl2ZUdyb3VwLnByb3RvdHlwZSksIFwiY2hlY2tSZW1vdmVDaGlsZFwiLCB0aGlzKS5jYWxsKHRoaXMsIGlkKTtcblxuICAgICAgICBpZiAoaW5pdGlhbENoZWNrLnJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gaW5pdGlhbENoZWNrO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1jQ2hlY2sgPSB0aGlzLnB1dE1lc3NhZ2VPblBpcGUoJ2NoZWNrRGVsZXRpb24nLCB7XG4gICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgIHBhcmVudEdyb3VwSWQ6IHRoaXMuaWRcbiAgICAgICAgfSwgX0NPTlNULl9UQVJHRVRUWVBFUy5fREVDSVNJT05BVVRIT1JJVFksIHtcbiAgICAgICAgICBzZWxmRXhlY3V0ZTogdHJ1ZSxcbiAgICAgICAgICBkaXJlY3Rpb246IF9UUkVFQ09OU1QuX0RJUkVDVElPTlMuX1VQXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChtY0NoZWNrLnJlc3BvbnNlLnJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gbWNDaGVjay5yZXNwb25zZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXMgPSB0aGlzLnJlbW92ZUNoaWxkKGlkKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH1cbiAgICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKiogSEFORExJTkcgTUVUSE9EUyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgfSwge1xuICAgICAga2luZDogXCJtZXRob2RcIixcbiAgICAgIGtleTogXCJoYW5kbGVDaGVja0ZvckNsaXBcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVDaGVja0ZvckNsaXAodGFyZ2V0LCBwYXlsb2FkKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgICAgaWYgKHRoaXMuaGFzUGFyZW50KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYnlwYXNzKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2luZDogXCJtZXRob2RcIixcbiAgICAgIGtleTogXCJoYW5kbGVDaGVja0FkZGl0aW9uXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlQ2hlY2tBZGRpdGlvbih0YXJnZXQsIHBheWxvYWQpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG4gICAgICAgIC8qXG4gICAgICAgIFRoZSBEZXNjcmlwdGl2ZUdyb3VwIGhhbmRsZXMgdGhlIGNoZWNrQWRkaXRpb24gY29tbWFuZCB3aGljaCBoYXMgdGhlIFVQXG4gICAgICAgIGRpcmVjdGlvbi4gSWYgdGhlIERHIGhhcyBhIHBhcmVudCBpdCBmb3J3YXJkcyB0aGUgY29tbWFuZCB0byBpdC4gSWYgbm90XG4gICAgICAgIGl0IGp1c3QgcmV0dXJucyB0cnVlLCBhcyBpdCBpcyBhIGRlYWRsZXNzIHRyZWVcbiAgICAgICAgKi9cbiAgICAgICAgaWYgKHRoaXMuaGFzUGFyZW50KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYnlwYXNzKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlc3VsdDogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtpbmQ6IFwibWV0aG9kXCIsXG4gICAgICBrZXk6IFwiaGFuZGxlQ2hlY2tNb3ZlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlQ2hlY2tNb3ZlKHRhcmdldCwgcGF5bG9hZCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICAgIGlmICh0aGlzLmhhc1BhcmVudCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmJ5cGFzcygpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZXN1bHQ6IHRydWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBraW5kOiBcIm1ldGhvZFwiLFxuICAgICAga2V5OiBcImhhbmRsZUNoZWNrRGVsZXRpb25cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVDaGVja0RlbGV0aW9uKHRhcmdldCwgcGF5bG9hZCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICAgIGlmICh0aGlzLmhhc1BhcmVudCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmJ5cGFzcygpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZXN1bHQ6IHRydWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBraW5kOiBcIm1ldGhvZFwiLFxuICAgICAga2V5OiBcImhhbmRsZUNoZWNrUmVzaXplXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlQ2hlY2tSZXNpemUodGFyZ2V0LCBwYXlsb2FkKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgICAgaWYgKHRoaXMuaGFzUGFyZW50KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYnlwYXNzKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlc3VsdDogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1dXG4gIH07XG59LCBOb2RlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBEZXNjcmlwdGl2ZUdyb3VwOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/_DescriptiveIncidents/DescriptiveGroup.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/_DescriptiveIncidents/DescriptiveIncident.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/_DescriptiveIncidents/DescriptiveIncident.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _decorate(decorators, factory, superClass, mixins) { var api = _getDecoratorsApi(); if (mixins) { for (var i = 0; i < mixins.length; i++) { api = mixins[i](api); } } var r = factory(function initialize(O) { api.initializeInstanceElements(O, decorated.elements); }, superClass); var decorated = api.decorateClass(_coalesceClassElements(r.d.map(_createElementDescriptor)), decorators); api.initializeClassElements(r.F, decorated.elements); return api.runClassFinishers(r.F, decorated.finishers); }\n\nfunction _getDecoratorsApi() { _getDecoratorsApi = function _getDecoratorsApi() { return api; }; var api = { elementsDefinitionOrder: [[\"method\"], [\"field\"]], initializeInstanceElements: function initializeInstanceElements(O, elements) { [\"method\", \"field\"].forEach(function (kind) { elements.forEach(function (element) { if (element.kind === kind && element.placement === \"own\") { this.defineClassElement(O, element); } }, this); }, this); }, initializeClassElements: function initializeClassElements(F, elements) { var proto = F.prototype; [\"method\", \"field\"].forEach(function (kind) { elements.forEach(function (element) { var placement = element.placement; if (element.kind === kind && (placement === \"static\" || placement === \"prototype\")) { var receiver = placement === \"static\" ? F : proto; this.defineClassElement(receiver, element); } }, this); }, this); }, defineClassElement: function defineClassElement(receiver, element) { var descriptor = element.descriptor; if (element.kind === \"field\") { var initializer = element.initializer; descriptor = { enumerable: descriptor.enumerable, writable: descriptor.writable, configurable: descriptor.configurable, value: initializer === void 0 ? void 0 : initializer.call(receiver) }; } Object.defineProperty(receiver, element.key, descriptor); }, decorateClass: function decorateClass(elements, decorators) { var newElements = []; var finishers = []; var placements = { \"static\": [], prototype: [], own: [] }; elements.forEach(function (element) { this.addElementPlacement(element, placements); }, this); elements.forEach(function (element) { if (!_hasDecorators(element)) return newElements.push(element); var elementFinishersExtras = this.decorateElement(element, placements); newElements.push(elementFinishersExtras.element); newElements.push.apply(newElements, elementFinishersExtras.extras); finishers.push.apply(finishers, elementFinishersExtras.finishers); }, this); if (!decorators) { return { elements: newElements, finishers: finishers }; } var result = this.decorateConstructor(newElements, decorators); finishers.push.apply(finishers, result.finishers); result.finishers = finishers; return result; }, addElementPlacement: function addElementPlacement(element, placements, silent) { var keys = placements[element.placement]; if (!silent && keys.indexOf(element.key) !== -1) { throw new TypeError(\"Duplicated element (\" + element.key + \")\"); } keys.push(element.key); }, decorateElement: function decorateElement(element, placements) { var extras = []; var finishers = []; for (var decorators = element.decorators, i = decorators.length - 1; i >= 0; i--) { var keys = placements[element.placement]; keys.splice(keys.indexOf(element.key), 1); var elementObject = this.fromElementDescriptor(element); var elementFinisherExtras = this.toElementFinisherExtras((0, decorators[i])(elementObject) || elementObject); element = elementFinisherExtras.element; this.addElementPlacement(element, placements); if (elementFinisherExtras.finisher) { finishers.push(elementFinisherExtras.finisher); } var newExtras = elementFinisherExtras.extras; if (newExtras) { for (var j = 0; j < newExtras.length; j++) { this.addElementPlacement(newExtras[j], placements); } extras.push.apply(extras, newExtras); } } return { element: element, finishers: finishers, extras: extras }; }, decorateConstructor: function decorateConstructor(elements, decorators) { var finishers = []; for (var i = decorators.length - 1; i >= 0; i--) { var obj = this.fromClassDescriptor(elements); var elementsAndFinisher = this.toClassDescriptor((0, decorators[i])(obj) || obj); if (elementsAndFinisher.finisher !== undefined) { finishers.push(elementsAndFinisher.finisher); } if (elementsAndFinisher.elements !== undefined) { elements = elementsAndFinisher.elements; for (var j = 0; j < elements.length - 1; j++) { for (var k = j + 1; k < elements.length; k++) { if (elements[j].key === elements[k].key && elements[j].placement === elements[k].placement) { throw new TypeError(\"Duplicated element (\" + elements[j].key + \")\"); } } } } } return { elements: elements, finishers: finishers }; }, fromElementDescriptor: function fromElementDescriptor(element) { var obj = { kind: element.kind, key: element.key, placement: element.placement, descriptor: element.descriptor }; var desc = { value: \"Descriptor\", configurable: true }; Object.defineProperty(obj, Symbol.toStringTag, desc); if (element.kind === \"field\") obj.initializer = element.initializer; return obj; }, toElementDescriptors: function toElementDescriptors(elementObjects) { if (elementObjects === undefined) return; return _toArray(elementObjects).map(function (elementObject) { var element = this.toElementDescriptor(elementObject); this.disallowProperty(elementObject, \"finisher\", \"An element descriptor\"); this.disallowProperty(elementObject, \"extras\", \"An element descriptor\"); return element; }, this); }, toElementDescriptor: function toElementDescriptor(elementObject) { var kind = String(elementObject.kind); if (kind !== \"method\" && kind !== \"field\") { throw new TypeError('An element descriptor\\'s .kind property must be either \"method\" or' + ' \"field\", but a decorator created an element descriptor with' + ' .kind \"' + kind + '\"'); } var key = _toPropertyKey(elementObject.key); var placement = String(elementObject.placement); if (placement !== \"static\" && placement !== \"prototype\" && placement !== \"own\") { throw new TypeError('An element descriptor\\'s .placement property must be one of \"static\",' + ' \"prototype\" or \"own\", but a decorator created an element descriptor' + ' with .placement \"' + placement + '\"'); } var descriptor = elementObject.descriptor; this.disallowProperty(elementObject, \"elements\", \"An element descriptor\"); var element = { kind: kind, key: key, placement: placement, descriptor: Object.assign({}, descriptor) }; if (kind !== \"field\") { this.disallowProperty(elementObject, \"initializer\", \"A method descriptor\"); } else { this.disallowProperty(descriptor, \"get\", \"The property descriptor of a field descriptor\"); this.disallowProperty(descriptor, \"set\", \"The property descriptor of a field descriptor\"); this.disallowProperty(descriptor, \"value\", \"The property descriptor of a field descriptor\"); element.initializer = elementObject.initializer; } return element; }, toElementFinisherExtras: function toElementFinisherExtras(elementObject) { var element = this.toElementDescriptor(elementObject); var finisher = _optionalCallableProperty(elementObject, \"finisher\"); var extras = this.toElementDescriptors(elementObject.extras); return { element: element, finisher: finisher, extras: extras }; }, fromClassDescriptor: function fromClassDescriptor(elements) { var obj = { kind: \"class\", elements: elements.map(this.fromElementDescriptor, this) }; var desc = { value: \"Descriptor\", configurable: true }; Object.defineProperty(obj, Symbol.toStringTag, desc); return obj; }, toClassDescriptor: function toClassDescriptor(obj) { var kind = String(obj.kind); if (kind !== \"class\") { throw new TypeError('A class descriptor\\'s .kind property must be \"class\", but a decorator' + ' created a class descriptor with .kind \"' + kind + '\"'); } this.disallowProperty(obj, \"key\", \"A class descriptor\"); this.disallowProperty(obj, \"placement\", \"A class descriptor\"); this.disallowProperty(obj, \"descriptor\", \"A class descriptor\"); this.disallowProperty(obj, \"initializer\", \"A class descriptor\"); this.disallowProperty(obj, \"extras\", \"A class descriptor\"); var finisher = _optionalCallableProperty(obj, \"finisher\"); var elements = this.toElementDescriptors(obj.elements); return { elements: elements, finisher: finisher }; }, runClassFinishers: function runClassFinishers(constructor, finishers) { for (var i = 0; i < finishers.length; i++) { var newConstructor = (0, finishers[i])(constructor); if (newConstructor !== undefined) { if (typeof newConstructor !== \"function\") { throw new TypeError(\"Finishers must return a constructor.\"); } constructor = newConstructor; } } return constructor; }, disallowProperty: function disallowProperty(obj, name, objectType) { if (obj[name] !== undefined) { throw new TypeError(objectType + \" can't have a .\" + name + \" property.\"); } } }; return api; }\n\nfunction _createElementDescriptor(def) { var key = _toPropertyKey(def.key); var descriptor; if (def.kind === \"method\") { descriptor = { value: def.value, writable: true, configurable: true, enumerable: false }; } else if (def.kind === \"get\") { descriptor = { get: def.value, configurable: true, enumerable: false }; } else if (def.kind === \"set\") { descriptor = { set: def.value, configurable: true, enumerable: false }; } else if (def.kind === \"field\") { descriptor = { configurable: true, writable: true, enumerable: true }; } var element = { kind: def.kind === \"field\" ? \"field\" : \"method\", key: key, placement: def[\"static\"] ? \"static\" : def.kind === \"field\" ? \"own\" : \"prototype\", descriptor: descriptor }; if (def.decorators) element.decorators = def.decorators; if (def.kind === \"field\") element.initializer = def.value; return element; }\n\nfunction _coalesceGetterSetter(element, other) { if (element.descriptor.get !== undefined) { other.descriptor.get = element.descriptor.get; } else { other.descriptor.set = element.descriptor.set; } }\n\nfunction _coalesceClassElements(elements) { var newElements = []; var isSameElement = function isSameElement(other) { return other.kind === \"method\" && other.key === element.key && other.placement === element.placement; }; for (var i = 0; i < elements.length; i++) { var element = elements[i]; var other; if (element.kind === \"method\" && (other = newElements.find(isSameElement))) { if (_isDataDescriptor(element.descriptor) || _isDataDescriptor(other.descriptor)) { if (_hasDecorators(element) || _hasDecorators(other)) { throw new ReferenceError(\"Duplicated methods (\" + element.key + \") can't be decorated.\"); } other.descriptor = element.descriptor; } else { if (_hasDecorators(element)) { if (_hasDecorators(other)) { throw new ReferenceError(\"Decorators can't be placed on different accessors with for \" + \"the same property (\" + element.key + \").\"); } other.decorators = element.decorators; } _coalesceGetterSetter(element, other); } } else { newElements.push(element); } } return newElements; }\n\nfunction _hasDecorators(element) { return element.decorators && element.decorators.length; }\n\nfunction _isDataDescriptor(desc) { return desc !== undefined && !(desc.value === undefined && desc.writable === undefined); }\n\nfunction _optionalCallableProperty(obj, name) { var value = obj[name]; if (value !== undefined && typeof value !== \"function\") { throw new TypeError(\"Expected '\" + name + \"' to be a function\"); } return value; }\n\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\n\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\nfunction _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nvar Leaf = __webpack_require__(/*! ../_Tree/Leaf */ \"./node_modules/@kissmybutton/motorcortex/dist/_Tree/Leaf.js\");\n\nvar resize = __webpack_require__(/*! ./decorators/resize */ \"./node_modules/@kissmybutton/motorcortex/dist/_DescriptiveIncidents/decorators/resize.js\");\n\nvar editAttributes = __webpack_require__(/*! ./decorators/editAttributes */ \"./node_modules/@kissmybutton/motorcortex/dist/_DescriptiveIncidents/decorators/editAttributes.js\");\n\nvar editProperties = __webpack_require__(/*! ./decorators/editProperties */ \"./node_modules/@kissmybutton/motorcortex/dist/_DescriptiveIncidents/decorators/editProperties.js\");\n\nvar selectorGetter = __webpack_require__(/*! ./decorators/selector */ \"./node_modules/@kissmybutton/motorcortex/dist/_DescriptiveIncidents/decorators/selector.js\");\n\nvar TimedIncident = __webpack_require__(/*! ../_BaseClasses/Incident */ \"./node_modules/@kissmybutton/motorcortex/dist/_BaseClasses/Incident.js\");\n\nvar AttributeChannel = __webpack_require__(/*! ../_Channels/_Attribute/AttributeChannel */ \"./node_modules/@kissmybutton/motorcortex/dist/_Channels/_Attribute/AttributeChannel.js\");\n\nvar DescriptiveIncident = _decorate(null, function (_initialize, _Leaf) {\n  var DescriptiveIncident =\n  /*#__PURE__*/\n  function (_Leaf2) {\n    _inherits(DescriptiveIncident, _Leaf2);\n\n    function DescriptiveIncident(attrs, props) {\n      var _this;\n\n      _classCallCheck(this, DescriptiveIncident);\n\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(DescriptiveIncident).call(this, props));\n\n      _initialize(_assertThisInitialized(_this));\n\n      _this.inheritedSelector = null;\n      _this.attrs = attrs;\n\n      if (!Object.prototype.hasOwnProperty.call(props, \"duration\")) {\n        props.duration = 0;\n      }\n\n      _this.props = props; // the passive flag (when true) indicates that the Descriptive Group has been created\n      // and passively added to a Clip or a Combo via buildTree method.\n      // Defaults to false\n\n      _this.passive = false;\n      return _this;\n    }\n\n    return DescriptiveIncident;\n  }(_Leaf);\n\n  return {\n    F: DescriptiveIncident,\n    d: [{\n      kind: \"field\",\n      \"static\": true,\n      key: \"Incident\",\n      value: function value() {\n        return TimedIncident;\n      }\n    }, {\n      kind: \"field\",\n      \"static\": true,\n      key: \"plugin_npm_name\",\n      value: function value() {\n        return \"motor-cortex-js-attribute\";\n      }\n    }, {\n      kind: \"field\",\n      \"static\": true,\n      key: \"Channel\",\n      value: function value() {\n        return AttributeChannel;\n      }\n    }, {\n      kind: \"field\",\n      \"static\": true,\n      key: \"ClassName\",\n      value: function value() {\n        return \"Incident\";\n      }\n    }, {\n      kind: \"method\",\n      decorators: [editAttributes],\n      key: \"editAttributes\",\n      value: function editAttributes() {}\n    }, {\n      kind: \"method\",\n      decorators: [editProperties],\n      key: \"editProperties\",\n      value: function editProperties() {}\n    }, {\n      kind: \"method\",\n      decorators: [resize],\n      key: \"resize\",\n      value: function resize() {}\n    }, {\n      kind: \"method\",\n      decorators: [selectorGetter],\n      key: \"selector\",\n      value: function selector() {}\n    }, {\n      kind: \"method\",\n      key: \"manageEditAttrProps\",\n      value: function manageEditAttrProps(newAttrs, type) {\n        // get a permanent reference to its parent node\n        var parentNode = this.parentNode; // get the position of the Incident within its parent\n\n        var position = parentNode.getLeafPosition(this.id); // first detach the Incident from its parent\n\n        parentNode.removeIncident(this.id); // keep a backup of the current attrs/props\n\n        var oldAttrs = JSON.parse(JSON.stringify(this[type]));\n        this[type] = newAttrs;\n        var res = parentNode.addIncident(this, position);\n\n        if (res.result === false) {\n          parentNode.removeIncident(this.id);\n          this[type] = oldAttrs;\n          parentNode.addIncident(this, position);\n          return res;\n        }\n\n        return res;\n      }\n    }, {\n      kind: \"method\",\n      key: \"detachFromParent\",\n      value: function detachFromParent() {\n        _get(_getPrototypeOf(DescriptiveIncident.prototype), \"detachFromParent\", this).call(this);\n\n        this.inheritedSelector = null;\n      }\n    }, {\n      kind: \"method\",\n      key: \"handleCheckForInvalidSelectors\",\n      value: function handleCheckForInvalidSelectors() {\n        var selector = this.selector();\n\n        if (selector === null) {\n          return {\n            id: this.id,\n            ClassName: this.constructor.ClassName,\n            plugin_npm_name: this.constructor.plugin_npm_name,\n            error: 'null selector'\n          };\n        } else if (selector.charAt(0) === \"&\") {\n          return {\n            id: this.id,\n            ClassName: this.constructor.ClassName,\n            plugin_npm_name: this.constructor.plugin_npm_name,\n            error: 'relative selector with no inherited selector',\n            selector: selector\n          };\n        } else return this.bypass();\n      }\n      /**\n       * The purpose of this method is to export a portable definition that can be\n       * later used in order to rebuild the Inicdent at any time\n       */\n\n    }, {\n      kind: \"method\",\n      key: \"exportDefinition\",\n      value: function exportDefinition() {\n        return {\n          ClassName: this.constructor.ClassName,\n          plugin_npm_name: this.constructor.plugin_npm_name,\n          attrs: this.attrs,\n          props: this.props\n        };\n      }\n    }]\n  };\n}, Leaf);\n\nmodule.exports = DescriptiveIncident;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19EZXNjcmlwdGl2ZUluY2lkZW50cy9EZXNjcmlwdGl2ZUluY2lkZW50LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvZGlzdC9fRGVzY3JpcHRpdmVJbmNpZGVudHMvRGVzY3JpcHRpdmVJbmNpZGVudC5qcz9mMjBkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfZGVjb3JhdGUoZGVjb3JhdG9ycywgZmFjdG9yeSwgc3VwZXJDbGFzcywgbWl4aW5zKSB7IHZhciBhcGkgPSBfZ2V0RGVjb3JhdG9yc0FwaSgpOyBpZiAobWl4aW5zKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgbWl4aW5zLmxlbmd0aDsgaSsrKSB7IGFwaSA9IG1peGluc1tpXShhcGkpOyB9IH0gdmFyIHIgPSBmYWN0b3J5KGZ1bmN0aW9uIGluaXRpYWxpemUoTykgeyBhcGkuaW5pdGlhbGl6ZUluc3RhbmNlRWxlbWVudHMoTywgZGVjb3JhdGVkLmVsZW1lbnRzKTsgfSwgc3VwZXJDbGFzcyk7IHZhciBkZWNvcmF0ZWQgPSBhcGkuZGVjb3JhdGVDbGFzcyhfY29hbGVzY2VDbGFzc0VsZW1lbnRzKHIuZC5tYXAoX2NyZWF0ZUVsZW1lbnREZXNjcmlwdG9yKSksIGRlY29yYXRvcnMpOyBhcGkuaW5pdGlhbGl6ZUNsYXNzRWxlbWVudHMoci5GLCBkZWNvcmF0ZWQuZWxlbWVudHMpOyByZXR1cm4gYXBpLnJ1bkNsYXNzRmluaXNoZXJzKHIuRiwgZGVjb3JhdGVkLmZpbmlzaGVycyk7IH1cblxuZnVuY3Rpb24gX2dldERlY29yYXRvcnNBcGkoKSB7IF9nZXREZWNvcmF0b3JzQXBpID0gZnVuY3Rpb24gX2dldERlY29yYXRvcnNBcGkoKSB7IHJldHVybiBhcGk7IH07IHZhciBhcGkgPSB7IGVsZW1lbnRzRGVmaW5pdGlvbk9yZGVyOiBbW1wibWV0aG9kXCJdLCBbXCJmaWVsZFwiXV0sIGluaXRpYWxpemVJbnN0YW5jZUVsZW1lbnRzOiBmdW5jdGlvbiBpbml0aWFsaXplSW5zdGFuY2VFbGVtZW50cyhPLCBlbGVtZW50cykgeyBbXCJtZXRob2RcIiwgXCJmaWVsZFwiXS5mb3JFYWNoKGZ1bmN0aW9uIChraW5kKSB7IGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHsgaWYgKGVsZW1lbnQua2luZCA9PT0ga2luZCAmJiBlbGVtZW50LnBsYWNlbWVudCA9PT0gXCJvd25cIikgeyB0aGlzLmRlZmluZUNsYXNzRWxlbWVudChPLCBlbGVtZW50KTsgfSB9LCB0aGlzKTsgfSwgdGhpcyk7IH0sIGluaXRpYWxpemVDbGFzc0VsZW1lbnRzOiBmdW5jdGlvbiBpbml0aWFsaXplQ2xhc3NFbGVtZW50cyhGLCBlbGVtZW50cykgeyB2YXIgcHJvdG8gPSBGLnByb3RvdHlwZTsgW1wibWV0aG9kXCIsIFwiZmllbGRcIl0uZm9yRWFjaChmdW5jdGlvbiAoa2luZCkgeyBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7IHZhciBwbGFjZW1lbnQgPSBlbGVtZW50LnBsYWNlbWVudDsgaWYgKGVsZW1lbnQua2luZCA9PT0ga2luZCAmJiAocGxhY2VtZW50ID09PSBcInN0YXRpY1wiIHx8IHBsYWNlbWVudCA9PT0gXCJwcm90b3R5cGVcIikpIHsgdmFyIHJlY2VpdmVyID0gcGxhY2VtZW50ID09PSBcInN0YXRpY1wiID8gRiA6IHByb3RvOyB0aGlzLmRlZmluZUNsYXNzRWxlbWVudChyZWNlaXZlciwgZWxlbWVudCk7IH0gfSwgdGhpcyk7IH0sIHRoaXMpOyB9LCBkZWZpbmVDbGFzc0VsZW1lbnQ6IGZ1bmN0aW9uIGRlZmluZUNsYXNzRWxlbWVudChyZWNlaXZlciwgZWxlbWVudCkgeyB2YXIgZGVzY3JpcHRvciA9IGVsZW1lbnQuZGVzY3JpcHRvcjsgaWYgKGVsZW1lbnQua2luZCA9PT0gXCJmaWVsZFwiKSB7IHZhciBpbml0aWFsaXplciA9IGVsZW1lbnQuaW5pdGlhbGl6ZXI7IGRlc2NyaXB0b3IgPSB7IGVudW1lcmFibGU6IGRlc2NyaXB0b3IuZW51bWVyYWJsZSwgd3JpdGFibGU6IGRlc2NyaXB0b3Iud3JpdGFibGUsIGNvbmZpZ3VyYWJsZTogZGVzY3JpcHRvci5jb25maWd1cmFibGUsIHZhbHVlOiBpbml0aWFsaXplciA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5pdGlhbGl6ZXIuY2FsbChyZWNlaXZlcikgfTsgfSBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVjZWl2ZXIsIGVsZW1lbnQua2V5LCBkZXNjcmlwdG9yKTsgfSwgZGVjb3JhdGVDbGFzczogZnVuY3Rpb24gZGVjb3JhdGVDbGFzcyhlbGVtZW50cywgZGVjb3JhdG9ycykgeyB2YXIgbmV3RWxlbWVudHMgPSBbXTsgdmFyIGZpbmlzaGVycyA9IFtdOyB2YXIgcGxhY2VtZW50cyA9IHsgXCJzdGF0aWNcIjogW10sIHByb3RvdHlwZTogW10sIG93bjogW10gfTsgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkgeyB0aGlzLmFkZEVsZW1lbnRQbGFjZW1lbnQoZWxlbWVudCwgcGxhY2VtZW50cyk7IH0sIHRoaXMpOyBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7IGlmICghX2hhc0RlY29yYXRvcnMoZWxlbWVudCkpIHJldHVybiBuZXdFbGVtZW50cy5wdXNoKGVsZW1lbnQpOyB2YXIgZWxlbWVudEZpbmlzaGVyc0V4dHJhcyA9IHRoaXMuZGVjb3JhdGVFbGVtZW50KGVsZW1lbnQsIHBsYWNlbWVudHMpOyBuZXdFbGVtZW50cy5wdXNoKGVsZW1lbnRGaW5pc2hlcnNFeHRyYXMuZWxlbWVudCk7IG5ld0VsZW1lbnRzLnB1c2guYXBwbHkobmV3RWxlbWVudHMsIGVsZW1lbnRGaW5pc2hlcnNFeHRyYXMuZXh0cmFzKTsgZmluaXNoZXJzLnB1c2guYXBwbHkoZmluaXNoZXJzLCBlbGVtZW50RmluaXNoZXJzRXh0cmFzLmZpbmlzaGVycyk7IH0sIHRoaXMpOyBpZiAoIWRlY29yYXRvcnMpIHsgcmV0dXJuIHsgZWxlbWVudHM6IG5ld0VsZW1lbnRzLCBmaW5pc2hlcnM6IGZpbmlzaGVycyB9OyB9IHZhciByZXN1bHQgPSB0aGlzLmRlY29yYXRlQ29uc3RydWN0b3IobmV3RWxlbWVudHMsIGRlY29yYXRvcnMpOyBmaW5pc2hlcnMucHVzaC5hcHBseShmaW5pc2hlcnMsIHJlc3VsdC5maW5pc2hlcnMpOyByZXN1bHQuZmluaXNoZXJzID0gZmluaXNoZXJzOyByZXR1cm4gcmVzdWx0OyB9LCBhZGRFbGVtZW50UGxhY2VtZW50OiBmdW5jdGlvbiBhZGRFbGVtZW50UGxhY2VtZW50KGVsZW1lbnQsIHBsYWNlbWVudHMsIHNpbGVudCkgeyB2YXIga2V5cyA9IHBsYWNlbWVudHNbZWxlbWVudC5wbGFjZW1lbnRdOyBpZiAoIXNpbGVudCAmJiBrZXlzLmluZGV4T2YoZWxlbWVudC5rZXkpICE9PSAtMSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRHVwbGljYXRlZCBlbGVtZW50IChcIiArIGVsZW1lbnQua2V5ICsgXCIpXCIpOyB9IGtleXMucHVzaChlbGVtZW50LmtleSk7IH0sIGRlY29yYXRlRWxlbWVudDogZnVuY3Rpb24gZGVjb3JhdGVFbGVtZW50KGVsZW1lbnQsIHBsYWNlbWVudHMpIHsgdmFyIGV4dHJhcyA9IFtdOyB2YXIgZmluaXNoZXJzID0gW107IGZvciAodmFyIGRlY29yYXRvcnMgPSBlbGVtZW50LmRlY29yYXRvcnMsIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7IHZhciBrZXlzID0gcGxhY2VtZW50c1tlbGVtZW50LnBsYWNlbWVudF07IGtleXMuc3BsaWNlKGtleXMuaW5kZXhPZihlbGVtZW50LmtleSksIDEpOyB2YXIgZWxlbWVudE9iamVjdCA9IHRoaXMuZnJvbUVsZW1lbnREZXNjcmlwdG9yKGVsZW1lbnQpOyB2YXIgZWxlbWVudEZpbmlzaGVyRXh0cmFzID0gdGhpcy50b0VsZW1lbnRGaW5pc2hlckV4dHJhcygoMCwgZGVjb3JhdG9yc1tpXSkoZWxlbWVudE9iamVjdCkgfHwgZWxlbWVudE9iamVjdCk7IGVsZW1lbnQgPSBlbGVtZW50RmluaXNoZXJFeHRyYXMuZWxlbWVudDsgdGhpcy5hZGRFbGVtZW50UGxhY2VtZW50KGVsZW1lbnQsIHBsYWNlbWVudHMpOyBpZiAoZWxlbWVudEZpbmlzaGVyRXh0cmFzLmZpbmlzaGVyKSB7IGZpbmlzaGVycy5wdXNoKGVsZW1lbnRGaW5pc2hlckV4dHJhcy5maW5pc2hlcik7IH0gdmFyIG5ld0V4dHJhcyA9IGVsZW1lbnRGaW5pc2hlckV4dHJhcy5leHRyYXM7IGlmIChuZXdFeHRyYXMpIHsgZm9yICh2YXIgaiA9IDA7IGogPCBuZXdFeHRyYXMubGVuZ3RoOyBqKyspIHsgdGhpcy5hZGRFbGVtZW50UGxhY2VtZW50KG5ld0V4dHJhc1tqXSwgcGxhY2VtZW50cyk7IH0gZXh0cmFzLnB1c2guYXBwbHkoZXh0cmFzLCBuZXdFeHRyYXMpOyB9IH0gcmV0dXJuIHsgZWxlbWVudDogZWxlbWVudCwgZmluaXNoZXJzOiBmaW5pc2hlcnMsIGV4dHJhczogZXh0cmFzIH07IH0sIGRlY29yYXRlQ29uc3RydWN0b3I6IGZ1bmN0aW9uIGRlY29yYXRlQ29uc3RydWN0b3IoZWxlbWVudHMsIGRlY29yYXRvcnMpIHsgdmFyIGZpbmlzaGVycyA9IFtdOyBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgeyB2YXIgb2JqID0gdGhpcy5mcm9tQ2xhc3NEZXNjcmlwdG9yKGVsZW1lbnRzKTsgdmFyIGVsZW1lbnRzQW5kRmluaXNoZXIgPSB0aGlzLnRvQ2xhc3NEZXNjcmlwdG9yKCgwLCBkZWNvcmF0b3JzW2ldKShvYmopIHx8IG9iaik7IGlmIChlbGVtZW50c0FuZEZpbmlzaGVyLmZpbmlzaGVyICE9PSB1bmRlZmluZWQpIHsgZmluaXNoZXJzLnB1c2goZWxlbWVudHNBbmRGaW5pc2hlci5maW5pc2hlcik7IH0gaWYgKGVsZW1lbnRzQW5kRmluaXNoZXIuZWxlbWVudHMgIT09IHVuZGVmaW5lZCkgeyBlbGVtZW50cyA9IGVsZW1lbnRzQW5kRmluaXNoZXIuZWxlbWVudHM7IGZvciAodmFyIGogPSAwOyBqIDwgZWxlbWVudHMubGVuZ3RoIC0gMTsgaisrKSB7IGZvciAodmFyIGsgPSBqICsgMTsgayA8IGVsZW1lbnRzLmxlbmd0aDsgaysrKSB7IGlmIChlbGVtZW50c1tqXS5rZXkgPT09IGVsZW1lbnRzW2tdLmtleSAmJiBlbGVtZW50c1tqXS5wbGFjZW1lbnQgPT09IGVsZW1lbnRzW2tdLnBsYWNlbWVudCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRHVwbGljYXRlZCBlbGVtZW50IChcIiArIGVsZW1lbnRzW2pdLmtleSArIFwiKVwiKTsgfSB9IH0gfSB9IHJldHVybiB7IGVsZW1lbnRzOiBlbGVtZW50cywgZmluaXNoZXJzOiBmaW5pc2hlcnMgfTsgfSwgZnJvbUVsZW1lbnREZXNjcmlwdG9yOiBmdW5jdGlvbiBmcm9tRWxlbWVudERlc2NyaXB0b3IoZWxlbWVudCkgeyB2YXIgb2JqID0geyBraW5kOiBlbGVtZW50LmtpbmQsIGtleTogZWxlbWVudC5rZXksIHBsYWNlbWVudDogZWxlbWVudC5wbGFjZW1lbnQsIGRlc2NyaXB0b3I6IGVsZW1lbnQuZGVzY3JpcHRvciB9OyB2YXIgZGVzYyA9IHsgdmFsdWU6IFwiRGVzY3JpcHRvclwiLCBjb25maWd1cmFibGU6IHRydWUgfTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgU3ltYm9sLnRvU3RyaW5nVGFnLCBkZXNjKTsgaWYgKGVsZW1lbnQua2luZCA9PT0gXCJmaWVsZFwiKSBvYmouaW5pdGlhbGl6ZXIgPSBlbGVtZW50LmluaXRpYWxpemVyOyByZXR1cm4gb2JqOyB9LCB0b0VsZW1lbnREZXNjcmlwdG9yczogZnVuY3Rpb24gdG9FbGVtZW50RGVzY3JpcHRvcnMoZWxlbWVudE9iamVjdHMpIHsgaWYgKGVsZW1lbnRPYmplY3RzID09PSB1bmRlZmluZWQpIHJldHVybjsgcmV0dXJuIF90b0FycmF5KGVsZW1lbnRPYmplY3RzKS5tYXAoZnVuY3Rpb24gKGVsZW1lbnRPYmplY3QpIHsgdmFyIGVsZW1lbnQgPSB0aGlzLnRvRWxlbWVudERlc2NyaXB0b3IoZWxlbWVudE9iamVjdCk7IHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShlbGVtZW50T2JqZWN0LCBcImZpbmlzaGVyXCIsIFwiQW4gZWxlbWVudCBkZXNjcmlwdG9yXCIpOyB0aGlzLmRpc2FsbG93UHJvcGVydHkoZWxlbWVudE9iamVjdCwgXCJleHRyYXNcIiwgXCJBbiBlbGVtZW50IGRlc2NyaXB0b3JcIik7IHJldHVybiBlbGVtZW50OyB9LCB0aGlzKTsgfSwgdG9FbGVtZW50RGVzY3JpcHRvcjogZnVuY3Rpb24gdG9FbGVtZW50RGVzY3JpcHRvcihlbGVtZW50T2JqZWN0KSB7IHZhciBraW5kID0gU3RyaW5nKGVsZW1lbnRPYmplY3Qua2luZCk7IGlmIChraW5kICE9PSBcIm1ldGhvZFwiICYmIGtpbmQgIT09IFwiZmllbGRcIikgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdBbiBlbGVtZW50IGRlc2NyaXB0b3JcXCdzIC5raW5kIHByb3BlcnR5IG11c3QgYmUgZWl0aGVyIFwibWV0aG9kXCIgb3InICsgJyBcImZpZWxkXCIsIGJ1dCBhIGRlY29yYXRvciBjcmVhdGVkIGFuIGVsZW1lbnQgZGVzY3JpcHRvciB3aXRoJyArICcgLmtpbmQgXCInICsga2luZCArICdcIicpOyB9IHZhciBrZXkgPSBfdG9Qcm9wZXJ0eUtleShlbGVtZW50T2JqZWN0LmtleSk7IHZhciBwbGFjZW1lbnQgPSBTdHJpbmcoZWxlbWVudE9iamVjdC5wbGFjZW1lbnQpOyBpZiAocGxhY2VtZW50ICE9PSBcInN0YXRpY1wiICYmIHBsYWNlbWVudCAhPT0gXCJwcm90b3R5cGVcIiAmJiBwbGFjZW1lbnQgIT09IFwib3duXCIpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQW4gZWxlbWVudCBkZXNjcmlwdG9yXFwncyAucGxhY2VtZW50IHByb3BlcnR5IG11c3QgYmUgb25lIG9mIFwic3RhdGljXCIsJyArICcgXCJwcm90b3R5cGVcIiBvciBcIm93blwiLCBidXQgYSBkZWNvcmF0b3IgY3JlYXRlZCBhbiBlbGVtZW50IGRlc2NyaXB0b3InICsgJyB3aXRoIC5wbGFjZW1lbnQgXCInICsgcGxhY2VtZW50ICsgJ1wiJyk7IH0gdmFyIGRlc2NyaXB0b3IgPSBlbGVtZW50T2JqZWN0LmRlc2NyaXB0b3I7IHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShlbGVtZW50T2JqZWN0LCBcImVsZW1lbnRzXCIsIFwiQW4gZWxlbWVudCBkZXNjcmlwdG9yXCIpOyB2YXIgZWxlbWVudCA9IHsga2luZDoga2luZCwga2V5OiBrZXksIHBsYWNlbWVudDogcGxhY2VtZW50LCBkZXNjcmlwdG9yOiBPYmplY3QuYXNzaWduKHt9LCBkZXNjcmlwdG9yKSB9OyBpZiAoa2luZCAhPT0gXCJmaWVsZFwiKSB7IHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShlbGVtZW50T2JqZWN0LCBcImluaXRpYWxpemVyXCIsIFwiQSBtZXRob2QgZGVzY3JpcHRvclwiKTsgfSBlbHNlIHsgdGhpcy5kaXNhbGxvd1Byb3BlcnR5KGRlc2NyaXB0b3IsIFwiZ2V0XCIsIFwiVGhlIHByb3BlcnR5IGRlc2NyaXB0b3Igb2YgYSBmaWVsZCBkZXNjcmlwdG9yXCIpOyB0aGlzLmRpc2FsbG93UHJvcGVydHkoZGVzY3JpcHRvciwgXCJzZXRcIiwgXCJUaGUgcHJvcGVydHkgZGVzY3JpcHRvciBvZiBhIGZpZWxkIGRlc2NyaXB0b3JcIik7IHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShkZXNjcmlwdG9yLCBcInZhbHVlXCIsIFwiVGhlIHByb3BlcnR5IGRlc2NyaXB0b3Igb2YgYSBmaWVsZCBkZXNjcmlwdG9yXCIpOyBlbGVtZW50LmluaXRpYWxpemVyID0gZWxlbWVudE9iamVjdC5pbml0aWFsaXplcjsgfSByZXR1cm4gZWxlbWVudDsgfSwgdG9FbGVtZW50RmluaXNoZXJFeHRyYXM6IGZ1bmN0aW9uIHRvRWxlbWVudEZpbmlzaGVyRXh0cmFzKGVsZW1lbnRPYmplY3QpIHsgdmFyIGVsZW1lbnQgPSB0aGlzLnRvRWxlbWVudERlc2NyaXB0b3IoZWxlbWVudE9iamVjdCk7IHZhciBmaW5pc2hlciA9IF9vcHRpb25hbENhbGxhYmxlUHJvcGVydHkoZWxlbWVudE9iamVjdCwgXCJmaW5pc2hlclwiKTsgdmFyIGV4dHJhcyA9IHRoaXMudG9FbGVtZW50RGVzY3JpcHRvcnMoZWxlbWVudE9iamVjdC5leHRyYXMpOyByZXR1cm4geyBlbGVtZW50OiBlbGVtZW50LCBmaW5pc2hlcjogZmluaXNoZXIsIGV4dHJhczogZXh0cmFzIH07IH0sIGZyb21DbGFzc0Rlc2NyaXB0b3I6IGZ1bmN0aW9uIGZyb21DbGFzc0Rlc2NyaXB0b3IoZWxlbWVudHMpIHsgdmFyIG9iaiA9IHsga2luZDogXCJjbGFzc1wiLCBlbGVtZW50czogZWxlbWVudHMubWFwKHRoaXMuZnJvbUVsZW1lbnREZXNjcmlwdG9yLCB0aGlzKSB9OyB2YXIgZGVzYyA9IHsgdmFsdWU6IFwiRGVzY3JpcHRvclwiLCBjb25maWd1cmFibGU6IHRydWUgfTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgU3ltYm9sLnRvU3RyaW5nVGFnLCBkZXNjKTsgcmV0dXJuIG9iajsgfSwgdG9DbGFzc0Rlc2NyaXB0b3I6IGZ1bmN0aW9uIHRvQ2xhc3NEZXNjcmlwdG9yKG9iaikgeyB2YXIga2luZCA9IFN0cmluZyhvYmoua2luZCk7IGlmIChraW5kICE9PSBcImNsYXNzXCIpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQSBjbGFzcyBkZXNjcmlwdG9yXFwncyAua2luZCBwcm9wZXJ0eSBtdXN0IGJlIFwiY2xhc3NcIiwgYnV0IGEgZGVjb3JhdG9yJyArICcgY3JlYXRlZCBhIGNsYXNzIGRlc2NyaXB0b3Igd2l0aCAua2luZCBcIicgKyBraW5kICsgJ1wiJyk7IH0gdGhpcy5kaXNhbGxvd1Byb3BlcnR5KG9iaiwgXCJrZXlcIiwgXCJBIGNsYXNzIGRlc2NyaXB0b3JcIik7IHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShvYmosIFwicGxhY2VtZW50XCIsIFwiQSBjbGFzcyBkZXNjcmlwdG9yXCIpOyB0aGlzLmRpc2FsbG93UHJvcGVydHkob2JqLCBcImRlc2NyaXB0b3JcIiwgXCJBIGNsYXNzIGRlc2NyaXB0b3JcIik7IHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShvYmosIFwiaW5pdGlhbGl6ZXJcIiwgXCJBIGNsYXNzIGRlc2NyaXB0b3JcIik7IHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShvYmosIFwiZXh0cmFzXCIsIFwiQSBjbGFzcyBkZXNjcmlwdG9yXCIpOyB2YXIgZmluaXNoZXIgPSBfb3B0aW9uYWxDYWxsYWJsZVByb3BlcnR5KG9iaiwgXCJmaW5pc2hlclwiKTsgdmFyIGVsZW1lbnRzID0gdGhpcy50b0VsZW1lbnREZXNjcmlwdG9ycyhvYmouZWxlbWVudHMpOyByZXR1cm4geyBlbGVtZW50czogZWxlbWVudHMsIGZpbmlzaGVyOiBmaW5pc2hlciB9OyB9LCBydW5DbGFzc0ZpbmlzaGVyczogZnVuY3Rpb24gcnVuQ2xhc3NGaW5pc2hlcnMoY29uc3RydWN0b3IsIGZpbmlzaGVycykgeyBmb3IgKHZhciBpID0gMDsgaSA8IGZpbmlzaGVycy5sZW5ndGg7IGkrKykgeyB2YXIgbmV3Q29uc3RydWN0b3IgPSAoMCwgZmluaXNoZXJzW2ldKShjb25zdHJ1Y3Rvcik7IGlmIChuZXdDb25zdHJ1Y3RvciAhPT0gdW5kZWZpbmVkKSB7IGlmICh0eXBlb2YgbmV3Q29uc3RydWN0b3IgIT09IFwiZnVuY3Rpb25cIikgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmluaXNoZXJzIG11c3QgcmV0dXJuIGEgY29uc3RydWN0b3IuXCIpOyB9IGNvbnN0cnVjdG9yID0gbmV3Q29uc3RydWN0b3I7IH0gfSByZXR1cm4gY29uc3RydWN0b3I7IH0sIGRpc2FsbG93UHJvcGVydHk6IGZ1bmN0aW9uIGRpc2FsbG93UHJvcGVydHkob2JqLCBuYW1lLCBvYmplY3RUeXBlKSB7IGlmIChvYmpbbmFtZV0gIT09IHVuZGVmaW5lZCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKG9iamVjdFR5cGUgKyBcIiBjYW4ndCBoYXZlIGEgLlwiICsgbmFtZSArIFwiIHByb3BlcnR5LlwiKTsgfSB9IH07IHJldHVybiBhcGk7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUVsZW1lbnREZXNjcmlwdG9yKGRlZikgeyB2YXIga2V5ID0gX3RvUHJvcGVydHlLZXkoZGVmLmtleSk7IHZhciBkZXNjcmlwdG9yOyBpZiAoZGVmLmtpbmQgPT09IFwibWV0aG9kXCIpIHsgZGVzY3JpcHRvciA9IHsgdmFsdWU6IGRlZi52YWx1ZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZW51bWVyYWJsZTogZmFsc2UgfTsgfSBlbHNlIGlmIChkZWYua2luZCA9PT0gXCJnZXRcIikgeyBkZXNjcmlwdG9yID0geyBnZXQ6IGRlZi52YWx1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCBlbnVtZXJhYmxlOiBmYWxzZSB9OyB9IGVsc2UgaWYgKGRlZi5raW5kID09PSBcInNldFwiKSB7IGRlc2NyaXB0b3IgPSB7IHNldDogZGVmLnZhbHVlLCBjb25maWd1cmFibGU6IHRydWUsIGVudW1lcmFibGU6IGZhbHNlIH07IH0gZWxzZSBpZiAoZGVmLmtpbmQgPT09IFwiZmllbGRcIikgeyBkZXNjcmlwdG9yID0geyBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCBlbnVtZXJhYmxlOiB0cnVlIH07IH0gdmFyIGVsZW1lbnQgPSB7IGtpbmQ6IGRlZi5raW5kID09PSBcImZpZWxkXCIgPyBcImZpZWxkXCIgOiBcIm1ldGhvZFwiLCBrZXk6IGtleSwgcGxhY2VtZW50OiBkZWZbXCJzdGF0aWNcIl0gPyBcInN0YXRpY1wiIDogZGVmLmtpbmQgPT09IFwiZmllbGRcIiA/IFwib3duXCIgOiBcInByb3RvdHlwZVwiLCBkZXNjcmlwdG9yOiBkZXNjcmlwdG9yIH07IGlmIChkZWYuZGVjb3JhdG9ycykgZWxlbWVudC5kZWNvcmF0b3JzID0gZGVmLmRlY29yYXRvcnM7IGlmIChkZWYua2luZCA9PT0gXCJmaWVsZFwiKSBlbGVtZW50LmluaXRpYWxpemVyID0gZGVmLnZhbHVlOyByZXR1cm4gZWxlbWVudDsgfVxuXG5mdW5jdGlvbiBfY29hbGVzY2VHZXR0ZXJTZXR0ZXIoZWxlbWVudCwgb3RoZXIpIHsgaWYgKGVsZW1lbnQuZGVzY3JpcHRvci5nZXQgIT09IHVuZGVmaW5lZCkgeyBvdGhlci5kZXNjcmlwdG9yLmdldCA9IGVsZW1lbnQuZGVzY3JpcHRvci5nZXQ7IH0gZWxzZSB7IG90aGVyLmRlc2NyaXB0b3Iuc2V0ID0gZWxlbWVudC5kZXNjcmlwdG9yLnNldDsgfSB9XG5cbmZ1bmN0aW9uIF9jb2FsZXNjZUNsYXNzRWxlbWVudHMoZWxlbWVudHMpIHsgdmFyIG5ld0VsZW1lbnRzID0gW107IHZhciBpc1NhbWVFbGVtZW50ID0gZnVuY3Rpb24gaXNTYW1lRWxlbWVudChvdGhlcikgeyByZXR1cm4gb3RoZXIua2luZCA9PT0gXCJtZXRob2RcIiAmJiBvdGhlci5rZXkgPT09IGVsZW1lbnQua2V5ICYmIG90aGVyLnBsYWNlbWVudCA9PT0gZWxlbWVudC5wbGFjZW1lbnQ7IH07IGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIGVsZW1lbnQgPSBlbGVtZW50c1tpXTsgdmFyIG90aGVyOyBpZiAoZWxlbWVudC5raW5kID09PSBcIm1ldGhvZFwiICYmIChvdGhlciA9IG5ld0VsZW1lbnRzLmZpbmQoaXNTYW1lRWxlbWVudCkpKSB7IGlmIChfaXNEYXRhRGVzY3JpcHRvcihlbGVtZW50LmRlc2NyaXB0b3IpIHx8IF9pc0RhdGFEZXNjcmlwdG9yKG90aGVyLmRlc2NyaXB0b3IpKSB7IGlmIChfaGFzRGVjb3JhdG9ycyhlbGVtZW50KSB8fCBfaGFzRGVjb3JhdG9ycyhvdGhlcikpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwiRHVwbGljYXRlZCBtZXRob2RzIChcIiArIGVsZW1lbnQua2V5ICsgXCIpIGNhbid0IGJlIGRlY29yYXRlZC5cIik7IH0gb3RoZXIuZGVzY3JpcHRvciA9IGVsZW1lbnQuZGVzY3JpcHRvcjsgfSBlbHNlIHsgaWYgKF9oYXNEZWNvcmF0b3JzKGVsZW1lbnQpKSB7IGlmIChfaGFzRGVjb3JhdG9ycyhvdGhlcikpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwiRGVjb3JhdG9ycyBjYW4ndCBiZSBwbGFjZWQgb24gZGlmZmVyZW50IGFjY2Vzc29ycyB3aXRoIGZvciBcIiArIFwidGhlIHNhbWUgcHJvcGVydHkgKFwiICsgZWxlbWVudC5rZXkgKyBcIikuXCIpOyB9IG90aGVyLmRlY29yYXRvcnMgPSBlbGVtZW50LmRlY29yYXRvcnM7IH0gX2NvYWxlc2NlR2V0dGVyU2V0dGVyKGVsZW1lbnQsIG90aGVyKTsgfSB9IGVsc2UgeyBuZXdFbGVtZW50cy5wdXNoKGVsZW1lbnQpOyB9IH0gcmV0dXJuIG5ld0VsZW1lbnRzOyB9XG5cbmZ1bmN0aW9uIF9oYXNEZWNvcmF0b3JzKGVsZW1lbnQpIHsgcmV0dXJuIGVsZW1lbnQuZGVjb3JhdG9ycyAmJiBlbGVtZW50LmRlY29yYXRvcnMubGVuZ3RoOyB9XG5cbmZ1bmN0aW9uIF9pc0RhdGFEZXNjcmlwdG9yKGRlc2MpIHsgcmV0dXJuIGRlc2MgIT09IHVuZGVmaW5lZCAmJiAhKGRlc2MudmFsdWUgPT09IHVuZGVmaW5lZCAmJiBkZXNjLndyaXRhYmxlID09PSB1bmRlZmluZWQpOyB9XG5cbmZ1bmN0aW9uIF9vcHRpb25hbENhbGxhYmxlUHJvcGVydHkob2JqLCBuYW1lKSB7IHZhciB2YWx1ZSA9IG9ialtuYW1lXTsgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkICdcIiArIG5hbWUgKyBcIicgdG8gYmUgYSBmdW5jdGlvblwiKTsgfSByZXR1cm4gdmFsdWU7IH1cblxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkoYXJnKSB7IHZhciBrZXkgPSBfdG9QcmltaXRpdmUoYXJnLCBcInN0cmluZ1wiKTsgcmV0dXJuIF90eXBlb2Yoa2V5KSA9PT0gXCJzeW1ib2xcIiA/IGtleSA6IFN0cmluZyhrZXkpOyB9XG5cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZShpbnB1dCwgaGludCkgeyBpZiAoX3R5cGVvZihpbnB1dCkgIT09IFwib2JqZWN0XCIgfHwgaW5wdXQgPT09IG51bGwpIHJldHVybiBpbnB1dDsgdmFyIHByaW0gPSBpbnB1dFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAocHJpbSAhPT0gdW5kZWZpbmVkKSB7IHZhciByZXMgPSBwcmltLmNhbGwoaW5wdXQsIGhpbnQgfHwgXCJkZWZhdWx0XCIpOyBpZiAoX3R5cGVvZihyZXMpICE9PSBcIm9iamVjdFwiKSByZXR1cm4gcmVzOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChoaW50ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShpbnB1dCk7IH1cblxuZnVuY3Rpb24gX3RvQXJyYXkoYXJyKSB7IHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlUmVzdCgpOyB9XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpOyB9XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikgeyBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChpdGVyKSB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaXRlcikgPT09IFwiW29iamVjdCBBcmd1bWVudHNdXCIpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpOyB9XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjsgfVxuXG5mdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LmdldCkgeyBfZ2V0ID0gUmVmbGVjdC5nZXQ7IH0gZWxzZSB7IF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IHZhciBiYXNlID0gX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7IGlmICghYmFzZSkgcmV0dXJuOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpOyBpZiAoZGVzYy5nZXQpIHsgcmV0dXJuIGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpOyB9IHJldHVybiBkZXNjLnZhbHVlOyB9OyB9IHJldHVybiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyIHx8IHRhcmdldCk7IH1cblxuZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkgeyB3aGlsZSAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkgeyBvYmplY3QgPSBfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7IH0gcmV0dXJuIG9iamVjdDsgfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbnZhciBMZWFmID0gcmVxdWlyZSgnLi4vX1RyZWUvTGVhZicpO1xuXG52YXIgcmVzaXplID0gcmVxdWlyZSgnLi9kZWNvcmF0b3JzL3Jlc2l6ZScpO1xuXG52YXIgZWRpdEF0dHJpYnV0ZXMgPSByZXF1aXJlKCcuL2RlY29yYXRvcnMvZWRpdEF0dHJpYnV0ZXMnKTtcblxudmFyIGVkaXRQcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi9kZWNvcmF0b3JzL2VkaXRQcm9wZXJ0aWVzJyk7XG5cbnZhciBzZWxlY3RvckdldHRlciA9IHJlcXVpcmUoJy4vZGVjb3JhdG9ycy9zZWxlY3RvcicpO1xuXG52YXIgVGltZWRJbmNpZGVudCA9IHJlcXVpcmUoJy4uL19CYXNlQ2xhc3Nlcy9JbmNpZGVudCcpO1xuXG52YXIgQXR0cmlidXRlQ2hhbm5lbCA9IHJlcXVpcmUoJy4uL19DaGFubmVscy9fQXR0cmlidXRlL0F0dHJpYnV0ZUNoYW5uZWwnKTtcblxudmFyIERlc2NyaXB0aXZlSW5jaWRlbnQgPSBfZGVjb3JhdGUobnVsbCwgZnVuY3Rpb24gKF9pbml0aWFsaXplLCBfTGVhZikge1xuICB2YXIgRGVzY3JpcHRpdmVJbmNpZGVudCA9XG4gIC8qI19fUFVSRV9fKi9cbiAgZnVuY3Rpb24gKF9MZWFmMikge1xuICAgIF9pbmhlcml0cyhEZXNjcmlwdGl2ZUluY2lkZW50LCBfTGVhZjIpO1xuXG4gICAgZnVuY3Rpb24gRGVzY3JpcHRpdmVJbmNpZGVudChhdHRycywgcHJvcHMpIHtcbiAgICAgIHZhciBfdGhpcztcblxuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERlc2NyaXB0aXZlSW5jaWRlbnQpO1xuXG4gICAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihEZXNjcmlwdGl2ZUluY2lkZW50KS5jYWxsKHRoaXMsIHByb3BzKSk7XG5cbiAgICAgIF9pbml0aWFsaXplKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgICAgX3RoaXMuaW5oZXJpdGVkU2VsZWN0b3IgPSBudWxsO1xuICAgICAgX3RoaXMuYXR0cnMgPSBhdHRycztcblxuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIFwiZHVyYXRpb25cIikpIHtcbiAgICAgICAgcHJvcHMuZHVyYXRpb24gPSAwO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5wcm9wcyA9IHByb3BzOyAvLyB0aGUgcGFzc2l2ZSBmbGFnICh3aGVuIHRydWUpIGluZGljYXRlcyB0aGF0IHRoZSBEZXNjcmlwdGl2ZSBHcm91cCBoYXMgYmVlbiBjcmVhdGVkXG4gICAgICAvLyBhbmQgcGFzc2l2ZWx5IGFkZGVkIHRvIGEgQ2xpcCBvciBhIENvbWJvIHZpYSBidWlsZFRyZWUgbWV0aG9kLlxuICAgICAgLy8gRGVmYXVsdHMgdG8gZmFsc2VcblxuICAgICAgX3RoaXMucGFzc2l2ZSA9IGZhbHNlO1xuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIHJldHVybiBEZXNjcmlwdGl2ZUluY2lkZW50O1xuICB9KF9MZWFmKTtcblxuICByZXR1cm4ge1xuICAgIEY6IERlc2NyaXB0aXZlSW5jaWRlbnQsXG4gICAgZDogW3tcbiAgICAgIGtpbmQ6IFwiZmllbGRcIixcbiAgICAgIFwic3RhdGljXCI6IHRydWUsXG4gICAgICBrZXk6IFwiSW5jaWRlbnRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIFRpbWVkSW5jaWRlbnQ7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2luZDogXCJmaWVsZFwiLFxuICAgICAgXCJzdGF0aWNcIjogdHJ1ZSxcbiAgICAgIGtleTogXCJwbHVnaW5fbnBtX25hbWVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIFwibW90b3ItY29ydGV4LWpzLWF0dHJpYnV0ZVwiO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtpbmQ6IFwiZmllbGRcIixcbiAgICAgIFwic3RhdGljXCI6IHRydWUsXG4gICAgICBrZXk6IFwiQ2hhbm5lbFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xuICAgICAgICByZXR1cm4gQXR0cmlidXRlQ2hhbm5lbDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBraW5kOiBcImZpZWxkXCIsXG4gICAgICBcInN0YXRpY1wiOiB0cnVlLFxuICAgICAga2V5OiBcIkNsYXNzTmFtZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xuICAgICAgICByZXR1cm4gXCJJbmNpZGVudFwiO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtpbmQ6IFwibWV0aG9kXCIsXG4gICAgICBkZWNvcmF0b3JzOiBbZWRpdEF0dHJpYnV0ZXNdLFxuICAgICAga2V5OiBcImVkaXRBdHRyaWJ1dGVzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZWRpdEF0dHJpYnV0ZXMoKSB7fVxuICAgIH0sIHtcbiAgICAgIGtpbmQ6IFwibWV0aG9kXCIsXG4gICAgICBkZWNvcmF0b3JzOiBbZWRpdFByb3BlcnRpZXNdLFxuICAgICAga2V5OiBcImVkaXRQcm9wZXJ0aWVzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZWRpdFByb3BlcnRpZXMoKSB7fVxuICAgIH0sIHtcbiAgICAgIGtpbmQ6IFwibWV0aG9kXCIsXG4gICAgICBkZWNvcmF0b3JzOiBbcmVzaXplXSxcbiAgICAgIGtleTogXCJyZXNpemVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZXNpemUoKSB7fVxuICAgIH0sIHtcbiAgICAgIGtpbmQ6IFwibWV0aG9kXCIsXG4gICAgICBkZWNvcmF0b3JzOiBbc2VsZWN0b3JHZXR0ZXJdLFxuICAgICAga2V5OiBcInNlbGVjdG9yXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2VsZWN0b3IoKSB7fVxuICAgIH0sIHtcbiAgICAgIGtpbmQ6IFwibWV0aG9kXCIsXG4gICAgICBrZXk6IFwibWFuYWdlRWRpdEF0dHJQcm9wc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1hbmFnZUVkaXRBdHRyUHJvcHMobmV3QXR0cnMsIHR5cGUpIHtcbiAgICAgICAgLy8gZ2V0IGEgcGVybWFuZW50IHJlZmVyZW5jZSB0byBpdHMgcGFyZW50IG5vZGVcbiAgICAgICAgdmFyIHBhcmVudE5vZGUgPSB0aGlzLnBhcmVudE5vZGU7IC8vIGdldCB0aGUgcG9zaXRpb24gb2YgdGhlIEluY2lkZW50IHdpdGhpbiBpdHMgcGFyZW50XG5cbiAgICAgICAgdmFyIHBvc2l0aW9uID0gcGFyZW50Tm9kZS5nZXRMZWFmUG9zaXRpb24odGhpcy5pZCk7IC8vIGZpcnN0IGRldGFjaCB0aGUgSW5jaWRlbnQgZnJvbSBpdHMgcGFyZW50XG5cbiAgICAgICAgcGFyZW50Tm9kZS5yZW1vdmVJbmNpZGVudCh0aGlzLmlkKTsgLy8ga2VlcCBhIGJhY2t1cCBvZiB0aGUgY3VycmVudCBhdHRycy9wcm9wc1xuXG4gICAgICAgIHZhciBvbGRBdHRycyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpc1t0eXBlXSkpO1xuICAgICAgICB0aGlzW3R5cGVdID0gbmV3QXR0cnM7XG4gICAgICAgIHZhciByZXMgPSBwYXJlbnROb2RlLmFkZEluY2lkZW50KHRoaXMsIHBvc2l0aW9uKTtcblxuICAgICAgICBpZiAocmVzLnJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBwYXJlbnROb2RlLnJlbW92ZUluY2lkZW50KHRoaXMuaWQpO1xuICAgICAgICAgIHRoaXNbdHlwZV0gPSBvbGRBdHRycztcbiAgICAgICAgICBwYXJlbnROb2RlLmFkZEluY2lkZW50KHRoaXMsIHBvc2l0aW9uKTtcbiAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBraW5kOiBcIm1ldGhvZFwiLFxuICAgICAga2V5OiBcImRldGFjaEZyb21QYXJlbnRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZXRhY2hGcm9tUGFyZW50KCkge1xuICAgICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihEZXNjcmlwdGl2ZUluY2lkZW50LnByb3RvdHlwZSksIFwiZGV0YWNoRnJvbVBhcmVudFwiLCB0aGlzKS5jYWxsKHRoaXMpO1xuXG4gICAgICAgIHRoaXMuaW5oZXJpdGVkU2VsZWN0b3IgPSBudWxsO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtpbmQ6IFwibWV0aG9kXCIsXG4gICAgICBrZXk6IFwiaGFuZGxlQ2hlY2tGb3JJbnZhbGlkU2VsZWN0b3JzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlQ2hlY2tGb3JJbnZhbGlkU2VsZWN0b3JzKCkge1xuICAgICAgICB2YXIgc2VsZWN0b3IgPSB0aGlzLnNlbGVjdG9yKCk7XG5cbiAgICAgICAgaWYgKHNlbGVjdG9yID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgICAgICAgQ2xhc3NOYW1lOiB0aGlzLmNvbnN0cnVjdG9yLkNsYXNzTmFtZSxcbiAgICAgICAgICAgIHBsdWdpbl9ucG1fbmFtZTogdGhpcy5jb25zdHJ1Y3Rvci5wbHVnaW5fbnBtX25hbWUsXG4gICAgICAgICAgICBlcnJvcjogJ251bGwgc2VsZWN0b3InXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChzZWxlY3Rvci5jaGFyQXQoMCkgPT09IFwiJlwiKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgICAgICAgQ2xhc3NOYW1lOiB0aGlzLmNvbnN0cnVjdG9yLkNsYXNzTmFtZSxcbiAgICAgICAgICAgIHBsdWdpbl9ucG1fbmFtZTogdGhpcy5jb25zdHJ1Y3Rvci5wbHVnaW5fbnBtX25hbWUsXG4gICAgICAgICAgICBlcnJvcjogJ3JlbGF0aXZlIHNlbGVjdG9yIHdpdGggbm8gaW5oZXJpdGVkIHNlbGVjdG9yJyxcbiAgICAgICAgICAgIHNlbGVjdG9yOiBzZWxlY3RvclxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSByZXR1cm4gdGhpcy5ieXBhc3MoKTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogVGhlIHB1cnBvc2Ugb2YgdGhpcyBtZXRob2QgaXMgdG8gZXhwb3J0IGEgcG9ydGFibGUgZGVmaW5pdGlvbiB0aGF0IGNhbiBiZVxuICAgICAgICogbGF0ZXIgdXNlZCBpbiBvcmRlciB0byByZWJ1aWxkIHRoZSBJbmljZGVudCBhdCBhbnkgdGltZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBraW5kOiBcIm1ldGhvZFwiLFxuICAgICAga2V5OiBcImV4cG9ydERlZmluaXRpb25cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBleHBvcnREZWZpbml0aW9uKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIENsYXNzTmFtZTogdGhpcy5jb25zdHJ1Y3Rvci5DbGFzc05hbWUsXG4gICAgICAgICAgcGx1Z2luX25wbV9uYW1lOiB0aGlzLmNvbnN0cnVjdG9yLnBsdWdpbl9ucG1fbmFtZSxcbiAgICAgICAgICBhdHRyczogdGhpcy5hdHRycyxcbiAgICAgICAgICBwcm9wczogdGhpcy5wcm9wc1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1dXG4gIH07XG59LCBMZWFmKTtcblxubW9kdWxlLmV4cG9ydHMgPSBEZXNjcmlwdGl2ZUluY2lkZW50OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/_DescriptiveIncidents/DescriptiveIncident.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/_DescriptiveIncidents/_CONST.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/_DescriptiveIncidents/_CONST.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = {\n  _TARGETTYPES: {\n    _DECISIONAUTHORITY: \"mc.descriptive.decisionAuthority\"\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19EZXNjcmlwdGl2ZUluY2lkZW50cy9fQ09OU1QuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19EZXNjcmlwdGl2ZUluY2lkZW50cy9fQ09OU1QuanM/YWQ5ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIF9UQVJHRVRUWVBFUzoge1xuICAgIF9ERUNJU0lPTkFVVEhPUklUWTogXCJtYy5kZXNjcmlwdGl2ZS5kZWNpc2lvbkF1dGhvcml0eVwiXG4gIH1cbn07Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/_DescriptiveIncidents/_CONST.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/_DescriptiveIncidents/decorators/editAttributes.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/_DescriptiveIncidents/decorators/editAttributes.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _CONST = __webpack_require__(/*! ../_CONST */ \"./node_modules/@kissmybutton/motorcortex/dist/_DescriptiveIncidents/_CONST.js\");\n\nvar _TREECONST = __webpack_require__(/*! ../../_Tree/_CONST */ \"./node_modules/@kissmybutton/motorcortex/dist/_Tree/_CONST.js\");\n\nfunction editAttributes(payload) {\n  payload.descriptor.value = function (newAttrs) {\n    var checkIfBelongsToClip = this.putMessageOnPipe('checkForClip', {}, _CONST._TARGETTYPES._DECISIONAUTHORITY, {\n      selfExecute: true,\n      direction: _TREECONST._DIRECTIONS._UP\n    });\n\n    if (checkIfBelongsToClip.response === true) {\n      // if the Group belongs on a Clip\n      return this.manageEditAttrProps(newAttrs, 'attrs');\n    } else {\n      this.attrs = newAttrs;\n      return {\n        result: true\n      };\n    }\n  };\n}\n\nmodule.exports = editAttributes;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19EZXNjcmlwdGl2ZUluY2lkZW50cy9kZWNvcmF0b3JzL2VkaXRBdHRyaWJ1dGVzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvZGlzdC9fRGVzY3JpcHRpdmVJbmNpZGVudHMvZGVjb3JhdG9ycy9lZGl0QXR0cmlidXRlcy5qcz80ZjAwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX0NPTlNUID0gcmVxdWlyZSgnLi4vX0NPTlNUJyk7XG5cbnZhciBfVFJFRUNPTlNUID0gcmVxdWlyZSgnLi4vLi4vX1RyZWUvX0NPTlNUJyk7XG5cbmZ1bmN0aW9uIGVkaXRBdHRyaWJ1dGVzKHBheWxvYWQpIHtcbiAgcGF5bG9hZC5kZXNjcmlwdG9yLnZhbHVlID0gZnVuY3Rpb24gKG5ld0F0dHJzKSB7XG4gICAgdmFyIGNoZWNrSWZCZWxvbmdzVG9DbGlwID0gdGhpcy5wdXRNZXNzYWdlT25QaXBlKCdjaGVja0ZvckNsaXAnLCB7fSwgX0NPTlNULl9UQVJHRVRUWVBFUy5fREVDSVNJT05BVVRIT1JJVFksIHtcbiAgICAgIHNlbGZFeGVjdXRlOiB0cnVlLFxuICAgICAgZGlyZWN0aW9uOiBfVFJFRUNPTlNULl9ESVJFQ1RJT05TLl9VUFxuICAgIH0pO1xuXG4gICAgaWYgKGNoZWNrSWZCZWxvbmdzVG9DbGlwLnJlc3BvbnNlID09PSB0cnVlKSB7XG4gICAgICAvLyBpZiB0aGUgR3JvdXAgYmVsb25ncyBvbiBhIENsaXBcbiAgICAgIHJldHVybiB0aGlzLm1hbmFnZUVkaXRBdHRyUHJvcHMobmV3QXR0cnMsICdhdHRycycpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmF0dHJzID0gbmV3QXR0cnM7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZXN1bHQ6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVkaXRBdHRyaWJ1dGVzOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/_DescriptiveIncidents/decorators/editAttributes.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/_DescriptiveIncidents/decorators/editProperties.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/_DescriptiveIncidents/decorators/editProperties.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _CONST = __webpack_require__(/*! ../_CONST */ \"./node_modules/@kissmybutton/motorcortex/dist/_DescriptiveIncidents/_CONST.js\");\n\nvar _TREECONST = __webpack_require__(/*! ../../_Tree/_CONST */ \"./node_modules/@kissmybutton/motorcortex/dist/_Tree/_CONST.js\");\n\nfunction editProperties(payload) {\n  payload.descriptor.value = function (newProps) {\n    var checkIfBelongsToClip = this.putMessageOnPipe('checkForClip', {}, _CONST._TARGETTYPES._DECISIONAUTHORITY, {\n      selfExecute: true,\n      direction: _TREECONST._DIRECTIONS._UP\n    });\n\n    if (checkIfBelongsToClip.response === true) {\n      // if the Group belongs on a Clip\n      return this.manageEditAttrProps(newProps, 'props');\n    } else {\n      this.props = newProps;\n      return {\n        result: true\n      };\n    }\n  };\n}\n\nmodule.exports = editProperties;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19EZXNjcmlwdGl2ZUluY2lkZW50cy9kZWNvcmF0b3JzL2VkaXRQcm9wZXJ0aWVzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvZGlzdC9fRGVzY3JpcHRpdmVJbmNpZGVudHMvZGVjb3JhdG9ycy9lZGl0UHJvcGVydGllcy5qcz9lMWFmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX0NPTlNUID0gcmVxdWlyZSgnLi4vX0NPTlNUJyk7XG5cbnZhciBfVFJFRUNPTlNUID0gcmVxdWlyZSgnLi4vLi4vX1RyZWUvX0NPTlNUJyk7XG5cbmZ1bmN0aW9uIGVkaXRQcm9wZXJ0aWVzKHBheWxvYWQpIHtcbiAgcGF5bG9hZC5kZXNjcmlwdG9yLnZhbHVlID0gZnVuY3Rpb24gKG5ld1Byb3BzKSB7XG4gICAgdmFyIGNoZWNrSWZCZWxvbmdzVG9DbGlwID0gdGhpcy5wdXRNZXNzYWdlT25QaXBlKCdjaGVja0ZvckNsaXAnLCB7fSwgX0NPTlNULl9UQVJHRVRUWVBFUy5fREVDSVNJT05BVVRIT1JJVFksIHtcbiAgICAgIHNlbGZFeGVjdXRlOiB0cnVlLFxuICAgICAgZGlyZWN0aW9uOiBfVFJFRUNPTlNULl9ESVJFQ1RJT05TLl9VUFxuICAgIH0pO1xuXG4gICAgaWYgKGNoZWNrSWZCZWxvbmdzVG9DbGlwLnJlc3BvbnNlID09PSB0cnVlKSB7XG4gICAgICAvLyBpZiB0aGUgR3JvdXAgYmVsb25ncyBvbiBhIENsaXBcbiAgICAgIHJldHVybiB0aGlzLm1hbmFnZUVkaXRBdHRyUHJvcHMobmV3UHJvcHMsICdwcm9wcycpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnByb3BzID0gbmV3UHJvcHM7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZXN1bHQ6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVkaXRQcm9wZXJ0aWVzOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/_DescriptiveIncidents/decorators/editProperties.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/_DescriptiveIncidents/decorators/resize.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/_DescriptiveIncidents/decorators/resize.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _CONST = __webpack_require__(/*! ../_CONST */ \"./node_modules/@kissmybutton/motorcortex/dist/_DescriptiveIncidents/_CONST.js\");\n\nvar _TREECONST = __webpack_require__(/*! ../../_Tree/_CONST */ \"./node_modules/@kissmybutton/motorcortex/dist/_Tree/_CONST.js\");\n\nfunction resize(payload) {\n  payload.descriptor.value = function (newSize) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      check: true\n    };\n\n    if (newSize === this.duration) {\n      return {\n        result: true,\n        meta: {\n          unprocessed: true\n        }\n      };\n    }\n\n    if (newSize <= 0) {\n      return {\n        result: false,\n        reason: 'Size must always be > 0'\n      };\n    }\n\n    if (options.check === true && this.hasParent) {\n      var mcCheck = this.putMessageOnPipe('checkResize', {\n        id: this.id,\n        newSize: newSize,\n        fraction: newSize / this.duration\n      }, _CONST._TARGETTYPES._DECISIONAUTHORITY, {\n        selfExecute: false,\n        direction: _TREECONST._DIRECTIONS._UP\n      });\n\n      if (mcCheck.response.result === false) {\n        return mcCheck.response;\n      }\n    }\n\n    this.setNewDuration(newSize);\n    return {\n      result: true\n    };\n  };\n}\n\nmodule.exports = resize;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19EZXNjcmlwdGl2ZUluY2lkZW50cy9kZWNvcmF0b3JzL3Jlc2l6ZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Aa2lzc215YnV0dG9uL21vdG9yY29ydGV4L2Rpc3QvX0Rlc2NyaXB0aXZlSW5jaWRlbnRzL2RlY29yYXRvcnMvcmVzaXplLmpzP2RjM2MiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfQ09OU1QgPSByZXF1aXJlKCcuLi9fQ09OU1QnKTtcblxudmFyIF9UUkVFQ09OU1QgPSByZXF1aXJlKCcuLi8uLi9fVHJlZS9fQ09OU1QnKTtcblxuZnVuY3Rpb24gcmVzaXplKHBheWxvYWQpIHtcbiAgcGF5bG9hZC5kZXNjcmlwdG9yLnZhbHVlID0gZnVuY3Rpb24gKG5ld1NpemUpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge1xuICAgICAgY2hlY2s6IHRydWVcbiAgICB9O1xuXG4gICAgaWYgKG5ld1NpemUgPT09IHRoaXMuZHVyYXRpb24pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlc3VsdDogdHJ1ZSxcbiAgICAgICAgbWV0YToge1xuICAgICAgICAgIHVucHJvY2Vzc2VkOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKG5ld1NpemUgPD0gMCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVzdWx0OiBmYWxzZSxcbiAgICAgICAgcmVhc29uOiAnU2l6ZSBtdXN0IGFsd2F5cyBiZSA+IDAnXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmNoZWNrID09PSB0cnVlICYmIHRoaXMuaGFzUGFyZW50KSB7XG4gICAgICB2YXIgbWNDaGVjayA9IHRoaXMucHV0TWVzc2FnZU9uUGlwZSgnY2hlY2tSZXNpemUnLCB7XG4gICAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgICBuZXdTaXplOiBuZXdTaXplLFxuICAgICAgICBmcmFjdGlvbjogbmV3U2l6ZSAvIHRoaXMuZHVyYXRpb25cbiAgICAgIH0sIF9DT05TVC5fVEFSR0VUVFlQRVMuX0RFQ0lTSU9OQVVUSE9SSVRZLCB7XG4gICAgICAgIHNlbGZFeGVjdXRlOiBmYWxzZSxcbiAgICAgICAgZGlyZWN0aW9uOiBfVFJFRUNPTlNULl9ESVJFQ1RJT05TLl9VUFxuICAgICAgfSk7XG5cbiAgICAgIGlmIChtY0NoZWNrLnJlc3BvbnNlLnJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIG1jQ2hlY2sucmVzcG9uc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5zZXROZXdEdXJhdGlvbihuZXdTaXplKTtcbiAgICByZXR1cm4ge1xuICAgICAgcmVzdWx0OiB0cnVlXG4gICAgfTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZXNpemU7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/_DescriptiveIncidents/decorators/resize.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/_DescriptiveIncidents/decorators/selector.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/_DescriptiveIncidents/decorators/selector.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction selector(payload) {\n  payload.descriptor.value = function () {\n    if (this.inheritedSelector === null) {\n      // if the Incident has no parent selector inherited\n      if (!Object.prototype.hasOwnProperty.call(this.props, \"selector\")) {\n        // and does not have a selector neither\n        return null; // then its selector is null\n      } else {\n        return this.props.selector; // else, if it has a selector that's its final selector\n      }\n    } else {\n      // else if there is an inherited selector\n      if (!Object.prototype.hasOwnProperty.call(this.props, \"selector\")) {\n        // and does not have a selector of its own\n        return this.inheritedSelector; // then its selector is equal to the inherited selector\n      } else {\n        // else, if it both has an inherited and an own selector\n        if (this.props.selector.charAt(0) === \"&\") {\n          return this.inheritedSelector + this.props.selector.substring(1);\n        } else {\n          return this.inheritedSelector + ' ' + this.props.selector;\n        }\n      }\n    }\n  };\n}\n\nmodule.exports = selector;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19EZXNjcmlwdGl2ZUluY2lkZW50cy9kZWNvcmF0b3JzL3NlbGVjdG9yLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvZGlzdC9fRGVzY3JpcHRpdmVJbmNpZGVudHMvZGVjb3JhdG9ycy9zZWxlY3Rvci5qcz8wMjUxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBzZWxlY3RvcihwYXlsb2FkKSB7XG4gIHBheWxvYWQuZGVzY3JpcHRvci52YWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5pbmhlcml0ZWRTZWxlY3RvciA9PT0gbnVsbCkge1xuICAgICAgLy8gaWYgdGhlIEluY2lkZW50IGhhcyBubyBwYXJlbnQgc2VsZWN0b3IgaW5oZXJpdGVkXG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLnByb3BzLCBcInNlbGVjdG9yXCIpKSB7XG4gICAgICAgIC8vIGFuZCBkb2VzIG5vdCBoYXZlIGEgc2VsZWN0b3IgbmVpdGhlclxuICAgICAgICByZXR1cm4gbnVsbDsgLy8gdGhlbiBpdHMgc2VsZWN0b3IgaXMgbnVsbFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMuc2VsZWN0b3I7IC8vIGVsc2UsIGlmIGl0IGhhcyBhIHNlbGVjdG9yIHRoYXQncyBpdHMgZmluYWwgc2VsZWN0b3JcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZWxzZSBpZiB0aGVyZSBpcyBhbiBpbmhlcml0ZWQgc2VsZWN0b3JcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMucHJvcHMsIFwic2VsZWN0b3JcIikpIHtcbiAgICAgICAgLy8gYW5kIGRvZXMgbm90IGhhdmUgYSBzZWxlY3RvciBvZiBpdHMgb3duXG4gICAgICAgIHJldHVybiB0aGlzLmluaGVyaXRlZFNlbGVjdG9yOyAvLyB0aGVuIGl0cyBzZWxlY3RvciBpcyBlcXVhbCB0byB0aGUgaW5oZXJpdGVkIHNlbGVjdG9yXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBlbHNlLCBpZiBpdCBib3RoIGhhcyBhbiBpbmhlcml0ZWQgYW5kIGFuIG93biBzZWxlY3RvclxuICAgICAgICBpZiAodGhpcy5wcm9wcy5zZWxlY3Rvci5jaGFyQXQoMCkgPT09IFwiJlwiKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaW5oZXJpdGVkU2VsZWN0b3IgKyB0aGlzLnByb3BzLnNlbGVjdG9yLnN1YnN0cmluZygxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5pbmhlcml0ZWRTZWxlY3RvciArICcgJyArIHRoaXMucHJvcHMuc2VsZWN0b3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2VsZWN0b3I7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/_DescriptiveIncidents/decorators/selector.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/_Tree/Leaf.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/_Tree/Leaf.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _decorate(decorators, factory, superClass, mixins) { var api = _getDecoratorsApi(); if (mixins) { for (var i = 0; i < mixins.length; i++) { api = mixins[i](api); } } var r = factory(function initialize(O) { api.initializeInstanceElements(O, decorated.elements); }, superClass); var decorated = api.decorateClass(_coalesceClassElements(r.d.map(_createElementDescriptor)), decorators); api.initializeClassElements(r.F, decorated.elements); return api.runClassFinishers(r.F, decorated.finishers); }\n\nfunction _getDecoratorsApi() { _getDecoratorsApi = function _getDecoratorsApi() { return api; }; var api = { elementsDefinitionOrder: [[\"method\"], [\"field\"]], initializeInstanceElements: function initializeInstanceElements(O, elements) { [\"method\", \"field\"].forEach(function (kind) { elements.forEach(function (element) { if (element.kind === kind && element.placement === \"own\") { this.defineClassElement(O, element); } }, this); }, this); }, initializeClassElements: function initializeClassElements(F, elements) { var proto = F.prototype; [\"method\", \"field\"].forEach(function (kind) { elements.forEach(function (element) { var placement = element.placement; if (element.kind === kind && (placement === \"static\" || placement === \"prototype\")) { var receiver = placement === \"static\" ? F : proto; this.defineClassElement(receiver, element); } }, this); }, this); }, defineClassElement: function defineClassElement(receiver, element) { var descriptor = element.descriptor; if (element.kind === \"field\") { var initializer = element.initializer; descriptor = { enumerable: descriptor.enumerable, writable: descriptor.writable, configurable: descriptor.configurable, value: initializer === void 0 ? void 0 : initializer.call(receiver) }; } Object.defineProperty(receiver, element.key, descriptor); }, decorateClass: function decorateClass(elements, decorators) { var newElements = []; var finishers = []; var placements = { \"static\": [], prototype: [], own: [] }; elements.forEach(function (element) { this.addElementPlacement(element, placements); }, this); elements.forEach(function (element) { if (!_hasDecorators(element)) return newElements.push(element); var elementFinishersExtras = this.decorateElement(element, placements); newElements.push(elementFinishersExtras.element); newElements.push.apply(newElements, elementFinishersExtras.extras); finishers.push.apply(finishers, elementFinishersExtras.finishers); }, this); if (!decorators) { return { elements: newElements, finishers: finishers }; } var result = this.decorateConstructor(newElements, decorators); finishers.push.apply(finishers, result.finishers); result.finishers = finishers; return result; }, addElementPlacement: function addElementPlacement(element, placements, silent) { var keys = placements[element.placement]; if (!silent && keys.indexOf(element.key) !== -1) { throw new TypeError(\"Duplicated element (\" + element.key + \")\"); } keys.push(element.key); }, decorateElement: function decorateElement(element, placements) { var extras = []; var finishers = []; for (var decorators = element.decorators, i = decorators.length - 1; i >= 0; i--) { var keys = placements[element.placement]; keys.splice(keys.indexOf(element.key), 1); var elementObject = this.fromElementDescriptor(element); var elementFinisherExtras = this.toElementFinisherExtras((0, decorators[i])(elementObject) || elementObject); element = elementFinisherExtras.element; this.addElementPlacement(element, placements); if (elementFinisherExtras.finisher) { finishers.push(elementFinisherExtras.finisher); } var newExtras = elementFinisherExtras.extras; if (newExtras) { for (var j = 0; j < newExtras.length; j++) { this.addElementPlacement(newExtras[j], placements); } extras.push.apply(extras, newExtras); } } return { element: element, finishers: finishers, extras: extras }; }, decorateConstructor: function decorateConstructor(elements, decorators) { var finishers = []; for (var i = decorators.length - 1; i >= 0; i--) { var obj = this.fromClassDescriptor(elements); var elementsAndFinisher = this.toClassDescriptor((0, decorators[i])(obj) || obj); if (elementsAndFinisher.finisher !== undefined) { finishers.push(elementsAndFinisher.finisher); } if (elementsAndFinisher.elements !== undefined) { elements = elementsAndFinisher.elements; for (var j = 0; j < elements.length - 1; j++) { for (var k = j + 1; k < elements.length; k++) { if (elements[j].key === elements[k].key && elements[j].placement === elements[k].placement) { throw new TypeError(\"Duplicated element (\" + elements[j].key + \")\"); } } } } } return { elements: elements, finishers: finishers }; }, fromElementDescriptor: function fromElementDescriptor(element) { var obj = { kind: element.kind, key: element.key, placement: element.placement, descriptor: element.descriptor }; var desc = { value: \"Descriptor\", configurable: true }; Object.defineProperty(obj, Symbol.toStringTag, desc); if (element.kind === \"field\") obj.initializer = element.initializer; return obj; }, toElementDescriptors: function toElementDescriptors(elementObjects) { if (elementObjects === undefined) return; return _toArray(elementObjects).map(function (elementObject) { var element = this.toElementDescriptor(elementObject); this.disallowProperty(elementObject, \"finisher\", \"An element descriptor\"); this.disallowProperty(elementObject, \"extras\", \"An element descriptor\"); return element; }, this); }, toElementDescriptor: function toElementDescriptor(elementObject) { var kind = String(elementObject.kind); if (kind !== \"method\" && kind !== \"field\") { throw new TypeError('An element descriptor\\'s .kind property must be either \"method\" or' + ' \"field\", but a decorator created an element descriptor with' + ' .kind \"' + kind + '\"'); } var key = _toPropertyKey(elementObject.key); var placement = String(elementObject.placement); if (placement !== \"static\" && placement !== \"prototype\" && placement !== \"own\") { throw new TypeError('An element descriptor\\'s .placement property must be one of \"static\",' + ' \"prototype\" or \"own\", but a decorator created an element descriptor' + ' with .placement \"' + placement + '\"'); } var descriptor = elementObject.descriptor; this.disallowProperty(elementObject, \"elements\", \"An element descriptor\"); var element = { kind: kind, key: key, placement: placement, descriptor: Object.assign({}, descriptor) }; if (kind !== \"field\") { this.disallowProperty(elementObject, \"initializer\", \"A method descriptor\"); } else { this.disallowProperty(descriptor, \"get\", \"The property descriptor of a field descriptor\"); this.disallowProperty(descriptor, \"set\", \"The property descriptor of a field descriptor\"); this.disallowProperty(descriptor, \"value\", \"The property descriptor of a field descriptor\"); element.initializer = elementObject.initializer; } return element; }, toElementFinisherExtras: function toElementFinisherExtras(elementObject) { var element = this.toElementDescriptor(elementObject); var finisher = _optionalCallableProperty(elementObject, \"finisher\"); var extras = this.toElementDescriptors(elementObject.extras); return { element: element, finisher: finisher, extras: extras }; }, fromClassDescriptor: function fromClassDescriptor(elements) { var obj = { kind: \"class\", elements: elements.map(this.fromElementDescriptor, this) }; var desc = { value: \"Descriptor\", configurable: true }; Object.defineProperty(obj, Symbol.toStringTag, desc); return obj; }, toClassDescriptor: function toClassDescriptor(obj) { var kind = String(obj.kind); if (kind !== \"class\") { throw new TypeError('A class descriptor\\'s .kind property must be \"class\", but a decorator' + ' created a class descriptor with .kind \"' + kind + '\"'); } this.disallowProperty(obj, \"key\", \"A class descriptor\"); this.disallowProperty(obj, \"placement\", \"A class descriptor\"); this.disallowProperty(obj, \"descriptor\", \"A class descriptor\"); this.disallowProperty(obj, \"initializer\", \"A class descriptor\"); this.disallowProperty(obj, \"extras\", \"A class descriptor\"); var finisher = _optionalCallableProperty(obj, \"finisher\"); var elements = this.toElementDescriptors(obj.elements); return { elements: elements, finisher: finisher }; }, runClassFinishers: function runClassFinishers(constructor, finishers) { for (var i = 0; i < finishers.length; i++) { var newConstructor = (0, finishers[i])(constructor); if (newConstructor !== undefined) { if (typeof newConstructor !== \"function\") { throw new TypeError(\"Finishers must return a constructor.\"); } constructor = newConstructor; } } return constructor; }, disallowProperty: function disallowProperty(obj, name, objectType) { if (obj[name] !== undefined) { throw new TypeError(objectType + \" can't have a .\" + name + \" property.\"); } } }; return api; }\n\nfunction _createElementDescriptor(def) { var key = _toPropertyKey(def.key); var descriptor; if (def.kind === \"method\") { descriptor = { value: def.value, writable: true, configurable: true, enumerable: false }; } else if (def.kind === \"get\") { descriptor = { get: def.value, configurable: true, enumerable: false }; } else if (def.kind === \"set\") { descriptor = { set: def.value, configurable: true, enumerable: false }; } else if (def.kind === \"field\") { descriptor = { configurable: true, writable: true, enumerable: true }; } var element = { kind: def.kind === \"field\" ? \"field\" : \"method\", key: key, placement: def[\"static\"] ? \"static\" : def.kind === \"field\" ? \"own\" : \"prototype\", descriptor: descriptor }; if (def.decorators) element.decorators = def.decorators; if (def.kind === \"field\") element.initializer = def.value; return element; }\n\nfunction _coalesceGetterSetter(element, other) { if (element.descriptor.get !== undefined) { other.descriptor.get = element.descriptor.get; } else { other.descriptor.set = element.descriptor.set; } }\n\nfunction _coalesceClassElements(elements) { var newElements = []; var isSameElement = function isSameElement(other) { return other.kind === \"method\" && other.key === element.key && other.placement === element.placement; }; for (var i = 0; i < elements.length; i++) { var element = elements[i]; var other; if (element.kind === \"method\" && (other = newElements.find(isSameElement))) { if (_isDataDescriptor(element.descriptor) || _isDataDescriptor(other.descriptor)) { if (_hasDecorators(element) || _hasDecorators(other)) { throw new ReferenceError(\"Duplicated methods (\" + element.key + \") can't be decorated.\"); } other.descriptor = element.descriptor; } else { if (_hasDecorators(element)) { if (_hasDecorators(other)) { throw new ReferenceError(\"Decorators can't be placed on different accessors with for \" + \"the same property (\" + element.key + \").\"); } other.decorators = element.decorators; } _coalesceGetterSetter(element, other); } } else { newElements.push(element); } } return newElements; }\n\nfunction _hasDecorators(element) { return element.decorators && element.decorators.length; }\n\nfunction _isDataDescriptor(desc) { return desc !== undefined && !(desc.value === undefined && desc.writable === undefined); }\n\nfunction _optionalCallableProperty(obj, name) { var value = obj[name]; if (value !== undefined && typeof value !== \"function\") { throw new TypeError(\"Expected '\" + name + \"' to be a function\"); } return value; }\n\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\n\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\nfunction _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nvar _CONST = __webpack_require__(/*! ./_CONST */ \"./node_modules/@kissmybutton/motorcortex/dist/_Tree/_CONST.js\");\n\nvar Helper = __webpack_require__(/*! ../_coreUtils/Helper */ \"./node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\");\n\nvar helper = new Helper();\n\nvar systoleDiastole = __webpack_require__(/*! ./decorators/systoleDiastole */ \"./node_modules/@kissmybutton/motorcortex/dist/_Tree/decorators/systoleDiastole.js\");\n\nvar Leaf = _decorate(null, function (_initialize) {\n  var Leaf = function Leaf() {\n    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Leaf);\n\n    _initialize(this);\n\n    // parentNode is a reference to the parent Node the Leaf is attached to (if any)\n    this.parentNode = null;\n    this.isNode = false;\n\n    if (Object.prototype.hasOwnProperty.call(props, \"id\")) {\n      this.id = props.id;\n    } else {\n      this.id = helper.getAnId();\n    }\n\n    this.props = props;\n  };\n\n  return {\n    F: Leaf,\n    d: [{\n      kind: \"get\",\n      key: \"duration\",\n      value: function duration() {\n        return this.props.duration;\n      }\n    }, {\n      kind: \"set\",\n      key: \"duration\",\n      value: function duration(milliseconds) {\n        this.props.duration = milliseconds;\n      }\n    }, {\n      kind: \"method\",\n      key: \"setNewDuration\",\n      value: function setNewDuration(newDuration) {\n        this.duration = newDuration;\n        this.putMessageOnPipe('recalcDuration', {}, 'Groups', {\n          selfExecute: false,\n          direction: _CONST._DIRECTIONS._UP\n        });\n      }\n    }, {\n      kind: \"method\",\n      decorators: [systoleDiastole],\n      key: \"systoleDiastole\",\n      value: function systoleDiastole() {}\n    }, {\n      kind: \"get\",\n      key: \"hasParent\",\n      value: function hasParent() {\n        if (this.parentNode === null) {\n          return false;\n        }\n\n        return true;\n      }\n    }, {\n      kind: \"method\",\n      key: \"attachToNode\",\n      value: function attachToNode(node) {\n        this.parentNode = node;\n      }\n    }, {\n      kind: \"method\",\n      key: \"detachFromParent\",\n      value: function detachFromParent() {\n        this.parentNode = null;\n      }\n      /**\n      @param {string} name - the name of the message\n      @param {object} payload - the payload of the message\n      @param {object} target - specifies the target of the message in a key-value pairs object\n      @param {object} options - in the form:\n      {\n          direction (either _UP or _DOWN)\n          selfExecute (either true which means the Leaf should try to handle the message itself or\n              false which means the Leaf should directly forward the message to its parent)\n      }\n      @returns The expected result of this method is on the form:\n      {\n          response: an object the structure of which depends on the name of the message\n              and maybe even on the payload\n          responder: a direct reference to the lead that actually responded\n          (only valid for direaction _DOWN) positionDelta: the position delta of the responder compared to the requester\n      }\n      **/\n\n    }, {\n      kind: \"method\",\n      key: \"putMessageOnPipe\",\n      value: function putMessageOnPipe(name, payload, target) {\n        var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n        // default direction: _DOWN\n        if (!Object.prototype.hasOwnProperty.call(options, \"direction\")) {\n          options.direction = _CONST._DIRECTIONS._DOWN;\n        } // default positionDelta = 0\n\n\n        if (options.direction === _CONST._DIRECTIONS._DOWN && !Object.prototype.hasOwnProperty.call(options, \"positionDelta\")) {\n          options.positionDelta = 0;\n        }\n\n        if (options.selfExecute === true) {\n          // if the Leaf has a \"handle<name>\" method with the first letter of\n          // name in Capital it runs it\n          var handlingMethodName = \"handle\".concat(helper.jsUcfirst(name));\n          var capable = typeof this[handlingMethodName] === 'function';\n\n          if (capable) {\n            var response = this[handlingMethodName](target, payload);\n\n            if (response !== _CONST._BYPASS) {\n              var result = {\n                response: response,\n                responder: this\n              };\n\n              if (options.direction === _CONST._DIRECTIONS._UP) {\n                return result;\n              } else {\n                return [_objectSpread({}, result, {\n                  positionDelta: options.positionDelta\n                })];\n              }\n            }\n          }\n        }\n\n        if (options.direction === _CONST._DIRECTIONS._UP) {\n          if (this.hasParent) {\n            return this.parentNode.putMessageOnPipe(name, payload, target, {\n              selfExecute: true,\n              direction: _CONST._DIRECTIONS._UP\n            });\n          } else {\n            // if the message reaches the top of the tree without finding any liable target\n            return {\n              response: false,\n              responder: null\n            };\n          }\n        } else {\n          // _CONST._DIRECTIONS._DOWN\n          return [];\n        }\n      }\n    }, {\n      kind: \"method\",\n      key: \"bypass\",\n      value: function bypass() {\n        return _CONST._BYPASS;\n      }\n    }]\n  };\n});\n\nmodule.exports = Leaf;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19UcmVlL0xlYWYuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19UcmVlL0xlYWYuanM/MjE3MyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IHZhciBvd25LZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTsgaWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSAnZnVuY3Rpb24nKSB7IG93bktleXMgPSBvd25LZXlzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSkuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBzeW0pLmVudW1lcmFibGU7IH0pKTsgfSBvd25LZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVjb3JhdGUoZGVjb3JhdG9ycywgZmFjdG9yeSwgc3VwZXJDbGFzcywgbWl4aW5zKSB7IHZhciBhcGkgPSBfZ2V0RGVjb3JhdG9yc0FwaSgpOyBpZiAobWl4aW5zKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgbWl4aW5zLmxlbmd0aDsgaSsrKSB7IGFwaSA9IG1peGluc1tpXShhcGkpOyB9IH0gdmFyIHIgPSBmYWN0b3J5KGZ1bmN0aW9uIGluaXRpYWxpemUoTykgeyBhcGkuaW5pdGlhbGl6ZUluc3RhbmNlRWxlbWVudHMoTywgZGVjb3JhdGVkLmVsZW1lbnRzKTsgfSwgc3VwZXJDbGFzcyk7IHZhciBkZWNvcmF0ZWQgPSBhcGkuZGVjb3JhdGVDbGFzcyhfY29hbGVzY2VDbGFzc0VsZW1lbnRzKHIuZC5tYXAoX2NyZWF0ZUVsZW1lbnREZXNjcmlwdG9yKSksIGRlY29yYXRvcnMpOyBhcGkuaW5pdGlhbGl6ZUNsYXNzRWxlbWVudHMoci5GLCBkZWNvcmF0ZWQuZWxlbWVudHMpOyByZXR1cm4gYXBpLnJ1bkNsYXNzRmluaXNoZXJzKHIuRiwgZGVjb3JhdGVkLmZpbmlzaGVycyk7IH1cblxuZnVuY3Rpb24gX2dldERlY29yYXRvcnNBcGkoKSB7IF9nZXREZWNvcmF0b3JzQXBpID0gZnVuY3Rpb24gX2dldERlY29yYXRvcnNBcGkoKSB7IHJldHVybiBhcGk7IH07IHZhciBhcGkgPSB7IGVsZW1lbnRzRGVmaW5pdGlvbk9yZGVyOiBbW1wibWV0aG9kXCJdLCBbXCJmaWVsZFwiXV0sIGluaXRpYWxpemVJbnN0YW5jZUVsZW1lbnRzOiBmdW5jdGlvbiBpbml0aWFsaXplSW5zdGFuY2VFbGVtZW50cyhPLCBlbGVtZW50cykgeyBbXCJtZXRob2RcIiwgXCJmaWVsZFwiXS5mb3JFYWNoKGZ1bmN0aW9uIChraW5kKSB7IGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHsgaWYgKGVsZW1lbnQua2luZCA9PT0ga2luZCAmJiBlbGVtZW50LnBsYWNlbWVudCA9PT0gXCJvd25cIikgeyB0aGlzLmRlZmluZUNsYXNzRWxlbWVudChPLCBlbGVtZW50KTsgfSB9LCB0aGlzKTsgfSwgdGhpcyk7IH0sIGluaXRpYWxpemVDbGFzc0VsZW1lbnRzOiBmdW5jdGlvbiBpbml0aWFsaXplQ2xhc3NFbGVtZW50cyhGLCBlbGVtZW50cykgeyB2YXIgcHJvdG8gPSBGLnByb3RvdHlwZTsgW1wibWV0aG9kXCIsIFwiZmllbGRcIl0uZm9yRWFjaChmdW5jdGlvbiAoa2luZCkgeyBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7IHZhciBwbGFjZW1lbnQgPSBlbGVtZW50LnBsYWNlbWVudDsgaWYgKGVsZW1lbnQua2luZCA9PT0ga2luZCAmJiAocGxhY2VtZW50ID09PSBcInN0YXRpY1wiIHx8IHBsYWNlbWVudCA9PT0gXCJwcm90b3R5cGVcIikpIHsgdmFyIHJlY2VpdmVyID0gcGxhY2VtZW50ID09PSBcInN0YXRpY1wiID8gRiA6IHByb3RvOyB0aGlzLmRlZmluZUNsYXNzRWxlbWVudChyZWNlaXZlciwgZWxlbWVudCk7IH0gfSwgdGhpcyk7IH0sIHRoaXMpOyB9LCBkZWZpbmVDbGFzc0VsZW1lbnQ6IGZ1bmN0aW9uIGRlZmluZUNsYXNzRWxlbWVudChyZWNlaXZlciwgZWxlbWVudCkgeyB2YXIgZGVzY3JpcHRvciA9IGVsZW1lbnQuZGVzY3JpcHRvcjsgaWYgKGVsZW1lbnQua2luZCA9PT0gXCJmaWVsZFwiKSB7IHZhciBpbml0aWFsaXplciA9IGVsZW1lbnQuaW5pdGlhbGl6ZXI7IGRlc2NyaXB0b3IgPSB7IGVudW1lcmFibGU6IGRlc2NyaXB0b3IuZW51bWVyYWJsZSwgd3JpdGFibGU6IGRlc2NyaXB0b3Iud3JpdGFibGUsIGNvbmZpZ3VyYWJsZTogZGVzY3JpcHRvci5jb25maWd1cmFibGUsIHZhbHVlOiBpbml0aWFsaXplciA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5pdGlhbGl6ZXIuY2FsbChyZWNlaXZlcikgfTsgfSBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVjZWl2ZXIsIGVsZW1lbnQua2V5LCBkZXNjcmlwdG9yKTsgfSwgZGVjb3JhdGVDbGFzczogZnVuY3Rpb24gZGVjb3JhdGVDbGFzcyhlbGVtZW50cywgZGVjb3JhdG9ycykgeyB2YXIgbmV3RWxlbWVudHMgPSBbXTsgdmFyIGZpbmlzaGVycyA9IFtdOyB2YXIgcGxhY2VtZW50cyA9IHsgXCJzdGF0aWNcIjogW10sIHByb3RvdHlwZTogW10sIG93bjogW10gfTsgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkgeyB0aGlzLmFkZEVsZW1lbnRQbGFjZW1lbnQoZWxlbWVudCwgcGxhY2VtZW50cyk7IH0sIHRoaXMpOyBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7IGlmICghX2hhc0RlY29yYXRvcnMoZWxlbWVudCkpIHJldHVybiBuZXdFbGVtZW50cy5wdXNoKGVsZW1lbnQpOyB2YXIgZWxlbWVudEZpbmlzaGVyc0V4dHJhcyA9IHRoaXMuZGVjb3JhdGVFbGVtZW50KGVsZW1lbnQsIHBsYWNlbWVudHMpOyBuZXdFbGVtZW50cy5wdXNoKGVsZW1lbnRGaW5pc2hlcnNFeHRyYXMuZWxlbWVudCk7IG5ld0VsZW1lbnRzLnB1c2guYXBwbHkobmV3RWxlbWVudHMsIGVsZW1lbnRGaW5pc2hlcnNFeHRyYXMuZXh0cmFzKTsgZmluaXNoZXJzLnB1c2guYXBwbHkoZmluaXNoZXJzLCBlbGVtZW50RmluaXNoZXJzRXh0cmFzLmZpbmlzaGVycyk7IH0sIHRoaXMpOyBpZiAoIWRlY29yYXRvcnMpIHsgcmV0dXJuIHsgZWxlbWVudHM6IG5ld0VsZW1lbnRzLCBmaW5pc2hlcnM6IGZpbmlzaGVycyB9OyB9IHZhciByZXN1bHQgPSB0aGlzLmRlY29yYXRlQ29uc3RydWN0b3IobmV3RWxlbWVudHMsIGRlY29yYXRvcnMpOyBmaW5pc2hlcnMucHVzaC5hcHBseShmaW5pc2hlcnMsIHJlc3VsdC5maW5pc2hlcnMpOyByZXN1bHQuZmluaXNoZXJzID0gZmluaXNoZXJzOyByZXR1cm4gcmVzdWx0OyB9LCBhZGRFbGVtZW50UGxhY2VtZW50OiBmdW5jdGlvbiBhZGRFbGVtZW50UGxhY2VtZW50KGVsZW1lbnQsIHBsYWNlbWVudHMsIHNpbGVudCkgeyB2YXIga2V5cyA9IHBsYWNlbWVudHNbZWxlbWVudC5wbGFjZW1lbnRdOyBpZiAoIXNpbGVudCAmJiBrZXlzLmluZGV4T2YoZWxlbWVudC5rZXkpICE9PSAtMSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRHVwbGljYXRlZCBlbGVtZW50IChcIiArIGVsZW1lbnQua2V5ICsgXCIpXCIpOyB9IGtleXMucHVzaChlbGVtZW50LmtleSk7IH0sIGRlY29yYXRlRWxlbWVudDogZnVuY3Rpb24gZGVjb3JhdGVFbGVtZW50KGVsZW1lbnQsIHBsYWNlbWVudHMpIHsgdmFyIGV4dHJhcyA9IFtdOyB2YXIgZmluaXNoZXJzID0gW107IGZvciAodmFyIGRlY29yYXRvcnMgPSBlbGVtZW50LmRlY29yYXRvcnMsIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7IHZhciBrZXlzID0gcGxhY2VtZW50c1tlbGVtZW50LnBsYWNlbWVudF07IGtleXMuc3BsaWNlKGtleXMuaW5kZXhPZihlbGVtZW50LmtleSksIDEpOyB2YXIgZWxlbWVudE9iamVjdCA9IHRoaXMuZnJvbUVsZW1lbnREZXNjcmlwdG9yKGVsZW1lbnQpOyB2YXIgZWxlbWVudEZpbmlzaGVyRXh0cmFzID0gdGhpcy50b0VsZW1lbnRGaW5pc2hlckV4dHJhcygoMCwgZGVjb3JhdG9yc1tpXSkoZWxlbWVudE9iamVjdCkgfHwgZWxlbWVudE9iamVjdCk7IGVsZW1lbnQgPSBlbGVtZW50RmluaXNoZXJFeHRyYXMuZWxlbWVudDsgdGhpcy5hZGRFbGVtZW50UGxhY2VtZW50KGVsZW1lbnQsIHBsYWNlbWVudHMpOyBpZiAoZWxlbWVudEZpbmlzaGVyRXh0cmFzLmZpbmlzaGVyKSB7IGZpbmlzaGVycy5wdXNoKGVsZW1lbnRGaW5pc2hlckV4dHJhcy5maW5pc2hlcik7IH0gdmFyIG5ld0V4dHJhcyA9IGVsZW1lbnRGaW5pc2hlckV4dHJhcy5leHRyYXM7IGlmIChuZXdFeHRyYXMpIHsgZm9yICh2YXIgaiA9IDA7IGogPCBuZXdFeHRyYXMubGVuZ3RoOyBqKyspIHsgdGhpcy5hZGRFbGVtZW50UGxhY2VtZW50KG5ld0V4dHJhc1tqXSwgcGxhY2VtZW50cyk7IH0gZXh0cmFzLnB1c2guYXBwbHkoZXh0cmFzLCBuZXdFeHRyYXMpOyB9IH0gcmV0dXJuIHsgZWxlbWVudDogZWxlbWVudCwgZmluaXNoZXJzOiBmaW5pc2hlcnMsIGV4dHJhczogZXh0cmFzIH07IH0sIGRlY29yYXRlQ29uc3RydWN0b3I6IGZ1bmN0aW9uIGRlY29yYXRlQ29uc3RydWN0b3IoZWxlbWVudHMsIGRlY29yYXRvcnMpIHsgdmFyIGZpbmlzaGVycyA9IFtdOyBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgeyB2YXIgb2JqID0gdGhpcy5mcm9tQ2xhc3NEZXNjcmlwdG9yKGVsZW1lbnRzKTsgdmFyIGVsZW1lbnRzQW5kRmluaXNoZXIgPSB0aGlzLnRvQ2xhc3NEZXNjcmlwdG9yKCgwLCBkZWNvcmF0b3JzW2ldKShvYmopIHx8IG9iaik7IGlmIChlbGVtZW50c0FuZEZpbmlzaGVyLmZpbmlzaGVyICE9PSB1bmRlZmluZWQpIHsgZmluaXNoZXJzLnB1c2goZWxlbWVudHNBbmRGaW5pc2hlci5maW5pc2hlcik7IH0gaWYgKGVsZW1lbnRzQW5kRmluaXNoZXIuZWxlbWVudHMgIT09IHVuZGVmaW5lZCkgeyBlbGVtZW50cyA9IGVsZW1lbnRzQW5kRmluaXNoZXIuZWxlbWVudHM7IGZvciAodmFyIGogPSAwOyBqIDwgZWxlbWVudHMubGVuZ3RoIC0gMTsgaisrKSB7IGZvciAodmFyIGsgPSBqICsgMTsgayA8IGVsZW1lbnRzLmxlbmd0aDsgaysrKSB7IGlmIChlbGVtZW50c1tqXS5rZXkgPT09IGVsZW1lbnRzW2tdLmtleSAmJiBlbGVtZW50c1tqXS5wbGFjZW1lbnQgPT09IGVsZW1lbnRzW2tdLnBsYWNlbWVudCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRHVwbGljYXRlZCBlbGVtZW50IChcIiArIGVsZW1lbnRzW2pdLmtleSArIFwiKVwiKTsgfSB9IH0gfSB9IHJldHVybiB7IGVsZW1lbnRzOiBlbGVtZW50cywgZmluaXNoZXJzOiBmaW5pc2hlcnMgfTsgfSwgZnJvbUVsZW1lbnREZXNjcmlwdG9yOiBmdW5jdGlvbiBmcm9tRWxlbWVudERlc2NyaXB0b3IoZWxlbWVudCkgeyB2YXIgb2JqID0geyBraW5kOiBlbGVtZW50LmtpbmQsIGtleTogZWxlbWVudC5rZXksIHBsYWNlbWVudDogZWxlbWVudC5wbGFjZW1lbnQsIGRlc2NyaXB0b3I6IGVsZW1lbnQuZGVzY3JpcHRvciB9OyB2YXIgZGVzYyA9IHsgdmFsdWU6IFwiRGVzY3JpcHRvclwiLCBjb25maWd1cmFibGU6IHRydWUgfTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgU3ltYm9sLnRvU3RyaW5nVGFnLCBkZXNjKTsgaWYgKGVsZW1lbnQua2luZCA9PT0gXCJmaWVsZFwiKSBvYmouaW5pdGlhbGl6ZXIgPSBlbGVtZW50LmluaXRpYWxpemVyOyByZXR1cm4gb2JqOyB9LCB0b0VsZW1lbnREZXNjcmlwdG9yczogZnVuY3Rpb24gdG9FbGVtZW50RGVzY3JpcHRvcnMoZWxlbWVudE9iamVjdHMpIHsgaWYgKGVsZW1lbnRPYmplY3RzID09PSB1bmRlZmluZWQpIHJldHVybjsgcmV0dXJuIF90b0FycmF5KGVsZW1lbnRPYmplY3RzKS5tYXAoZnVuY3Rpb24gKGVsZW1lbnRPYmplY3QpIHsgdmFyIGVsZW1lbnQgPSB0aGlzLnRvRWxlbWVudERlc2NyaXB0b3IoZWxlbWVudE9iamVjdCk7IHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShlbGVtZW50T2JqZWN0LCBcImZpbmlzaGVyXCIsIFwiQW4gZWxlbWVudCBkZXNjcmlwdG9yXCIpOyB0aGlzLmRpc2FsbG93UHJvcGVydHkoZWxlbWVudE9iamVjdCwgXCJleHRyYXNcIiwgXCJBbiBlbGVtZW50IGRlc2NyaXB0b3JcIik7IHJldHVybiBlbGVtZW50OyB9LCB0aGlzKTsgfSwgdG9FbGVtZW50RGVzY3JpcHRvcjogZnVuY3Rpb24gdG9FbGVtZW50RGVzY3JpcHRvcihlbGVtZW50T2JqZWN0KSB7IHZhciBraW5kID0gU3RyaW5nKGVsZW1lbnRPYmplY3Qua2luZCk7IGlmIChraW5kICE9PSBcIm1ldGhvZFwiICYmIGtpbmQgIT09IFwiZmllbGRcIikgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdBbiBlbGVtZW50IGRlc2NyaXB0b3JcXCdzIC5raW5kIHByb3BlcnR5IG11c3QgYmUgZWl0aGVyIFwibWV0aG9kXCIgb3InICsgJyBcImZpZWxkXCIsIGJ1dCBhIGRlY29yYXRvciBjcmVhdGVkIGFuIGVsZW1lbnQgZGVzY3JpcHRvciB3aXRoJyArICcgLmtpbmQgXCInICsga2luZCArICdcIicpOyB9IHZhciBrZXkgPSBfdG9Qcm9wZXJ0eUtleShlbGVtZW50T2JqZWN0LmtleSk7IHZhciBwbGFjZW1lbnQgPSBTdHJpbmcoZWxlbWVudE9iamVjdC5wbGFjZW1lbnQpOyBpZiAocGxhY2VtZW50ICE9PSBcInN0YXRpY1wiICYmIHBsYWNlbWVudCAhPT0gXCJwcm90b3R5cGVcIiAmJiBwbGFjZW1lbnQgIT09IFwib3duXCIpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQW4gZWxlbWVudCBkZXNjcmlwdG9yXFwncyAucGxhY2VtZW50IHByb3BlcnR5IG11c3QgYmUgb25lIG9mIFwic3RhdGljXCIsJyArICcgXCJwcm90b3R5cGVcIiBvciBcIm93blwiLCBidXQgYSBkZWNvcmF0b3IgY3JlYXRlZCBhbiBlbGVtZW50IGRlc2NyaXB0b3InICsgJyB3aXRoIC5wbGFjZW1lbnQgXCInICsgcGxhY2VtZW50ICsgJ1wiJyk7IH0gdmFyIGRlc2NyaXB0b3IgPSBlbGVtZW50T2JqZWN0LmRlc2NyaXB0b3I7IHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShlbGVtZW50T2JqZWN0LCBcImVsZW1lbnRzXCIsIFwiQW4gZWxlbWVudCBkZXNjcmlwdG9yXCIpOyB2YXIgZWxlbWVudCA9IHsga2luZDoga2luZCwga2V5OiBrZXksIHBsYWNlbWVudDogcGxhY2VtZW50LCBkZXNjcmlwdG9yOiBPYmplY3QuYXNzaWduKHt9LCBkZXNjcmlwdG9yKSB9OyBpZiAoa2luZCAhPT0gXCJmaWVsZFwiKSB7IHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShlbGVtZW50T2JqZWN0LCBcImluaXRpYWxpemVyXCIsIFwiQSBtZXRob2QgZGVzY3JpcHRvclwiKTsgfSBlbHNlIHsgdGhpcy5kaXNhbGxvd1Byb3BlcnR5KGRlc2NyaXB0b3IsIFwiZ2V0XCIsIFwiVGhlIHByb3BlcnR5IGRlc2NyaXB0b3Igb2YgYSBmaWVsZCBkZXNjcmlwdG9yXCIpOyB0aGlzLmRpc2FsbG93UHJvcGVydHkoZGVzY3JpcHRvciwgXCJzZXRcIiwgXCJUaGUgcHJvcGVydHkgZGVzY3JpcHRvciBvZiBhIGZpZWxkIGRlc2NyaXB0b3JcIik7IHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShkZXNjcmlwdG9yLCBcInZhbHVlXCIsIFwiVGhlIHByb3BlcnR5IGRlc2NyaXB0b3Igb2YgYSBmaWVsZCBkZXNjcmlwdG9yXCIpOyBlbGVtZW50LmluaXRpYWxpemVyID0gZWxlbWVudE9iamVjdC5pbml0aWFsaXplcjsgfSByZXR1cm4gZWxlbWVudDsgfSwgdG9FbGVtZW50RmluaXNoZXJFeHRyYXM6IGZ1bmN0aW9uIHRvRWxlbWVudEZpbmlzaGVyRXh0cmFzKGVsZW1lbnRPYmplY3QpIHsgdmFyIGVsZW1lbnQgPSB0aGlzLnRvRWxlbWVudERlc2NyaXB0b3IoZWxlbWVudE9iamVjdCk7IHZhciBmaW5pc2hlciA9IF9vcHRpb25hbENhbGxhYmxlUHJvcGVydHkoZWxlbWVudE9iamVjdCwgXCJmaW5pc2hlclwiKTsgdmFyIGV4dHJhcyA9IHRoaXMudG9FbGVtZW50RGVzY3JpcHRvcnMoZWxlbWVudE9iamVjdC5leHRyYXMpOyByZXR1cm4geyBlbGVtZW50OiBlbGVtZW50LCBmaW5pc2hlcjogZmluaXNoZXIsIGV4dHJhczogZXh0cmFzIH07IH0sIGZyb21DbGFzc0Rlc2NyaXB0b3I6IGZ1bmN0aW9uIGZyb21DbGFzc0Rlc2NyaXB0b3IoZWxlbWVudHMpIHsgdmFyIG9iaiA9IHsga2luZDogXCJjbGFzc1wiLCBlbGVtZW50czogZWxlbWVudHMubWFwKHRoaXMuZnJvbUVsZW1lbnREZXNjcmlwdG9yLCB0aGlzKSB9OyB2YXIgZGVzYyA9IHsgdmFsdWU6IFwiRGVzY3JpcHRvclwiLCBjb25maWd1cmFibGU6IHRydWUgfTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgU3ltYm9sLnRvU3RyaW5nVGFnLCBkZXNjKTsgcmV0dXJuIG9iajsgfSwgdG9DbGFzc0Rlc2NyaXB0b3I6IGZ1bmN0aW9uIHRvQ2xhc3NEZXNjcmlwdG9yKG9iaikgeyB2YXIga2luZCA9IFN0cmluZyhvYmoua2luZCk7IGlmIChraW5kICE9PSBcImNsYXNzXCIpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQSBjbGFzcyBkZXNjcmlwdG9yXFwncyAua2luZCBwcm9wZXJ0eSBtdXN0IGJlIFwiY2xhc3NcIiwgYnV0IGEgZGVjb3JhdG9yJyArICcgY3JlYXRlZCBhIGNsYXNzIGRlc2NyaXB0b3Igd2l0aCAua2luZCBcIicgKyBraW5kICsgJ1wiJyk7IH0gdGhpcy5kaXNhbGxvd1Byb3BlcnR5KG9iaiwgXCJrZXlcIiwgXCJBIGNsYXNzIGRlc2NyaXB0b3JcIik7IHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShvYmosIFwicGxhY2VtZW50XCIsIFwiQSBjbGFzcyBkZXNjcmlwdG9yXCIpOyB0aGlzLmRpc2FsbG93UHJvcGVydHkob2JqLCBcImRlc2NyaXB0b3JcIiwgXCJBIGNsYXNzIGRlc2NyaXB0b3JcIik7IHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShvYmosIFwiaW5pdGlhbGl6ZXJcIiwgXCJBIGNsYXNzIGRlc2NyaXB0b3JcIik7IHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShvYmosIFwiZXh0cmFzXCIsIFwiQSBjbGFzcyBkZXNjcmlwdG9yXCIpOyB2YXIgZmluaXNoZXIgPSBfb3B0aW9uYWxDYWxsYWJsZVByb3BlcnR5KG9iaiwgXCJmaW5pc2hlclwiKTsgdmFyIGVsZW1lbnRzID0gdGhpcy50b0VsZW1lbnREZXNjcmlwdG9ycyhvYmouZWxlbWVudHMpOyByZXR1cm4geyBlbGVtZW50czogZWxlbWVudHMsIGZpbmlzaGVyOiBmaW5pc2hlciB9OyB9LCBydW5DbGFzc0ZpbmlzaGVyczogZnVuY3Rpb24gcnVuQ2xhc3NGaW5pc2hlcnMoY29uc3RydWN0b3IsIGZpbmlzaGVycykgeyBmb3IgKHZhciBpID0gMDsgaSA8IGZpbmlzaGVycy5sZW5ndGg7IGkrKykgeyB2YXIgbmV3Q29uc3RydWN0b3IgPSAoMCwgZmluaXNoZXJzW2ldKShjb25zdHJ1Y3Rvcik7IGlmIChuZXdDb25zdHJ1Y3RvciAhPT0gdW5kZWZpbmVkKSB7IGlmICh0eXBlb2YgbmV3Q29uc3RydWN0b3IgIT09IFwiZnVuY3Rpb25cIikgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmluaXNoZXJzIG11c3QgcmV0dXJuIGEgY29uc3RydWN0b3IuXCIpOyB9IGNvbnN0cnVjdG9yID0gbmV3Q29uc3RydWN0b3I7IH0gfSByZXR1cm4gY29uc3RydWN0b3I7IH0sIGRpc2FsbG93UHJvcGVydHk6IGZ1bmN0aW9uIGRpc2FsbG93UHJvcGVydHkob2JqLCBuYW1lLCBvYmplY3RUeXBlKSB7IGlmIChvYmpbbmFtZV0gIT09IHVuZGVmaW5lZCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKG9iamVjdFR5cGUgKyBcIiBjYW4ndCBoYXZlIGEgLlwiICsgbmFtZSArIFwiIHByb3BlcnR5LlwiKTsgfSB9IH07IHJldHVybiBhcGk7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUVsZW1lbnREZXNjcmlwdG9yKGRlZikgeyB2YXIga2V5ID0gX3RvUHJvcGVydHlLZXkoZGVmLmtleSk7IHZhciBkZXNjcmlwdG9yOyBpZiAoZGVmLmtpbmQgPT09IFwibWV0aG9kXCIpIHsgZGVzY3JpcHRvciA9IHsgdmFsdWU6IGRlZi52YWx1ZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZW51bWVyYWJsZTogZmFsc2UgfTsgfSBlbHNlIGlmIChkZWYua2luZCA9PT0gXCJnZXRcIikgeyBkZXNjcmlwdG9yID0geyBnZXQ6IGRlZi52YWx1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCBlbnVtZXJhYmxlOiBmYWxzZSB9OyB9IGVsc2UgaWYgKGRlZi5raW5kID09PSBcInNldFwiKSB7IGRlc2NyaXB0b3IgPSB7IHNldDogZGVmLnZhbHVlLCBjb25maWd1cmFibGU6IHRydWUsIGVudW1lcmFibGU6IGZhbHNlIH07IH0gZWxzZSBpZiAoZGVmLmtpbmQgPT09IFwiZmllbGRcIikgeyBkZXNjcmlwdG9yID0geyBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCBlbnVtZXJhYmxlOiB0cnVlIH07IH0gdmFyIGVsZW1lbnQgPSB7IGtpbmQ6IGRlZi5raW5kID09PSBcImZpZWxkXCIgPyBcImZpZWxkXCIgOiBcIm1ldGhvZFwiLCBrZXk6IGtleSwgcGxhY2VtZW50OiBkZWZbXCJzdGF0aWNcIl0gPyBcInN0YXRpY1wiIDogZGVmLmtpbmQgPT09IFwiZmllbGRcIiA/IFwib3duXCIgOiBcInByb3RvdHlwZVwiLCBkZXNjcmlwdG9yOiBkZXNjcmlwdG9yIH07IGlmIChkZWYuZGVjb3JhdG9ycykgZWxlbWVudC5kZWNvcmF0b3JzID0gZGVmLmRlY29yYXRvcnM7IGlmIChkZWYua2luZCA9PT0gXCJmaWVsZFwiKSBlbGVtZW50LmluaXRpYWxpemVyID0gZGVmLnZhbHVlOyByZXR1cm4gZWxlbWVudDsgfVxuXG5mdW5jdGlvbiBfY29hbGVzY2VHZXR0ZXJTZXR0ZXIoZWxlbWVudCwgb3RoZXIpIHsgaWYgKGVsZW1lbnQuZGVzY3JpcHRvci5nZXQgIT09IHVuZGVmaW5lZCkgeyBvdGhlci5kZXNjcmlwdG9yLmdldCA9IGVsZW1lbnQuZGVzY3JpcHRvci5nZXQ7IH0gZWxzZSB7IG90aGVyLmRlc2NyaXB0b3Iuc2V0ID0gZWxlbWVudC5kZXNjcmlwdG9yLnNldDsgfSB9XG5cbmZ1bmN0aW9uIF9jb2FsZXNjZUNsYXNzRWxlbWVudHMoZWxlbWVudHMpIHsgdmFyIG5ld0VsZW1lbnRzID0gW107IHZhciBpc1NhbWVFbGVtZW50ID0gZnVuY3Rpb24gaXNTYW1lRWxlbWVudChvdGhlcikgeyByZXR1cm4gb3RoZXIua2luZCA9PT0gXCJtZXRob2RcIiAmJiBvdGhlci5rZXkgPT09IGVsZW1lbnQua2V5ICYmIG90aGVyLnBsYWNlbWVudCA9PT0gZWxlbWVudC5wbGFjZW1lbnQ7IH07IGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIGVsZW1lbnQgPSBlbGVtZW50c1tpXTsgdmFyIG90aGVyOyBpZiAoZWxlbWVudC5raW5kID09PSBcIm1ldGhvZFwiICYmIChvdGhlciA9IG5ld0VsZW1lbnRzLmZpbmQoaXNTYW1lRWxlbWVudCkpKSB7IGlmIChfaXNEYXRhRGVzY3JpcHRvcihlbGVtZW50LmRlc2NyaXB0b3IpIHx8IF9pc0RhdGFEZXNjcmlwdG9yKG90aGVyLmRlc2NyaXB0b3IpKSB7IGlmIChfaGFzRGVjb3JhdG9ycyhlbGVtZW50KSB8fCBfaGFzRGVjb3JhdG9ycyhvdGhlcikpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwiRHVwbGljYXRlZCBtZXRob2RzIChcIiArIGVsZW1lbnQua2V5ICsgXCIpIGNhbid0IGJlIGRlY29yYXRlZC5cIik7IH0gb3RoZXIuZGVzY3JpcHRvciA9IGVsZW1lbnQuZGVzY3JpcHRvcjsgfSBlbHNlIHsgaWYgKF9oYXNEZWNvcmF0b3JzKGVsZW1lbnQpKSB7IGlmIChfaGFzRGVjb3JhdG9ycyhvdGhlcikpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwiRGVjb3JhdG9ycyBjYW4ndCBiZSBwbGFjZWQgb24gZGlmZmVyZW50IGFjY2Vzc29ycyB3aXRoIGZvciBcIiArIFwidGhlIHNhbWUgcHJvcGVydHkgKFwiICsgZWxlbWVudC5rZXkgKyBcIikuXCIpOyB9IG90aGVyLmRlY29yYXRvcnMgPSBlbGVtZW50LmRlY29yYXRvcnM7IH0gX2NvYWxlc2NlR2V0dGVyU2V0dGVyKGVsZW1lbnQsIG90aGVyKTsgfSB9IGVsc2UgeyBuZXdFbGVtZW50cy5wdXNoKGVsZW1lbnQpOyB9IH0gcmV0dXJuIG5ld0VsZW1lbnRzOyB9XG5cbmZ1bmN0aW9uIF9oYXNEZWNvcmF0b3JzKGVsZW1lbnQpIHsgcmV0dXJuIGVsZW1lbnQuZGVjb3JhdG9ycyAmJiBlbGVtZW50LmRlY29yYXRvcnMubGVuZ3RoOyB9XG5cbmZ1bmN0aW9uIF9pc0RhdGFEZXNjcmlwdG9yKGRlc2MpIHsgcmV0dXJuIGRlc2MgIT09IHVuZGVmaW5lZCAmJiAhKGRlc2MudmFsdWUgPT09IHVuZGVmaW5lZCAmJiBkZXNjLndyaXRhYmxlID09PSB1bmRlZmluZWQpOyB9XG5cbmZ1bmN0aW9uIF9vcHRpb25hbENhbGxhYmxlUHJvcGVydHkob2JqLCBuYW1lKSB7IHZhciB2YWx1ZSA9IG9ialtuYW1lXTsgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkICdcIiArIG5hbWUgKyBcIicgdG8gYmUgYSBmdW5jdGlvblwiKTsgfSByZXR1cm4gdmFsdWU7IH1cblxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkoYXJnKSB7IHZhciBrZXkgPSBfdG9QcmltaXRpdmUoYXJnLCBcInN0cmluZ1wiKTsgcmV0dXJuIF90eXBlb2Yoa2V5KSA9PT0gXCJzeW1ib2xcIiA/IGtleSA6IFN0cmluZyhrZXkpOyB9XG5cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZShpbnB1dCwgaGludCkgeyBpZiAoX3R5cGVvZihpbnB1dCkgIT09IFwib2JqZWN0XCIgfHwgaW5wdXQgPT09IG51bGwpIHJldHVybiBpbnB1dDsgdmFyIHByaW0gPSBpbnB1dFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAocHJpbSAhPT0gdW5kZWZpbmVkKSB7IHZhciByZXMgPSBwcmltLmNhbGwoaW5wdXQsIGhpbnQgfHwgXCJkZWZhdWx0XCIpOyBpZiAoX3R5cGVvZihyZXMpICE9PSBcIm9iamVjdFwiKSByZXR1cm4gcmVzOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChoaW50ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShpbnB1dCk7IH1cblxuZnVuY3Rpb24gX3RvQXJyYXkoYXJyKSB7IHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlUmVzdCgpOyB9XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpOyB9XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikgeyBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChpdGVyKSB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaXRlcikgPT09IFwiW29iamVjdCBBcmd1bWVudHNdXCIpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpOyB9XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjsgfVxuXG52YXIgX0NPTlNUID0gcmVxdWlyZSgnLi9fQ09OU1QnKTtcblxudmFyIEhlbHBlciA9IHJlcXVpcmUoJy4uL19jb3JlVXRpbHMvSGVscGVyJyk7XG5cbnZhciBoZWxwZXIgPSBuZXcgSGVscGVyKCk7XG5cbnZhciBzeXN0b2xlRGlhc3RvbGUgPSByZXF1aXJlKCcuL2RlY29yYXRvcnMvc3lzdG9sZURpYXN0b2xlJyk7XG5cbnZhciBMZWFmID0gX2RlY29yYXRlKG51bGwsIGZ1bmN0aW9uIChfaW5pdGlhbGl6ZSkge1xuICB2YXIgTGVhZiA9IGZ1bmN0aW9uIExlYWYoKSB7XG4gICAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMZWFmKTtcblxuICAgIF9pbml0aWFsaXplKHRoaXMpO1xuXG4gICAgLy8gcGFyZW50Tm9kZSBpcyBhIHJlZmVyZW5jZSB0byB0aGUgcGFyZW50IE5vZGUgdGhlIExlYWYgaXMgYXR0YWNoZWQgdG8gKGlmIGFueSlcbiAgICB0aGlzLnBhcmVudE5vZGUgPSBudWxsO1xuICAgIHRoaXMuaXNOb2RlID0gZmFsc2U7XG5cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBcImlkXCIpKSB7XG4gICAgICB0aGlzLmlkID0gcHJvcHMuaWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaWQgPSBoZWxwZXIuZ2V0QW5JZCgpO1xuICAgIH1cblxuICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIEY6IExlYWYsXG4gICAgZDogW3tcbiAgICAgIGtpbmQ6IFwiZ2V0XCIsXG4gICAgICBrZXk6IFwiZHVyYXRpb25cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkdXJhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMuZHVyYXRpb247XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2luZDogXCJzZXRcIixcbiAgICAgIGtleTogXCJkdXJhdGlvblwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGR1cmF0aW9uKG1pbGxpc2Vjb25kcykge1xuICAgICAgICB0aGlzLnByb3BzLmR1cmF0aW9uID0gbWlsbGlzZWNvbmRzO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtpbmQ6IFwibWV0aG9kXCIsXG4gICAgICBrZXk6IFwic2V0TmV3RHVyYXRpb25cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXROZXdEdXJhdGlvbihuZXdEdXJhdGlvbikge1xuICAgICAgICB0aGlzLmR1cmF0aW9uID0gbmV3RHVyYXRpb247XG4gICAgICAgIHRoaXMucHV0TWVzc2FnZU9uUGlwZSgncmVjYWxjRHVyYXRpb24nLCB7fSwgJ0dyb3VwcycsIHtcbiAgICAgICAgICBzZWxmRXhlY3V0ZTogZmFsc2UsXG4gICAgICAgICAgZGlyZWN0aW9uOiBfQ09OU1QuX0RJUkVDVElPTlMuX1VQXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtpbmQ6IFwibWV0aG9kXCIsXG4gICAgICBkZWNvcmF0b3JzOiBbc3lzdG9sZURpYXN0b2xlXSxcbiAgICAgIGtleTogXCJzeXN0b2xlRGlhc3RvbGVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzeXN0b2xlRGlhc3RvbGUoKSB7fVxuICAgIH0sIHtcbiAgICAgIGtpbmQ6IFwiZ2V0XCIsXG4gICAgICBrZXk6IFwiaGFzUGFyZW50XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaGFzUGFyZW50KCkge1xuICAgICAgICBpZiAodGhpcy5wYXJlbnROb2RlID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2luZDogXCJtZXRob2RcIixcbiAgICAgIGtleTogXCJhdHRhY2hUb05vZGVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBhdHRhY2hUb05vZGUobm9kZSkge1xuICAgICAgICB0aGlzLnBhcmVudE5vZGUgPSBub2RlO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtpbmQ6IFwibWV0aG9kXCIsXG4gICAgICBrZXk6IFwiZGV0YWNoRnJvbVBhcmVudFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRldGFjaEZyb21QYXJlbnQoKSB7XG4gICAgICAgIHRoaXMucGFyZW50Tm9kZSA9IG51bGw7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gdGhlIG5hbWUgb2YgdGhlIG1lc3NhZ2VcbiAgICAgIEBwYXJhbSB7b2JqZWN0fSBwYXlsb2FkIC0gdGhlIHBheWxvYWQgb2YgdGhlIG1lc3NhZ2VcbiAgICAgIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXQgLSBzcGVjaWZpZXMgdGhlIHRhcmdldCBvZiB0aGUgbWVzc2FnZSBpbiBhIGtleS12YWx1ZSBwYWlycyBvYmplY3RcbiAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gaW4gdGhlIGZvcm06XG4gICAgICB7XG4gICAgICAgICAgZGlyZWN0aW9uIChlaXRoZXIgX1VQIG9yIF9ET1dOKVxuICAgICAgICAgIHNlbGZFeGVjdXRlIChlaXRoZXIgdHJ1ZSB3aGljaCBtZWFucyB0aGUgTGVhZiBzaG91bGQgdHJ5IHRvIGhhbmRsZSB0aGUgbWVzc2FnZSBpdHNlbGYgb3JcbiAgICAgICAgICAgICAgZmFsc2Ugd2hpY2ggbWVhbnMgdGhlIExlYWYgc2hvdWxkIGRpcmVjdGx5IGZvcndhcmQgdGhlIG1lc3NhZ2UgdG8gaXRzIHBhcmVudClcbiAgICAgIH1cbiAgICAgIEByZXR1cm5zIFRoZSBleHBlY3RlZCByZXN1bHQgb2YgdGhpcyBtZXRob2QgaXMgb24gdGhlIGZvcm06XG4gICAgICB7XG4gICAgICAgICAgcmVzcG9uc2U6IGFuIG9iamVjdCB0aGUgc3RydWN0dXJlIG9mIHdoaWNoIGRlcGVuZHMgb24gdGhlIG5hbWUgb2YgdGhlIG1lc3NhZ2VcbiAgICAgICAgICAgICAgYW5kIG1heWJlIGV2ZW4gb24gdGhlIHBheWxvYWRcbiAgICAgICAgICByZXNwb25kZXI6IGEgZGlyZWN0IHJlZmVyZW5jZSB0byB0aGUgbGVhZCB0aGF0IGFjdHVhbGx5IHJlc3BvbmRlZFxuICAgICAgICAgIChvbmx5IHZhbGlkIGZvciBkaXJlYWN0aW9uIF9ET1dOKSBwb3NpdGlvbkRlbHRhOiB0aGUgcG9zaXRpb24gZGVsdGEgb2YgdGhlIHJlc3BvbmRlciBjb21wYXJlZCB0byB0aGUgcmVxdWVzdGVyXG4gICAgICB9XG4gICAgICAqKi9cblxuICAgIH0sIHtcbiAgICAgIGtpbmQ6IFwibWV0aG9kXCIsXG4gICAgICBrZXk6IFwicHV0TWVzc2FnZU9uUGlwZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHB1dE1lc3NhZ2VPblBpcGUobmFtZSwgcGF5bG9hZCwgdGFyZ2V0KSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcblxuICAgICAgICAvLyBkZWZhdWx0IGRpcmVjdGlvbjogX0RPV05cbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgXCJkaXJlY3Rpb25cIikpIHtcbiAgICAgICAgICBvcHRpb25zLmRpcmVjdGlvbiA9IF9DT05TVC5fRElSRUNUSU9OUy5fRE9XTjtcbiAgICAgICAgfSAvLyBkZWZhdWx0IHBvc2l0aW9uRGVsdGEgPSAwXG5cblxuICAgICAgICBpZiAob3B0aW9ucy5kaXJlY3Rpb24gPT09IF9DT05TVC5fRElSRUNUSU9OUy5fRE9XTiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsIFwicG9zaXRpb25EZWx0YVwiKSkge1xuICAgICAgICAgIG9wdGlvbnMucG9zaXRpb25EZWx0YSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5zZWxmRXhlY3V0ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIC8vIGlmIHRoZSBMZWFmIGhhcyBhIFwiaGFuZGxlPG5hbWU+XCIgbWV0aG9kIHdpdGggdGhlIGZpcnN0IGxldHRlciBvZlxuICAgICAgICAgIC8vIG5hbWUgaW4gQ2FwaXRhbCBpdCBydW5zIGl0XG4gICAgICAgICAgdmFyIGhhbmRsaW5nTWV0aG9kTmFtZSA9IFwiaGFuZGxlXCIuY29uY2F0KGhlbHBlci5qc1VjZmlyc3QobmFtZSkpO1xuICAgICAgICAgIHZhciBjYXBhYmxlID0gdHlwZW9mIHRoaXNbaGFuZGxpbmdNZXRob2ROYW1lXSA9PT0gJ2Z1bmN0aW9uJztcblxuICAgICAgICAgIGlmIChjYXBhYmxlKSB7XG4gICAgICAgICAgICB2YXIgcmVzcG9uc2UgPSB0aGlzW2hhbmRsaW5nTWV0aG9kTmFtZV0odGFyZ2V0LCBwYXlsb2FkKTtcblxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlICE9PSBfQ09OU1QuX0JZUEFTUykge1xuICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlOiByZXNwb25zZSxcbiAgICAgICAgICAgICAgICByZXNwb25kZXI6IHRoaXNcbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICBpZiAob3B0aW9ucy5kaXJlY3Rpb24gPT09IF9DT05TVC5fRElSRUNUSU9OUy5fVVApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBbX29iamVjdFNwcmVhZCh7fSwgcmVzdWx0LCB7XG4gICAgICAgICAgICAgICAgICBwb3NpdGlvbkRlbHRhOiBvcHRpb25zLnBvc2l0aW9uRGVsdGFcbiAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5kaXJlY3Rpb24gPT09IF9DT05TVC5fRElSRUNUSU9OUy5fVVApIHtcbiAgICAgICAgICBpZiAodGhpcy5oYXNQYXJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudE5vZGUucHV0TWVzc2FnZU9uUGlwZShuYW1lLCBwYXlsb2FkLCB0YXJnZXQsIHtcbiAgICAgICAgICAgICAgc2VsZkV4ZWN1dGU6IHRydWUsXG4gICAgICAgICAgICAgIGRpcmVjdGlvbjogX0NPTlNULl9ESVJFQ1RJT05TLl9VUFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBtZXNzYWdlIHJlYWNoZXMgdGhlIHRvcCBvZiB0aGUgdHJlZSB3aXRob3V0IGZpbmRpbmcgYW55IGxpYWJsZSB0YXJnZXRcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHJlc3BvbnNlOiBmYWxzZSxcbiAgICAgICAgICAgICAgcmVzcG9uZGVyOiBudWxsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBfQ09OU1QuX0RJUkVDVElPTlMuX0RPV05cbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBraW5kOiBcIm1ldGhvZFwiLFxuICAgICAga2V5OiBcImJ5cGFzc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGJ5cGFzcygpIHtcbiAgICAgICAgcmV0dXJuIF9DT05TVC5fQllQQVNTO1xuICAgICAgfVxuICAgIH1dXG4gIH07XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBMZWFmOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/_Tree/Leaf.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/_Tree/Node.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/_Tree/Node.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _decorate(decorators, factory, superClass, mixins) { var api = _getDecoratorsApi(); if (mixins) { for (var i = 0; i < mixins.length; i++) { api = mixins[i](api); } } var r = factory(function initialize(O) { api.initializeInstanceElements(O, decorated.elements); }, superClass); var decorated = api.decorateClass(_coalesceClassElements(r.d.map(_createElementDescriptor)), decorators); api.initializeClassElements(r.F, decorated.elements); return api.runClassFinishers(r.F, decorated.finishers); }\n\nfunction _getDecoratorsApi() { _getDecoratorsApi = function _getDecoratorsApi() { return api; }; var api = { elementsDefinitionOrder: [[\"method\"], [\"field\"]], initializeInstanceElements: function initializeInstanceElements(O, elements) { [\"method\", \"field\"].forEach(function (kind) { elements.forEach(function (element) { if (element.kind === kind && element.placement === \"own\") { this.defineClassElement(O, element); } }, this); }, this); }, initializeClassElements: function initializeClassElements(F, elements) { var proto = F.prototype; [\"method\", \"field\"].forEach(function (kind) { elements.forEach(function (element) { var placement = element.placement; if (element.kind === kind && (placement === \"static\" || placement === \"prototype\")) { var receiver = placement === \"static\" ? F : proto; this.defineClassElement(receiver, element); } }, this); }, this); }, defineClassElement: function defineClassElement(receiver, element) { var descriptor = element.descriptor; if (element.kind === \"field\") { var initializer = element.initializer; descriptor = { enumerable: descriptor.enumerable, writable: descriptor.writable, configurable: descriptor.configurable, value: initializer === void 0 ? void 0 : initializer.call(receiver) }; } Object.defineProperty(receiver, element.key, descriptor); }, decorateClass: function decorateClass(elements, decorators) { var newElements = []; var finishers = []; var placements = { \"static\": [], prototype: [], own: [] }; elements.forEach(function (element) { this.addElementPlacement(element, placements); }, this); elements.forEach(function (element) { if (!_hasDecorators(element)) return newElements.push(element); var elementFinishersExtras = this.decorateElement(element, placements); newElements.push(elementFinishersExtras.element); newElements.push.apply(newElements, elementFinishersExtras.extras); finishers.push.apply(finishers, elementFinishersExtras.finishers); }, this); if (!decorators) { return { elements: newElements, finishers: finishers }; } var result = this.decorateConstructor(newElements, decorators); finishers.push.apply(finishers, result.finishers); result.finishers = finishers; return result; }, addElementPlacement: function addElementPlacement(element, placements, silent) { var keys = placements[element.placement]; if (!silent && keys.indexOf(element.key) !== -1) { throw new TypeError(\"Duplicated element (\" + element.key + \")\"); } keys.push(element.key); }, decorateElement: function decorateElement(element, placements) { var extras = []; var finishers = []; for (var decorators = element.decorators, i = decorators.length - 1; i >= 0; i--) { var keys = placements[element.placement]; keys.splice(keys.indexOf(element.key), 1); var elementObject = this.fromElementDescriptor(element); var elementFinisherExtras = this.toElementFinisherExtras((0, decorators[i])(elementObject) || elementObject); element = elementFinisherExtras.element; this.addElementPlacement(element, placements); if (elementFinisherExtras.finisher) { finishers.push(elementFinisherExtras.finisher); } var newExtras = elementFinisherExtras.extras; if (newExtras) { for (var j = 0; j < newExtras.length; j++) { this.addElementPlacement(newExtras[j], placements); } extras.push.apply(extras, newExtras); } } return { element: element, finishers: finishers, extras: extras }; }, decorateConstructor: function decorateConstructor(elements, decorators) { var finishers = []; for (var i = decorators.length - 1; i >= 0; i--) { var obj = this.fromClassDescriptor(elements); var elementsAndFinisher = this.toClassDescriptor((0, decorators[i])(obj) || obj); if (elementsAndFinisher.finisher !== undefined) { finishers.push(elementsAndFinisher.finisher); } if (elementsAndFinisher.elements !== undefined) { elements = elementsAndFinisher.elements; for (var j = 0; j < elements.length - 1; j++) { for (var k = j + 1; k < elements.length; k++) { if (elements[j].key === elements[k].key && elements[j].placement === elements[k].placement) { throw new TypeError(\"Duplicated element (\" + elements[j].key + \")\"); } } } } } return { elements: elements, finishers: finishers }; }, fromElementDescriptor: function fromElementDescriptor(element) { var obj = { kind: element.kind, key: element.key, placement: element.placement, descriptor: element.descriptor }; var desc = { value: \"Descriptor\", configurable: true }; Object.defineProperty(obj, Symbol.toStringTag, desc); if (element.kind === \"field\") obj.initializer = element.initializer; return obj; }, toElementDescriptors: function toElementDescriptors(elementObjects) { if (elementObjects === undefined) return; return _toArray(elementObjects).map(function (elementObject) { var element = this.toElementDescriptor(elementObject); this.disallowProperty(elementObject, \"finisher\", \"An element descriptor\"); this.disallowProperty(elementObject, \"extras\", \"An element descriptor\"); return element; }, this); }, toElementDescriptor: function toElementDescriptor(elementObject) { var kind = String(elementObject.kind); if (kind !== \"method\" && kind !== \"field\") { throw new TypeError('An element descriptor\\'s .kind property must be either \"method\" or' + ' \"field\", but a decorator created an element descriptor with' + ' .kind \"' + kind + '\"'); } var key = _toPropertyKey(elementObject.key); var placement = String(elementObject.placement); if (placement !== \"static\" && placement !== \"prototype\" && placement !== \"own\") { throw new TypeError('An element descriptor\\'s .placement property must be one of \"static\",' + ' \"prototype\" or \"own\", but a decorator created an element descriptor' + ' with .placement \"' + placement + '\"'); } var descriptor = elementObject.descriptor; this.disallowProperty(elementObject, \"elements\", \"An element descriptor\"); var element = { kind: kind, key: key, placement: placement, descriptor: Object.assign({}, descriptor) }; if (kind !== \"field\") { this.disallowProperty(elementObject, \"initializer\", \"A method descriptor\"); } else { this.disallowProperty(descriptor, \"get\", \"The property descriptor of a field descriptor\"); this.disallowProperty(descriptor, \"set\", \"The property descriptor of a field descriptor\"); this.disallowProperty(descriptor, \"value\", \"The property descriptor of a field descriptor\"); element.initializer = elementObject.initializer; } return element; }, toElementFinisherExtras: function toElementFinisherExtras(elementObject) { var element = this.toElementDescriptor(elementObject); var finisher = _optionalCallableProperty(elementObject, \"finisher\"); var extras = this.toElementDescriptors(elementObject.extras); return { element: element, finisher: finisher, extras: extras }; }, fromClassDescriptor: function fromClassDescriptor(elements) { var obj = { kind: \"class\", elements: elements.map(this.fromElementDescriptor, this) }; var desc = { value: \"Descriptor\", configurable: true }; Object.defineProperty(obj, Symbol.toStringTag, desc); return obj; }, toClassDescriptor: function toClassDescriptor(obj) { var kind = String(obj.kind); if (kind !== \"class\") { throw new TypeError('A class descriptor\\'s .kind property must be \"class\", but a decorator' + ' created a class descriptor with .kind \"' + kind + '\"'); } this.disallowProperty(obj, \"key\", \"A class descriptor\"); this.disallowProperty(obj, \"placement\", \"A class descriptor\"); this.disallowProperty(obj, \"descriptor\", \"A class descriptor\"); this.disallowProperty(obj, \"initializer\", \"A class descriptor\"); this.disallowProperty(obj, \"extras\", \"A class descriptor\"); var finisher = _optionalCallableProperty(obj, \"finisher\"); var elements = this.toElementDescriptors(obj.elements); return { elements: elements, finisher: finisher }; }, runClassFinishers: function runClassFinishers(constructor, finishers) { for (var i = 0; i < finishers.length; i++) { var newConstructor = (0, finishers[i])(constructor); if (newConstructor !== undefined) { if (typeof newConstructor !== \"function\") { throw new TypeError(\"Finishers must return a constructor.\"); } constructor = newConstructor; } } return constructor; }, disallowProperty: function disallowProperty(obj, name, objectType) { if (obj[name] !== undefined) { throw new TypeError(objectType + \" can't have a .\" + name + \" property.\"); } } }; return api; }\n\nfunction _createElementDescriptor(def) { var key = _toPropertyKey(def.key); var descriptor; if (def.kind === \"method\") { descriptor = { value: def.value, writable: true, configurable: true, enumerable: false }; } else if (def.kind === \"get\") { descriptor = { get: def.value, configurable: true, enumerable: false }; } else if (def.kind === \"set\") { descriptor = { set: def.value, configurable: true, enumerable: false }; } else if (def.kind === \"field\") { descriptor = { configurable: true, writable: true, enumerable: true }; } var element = { kind: def.kind === \"field\" ? \"field\" : \"method\", key: key, placement: def[\"static\"] ? \"static\" : def.kind === \"field\" ? \"own\" : \"prototype\", descriptor: descriptor }; if (def.decorators) element.decorators = def.decorators; if (def.kind === \"field\") element.initializer = def.value; return element; }\n\nfunction _coalesceGetterSetter(element, other) { if (element.descriptor.get !== undefined) { other.descriptor.get = element.descriptor.get; } else { other.descriptor.set = element.descriptor.set; } }\n\nfunction _coalesceClassElements(elements) { var newElements = []; var isSameElement = function isSameElement(other) { return other.kind === \"method\" && other.key === element.key && other.placement === element.placement; }; for (var i = 0; i < elements.length; i++) { var element = elements[i]; var other; if (element.kind === \"method\" && (other = newElements.find(isSameElement))) { if (_isDataDescriptor(element.descriptor) || _isDataDescriptor(other.descriptor)) { if (_hasDecorators(element) || _hasDecorators(other)) { throw new ReferenceError(\"Duplicated methods (\" + element.key + \") can't be decorated.\"); } other.descriptor = element.descriptor; } else { if (_hasDecorators(element)) { if (_hasDecorators(other)) { throw new ReferenceError(\"Decorators can't be placed on different accessors with for \" + \"the same property (\" + element.key + \").\"); } other.decorators = element.decorators; } _coalesceGetterSetter(element, other); } } else { newElements.push(element); } } return newElements; }\n\nfunction _hasDecorators(element) { return element.decorators && element.decorators.length; }\n\nfunction _isDataDescriptor(desc) { return desc !== undefined && !(desc.value === undefined && desc.writable === undefined); }\n\nfunction _optionalCallableProperty(obj, name) { var value = obj[name]; if (value !== undefined && typeof value !== \"function\") { throw new TypeError(\"Expected '\" + name + \"' to be a function\"); } return value; }\n\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\n\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\nfunction _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nvar Leaf = __webpack_require__(/*! ./Leaf */ \"./node_modules/@kissmybutton/motorcortex/dist/_Tree/Leaf.js\");\n\nvar _CONST = __webpack_require__(/*! ./_CONST */ \"./node_modules/@kissmybutton/motorcortex/dist/_Tree/_CONST.js\");\n\nvar _COPY = __webpack_require__(/*! ./_copy */ \"./node_modules/@kissmybutton/motorcortex/dist/_Tree/_copy.js\");\n\nvar systoleDiastole = __webpack_require__(/*! ./decorators/systoleDiastole */ \"./node_modules/@kissmybutton/motorcortex/dist/_Tree/decorators/systoleDiastole.js\");\n\nvar Node = _decorate(null, function (_initialize, _Leaf) {\n  var Node =\n  /*#__PURE__*/\n  function (_Leaf2) {\n    _inherits(Node, _Leaf2);\n\n    function Node() {\n      var _this;\n\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      _classCallCheck(this, Node);\n\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(Node).call(this, props));\n\n      _initialize(_assertThisInitialized(_this));\n\n      _this.isNode = true;\n      /**\n        The object holds the Incidents of the Scene on the format:\n        {\n            <id>: {\n                  id // the id of the Incident object\n                  leaf // the incident object\n                  position // the position of the incident\n            },\n            ...\n        }\n         */\n\n      _this.children = {};\n      _this.calculatedDuration = 0;\n      return _this;\n    }\n\n    return Node;\n  }(_Leaf);\n\n  return {\n    F: Node,\n    d: [{\n      kind: \"get\",\n      key: \"duration\",\n      value: function duration() {\n        return this.calculatedDuration;\n      }\n    }, {\n      kind: \"set\",\n      key: \"duration\",\n      value: function duration(newDuration) {\n        var durationFraction = newDuration / this.duration;\n\n        if (this.props) {\n          if (Object.prototype.hasOwnProperty.call(this.props, \"duration\")) {\n            this.props.duration = newDuration;\n          }\n        }\n\n        this.calculatedDuration = newDuration;\n\n        for (var childKey in this.children) {\n          var child = this.children[childKey];\n          this.editPosition(child.id, child.position * durationFraction, true);\n          child.leaf.systoleDiastole(durationFraction);\n        }\n      }\n    }, {\n      kind: \"method\",\n      key: \"setNewDuration\",\n      value: function setNewDuration(newDuration) {\n        this.duration = newDuration;\n        this.putMessageOnPipe('recalcDuration', {}, 'Groups', {\n          selfExecute: false,\n          direction: _CONST._DIRECTIONS._UP\n        });\n      }\n    }, {\n      kind: \"method\",\n      key: \"_calculateDuration\",\n      value: function _calculateDuration() {\n        var duration = 0;\n\n        for (var childKey in this.children) {\n          var child = this.children[childKey];\n\n          if (child.position + child.leaf.duration > duration) {\n            duration = child.position + child.leaf.duration;\n          }\n        }\n\n        if (duration === this.calculatedDuration) {\n          return false;\n        }\n\n        if (this.props) {\n          if (Object.prototype.hasOwnProperty.call(this.props, \"duration\")) {\n            this.props.duration = duration;\n          }\n        }\n\n        this.calculatedDuration = duration;\n        return true;\n      }\n    }, {\n      kind: \"method\",\n      decorators: [systoleDiastole],\n      key: \"systoleDiastole\",\n      value: function systoleDiastole() {}\n    }, {\n      kind: \"method\",\n      key: \"handleRecalcDuration\",\n      value: function handleRecalcDuration(target, payload) {\n        // eslint-disable-line no-unused-vars\n        if (this._calculateDuration()) {\n          return this.putMessageOnPipe('recalcDuration', {}, 'Groups', {\n            selfExecute: false,\n            direction: _CONST._DIRECTIONS._UP\n          });\n        }\n\n        return true;\n      }\n    }, {\n      kind: \"method\",\n      key: \"getLeafById\",\n      value: function getLeafById(id) {\n        var onlyDirectChild = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n        if (Object.prototype.hasOwnProperty.call(this.children, id)) {\n          return this.children[id].leaf;\n        } else if (onlyDirectChild === false) {\n          for (var child in this.children) {\n            var childLeaf = this.children[child].leaf;\n\n            if (childLeaf.isNode) {\n              var leaf = childLeaf.getLeafById(id);\n\n              if (leaf != null) {\n                return leaf;\n              }\n            }\n          }\n        } else {\n          return null;\n        }\n\n        return null;\n      }\n    }, {\n      kind: \"method\",\n      key: \"getLeafPosition\",\n      value: function getLeafPosition(id) {\n        return this.children[id].position;\n      }\n    }, {\n      kind: \"method\",\n      key: \"checkAddition\",\n      value: function checkAddition(leaf, position) {\n        if (leaf.hasParent) {\n          return {\n            result: false,\n            reason: _COPY._LEAFALREADYASSIGNED\n          };\n        }\n\n        if (position < 0) {\n          return {\n            result: false,\n            reason: _COPY._NEGATIVEPOSITIONNOTALLOWED\n          };\n        }\n\n        return {\n          result: true\n        };\n      }\n    }, {\n      kind: \"method\",\n      key: \"addChild\",\n      value: function addChild(leaf, position) {\n        // this hasParent check occurs here as an extra security check so it\n        // gets executed regardless if the user wants to perform checks or not\n        if (leaf.hasParent) {\n          return {\n            result: false,\n            reason: _COPY._LEAFALREADYASSIGNED\n          };\n        }\n\n        this.children[leaf.id] = {\n          id: leaf.id,\n          leaf: leaf,\n          position: position\n        };\n        leaf.attachToNode(this);\n        this.putMessageOnPipe('recalcDuration', {}, 'Groups', {\n          selfExecute: true,\n          direction: _CONST._DIRECTIONS._UP\n        });\n        return {\n          result: true\n        };\n      }\n    }, {\n      kind: \"method\",\n      key: \"checkRemoveChild\",\n      value: function checkRemoveChild(id) {\n        if (!Object.prototype.hasOwnProperty.call(this.children, id)) {\n          return {\n            result: false,\n            reason: _COPY._LEAFNOTFOUND\n          };\n        }\n\n        return {\n          result: true\n        };\n      }\n    }, {\n      kind: \"method\",\n      key: \"removeChild\",\n      value: function removeChild(id) {\n        this.children[id].leaf.detachFromParent();\n        delete this.children[id];\n        this.putMessageOnPipe('recalcDuration', {}, 'Groups', {\n          selfExecute: true,\n          direction: _CONST._DIRECTIONS._UP\n        });\n        return {\n          result: true\n        };\n      }\n    }, {\n      kind: \"method\",\n      key: \"checkEditPosition\",\n      value: function checkEditPosition(id, position) {\n        if (position < 0) {\n          return {\n            result: false,\n            reason: _COPY._NEGATIVEPOSITIONNOTALLOWED\n          };\n        }\n\n        if (!Object.prototype.hasOwnProperty.call(this.children, id)) {\n          return {\n            result: false,\n            reason: _COPY._LEAFNOTFOUND\n          };\n        }\n\n        return {\n          result: true\n        };\n      }\n    }, {\n      kind: \"method\",\n      key: \"editPosition\",\n      value: function editPosition(id, position) {\n        var bypassRecalcDuration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n        if (Object.prototype.hasOwnProperty.call(this.children, id)) {\n          this.children[id].position = position;\n\n          if (bypassRecalcDuration === false) {\n            this.putMessageOnPipe('recalcDuration', {}, 'Groups', {\n              selfExecute: true,\n              direction: _CONST._DIRECTIONS._UP\n            });\n          }\n\n          return {\n            result: true\n          };\n        }\n      }\n      /**\n      The expected result of this method depends on the direction of the message\n      The direction might either be _UP or _DOWN.\n      In the case of _UP the expected result is identical as on Leaf:\n      {\n          response: an object the structure of which depends on the name of the message\n              and maybe even on the payload\n          responder: a direct reference to the lead that actually responded\n      }\n      In the case of _DOWN though, where multiple Leafs might be eligible in the tree\n      for handling the message the result is on the form:\n      [\n          {\n              response: an object the structure of which depends on the name of the message\n                  and maybe even on the payload\n              responder: a direct reference to the lead that actually responded\n              positionDelta: the position delta of the responder compared to the requester\n          }\n      ]\n      */\n\n    }, {\n      kind: \"method\",\n      key: \"putMessageOnPipe\",\n      value: function putMessageOnPipe(name, payload, target) {\n        var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n        // default direction: _DOWN\n        if (!Object.prototype.hasOwnProperty.call(options, 'direction')) {\n          options.direction = _CONST._DIRECTIONS._DOWN;\n        } // default positionDelta = 0\n\n\n        if (options.direction === _CONST._DIRECTIONS._DOWN && !Object.prototype.hasOwnProperty.call(options, 'positionDelta')) {\n          options.positionDelta = 0;\n        }\n\n        if (options.direction === _CONST._DIRECTIONS._UP) {\n          // if the direction is up\n          return _get(_getPrototypeOf(Node.prototype), \"putMessageOnPipe\", this).call(this, name, payload, target, options); // act exactly as any other Leaf\n        } else {\n          var result = _get(_getPrototypeOf(Node.prototype), \"putMessageOnPipe\", this).call(this, name, payload, target, options);\n\n          if (result.length > 0) {\n            return result;\n          }\n\n          for (var child in this.children) {\n            var leaf = this.children[child].leaf;\n\n            var newOptions = _objectSpread({}, options, {\n              selfExecute: true,\n              positionDelta: options.positionDelta + this.children[child].position\n            });\n\n            result = result.concat(leaf.putMessageOnPipe(name, payload, target, newOptions));\n          }\n\n          return result;\n        }\n      }\n    }]\n  };\n}, Leaf);\n\nmodule.exports = Node;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19UcmVlL05vZGUuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19UcmVlL05vZGUuanM/NTBhZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IHZhciBvd25LZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTsgaWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSAnZnVuY3Rpb24nKSB7IG93bktleXMgPSBvd25LZXlzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSkuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBzeW0pLmVudW1lcmFibGU7IH0pKTsgfSBvd25LZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfZGVjb3JhdGUoZGVjb3JhdG9ycywgZmFjdG9yeSwgc3VwZXJDbGFzcywgbWl4aW5zKSB7IHZhciBhcGkgPSBfZ2V0RGVjb3JhdG9yc0FwaSgpOyBpZiAobWl4aW5zKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgbWl4aW5zLmxlbmd0aDsgaSsrKSB7IGFwaSA9IG1peGluc1tpXShhcGkpOyB9IH0gdmFyIHIgPSBmYWN0b3J5KGZ1bmN0aW9uIGluaXRpYWxpemUoTykgeyBhcGkuaW5pdGlhbGl6ZUluc3RhbmNlRWxlbWVudHMoTywgZGVjb3JhdGVkLmVsZW1lbnRzKTsgfSwgc3VwZXJDbGFzcyk7IHZhciBkZWNvcmF0ZWQgPSBhcGkuZGVjb3JhdGVDbGFzcyhfY29hbGVzY2VDbGFzc0VsZW1lbnRzKHIuZC5tYXAoX2NyZWF0ZUVsZW1lbnREZXNjcmlwdG9yKSksIGRlY29yYXRvcnMpOyBhcGkuaW5pdGlhbGl6ZUNsYXNzRWxlbWVudHMoci5GLCBkZWNvcmF0ZWQuZWxlbWVudHMpOyByZXR1cm4gYXBpLnJ1bkNsYXNzRmluaXNoZXJzKHIuRiwgZGVjb3JhdGVkLmZpbmlzaGVycyk7IH1cblxuZnVuY3Rpb24gX2dldERlY29yYXRvcnNBcGkoKSB7IF9nZXREZWNvcmF0b3JzQXBpID0gZnVuY3Rpb24gX2dldERlY29yYXRvcnNBcGkoKSB7IHJldHVybiBhcGk7IH07IHZhciBhcGkgPSB7IGVsZW1lbnRzRGVmaW5pdGlvbk9yZGVyOiBbW1wibWV0aG9kXCJdLCBbXCJmaWVsZFwiXV0sIGluaXRpYWxpemVJbnN0YW5jZUVsZW1lbnRzOiBmdW5jdGlvbiBpbml0aWFsaXplSW5zdGFuY2VFbGVtZW50cyhPLCBlbGVtZW50cykgeyBbXCJtZXRob2RcIiwgXCJmaWVsZFwiXS5mb3JFYWNoKGZ1bmN0aW9uIChraW5kKSB7IGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHsgaWYgKGVsZW1lbnQua2luZCA9PT0ga2luZCAmJiBlbGVtZW50LnBsYWNlbWVudCA9PT0gXCJvd25cIikgeyB0aGlzLmRlZmluZUNsYXNzRWxlbWVudChPLCBlbGVtZW50KTsgfSB9LCB0aGlzKTsgfSwgdGhpcyk7IH0sIGluaXRpYWxpemVDbGFzc0VsZW1lbnRzOiBmdW5jdGlvbiBpbml0aWFsaXplQ2xhc3NFbGVtZW50cyhGLCBlbGVtZW50cykgeyB2YXIgcHJvdG8gPSBGLnByb3RvdHlwZTsgW1wibWV0aG9kXCIsIFwiZmllbGRcIl0uZm9yRWFjaChmdW5jdGlvbiAoa2luZCkgeyBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7IHZhciBwbGFjZW1lbnQgPSBlbGVtZW50LnBsYWNlbWVudDsgaWYgKGVsZW1lbnQua2luZCA9PT0ga2luZCAmJiAocGxhY2VtZW50ID09PSBcInN0YXRpY1wiIHx8IHBsYWNlbWVudCA9PT0gXCJwcm90b3R5cGVcIikpIHsgdmFyIHJlY2VpdmVyID0gcGxhY2VtZW50ID09PSBcInN0YXRpY1wiID8gRiA6IHByb3RvOyB0aGlzLmRlZmluZUNsYXNzRWxlbWVudChyZWNlaXZlciwgZWxlbWVudCk7IH0gfSwgdGhpcyk7IH0sIHRoaXMpOyB9LCBkZWZpbmVDbGFzc0VsZW1lbnQ6IGZ1bmN0aW9uIGRlZmluZUNsYXNzRWxlbWVudChyZWNlaXZlciwgZWxlbWVudCkgeyB2YXIgZGVzY3JpcHRvciA9IGVsZW1lbnQuZGVzY3JpcHRvcjsgaWYgKGVsZW1lbnQua2luZCA9PT0gXCJmaWVsZFwiKSB7IHZhciBpbml0aWFsaXplciA9IGVsZW1lbnQuaW5pdGlhbGl6ZXI7IGRlc2NyaXB0b3IgPSB7IGVudW1lcmFibGU6IGRlc2NyaXB0b3IuZW51bWVyYWJsZSwgd3JpdGFibGU6IGRlc2NyaXB0b3Iud3JpdGFibGUsIGNvbmZpZ3VyYWJsZTogZGVzY3JpcHRvci5jb25maWd1cmFibGUsIHZhbHVlOiBpbml0aWFsaXplciA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5pdGlhbGl6ZXIuY2FsbChyZWNlaXZlcikgfTsgfSBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVjZWl2ZXIsIGVsZW1lbnQua2V5LCBkZXNjcmlwdG9yKTsgfSwgZGVjb3JhdGVDbGFzczogZnVuY3Rpb24gZGVjb3JhdGVDbGFzcyhlbGVtZW50cywgZGVjb3JhdG9ycykgeyB2YXIgbmV3RWxlbWVudHMgPSBbXTsgdmFyIGZpbmlzaGVycyA9IFtdOyB2YXIgcGxhY2VtZW50cyA9IHsgXCJzdGF0aWNcIjogW10sIHByb3RvdHlwZTogW10sIG93bjogW10gfTsgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkgeyB0aGlzLmFkZEVsZW1lbnRQbGFjZW1lbnQoZWxlbWVudCwgcGxhY2VtZW50cyk7IH0sIHRoaXMpOyBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7IGlmICghX2hhc0RlY29yYXRvcnMoZWxlbWVudCkpIHJldHVybiBuZXdFbGVtZW50cy5wdXNoKGVsZW1lbnQpOyB2YXIgZWxlbWVudEZpbmlzaGVyc0V4dHJhcyA9IHRoaXMuZGVjb3JhdGVFbGVtZW50KGVsZW1lbnQsIHBsYWNlbWVudHMpOyBuZXdFbGVtZW50cy5wdXNoKGVsZW1lbnRGaW5pc2hlcnNFeHRyYXMuZWxlbWVudCk7IG5ld0VsZW1lbnRzLnB1c2guYXBwbHkobmV3RWxlbWVudHMsIGVsZW1lbnRGaW5pc2hlcnNFeHRyYXMuZXh0cmFzKTsgZmluaXNoZXJzLnB1c2guYXBwbHkoZmluaXNoZXJzLCBlbGVtZW50RmluaXNoZXJzRXh0cmFzLmZpbmlzaGVycyk7IH0sIHRoaXMpOyBpZiAoIWRlY29yYXRvcnMpIHsgcmV0dXJuIHsgZWxlbWVudHM6IG5ld0VsZW1lbnRzLCBmaW5pc2hlcnM6IGZpbmlzaGVycyB9OyB9IHZhciByZXN1bHQgPSB0aGlzLmRlY29yYXRlQ29uc3RydWN0b3IobmV3RWxlbWVudHMsIGRlY29yYXRvcnMpOyBmaW5pc2hlcnMucHVzaC5hcHBseShmaW5pc2hlcnMsIHJlc3VsdC5maW5pc2hlcnMpOyByZXN1bHQuZmluaXNoZXJzID0gZmluaXNoZXJzOyByZXR1cm4gcmVzdWx0OyB9LCBhZGRFbGVtZW50UGxhY2VtZW50OiBmdW5jdGlvbiBhZGRFbGVtZW50UGxhY2VtZW50KGVsZW1lbnQsIHBsYWNlbWVudHMsIHNpbGVudCkgeyB2YXIga2V5cyA9IHBsYWNlbWVudHNbZWxlbWVudC5wbGFjZW1lbnRdOyBpZiAoIXNpbGVudCAmJiBrZXlzLmluZGV4T2YoZWxlbWVudC5rZXkpICE9PSAtMSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRHVwbGljYXRlZCBlbGVtZW50IChcIiArIGVsZW1lbnQua2V5ICsgXCIpXCIpOyB9IGtleXMucHVzaChlbGVtZW50LmtleSk7IH0sIGRlY29yYXRlRWxlbWVudDogZnVuY3Rpb24gZGVjb3JhdGVFbGVtZW50KGVsZW1lbnQsIHBsYWNlbWVudHMpIHsgdmFyIGV4dHJhcyA9IFtdOyB2YXIgZmluaXNoZXJzID0gW107IGZvciAodmFyIGRlY29yYXRvcnMgPSBlbGVtZW50LmRlY29yYXRvcnMsIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7IHZhciBrZXlzID0gcGxhY2VtZW50c1tlbGVtZW50LnBsYWNlbWVudF07IGtleXMuc3BsaWNlKGtleXMuaW5kZXhPZihlbGVtZW50LmtleSksIDEpOyB2YXIgZWxlbWVudE9iamVjdCA9IHRoaXMuZnJvbUVsZW1lbnREZXNjcmlwdG9yKGVsZW1lbnQpOyB2YXIgZWxlbWVudEZpbmlzaGVyRXh0cmFzID0gdGhpcy50b0VsZW1lbnRGaW5pc2hlckV4dHJhcygoMCwgZGVjb3JhdG9yc1tpXSkoZWxlbWVudE9iamVjdCkgfHwgZWxlbWVudE9iamVjdCk7IGVsZW1lbnQgPSBlbGVtZW50RmluaXNoZXJFeHRyYXMuZWxlbWVudDsgdGhpcy5hZGRFbGVtZW50UGxhY2VtZW50KGVsZW1lbnQsIHBsYWNlbWVudHMpOyBpZiAoZWxlbWVudEZpbmlzaGVyRXh0cmFzLmZpbmlzaGVyKSB7IGZpbmlzaGVycy5wdXNoKGVsZW1lbnRGaW5pc2hlckV4dHJhcy5maW5pc2hlcik7IH0gdmFyIG5ld0V4dHJhcyA9IGVsZW1lbnRGaW5pc2hlckV4dHJhcy5leHRyYXM7IGlmIChuZXdFeHRyYXMpIHsgZm9yICh2YXIgaiA9IDA7IGogPCBuZXdFeHRyYXMubGVuZ3RoOyBqKyspIHsgdGhpcy5hZGRFbGVtZW50UGxhY2VtZW50KG5ld0V4dHJhc1tqXSwgcGxhY2VtZW50cyk7IH0gZXh0cmFzLnB1c2guYXBwbHkoZXh0cmFzLCBuZXdFeHRyYXMpOyB9IH0gcmV0dXJuIHsgZWxlbWVudDogZWxlbWVudCwgZmluaXNoZXJzOiBmaW5pc2hlcnMsIGV4dHJhczogZXh0cmFzIH07IH0sIGRlY29yYXRlQ29uc3RydWN0b3I6IGZ1bmN0aW9uIGRlY29yYXRlQ29uc3RydWN0b3IoZWxlbWVudHMsIGRlY29yYXRvcnMpIHsgdmFyIGZpbmlzaGVycyA9IFtdOyBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgeyB2YXIgb2JqID0gdGhpcy5mcm9tQ2xhc3NEZXNjcmlwdG9yKGVsZW1lbnRzKTsgdmFyIGVsZW1lbnRzQW5kRmluaXNoZXIgPSB0aGlzLnRvQ2xhc3NEZXNjcmlwdG9yKCgwLCBkZWNvcmF0b3JzW2ldKShvYmopIHx8IG9iaik7IGlmIChlbGVtZW50c0FuZEZpbmlzaGVyLmZpbmlzaGVyICE9PSB1bmRlZmluZWQpIHsgZmluaXNoZXJzLnB1c2goZWxlbWVudHNBbmRGaW5pc2hlci5maW5pc2hlcik7IH0gaWYgKGVsZW1lbnRzQW5kRmluaXNoZXIuZWxlbWVudHMgIT09IHVuZGVmaW5lZCkgeyBlbGVtZW50cyA9IGVsZW1lbnRzQW5kRmluaXNoZXIuZWxlbWVudHM7IGZvciAodmFyIGogPSAwOyBqIDwgZWxlbWVudHMubGVuZ3RoIC0gMTsgaisrKSB7IGZvciAodmFyIGsgPSBqICsgMTsgayA8IGVsZW1lbnRzLmxlbmd0aDsgaysrKSB7IGlmIChlbGVtZW50c1tqXS5rZXkgPT09IGVsZW1lbnRzW2tdLmtleSAmJiBlbGVtZW50c1tqXS5wbGFjZW1lbnQgPT09IGVsZW1lbnRzW2tdLnBsYWNlbWVudCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRHVwbGljYXRlZCBlbGVtZW50IChcIiArIGVsZW1lbnRzW2pdLmtleSArIFwiKVwiKTsgfSB9IH0gfSB9IHJldHVybiB7IGVsZW1lbnRzOiBlbGVtZW50cywgZmluaXNoZXJzOiBmaW5pc2hlcnMgfTsgfSwgZnJvbUVsZW1lbnREZXNjcmlwdG9yOiBmdW5jdGlvbiBmcm9tRWxlbWVudERlc2NyaXB0b3IoZWxlbWVudCkgeyB2YXIgb2JqID0geyBraW5kOiBlbGVtZW50LmtpbmQsIGtleTogZWxlbWVudC5rZXksIHBsYWNlbWVudDogZWxlbWVudC5wbGFjZW1lbnQsIGRlc2NyaXB0b3I6IGVsZW1lbnQuZGVzY3JpcHRvciB9OyB2YXIgZGVzYyA9IHsgdmFsdWU6IFwiRGVzY3JpcHRvclwiLCBjb25maWd1cmFibGU6IHRydWUgfTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgU3ltYm9sLnRvU3RyaW5nVGFnLCBkZXNjKTsgaWYgKGVsZW1lbnQua2luZCA9PT0gXCJmaWVsZFwiKSBvYmouaW5pdGlhbGl6ZXIgPSBlbGVtZW50LmluaXRpYWxpemVyOyByZXR1cm4gb2JqOyB9LCB0b0VsZW1lbnREZXNjcmlwdG9yczogZnVuY3Rpb24gdG9FbGVtZW50RGVzY3JpcHRvcnMoZWxlbWVudE9iamVjdHMpIHsgaWYgKGVsZW1lbnRPYmplY3RzID09PSB1bmRlZmluZWQpIHJldHVybjsgcmV0dXJuIF90b0FycmF5KGVsZW1lbnRPYmplY3RzKS5tYXAoZnVuY3Rpb24gKGVsZW1lbnRPYmplY3QpIHsgdmFyIGVsZW1lbnQgPSB0aGlzLnRvRWxlbWVudERlc2NyaXB0b3IoZWxlbWVudE9iamVjdCk7IHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShlbGVtZW50T2JqZWN0LCBcImZpbmlzaGVyXCIsIFwiQW4gZWxlbWVudCBkZXNjcmlwdG9yXCIpOyB0aGlzLmRpc2FsbG93UHJvcGVydHkoZWxlbWVudE9iamVjdCwgXCJleHRyYXNcIiwgXCJBbiBlbGVtZW50IGRlc2NyaXB0b3JcIik7IHJldHVybiBlbGVtZW50OyB9LCB0aGlzKTsgfSwgdG9FbGVtZW50RGVzY3JpcHRvcjogZnVuY3Rpb24gdG9FbGVtZW50RGVzY3JpcHRvcihlbGVtZW50T2JqZWN0KSB7IHZhciBraW5kID0gU3RyaW5nKGVsZW1lbnRPYmplY3Qua2luZCk7IGlmIChraW5kICE9PSBcIm1ldGhvZFwiICYmIGtpbmQgIT09IFwiZmllbGRcIikgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdBbiBlbGVtZW50IGRlc2NyaXB0b3JcXCdzIC5raW5kIHByb3BlcnR5IG11c3QgYmUgZWl0aGVyIFwibWV0aG9kXCIgb3InICsgJyBcImZpZWxkXCIsIGJ1dCBhIGRlY29yYXRvciBjcmVhdGVkIGFuIGVsZW1lbnQgZGVzY3JpcHRvciB3aXRoJyArICcgLmtpbmQgXCInICsga2luZCArICdcIicpOyB9IHZhciBrZXkgPSBfdG9Qcm9wZXJ0eUtleShlbGVtZW50T2JqZWN0LmtleSk7IHZhciBwbGFjZW1lbnQgPSBTdHJpbmcoZWxlbWVudE9iamVjdC5wbGFjZW1lbnQpOyBpZiAocGxhY2VtZW50ICE9PSBcInN0YXRpY1wiICYmIHBsYWNlbWVudCAhPT0gXCJwcm90b3R5cGVcIiAmJiBwbGFjZW1lbnQgIT09IFwib3duXCIpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQW4gZWxlbWVudCBkZXNjcmlwdG9yXFwncyAucGxhY2VtZW50IHByb3BlcnR5IG11c3QgYmUgb25lIG9mIFwic3RhdGljXCIsJyArICcgXCJwcm90b3R5cGVcIiBvciBcIm93blwiLCBidXQgYSBkZWNvcmF0b3IgY3JlYXRlZCBhbiBlbGVtZW50IGRlc2NyaXB0b3InICsgJyB3aXRoIC5wbGFjZW1lbnQgXCInICsgcGxhY2VtZW50ICsgJ1wiJyk7IH0gdmFyIGRlc2NyaXB0b3IgPSBlbGVtZW50T2JqZWN0LmRlc2NyaXB0b3I7IHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShlbGVtZW50T2JqZWN0LCBcImVsZW1lbnRzXCIsIFwiQW4gZWxlbWVudCBkZXNjcmlwdG9yXCIpOyB2YXIgZWxlbWVudCA9IHsga2luZDoga2luZCwga2V5OiBrZXksIHBsYWNlbWVudDogcGxhY2VtZW50LCBkZXNjcmlwdG9yOiBPYmplY3QuYXNzaWduKHt9LCBkZXNjcmlwdG9yKSB9OyBpZiAoa2luZCAhPT0gXCJmaWVsZFwiKSB7IHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShlbGVtZW50T2JqZWN0LCBcImluaXRpYWxpemVyXCIsIFwiQSBtZXRob2QgZGVzY3JpcHRvclwiKTsgfSBlbHNlIHsgdGhpcy5kaXNhbGxvd1Byb3BlcnR5KGRlc2NyaXB0b3IsIFwiZ2V0XCIsIFwiVGhlIHByb3BlcnR5IGRlc2NyaXB0b3Igb2YgYSBmaWVsZCBkZXNjcmlwdG9yXCIpOyB0aGlzLmRpc2FsbG93UHJvcGVydHkoZGVzY3JpcHRvciwgXCJzZXRcIiwgXCJUaGUgcHJvcGVydHkgZGVzY3JpcHRvciBvZiBhIGZpZWxkIGRlc2NyaXB0b3JcIik7IHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShkZXNjcmlwdG9yLCBcInZhbHVlXCIsIFwiVGhlIHByb3BlcnR5IGRlc2NyaXB0b3Igb2YgYSBmaWVsZCBkZXNjcmlwdG9yXCIpOyBlbGVtZW50LmluaXRpYWxpemVyID0gZWxlbWVudE9iamVjdC5pbml0aWFsaXplcjsgfSByZXR1cm4gZWxlbWVudDsgfSwgdG9FbGVtZW50RmluaXNoZXJFeHRyYXM6IGZ1bmN0aW9uIHRvRWxlbWVudEZpbmlzaGVyRXh0cmFzKGVsZW1lbnRPYmplY3QpIHsgdmFyIGVsZW1lbnQgPSB0aGlzLnRvRWxlbWVudERlc2NyaXB0b3IoZWxlbWVudE9iamVjdCk7IHZhciBmaW5pc2hlciA9IF9vcHRpb25hbENhbGxhYmxlUHJvcGVydHkoZWxlbWVudE9iamVjdCwgXCJmaW5pc2hlclwiKTsgdmFyIGV4dHJhcyA9IHRoaXMudG9FbGVtZW50RGVzY3JpcHRvcnMoZWxlbWVudE9iamVjdC5leHRyYXMpOyByZXR1cm4geyBlbGVtZW50OiBlbGVtZW50LCBmaW5pc2hlcjogZmluaXNoZXIsIGV4dHJhczogZXh0cmFzIH07IH0sIGZyb21DbGFzc0Rlc2NyaXB0b3I6IGZ1bmN0aW9uIGZyb21DbGFzc0Rlc2NyaXB0b3IoZWxlbWVudHMpIHsgdmFyIG9iaiA9IHsga2luZDogXCJjbGFzc1wiLCBlbGVtZW50czogZWxlbWVudHMubWFwKHRoaXMuZnJvbUVsZW1lbnREZXNjcmlwdG9yLCB0aGlzKSB9OyB2YXIgZGVzYyA9IHsgdmFsdWU6IFwiRGVzY3JpcHRvclwiLCBjb25maWd1cmFibGU6IHRydWUgfTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgU3ltYm9sLnRvU3RyaW5nVGFnLCBkZXNjKTsgcmV0dXJuIG9iajsgfSwgdG9DbGFzc0Rlc2NyaXB0b3I6IGZ1bmN0aW9uIHRvQ2xhc3NEZXNjcmlwdG9yKG9iaikgeyB2YXIga2luZCA9IFN0cmluZyhvYmoua2luZCk7IGlmIChraW5kICE9PSBcImNsYXNzXCIpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQSBjbGFzcyBkZXNjcmlwdG9yXFwncyAua2luZCBwcm9wZXJ0eSBtdXN0IGJlIFwiY2xhc3NcIiwgYnV0IGEgZGVjb3JhdG9yJyArICcgY3JlYXRlZCBhIGNsYXNzIGRlc2NyaXB0b3Igd2l0aCAua2luZCBcIicgKyBraW5kICsgJ1wiJyk7IH0gdGhpcy5kaXNhbGxvd1Byb3BlcnR5KG9iaiwgXCJrZXlcIiwgXCJBIGNsYXNzIGRlc2NyaXB0b3JcIik7IHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShvYmosIFwicGxhY2VtZW50XCIsIFwiQSBjbGFzcyBkZXNjcmlwdG9yXCIpOyB0aGlzLmRpc2FsbG93UHJvcGVydHkob2JqLCBcImRlc2NyaXB0b3JcIiwgXCJBIGNsYXNzIGRlc2NyaXB0b3JcIik7IHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShvYmosIFwiaW5pdGlhbGl6ZXJcIiwgXCJBIGNsYXNzIGRlc2NyaXB0b3JcIik7IHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShvYmosIFwiZXh0cmFzXCIsIFwiQSBjbGFzcyBkZXNjcmlwdG9yXCIpOyB2YXIgZmluaXNoZXIgPSBfb3B0aW9uYWxDYWxsYWJsZVByb3BlcnR5KG9iaiwgXCJmaW5pc2hlclwiKTsgdmFyIGVsZW1lbnRzID0gdGhpcy50b0VsZW1lbnREZXNjcmlwdG9ycyhvYmouZWxlbWVudHMpOyByZXR1cm4geyBlbGVtZW50czogZWxlbWVudHMsIGZpbmlzaGVyOiBmaW5pc2hlciB9OyB9LCBydW5DbGFzc0ZpbmlzaGVyczogZnVuY3Rpb24gcnVuQ2xhc3NGaW5pc2hlcnMoY29uc3RydWN0b3IsIGZpbmlzaGVycykgeyBmb3IgKHZhciBpID0gMDsgaSA8IGZpbmlzaGVycy5sZW5ndGg7IGkrKykgeyB2YXIgbmV3Q29uc3RydWN0b3IgPSAoMCwgZmluaXNoZXJzW2ldKShjb25zdHJ1Y3Rvcik7IGlmIChuZXdDb25zdHJ1Y3RvciAhPT0gdW5kZWZpbmVkKSB7IGlmICh0eXBlb2YgbmV3Q29uc3RydWN0b3IgIT09IFwiZnVuY3Rpb25cIikgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmluaXNoZXJzIG11c3QgcmV0dXJuIGEgY29uc3RydWN0b3IuXCIpOyB9IGNvbnN0cnVjdG9yID0gbmV3Q29uc3RydWN0b3I7IH0gfSByZXR1cm4gY29uc3RydWN0b3I7IH0sIGRpc2FsbG93UHJvcGVydHk6IGZ1bmN0aW9uIGRpc2FsbG93UHJvcGVydHkob2JqLCBuYW1lLCBvYmplY3RUeXBlKSB7IGlmIChvYmpbbmFtZV0gIT09IHVuZGVmaW5lZCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKG9iamVjdFR5cGUgKyBcIiBjYW4ndCBoYXZlIGEgLlwiICsgbmFtZSArIFwiIHByb3BlcnR5LlwiKTsgfSB9IH07IHJldHVybiBhcGk7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUVsZW1lbnREZXNjcmlwdG9yKGRlZikgeyB2YXIga2V5ID0gX3RvUHJvcGVydHlLZXkoZGVmLmtleSk7IHZhciBkZXNjcmlwdG9yOyBpZiAoZGVmLmtpbmQgPT09IFwibWV0aG9kXCIpIHsgZGVzY3JpcHRvciA9IHsgdmFsdWU6IGRlZi52YWx1ZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZW51bWVyYWJsZTogZmFsc2UgfTsgfSBlbHNlIGlmIChkZWYua2luZCA9PT0gXCJnZXRcIikgeyBkZXNjcmlwdG9yID0geyBnZXQ6IGRlZi52YWx1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCBlbnVtZXJhYmxlOiBmYWxzZSB9OyB9IGVsc2UgaWYgKGRlZi5raW5kID09PSBcInNldFwiKSB7IGRlc2NyaXB0b3IgPSB7IHNldDogZGVmLnZhbHVlLCBjb25maWd1cmFibGU6IHRydWUsIGVudW1lcmFibGU6IGZhbHNlIH07IH0gZWxzZSBpZiAoZGVmLmtpbmQgPT09IFwiZmllbGRcIikgeyBkZXNjcmlwdG9yID0geyBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCBlbnVtZXJhYmxlOiB0cnVlIH07IH0gdmFyIGVsZW1lbnQgPSB7IGtpbmQ6IGRlZi5raW5kID09PSBcImZpZWxkXCIgPyBcImZpZWxkXCIgOiBcIm1ldGhvZFwiLCBrZXk6IGtleSwgcGxhY2VtZW50OiBkZWZbXCJzdGF0aWNcIl0gPyBcInN0YXRpY1wiIDogZGVmLmtpbmQgPT09IFwiZmllbGRcIiA/IFwib3duXCIgOiBcInByb3RvdHlwZVwiLCBkZXNjcmlwdG9yOiBkZXNjcmlwdG9yIH07IGlmIChkZWYuZGVjb3JhdG9ycykgZWxlbWVudC5kZWNvcmF0b3JzID0gZGVmLmRlY29yYXRvcnM7IGlmIChkZWYua2luZCA9PT0gXCJmaWVsZFwiKSBlbGVtZW50LmluaXRpYWxpemVyID0gZGVmLnZhbHVlOyByZXR1cm4gZWxlbWVudDsgfVxuXG5mdW5jdGlvbiBfY29hbGVzY2VHZXR0ZXJTZXR0ZXIoZWxlbWVudCwgb3RoZXIpIHsgaWYgKGVsZW1lbnQuZGVzY3JpcHRvci5nZXQgIT09IHVuZGVmaW5lZCkgeyBvdGhlci5kZXNjcmlwdG9yLmdldCA9IGVsZW1lbnQuZGVzY3JpcHRvci5nZXQ7IH0gZWxzZSB7IG90aGVyLmRlc2NyaXB0b3Iuc2V0ID0gZWxlbWVudC5kZXNjcmlwdG9yLnNldDsgfSB9XG5cbmZ1bmN0aW9uIF9jb2FsZXNjZUNsYXNzRWxlbWVudHMoZWxlbWVudHMpIHsgdmFyIG5ld0VsZW1lbnRzID0gW107IHZhciBpc1NhbWVFbGVtZW50ID0gZnVuY3Rpb24gaXNTYW1lRWxlbWVudChvdGhlcikgeyByZXR1cm4gb3RoZXIua2luZCA9PT0gXCJtZXRob2RcIiAmJiBvdGhlci5rZXkgPT09IGVsZW1lbnQua2V5ICYmIG90aGVyLnBsYWNlbWVudCA9PT0gZWxlbWVudC5wbGFjZW1lbnQ7IH07IGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIGVsZW1lbnQgPSBlbGVtZW50c1tpXTsgdmFyIG90aGVyOyBpZiAoZWxlbWVudC5raW5kID09PSBcIm1ldGhvZFwiICYmIChvdGhlciA9IG5ld0VsZW1lbnRzLmZpbmQoaXNTYW1lRWxlbWVudCkpKSB7IGlmIChfaXNEYXRhRGVzY3JpcHRvcihlbGVtZW50LmRlc2NyaXB0b3IpIHx8IF9pc0RhdGFEZXNjcmlwdG9yKG90aGVyLmRlc2NyaXB0b3IpKSB7IGlmIChfaGFzRGVjb3JhdG9ycyhlbGVtZW50KSB8fCBfaGFzRGVjb3JhdG9ycyhvdGhlcikpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwiRHVwbGljYXRlZCBtZXRob2RzIChcIiArIGVsZW1lbnQua2V5ICsgXCIpIGNhbid0IGJlIGRlY29yYXRlZC5cIik7IH0gb3RoZXIuZGVzY3JpcHRvciA9IGVsZW1lbnQuZGVzY3JpcHRvcjsgfSBlbHNlIHsgaWYgKF9oYXNEZWNvcmF0b3JzKGVsZW1lbnQpKSB7IGlmIChfaGFzRGVjb3JhdG9ycyhvdGhlcikpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwiRGVjb3JhdG9ycyBjYW4ndCBiZSBwbGFjZWQgb24gZGlmZmVyZW50IGFjY2Vzc29ycyB3aXRoIGZvciBcIiArIFwidGhlIHNhbWUgcHJvcGVydHkgKFwiICsgZWxlbWVudC5rZXkgKyBcIikuXCIpOyB9IG90aGVyLmRlY29yYXRvcnMgPSBlbGVtZW50LmRlY29yYXRvcnM7IH0gX2NvYWxlc2NlR2V0dGVyU2V0dGVyKGVsZW1lbnQsIG90aGVyKTsgfSB9IGVsc2UgeyBuZXdFbGVtZW50cy5wdXNoKGVsZW1lbnQpOyB9IH0gcmV0dXJuIG5ld0VsZW1lbnRzOyB9XG5cbmZ1bmN0aW9uIF9oYXNEZWNvcmF0b3JzKGVsZW1lbnQpIHsgcmV0dXJuIGVsZW1lbnQuZGVjb3JhdG9ycyAmJiBlbGVtZW50LmRlY29yYXRvcnMubGVuZ3RoOyB9XG5cbmZ1bmN0aW9uIF9pc0RhdGFEZXNjcmlwdG9yKGRlc2MpIHsgcmV0dXJuIGRlc2MgIT09IHVuZGVmaW5lZCAmJiAhKGRlc2MudmFsdWUgPT09IHVuZGVmaW5lZCAmJiBkZXNjLndyaXRhYmxlID09PSB1bmRlZmluZWQpOyB9XG5cbmZ1bmN0aW9uIF9vcHRpb25hbENhbGxhYmxlUHJvcGVydHkob2JqLCBuYW1lKSB7IHZhciB2YWx1ZSA9IG9ialtuYW1lXTsgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkICdcIiArIG5hbWUgKyBcIicgdG8gYmUgYSBmdW5jdGlvblwiKTsgfSByZXR1cm4gdmFsdWU7IH1cblxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkoYXJnKSB7IHZhciBrZXkgPSBfdG9QcmltaXRpdmUoYXJnLCBcInN0cmluZ1wiKTsgcmV0dXJuIF90eXBlb2Yoa2V5KSA9PT0gXCJzeW1ib2xcIiA/IGtleSA6IFN0cmluZyhrZXkpOyB9XG5cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZShpbnB1dCwgaGludCkgeyBpZiAoX3R5cGVvZihpbnB1dCkgIT09IFwib2JqZWN0XCIgfHwgaW5wdXQgPT09IG51bGwpIHJldHVybiBpbnB1dDsgdmFyIHByaW0gPSBpbnB1dFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAocHJpbSAhPT0gdW5kZWZpbmVkKSB7IHZhciByZXMgPSBwcmltLmNhbGwoaW5wdXQsIGhpbnQgfHwgXCJkZWZhdWx0XCIpOyBpZiAoX3R5cGVvZihyZXMpICE9PSBcIm9iamVjdFwiKSByZXR1cm4gcmVzOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChoaW50ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShpbnB1dCk7IH1cblxuZnVuY3Rpb24gX3RvQXJyYXkoYXJyKSB7IHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlUmVzdCgpOyB9XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpOyB9XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikgeyBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChpdGVyKSB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaXRlcikgPT09IFwiW29iamVjdCBBcmd1bWVudHNdXCIpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpOyB9XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjsgfVxuXG5mdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LmdldCkgeyBfZ2V0ID0gUmVmbGVjdC5nZXQ7IH0gZWxzZSB7IF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IHZhciBiYXNlID0gX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7IGlmICghYmFzZSkgcmV0dXJuOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpOyBpZiAoZGVzYy5nZXQpIHsgcmV0dXJuIGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpOyB9IHJldHVybiBkZXNjLnZhbHVlOyB9OyB9IHJldHVybiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyIHx8IHRhcmdldCk7IH1cblxuZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkgeyB3aGlsZSAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkgeyBvYmplY3QgPSBfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7IH0gcmV0dXJuIG9iamVjdDsgfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbnZhciBMZWFmID0gcmVxdWlyZSgnLi9MZWFmJyk7XG5cbnZhciBfQ09OU1QgPSByZXF1aXJlKCcuL19DT05TVCcpO1xuXG52YXIgX0NPUFkgPSByZXF1aXJlKCcuL19jb3B5Jyk7XG5cbnZhciBzeXN0b2xlRGlhc3RvbGUgPSByZXF1aXJlKCcuL2RlY29yYXRvcnMvc3lzdG9sZURpYXN0b2xlJyk7XG5cbnZhciBOb2RlID0gX2RlY29yYXRlKG51bGwsIGZ1bmN0aW9uIChfaW5pdGlhbGl6ZSwgX0xlYWYpIHtcbiAgdmFyIE5vZGUgPVxuICAvKiNfX1BVUkVfXyovXG4gIGZ1bmN0aW9uIChfTGVhZjIpIHtcbiAgICBfaW5oZXJpdHMoTm9kZSwgX0xlYWYyKTtcblxuICAgIGZ1bmN0aW9uIE5vZGUoKSB7XG4gICAgICB2YXIgX3RoaXM7XG5cbiAgICAgIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBOb2RlKTtcblxuICAgICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoTm9kZSkuY2FsbCh0aGlzLCBwcm9wcykpO1xuXG4gICAgICBfaW5pdGlhbGl6ZShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG5cbiAgICAgIF90aGlzLmlzTm9kZSA9IHRydWU7XG4gICAgICAvKipcbiAgICAgICAgVGhlIG9iamVjdCBob2xkcyB0aGUgSW5jaWRlbnRzIG9mIHRoZSBTY2VuZSBvbiB0aGUgZm9ybWF0OlxuICAgICAgICB7XG4gICAgICAgICAgICA8aWQ+OiB7XG4gICAgICAgICAgICAgICAgICBpZCAvLyB0aGUgaWQgb2YgdGhlIEluY2lkZW50IG9iamVjdFxuICAgICAgICAgICAgICAgICAgbGVhZiAvLyB0aGUgaW5jaWRlbnQgb2JqZWN0XG4gICAgICAgICAgICAgICAgICBwb3NpdGlvbiAvLyB0aGUgcG9zaXRpb24gb2YgdGhlIGluY2lkZW50XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLi4uXG4gICAgICAgIH1cbiAgICAgICAgICovXG5cbiAgICAgIF90aGlzLmNoaWxkcmVuID0ge307XG4gICAgICBfdGhpcy5jYWxjdWxhdGVkRHVyYXRpb24gPSAwO1xuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIHJldHVybiBOb2RlO1xuICB9KF9MZWFmKTtcblxuICByZXR1cm4ge1xuICAgIEY6IE5vZGUsXG4gICAgZDogW3tcbiAgICAgIGtpbmQ6IFwiZ2V0XCIsXG4gICAgICBrZXk6IFwiZHVyYXRpb25cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkdXJhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsY3VsYXRlZER1cmF0aW9uO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtpbmQ6IFwic2V0XCIsXG4gICAgICBrZXk6IFwiZHVyYXRpb25cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkdXJhdGlvbihuZXdEdXJhdGlvbikge1xuICAgICAgICB2YXIgZHVyYXRpb25GcmFjdGlvbiA9IG5ld0R1cmF0aW9uIC8gdGhpcy5kdXJhdGlvbjtcblxuICAgICAgICBpZiAodGhpcy5wcm9wcykge1xuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5wcm9wcywgXCJkdXJhdGlvblwiKSkge1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5kdXJhdGlvbiA9IG5ld0R1cmF0aW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2FsY3VsYXRlZER1cmF0aW9uID0gbmV3RHVyYXRpb247XG5cbiAgICAgICAgZm9yICh2YXIgY2hpbGRLZXkgaW4gdGhpcy5jaGlsZHJlbikge1xuICAgICAgICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5bY2hpbGRLZXldO1xuICAgICAgICAgIHRoaXMuZWRpdFBvc2l0aW9uKGNoaWxkLmlkLCBjaGlsZC5wb3NpdGlvbiAqIGR1cmF0aW9uRnJhY3Rpb24sIHRydWUpO1xuICAgICAgICAgIGNoaWxkLmxlYWYuc3lzdG9sZURpYXN0b2xlKGR1cmF0aW9uRnJhY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2luZDogXCJtZXRob2RcIixcbiAgICAgIGtleTogXCJzZXROZXdEdXJhdGlvblwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldE5ld0R1cmF0aW9uKG5ld0R1cmF0aW9uKSB7XG4gICAgICAgIHRoaXMuZHVyYXRpb24gPSBuZXdEdXJhdGlvbjtcbiAgICAgICAgdGhpcy5wdXRNZXNzYWdlT25QaXBlKCdyZWNhbGNEdXJhdGlvbicsIHt9LCAnR3JvdXBzJywge1xuICAgICAgICAgIHNlbGZFeGVjdXRlOiBmYWxzZSxcbiAgICAgICAgICBkaXJlY3Rpb246IF9DT05TVC5fRElSRUNUSU9OUy5fVVBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2luZDogXCJtZXRob2RcIixcbiAgICAgIGtleTogXCJfY2FsY3VsYXRlRHVyYXRpb25cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY2FsY3VsYXRlRHVyYXRpb24oKSB7XG4gICAgICAgIHZhciBkdXJhdGlvbiA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgY2hpbGRLZXkgaW4gdGhpcy5jaGlsZHJlbikge1xuICAgICAgICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5bY2hpbGRLZXldO1xuXG4gICAgICAgICAgaWYgKGNoaWxkLnBvc2l0aW9uICsgY2hpbGQubGVhZi5kdXJhdGlvbiA+IGR1cmF0aW9uKSB7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IGNoaWxkLnBvc2l0aW9uICsgY2hpbGQubGVhZi5kdXJhdGlvbjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZHVyYXRpb24gPT09IHRoaXMuY2FsY3VsYXRlZER1cmF0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMucHJvcHMpIHtcbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMucHJvcHMsIFwiZHVyYXRpb25cIikpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcHMuZHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNhbGN1bGF0ZWREdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBraW5kOiBcIm1ldGhvZFwiLFxuICAgICAgZGVjb3JhdG9yczogW3N5c3RvbGVEaWFzdG9sZV0sXG4gICAgICBrZXk6IFwic3lzdG9sZURpYXN0b2xlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc3lzdG9sZURpYXN0b2xlKCkge31cbiAgICB9LCB7XG4gICAgICBraW5kOiBcIm1ldGhvZFwiLFxuICAgICAga2V5OiBcImhhbmRsZVJlY2FsY0R1cmF0aW9uXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlUmVjYWxjRHVyYXRpb24odGFyZ2V0LCBwYXlsb2FkKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgICAgaWYgKHRoaXMuX2NhbGN1bGF0ZUR1cmF0aW9uKCkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wdXRNZXNzYWdlT25QaXBlKCdyZWNhbGNEdXJhdGlvbicsIHt9LCAnR3JvdXBzJywge1xuICAgICAgICAgICAgc2VsZkV4ZWN1dGU6IGZhbHNlLFxuICAgICAgICAgICAgZGlyZWN0aW9uOiBfQ09OU1QuX0RJUkVDVElPTlMuX1VQXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBraW5kOiBcIm1ldGhvZFwiLFxuICAgICAga2V5OiBcImdldExlYWZCeUlkXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TGVhZkJ5SWQoaWQpIHtcbiAgICAgICAgdmFyIG9ubHlEaXJlY3RDaGlsZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG5cbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmNoaWxkcmVuLCBpZCkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbltpZF0ubGVhZjtcbiAgICAgICAgfSBlbHNlIGlmIChvbmx5RGlyZWN0Q2hpbGQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgZm9yICh2YXIgY2hpbGQgaW4gdGhpcy5jaGlsZHJlbikge1xuICAgICAgICAgICAgdmFyIGNoaWxkTGVhZiA9IHRoaXMuY2hpbGRyZW5bY2hpbGRdLmxlYWY7XG5cbiAgICAgICAgICAgIGlmIChjaGlsZExlYWYuaXNOb2RlKSB7XG4gICAgICAgICAgICAgIHZhciBsZWFmID0gY2hpbGRMZWFmLmdldExlYWZCeUlkKGlkKTtcblxuICAgICAgICAgICAgICBpZiAobGVhZiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlYWY7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBraW5kOiBcIm1ldGhvZFwiLFxuICAgICAga2V5OiBcImdldExlYWZQb3NpdGlvblwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldExlYWZQb3NpdGlvbihpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbltpZF0ucG9zaXRpb247XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2luZDogXCJtZXRob2RcIixcbiAgICAgIGtleTogXCJjaGVja0FkZGl0aW9uXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tBZGRpdGlvbihsZWFmLCBwb3NpdGlvbikge1xuICAgICAgICBpZiAobGVhZi5oYXNQYXJlbnQpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdWx0OiBmYWxzZSxcbiAgICAgICAgICAgIHJlYXNvbjogX0NPUFkuX0xFQUZBTFJFQURZQVNTSUdORURcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgMCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXN1bHQ6IGZhbHNlLFxuICAgICAgICAgICAgcmVhc29uOiBfQ09QWS5fTkVHQVRJVkVQT1NJVElPTk5PVEFMTE9XRURcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZXN1bHQ6IHRydWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBraW5kOiBcIm1ldGhvZFwiLFxuICAgICAga2V5OiBcImFkZENoaWxkXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkQ2hpbGQobGVhZiwgcG9zaXRpb24pIHtcbiAgICAgICAgLy8gdGhpcyBoYXNQYXJlbnQgY2hlY2sgb2NjdXJzIGhlcmUgYXMgYW4gZXh0cmEgc2VjdXJpdHkgY2hlY2sgc28gaXRcbiAgICAgICAgLy8gZ2V0cyBleGVjdXRlZCByZWdhcmRsZXNzIGlmIHRoZSB1c2VyIHdhbnRzIHRvIHBlcmZvcm0gY2hlY2tzIG9yIG5vdFxuICAgICAgICBpZiAobGVhZi5oYXNQYXJlbnQpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdWx0OiBmYWxzZSxcbiAgICAgICAgICAgIHJlYXNvbjogX0NPUFkuX0xFQUZBTFJFQURZQVNTSUdORURcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jaGlsZHJlbltsZWFmLmlkXSA9IHtcbiAgICAgICAgICBpZDogbGVhZi5pZCxcbiAgICAgICAgICBsZWFmOiBsZWFmLFxuICAgICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvblxuICAgICAgICB9O1xuICAgICAgICBsZWFmLmF0dGFjaFRvTm9kZSh0aGlzKTtcbiAgICAgICAgdGhpcy5wdXRNZXNzYWdlT25QaXBlKCdyZWNhbGNEdXJhdGlvbicsIHt9LCAnR3JvdXBzJywge1xuICAgICAgICAgIHNlbGZFeGVjdXRlOiB0cnVlLFxuICAgICAgICAgIGRpcmVjdGlvbjogX0NPTlNULl9ESVJFQ1RJT05TLl9VUFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZXN1bHQ6IHRydWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBraW5kOiBcIm1ldGhvZFwiLFxuICAgICAga2V5OiBcImNoZWNrUmVtb3ZlQ2hpbGRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja1JlbW92ZUNoaWxkKGlkKSB7XG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuY2hpbGRyZW4sIGlkKSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXN1bHQ6IGZhbHNlLFxuICAgICAgICAgICAgcmVhc29uOiBfQ09QWS5fTEVBRk5PVEZPVU5EXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVzdWx0OiB0cnVlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2luZDogXCJtZXRob2RcIixcbiAgICAgIGtleTogXCJyZW1vdmVDaGlsZFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUNoaWxkKGlkKSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW5baWRdLmxlYWYuZGV0YWNoRnJvbVBhcmVudCgpO1xuICAgICAgICBkZWxldGUgdGhpcy5jaGlsZHJlbltpZF07XG4gICAgICAgIHRoaXMucHV0TWVzc2FnZU9uUGlwZSgncmVjYWxjRHVyYXRpb24nLCB7fSwgJ0dyb3VwcycsIHtcbiAgICAgICAgICBzZWxmRXhlY3V0ZTogdHJ1ZSxcbiAgICAgICAgICBkaXJlY3Rpb246IF9DT05TVC5fRElSRUNUSU9OUy5fVVBcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVzdWx0OiB0cnVlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2luZDogXCJtZXRob2RcIixcbiAgICAgIGtleTogXCJjaGVja0VkaXRQb3NpdGlvblwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrRWRpdFBvc2l0aW9uKGlkLCBwb3NpdGlvbikge1xuICAgICAgICBpZiAocG9zaXRpb24gPCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3VsdDogZmFsc2UsXG4gICAgICAgICAgICByZWFzb246IF9DT1BZLl9ORUdBVElWRVBPU0lUSU9OTk9UQUxMT1dFRFxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmNoaWxkcmVuLCBpZCkpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdWx0OiBmYWxzZSxcbiAgICAgICAgICAgIHJlYXNvbjogX0NPUFkuX0xFQUZOT1RGT1VORFxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlc3VsdDogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtpbmQ6IFwibWV0aG9kXCIsXG4gICAgICBrZXk6IFwiZWRpdFBvc2l0aW9uXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZWRpdFBvc2l0aW9uKGlkLCBwb3NpdGlvbikge1xuICAgICAgICB2YXIgYnlwYXNzUmVjYWxjRHVyYXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuXG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5jaGlsZHJlbiwgaWQpKSB7XG4gICAgICAgICAgdGhpcy5jaGlsZHJlbltpZF0ucG9zaXRpb24gPSBwb3NpdGlvbjtcblxuICAgICAgICAgIGlmIChieXBhc3NSZWNhbGNEdXJhdGlvbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMucHV0TWVzc2FnZU9uUGlwZSgncmVjYWxjRHVyYXRpb24nLCB7fSwgJ0dyb3VwcycsIHtcbiAgICAgICAgICAgICAgc2VsZkV4ZWN1dGU6IHRydWUsXG4gICAgICAgICAgICAgIGRpcmVjdGlvbjogX0NPTlNULl9ESVJFQ1RJT05TLl9VUFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3VsdDogdHJ1ZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgVGhlIGV4cGVjdGVkIHJlc3VsdCBvZiB0aGlzIG1ldGhvZCBkZXBlbmRzIG9uIHRoZSBkaXJlY3Rpb24gb2YgdGhlIG1lc3NhZ2VcbiAgICAgIFRoZSBkaXJlY3Rpb24gbWlnaHQgZWl0aGVyIGJlIF9VUCBvciBfRE9XTi5cbiAgICAgIEluIHRoZSBjYXNlIG9mIF9VUCB0aGUgZXhwZWN0ZWQgcmVzdWx0IGlzIGlkZW50aWNhbCBhcyBvbiBMZWFmOlxuICAgICAge1xuICAgICAgICAgIHJlc3BvbnNlOiBhbiBvYmplY3QgdGhlIHN0cnVjdHVyZSBvZiB3aGljaCBkZXBlbmRzIG9uIHRoZSBuYW1lIG9mIHRoZSBtZXNzYWdlXG4gICAgICAgICAgICAgIGFuZCBtYXliZSBldmVuIG9uIHRoZSBwYXlsb2FkXG4gICAgICAgICAgcmVzcG9uZGVyOiBhIGRpcmVjdCByZWZlcmVuY2UgdG8gdGhlIGxlYWQgdGhhdCBhY3R1YWxseSByZXNwb25kZWRcbiAgICAgIH1cbiAgICAgIEluIHRoZSBjYXNlIG9mIF9ET1dOIHRob3VnaCwgd2hlcmUgbXVsdGlwbGUgTGVhZnMgbWlnaHQgYmUgZWxpZ2libGUgaW4gdGhlIHRyZWVcbiAgICAgIGZvciBoYW5kbGluZyB0aGUgbWVzc2FnZSB0aGUgcmVzdWx0IGlzIG9uIHRoZSBmb3JtOlxuICAgICAgW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgICAgcmVzcG9uc2U6IGFuIG9iamVjdCB0aGUgc3RydWN0dXJlIG9mIHdoaWNoIGRlcGVuZHMgb24gdGhlIG5hbWUgb2YgdGhlIG1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgIGFuZCBtYXliZSBldmVuIG9uIHRoZSBwYXlsb2FkXG4gICAgICAgICAgICAgIHJlc3BvbmRlcjogYSBkaXJlY3QgcmVmZXJlbmNlIHRvIHRoZSBsZWFkIHRoYXQgYWN0dWFsbHkgcmVzcG9uZGVkXG4gICAgICAgICAgICAgIHBvc2l0aW9uRGVsdGE6IHRoZSBwb3NpdGlvbiBkZWx0YSBvZiB0aGUgcmVzcG9uZGVyIGNvbXBhcmVkIHRvIHRoZSByZXF1ZXN0ZXJcbiAgICAgICAgICB9XG4gICAgICBdXG4gICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2luZDogXCJtZXRob2RcIixcbiAgICAgIGtleTogXCJwdXRNZXNzYWdlT25QaXBlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcHV0TWVzc2FnZU9uUGlwZShuYW1lLCBwYXlsb2FkLCB0YXJnZXQpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9O1xuXG4gICAgICAgIC8vIGRlZmF1bHQgZGlyZWN0aW9uOiBfRE9XTlxuICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCAnZGlyZWN0aW9uJykpIHtcbiAgICAgICAgICBvcHRpb25zLmRpcmVjdGlvbiA9IF9DT05TVC5fRElSRUNUSU9OUy5fRE9XTjtcbiAgICAgICAgfSAvLyBkZWZhdWx0IHBvc2l0aW9uRGVsdGEgPSAwXG5cblxuICAgICAgICBpZiAob3B0aW9ucy5kaXJlY3Rpb24gPT09IF9DT05TVC5fRElSRUNUSU9OUy5fRE9XTiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsICdwb3NpdGlvbkRlbHRhJykpIHtcbiAgICAgICAgICBvcHRpb25zLnBvc2l0aW9uRGVsdGEgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuZGlyZWN0aW9uID09PSBfQ09OU1QuX0RJUkVDVElPTlMuX1VQKSB7XG4gICAgICAgICAgLy8gaWYgdGhlIGRpcmVjdGlvbiBpcyB1cFxuICAgICAgICAgIHJldHVybiBfZ2V0KF9nZXRQcm90b3R5cGVPZihOb2RlLnByb3RvdHlwZSksIFwicHV0TWVzc2FnZU9uUGlwZVwiLCB0aGlzKS5jYWxsKHRoaXMsIG5hbWUsIHBheWxvYWQsIHRhcmdldCwgb3B0aW9ucyk7IC8vIGFjdCBleGFjdGx5IGFzIGFueSBvdGhlciBMZWFmXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IF9nZXQoX2dldFByb3RvdHlwZU9mKE5vZGUucHJvdG90eXBlKSwgXCJwdXRNZXNzYWdlT25QaXBlXCIsIHRoaXMpLmNhbGwodGhpcywgbmFtZSwgcGF5bG9hZCwgdGFyZ2V0LCBvcHRpb25zKTtcblxuICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKHZhciBjaGlsZCBpbiB0aGlzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICB2YXIgbGVhZiA9IHRoaXMuY2hpbGRyZW5bY2hpbGRdLmxlYWY7XG5cbiAgICAgICAgICAgIHZhciBuZXdPcHRpb25zID0gX29iamVjdFNwcmVhZCh7fSwgb3B0aW9ucywge1xuICAgICAgICAgICAgICBzZWxmRXhlY3V0ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgcG9zaXRpb25EZWx0YTogb3B0aW9ucy5wb3NpdGlvbkRlbHRhICsgdGhpcy5jaGlsZHJlbltjaGlsZF0ucG9zaXRpb25cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KGxlYWYucHV0TWVzc2FnZU9uUGlwZShuYW1lLCBwYXlsb2FkLCB0YXJnZXQsIG5ld09wdGlvbnMpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfV1cbiAgfTtcbn0sIExlYWYpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5vZGU7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/_Tree/Node.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/_Tree/_CONST.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/_Tree/_CONST.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = {\n  _STATE: {\n    _ROOTOFTREE: \"root_of_descriptive_clip\",\n    // this Descriptive Incident is directly attached to a real Clip\n    _FREE: \"free\" // this DI is neither attached to a real Clip nor has a parent on the Descriptive Tree\n\n  },\n  _DIRECTIONS: {\n    _UP: \"up\",\n    _DOWN: \"down\"\n  },\n  _TARGETTYPES: {\n    _ROOTOFTREE: \"native.tree.rootoftree\"\n  },\n  _BYPASS: \"native.tree.bypass\"\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19UcmVlL19DT05TVC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Aa2lzc215YnV0dG9uL21vdG9yY29ydGV4L2Rpc3QvX1RyZWUvX0NPTlNULmpzP2ZiMWYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBfU1RBVEU6IHtcbiAgICBfUk9PVE9GVFJFRTogXCJyb290X29mX2Rlc2NyaXB0aXZlX2NsaXBcIixcbiAgICAvLyB0aGlzIERlc2NyaXB0aXZlIEluY2lkZW50IGlzIGRpcmVjdGx5IGF0dGFjaGVkIHRvIGEgcmVhbCBDbGlwXG4gICAgX0ZSRUU6IFwiZnJlZVwiIC8vIHRoaXMgREkgaXMgbmVpdGhlciBhdHRhY2hlZCB0byBhIHJlYWwgQ2xpcCBub3IgaGFzIGEgcGFyZW50IG9uIHRoZSBEZXNjcmlwdGl2ZSBUcmVlXG5cbiAgfSxcbiAgX0RJUkVDVElPTlM6IHtcbiAgICBfVVA6IFwidXBcIixcbiAgICBfRE9XTjogXCJkb3duXCJcbiAgfSxcbiAgX1RBUkdFVFRZUEVTOiB7XG4gICAgX1JPT1RPRlRSRUU6IFwibmF0aXZlLnRyZWUucm9vdG9mdHJlZVwiXG4gIH0sXG4gIF9CWVBBU1M6IFwibmF0aXZlLnRyZWUuYnlwYXNzXCJcbn07Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/_Tree/_CONST.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/_Tree/_copy.js":
/*!********************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/_Tree/_copy.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = {\n  _LEAFALREADYASSIGNED: \"Leaf has already been attached to another Node\",\n  _NEGATIVEPOSITIONNOTALLOWED: \"Negative positioning of childs on nodes is not allowed\",\n  _LEAFNOTFOUND: \"The Leaf with the requested id couldn't be found on the Tree\"\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19UcmVlL19jb3B5LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvZGlzdC9fVHJlZS9fY29weS5qcz8yMjZmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgX0xFQUZBTFJFQURZQVNTSUdORUQ6IFwiTGVhZiBoYXMgYWxyZWFkeSBiZWVuIGF0dGFjaGVkIHRvIGFub3RoZXIgTm9kZVwiLFxuICBfTkVHQVRJVkVQT1NJVElPTk5PVEFMTE9XRUQ6IFwiTmVnYXRpdmUgcG9zaXRpb25pbmcgb2YgY2hpbGRzIG9uIG5vZGVzIGlzIG5vdCBhbGxvd2VkXCIsXG4gIF9MRUFGTk9URk9VTkQ6IFwiVGhlIExlYWYgd2l0aCB0aGUgcmVxdWVzdGVkIGlkIGNvdWxkbid0IGJlIGZvdW5kIG9uIHRoZSBUcmVlXCJcbn07Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/_Tree/_copy.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/_Tree/decorators/systoleDiastole.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/_Tree/decorators/systoleDiastole.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction systoleDiastole(payload) {\n  payload.descriptor.value = function (durationFraction) {\n    this.duration = this.duration * durationFraction;\n  };\n}\n\nmodule.exports = systoleDiastole;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19UcmVlL2RlY29yYXRvcnMvc3lzdG9sZURpYXN0b2xlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvZGlzdC9fVHJlZS9kZWNvcmF0b3JzL3N5c3RvbGVEaWFzdG9sZS5qcz9mYzFhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBzeXN0b2xlRGlhc3RvbGUocGF5bG9hZCkge1xuICBwYXlsb2FkLmRlc2NyaXB0b3IudmFsdWUgPSBmdW5jdGlvbiAoZHVyYXRpb25GcmFjdGlvbikge1xuICAgIHRoaXMuZHVyYXRpb24gPSB0aGlzLmR1cmF0aW9uICogZHVyYXRpb25GcmFjdGlvbjtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzeXN0b2xlRGlhc3RvbGU7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/_Tree/decorators/systoleDiastole.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/** @classdesc Helper maintains a number of helpful functions in a single point  */\nvar conf = __webpack_require__(/*! ../configuration/generalConf */ \"./node_modules/@kissmybutton/motorcortex/dist/configuration/generalConf.js\");\n\nvar Helper =\n/*#__PURE__*/\nfunction () {\n  function Helper(configuration) {\n    _classCallCheck(this, Helper);\n\n    var logLevel = conf.logLevel;\n\n    if (configuration) {\n      if (Object.prototype.hasOwnProperty.call(configuration, \"logLevel\")) {\n        logLevel = configuration.logLevel;\n      }\n    }\n\n    this.lanesMCIDattrsSeperator = '___';\n\n    for (var i = 0; i < conf.logTypes.length; i++) {\n      var logType = conf.logTypes[i];\n\n      if (logLevel >= logType.level) {\n        if (conf.testMode === true) {\n          this[logType.key] = window.console.log.bind(window.console, \"MotorCortex - \".concat(logType.key, \": \"));\n        } else {\n          this[logType.key] = window.console.log.bind(window.console, \"MotorCortex - %c%s\", logType.style);\n        }\n      } else this[logType.key] = function () {};\n    }\n\n    if (logLevel >= 3) {\n      this.log = window.console.log.bind(window.console, \"MotorCortex - \");\n    } else this.log = function () {};\n  }\n\n  _createClass(Helper, [{\n    key: \"renderTemplate\",\n    value: function renderTemplate(templateString, templateVars) {\n      return new Function(\"return `\" + templateString + \"`;\").call(templateVars);\n    }\n    /**\n     * @returns {string} in the form \"1bc45f78-ab23-jl59\"\n     */\n\n  }, {\n    key: \"getAnId\",\n    value: function getAnId() {\n      var underscore = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var specialChar = '-';\n\n      if (underscore) {\n        specialChar = '_';\n      }\n\n      function s4() {\n        return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);\n      }\n\n      return s4() + s4() + specialChar + s4() + specialChar + s4();\n    }\n  }, {\n    key: \"getLaneKey\",\n    value: function getLaneKey(mcid, attribute) {\n      return mcid + this.lanesMCIDattrsSeperator + attribute;\n    }\n  }, {\n    key: \"getMCIDandAttrOutOfLaneKey\",\n    value: function getMCIDandAttrOutOfLaneKey(laneKey) {\n      var laneArray = laneKey.split(this.lanesMCIDattrsSeperator);\n      return {\n        mcid: laneArray[0],\n        attribute: laneArray[1]\n      };\n    }\n  }, {\n    key: \"getElementByMCID\",\n    value: function getElementByMCID(context, mcid) {\n      return context.rootElement.querySelectorAll('[' + conf.elements_data_attribute_name + '=\"' + mcid + '\"]')[0];\n    }\n    /**\n    subdivision might be rounding the number to its:\n    - units (subdivision = 1)\n    - tenths (subdivision = 10)\n    - hundreds (subdivision = 100)\n    - thousands (subdivision = 1000)\n     @param {string} int\n     @param {subdivision} int\n     @returns {int} the rounded number\n    */\n\n  }, {\n    key: \"roundNumberTo\",\n    value: function roundNumberTo(number, subdivision) {\n      return Math.round(number / subdivision) * subdivision;\n    }\n  }, {\n    key: \"isInteger\",\n    value: function isInteger(number) {\n      if (number === parseInt(number, 10)) {\n        return true;\n      } else {\n        return false;\n      }\n    }\n  }, {\n    key: \"isString\",\n    value: function isString(test) {\n      if (typeof test === 'string' || test instanceof String) {\n        return true;\n      } else {\n        return false;\n      }\n    }\n  }, {\n    key: \"isObject\",\n    value: function isObject(test) {\n      return _typeof(test) === \"object\";\n    }\n  }, {\n    key: \"isArray\",\n    value: function isArray(test) {\n      return Array.isArray(test);\n    }\n  }, {\n    key: \"isFunction\",\n    value: function isFunction(functionToCheck) {\n      return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';\n    }\n    /**\n     * systole / diastole of the projections\n     * @returns {array} - collection of objects with keys: {id, start, end, startDelta}\n     **/\n\n  }, {\n    key: \"systoleDiastoleProjections\",\n    value: function systoleDiastoleProjections(projections, durationFraction, anchorPoint) {\n      var alteredProjections = [];\n\n      for (var i = 0; i < projections.length; i++) {\n        var projectedIncident = projections[i];\n        var msInResizedPortion = projectedIncident.parentMillisecond - anchorPoint;\n\n        if (durationFraction != 1) {\n          alteredProjections.push({\n            id: projectedIncident.incident.id,\n            start: msInResizedPortion * durationFraction + anchorPoint,\n            end: msInResizedPortion * durationFraction + anchorPoint + projectedIncident.incident.duration * durationFraction,\n            startDelta: msInResizedPortion * durationFraction + anchorPoint - projectedIncident.millisecond\n          });\n        }\n      }\n\n      return alteredProjections;\n    }\n  }, {\n    key: \"jsUcfirst\",\n    value: function jsUcfirst(string) {\n      return string.charAt(0).toUpperCase() + string.slice(1);\n    }\n  }]);\n\n  return Helper;\n}();\n\nmodule.exports = Helper;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19jb3JlVXRpbHMvSGVscGVyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvZGlzdC9fY29yZVV0aWxzL0hlbHBlci5qcz85ZDBiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbi8qKiBAY2xhc3NkZXNjIEhlbHBlciBtYWludGFpbnMgYSBudW1iZXIgb2YgaGVscGZ1bCBmdW5jdGlvbnMgaW4gYSBzaW5nbGUgcG9pbnQgICovXG52YXIgY29uZiA9IHJlcXVpcmUoJy4uL2NvbmZpZ3VyYXRpb24vZ2VuZXJhbENvbmYnKTtcblxudmFyIEhlbHBlciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEhlbHBlcihjb25maWd1cmF0aW9uKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEhlbHBlcik7XG5cbiAgICB2YXIgbG9nTGV2ZWwgPSBjb25mLmxvZ0xldmVsO1xuXG4gICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY29uZmlndXJhdGlvbiwgXCJsb2dMZXZlbFwiKSkge1xuICAgICAgICBsb2dMZXZlbCA9IGNvbmZpZ3VyYXRpb24ubG9nTGV2ZWw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5sYW5lc01DSURhdHRyc1NlcGVyYXRvciA9ICdfX18nO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb25mLmxvZ1R5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbG9nVHlwZSA9IGNvbmYubG9nVHlwZXNbaV07XG5cbiAgICAgIGlmIChsb2dMZXZlbCA+PSBsb2dUeXBlLmxldmVsKSB7XG4gICAgICAgIGlmIChjb25mLnRlc3RNb2RlID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpc1tsb2dUeXBlLmtleV0gPSB3aW5kb3cuY29uc29sZS5sb2cuYmluZCh3aW5kb3cuY29uc29sZSwgXCJNb3RvckNvcnRleCAtIFwiLmNvbmNhdChsb2dUeXBlLmtleSwgXCI6IFwiKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpc1tsb2dUeXBlLmtleV0gPSB3aW5kb3cuY29uc29sZS5sb2cuYmluZCh3aW5kb3cuY29uc29sZSwgXCJNb3RvckNvcnRleCAtICVjJXNcIiwgbG9nVHlwZS5zdHlsZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB0aGlzW2xvZ1R5cGUua2V5XSA9IGZ1bmN0aW9uICgpIHt9O1xuICAgIH1cblxuICAgIGlmIChsb2dMZXZlbCA+PSAzKSB7XG4gICAgICB0aGlzLmxvZyA9IHdpbmRvdy5jb25zb2xlLmxvZy5iaW5kKHdpbmRvdy5jb25zb2xlLCBcIk1vdG9yQ29ydGV4IC0gXCIpO1xuICAgIH0gZWxzZSB0aGlzLmxvZyA9IGZ1bmN0aW9uICgpIHt9O1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEhlbHBlciwgW3tcbiAgICBrZXk6IFwicmVuZGVyVGVtcGxhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyVGVtcGxhdGUodGVtcGxhdGVTdHJpbmcsIHRlbXBsYXRlVmFycykge1xuICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbihcInJldHVybiBgXCIgKyB0ZW1wbGF0ZVN0cmluZyArIFwiYDtcIikuY2FsbCh0ZW1wbGF0ZVZhcnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBpbiB0aGUgZm9ybSBcIjFiYzQ1Zjc4LWFiMjMtamw1OVwiXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRBbklkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEFuSWQoKSB7XG4gICAgICB2YXIgdW5kZXJzY29yZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG4gICAgICB2YXIgc3BlY2lhbENoYXIgPSAnLSc7XG5cbiAgICAgIGlmICh1bmRlcnNjb3JlKSB7XG4gICAgICAgIHNwZWNpYWxDaGFyID0gJ18nO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBzNCgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoKDEgKyBNYXRoLnJhbmRvbSgpKSAqIDB4MTAwMDApLnRvU3RyaW5nKDE2KS5zdWJzdHJpbmcoMSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzNCgpICsgczQoKSArIHNwZWNpYWxDaGFyICsgczQoKSArIHNwZWNpYWxDaGFyICsgczQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TGFuZUtleVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMYW5lS2V5KG1jaWQsIGF0dHJpYnV0ZSkge1xuICAgICAgcmV0dXJuIG1jaWQgKyB0aGlzLmxhbmVzTUNJRGF0dHJzU2VwZXJhdG9yICsgYXR0cmlidXRlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRNQ0lEYW5kQXR0ck91dE9mTGFuZUtleVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNQ0lEYW5kQXR0ck91dE9mTGFuZUtleShsYW5lS2V5KSB7XG4gICAgICB2YXIgbGFuZUFycmF5ID0gbGFuZUtleS5zcGxpdCh0aGlzLmxhbmVzTUNJRGF0dHJzU2VwZXJhdG9yKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1jaWQ6IGxhbmVBcnJheVswXSxcbiAgICAgICAgYXR0cmlidXRlOiBsYW5lQXJyYXlbMV1cbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEVsZW1lbnRCeU1DSURcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RWxlbWVudEJ5TUNJRChjb250ZXh0LCBtY2lkKSB7XG4gICAgICByZXR1cm4gY29udGV4dC5yb290RWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbJyArIGNvbmYuZWxlbWVudHNfZGF0YV9hdHRyaWJ1dGVfbmFtZSArICc9XCInICsgbWNpZCArICdcIl0nKVswXTtcbiAgICB9XG4gICAgLyoqXG4gICAgc3ViZGl2aXNpb24gbWlnaHQgYmUgcm91bmRpbmcgdGhlIG51bWJlciB0byBpdHM6XG4gICAgLSB1bml0cyAoc3ViZGl2aXNpb24gPSAxKVxuICAgIC0gdGVudGhzIChzdWJkaXZpc2lvbiA9IDEwKVxuICAgIC0gaHVuZHJlZHMgKHN1YmRpdmlzaW9uID0gMTAwKVxuICAgIC0gdGhvdXNhbmRzIChzdWJkaXZpc2lvbiA9IDEwMDApXG4gICAgIEBwYXJhbSB7c3RyaW5nfSBpbnRcbiAgICAgQHBhcmFtIHtzdWJkaXZpc2lvbn0gaW50XG4gICAgIEByZXR1cm5zIHtpbnR9IHRoZSByb3VuZGVkIG51bWJlclxuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyb3VuZE51bWJlclRvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJvdW5kTnVtYmVyVG8obnVtYmVyLCBzdWJkaXZpc2lvbikge1xuICAgICAgcmV0dXJuIE1hdGgucm91bmQobnVtYmVyIC8gc3ViZGl2aXNpb24pICogc3ViZGl2aXNpb247XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzSW50ZWdlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0ludGVnZXIobnVtYmVyKSB7XG4gICAgICBpZiAobnVtYmVyID09PSBwYXJzZUludChudW1iZXIsIDEwKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNTdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNTdHJpbmcodGVzdCkge1xuICAgICAgaWYgKHR5cGVvZiB0ZXN0ID09PSAnc3RyaW5nJyB8fCB0ZXN0IGluc3RhbmNlb2YgU3RyaW5nKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc09iamVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc09iamVjdCh0ZXN0KSB7XG4gICAgICByZXR1cm4gX3R5cGVvZih0ZXN0KSA9PT0gXCJvYmplY3RcIjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNBcnJheVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0FycmF5KHRlc3QpIHtcbiAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHRlc3QpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc0Z1bmN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzRnVuY3Rpb24oZnVuY3Rpb25Ub0NoZWNrKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb25Ub0NoZWNrICYmIHt9LnRvU3RyaW5nLmNhbGwoZnVuY3Rpb25Ub0NoZWNrKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogc3lzdG9sZSAvIGRpYXN0b2xlIG9mIHRoZSBwcm9qZWN0aW9uc1xuICAgICAqIEByZXR1cm5zIHthcnJheX0gLSBjb2xsZWN0aW9uIG9mIG9iamVjdHMgd2l0aCBrZXlzOiB7aWQsIHN0YXJ0LCBlbmQsIHN0YXJ0RGVsdGF9XG4gICAgICoqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic3lzdG9sZURpYXN0b2xlUHJvamVjdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3lzdG9sZURpYXN0b2xlUHJvamVjdGlvbnMocHJvamVjdGlvbnMsIGR1cmF0aW9uRnJhY3Rpb24sIGFuY2hvclBvaW50KSB7XG4gICAgICB2YXIgYWx0ZXJlZFByb2plY3Rpb25zID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvamVjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHByb2plY3RlZEluY2lkZW50ID0gcHJvamVjdGlvbnNbaV07XG4gICAgICAgIHZhciBtc0luUmVzaXplZFBvcnRpb24gPSBwcm9qZWN0ZWRJbmNpZGVudC5wYXJlbnRNaWxsaXNlY29uZCAtIGFuY2hvclBvaW50O1xuXG4gICAgICAgIGlmIChkdXJhdGlvbkZyYWN0aW9uICE9IDEpIHtcbiAgICAgICAgICBhbHRlcmVkUHJvamVjdGlvbnMucHVzaCh7XG4gICAgICAgICAgICBpZDogcHJvamVjdGVkSW5jaWRlbnQuaW5jaWRlbnQuaWQsXG4gICAgICAgICAgICBzdGFydDogbXNJblJlc2l6ZWRQb3J0aW9uICogZHVyYXRpb25GcmFjdGlvbiArIGFuY2hvclBvaW50LFxuICAgICAgICAgICAgZW5kOiBtc0luUmVzaXplZFBvcnRpb24gKiBkdXJhdGlvbkZyYWN0aW9uICsgYW5jaG9yUG9pbnQgKyBwcm9qZWN0ZWRJbmNpZGVudC5pbmNpZGVudC5kdXJhdGlvbiAqIGR1cmF0aW9uRnJhY3Rpb24sXG4gICAgICAgICAgICBzdGFydERlbHRhOiBtc0luUmVzaXplZFBvcnRpb24gKiBkdXJhdGlvbkZyYWN0aW9uICsgYW5jaG9yUG9pbnQgLSBwcm9qZWN0ZWRJbmNpZGVudC5taWxsaXNlY29uZFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhbHRlcmVkUHJvamVjdGlvbnM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImpzVWNmaXJzdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBqc1VjZmlyc3Qoc3RyaW5nKSB7XG4gICAgICByZXR1cm4gc3RyaW5nLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyaW5nLnNsaWNlKDEpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBIZWxwZXI7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gSGVscGVyOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/_coreUtils/TimeCapsule.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/_coreUtils/TimeCapsule.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar Helper = __webpack_require__(/*! ../_coreUtils/Helper */ \"./node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\");\n\nvar helper = new Helper();\n\nvar Journey =\n/*#__PURE__*/\nfunction () {\n  function Journey(props) {\n    _classCallCheck(this, Journey);\n\n    if (!Object.prototype.hasOwnProperty.call(props, \"incident\")) {\n      helper.error('Journey constructor expects an Incident on its properties on the key \"incident\"');\n      return false;\n    }\n\n    this.memory = props.calpuleMemory;\n    this.stations = [];\n    this.incident = props.incident;\n    this.startMillisecond = this.incident.runTimeInfo.currentMillisecond * 1;\n    this.startState = this.incident.runTimeInfo.state + \"\";\n    this.incident.stop();\n  }\n\n  _createClass(Journey, [{\n    key: \"station\",\n    value: function station(millisecond) {\n      var props = {};\n\n      if (this.stations.length > 0) {\n        props.previousStop = this.stations[this.stations.length - 1];\n      }\n\n      this.stations.push(millisecond); // helper.log(`CAPSULE passes as previousStop: ${props.previousStop}`);\n      // helper.log(this.stations);\n\n      this.incident.onProgress(millisecond / this.incident.duration, millisecond);\n    }\n  }, {\n    key: \"destination\",\n    value: function destination() {\n      var millisecond = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n      if (millisecond != null) {\n        this.station(millisecond);\n      } else {\n        millisecond = this.stations[this.stations.length - 1];\n      }\n\n      this.incident.onProgress(millisecond / this.incident.duration, millisecond); // if the clip was playing start it again\n\n      if (this.startState === 'playing') {\n        this.incident.play();\n      } else {\n        if (millisecond >= this.incident.duration) {\n          this.incident.complete();\n        }\n      }\n\n      this.memory.push(this.exportJourneyLog);\n    }\n  }, {\n    key: \"exportJourneyLog\",\n    value: function exportJourneyLog() {\n      return {\n        startMillisecond: this.startMillisecond,\n        startState: this.startState,\n        stations: this.stations\n      };\n    }\n  }]);\n\n  return Journey;\n}();\n\nvar TimeCapsule =\n/*#__PURE__*/\nfunction () {\n  function TimeCapsule() {\n    _classCallCheck(this, TimeCapsule);\n\n    this.memory = [];\n  }\n\n  _createClass(TimeCapsule, [{\n    key: \"startJourney\",\n    value: function startJourney(incident) {\n      if (!incident) {\n        helper.error('startJourney expects an Incident as an argument');\n        return false;\n      }\n\n      return new Journey({\n        incident: incident,\n        calpuleMemory: this.memory\n      });\n    }\n  }]);\n\n  return TimeCapsule;\n}();\n\nmodule.exports = TimeCapsule;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19jb3JlVXRpbHMvVGltZUNhcHN1bGUuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19jb3JlVXRpbHMvVGltZUNhcHN1bGUuanM/YmIyMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG52YXIgSGVscGVyID0gcmVxdWlyZSgnLi4vX2NvcmVVdGlscy9IZWxwZXInKTtcblxudmFyIGhlbHBlciA9IG5ldyBIZWxwZXIoKTtcblxudmFyIEpvdXJuZXkgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBKb3VybmV5KHByb3BzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEpvdXJuZXkpO1xuXG4gICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIFwiaW5jaWRlbnRcIikpIHtcbiAgICAgIGhlbHBlci5lcnJvcignSm91cm5leSBjb25zdHJ1Y3RvciBleHBlY3RzIGFuIEluY2lkZW50IG9uIGl0cyBwcm9wZXJ0aWVzIG9uIHRoZSBrZXkgXCJpbmNpZGVudFwiJyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5tZW1vcnkgPSBwcm9wcy5jYWxwdWxlTWVtb3J5O1xuICAgIHRoaXMuc3RhdGlvbnMgPSBbXTtcbiAgICB0aGlzLmluY2lkZW50ID0gcHJvcHMuaW5jaWRlbnQ7XG4gICAgdGhpcy5zdGFydE1pbGxpc2Vjb25kID0gdGhpcy5pbmNpZGVudC5ydW5UaW1lSW5mby5jdXJyZW50TWlsbGlzZWNvbmQgKiAxO1xuICAgIHRoaXMuc3RhcnRTdGF0ZSA9IHRoaXMuaW5jaWRlbnQucnVuVGltZUluZm8uc3RhdGUgKyBcIlwiO1xuICAgIHRoaXMuaW5jaWRlbnQuc3RvcCgpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEpvdXJuZXksIFt7XG4gICAga2V5OiBcInN0YXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RhdGlvbihtaWxsaXNlY29uZCkge1xuICAgICAgdmFyIHByb3BzID0ge307XG5cbiAgICAgIGlmICh0aGlzLnN0YXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcHJvcHMucHJldmlvdXNTdG9wID0gdGhpcy5zdGF0aW9uc1t0aGlzLnN0YXRpb25zLmxlbmd0aCAtIDFdO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnN0YXRpb25zLnB1c2gobWlsbGlzZWNvbmQpOyAvLyBoZWxwZXIubG9nKGBDQVBTVUxFIHBhc3NlcyBhcyBwcmV2aW91c1N0b3A6ICR7cHJvcHMucHJldmlvdXNTdG9wfWApO1xuICAgICAgLy8gaGVscGVyLmxvZyh0aGlzLnN0YXRpb25zKTtcblxuICAgICAgdGhpcy5pbmNpZGVudC5vblByb2dyZXNzKG1pbGxpc2Vjb25kIC8gdGhpcy5pbmNpZGVudC5kdXJhdGlvbiwgbWlsbGlzZWNvbmQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZXN0aW5hdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0aW5hdGlvbigpIHtcbiAgICAgIHZhciBtaWxsaXNlY29uZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogbnVsbDtcblxuICAgICAgaWYgKG1pbGxpc2Vjb25kICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5zdGF0aW9uKG1pbGxpc2Vjb25kKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1pbGxpc2Vjb25kID0gdGhpcy5zdGF0aW9uc1t0aGlzLnN0YXRpb25zLmxlbmd0aCAtIDFdO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmluY2lkZW50Lm9uUHJvZ3Jlc3MobWlsbGlzZWNvbmQgLyB0aGlzLmluY2lkZW50LmR1cmF0aW9uLCBtaWxsaXNlY29uZCk7IC8vIGlmIHRoZSBjbGlwIHdhcyBwbGF5aW5nIHN0YXJ0IGl0IGFnYWluXG5cbiAgICAgIGlmICh0aGlzLnN0YXJ0U3RhdGUgPT09ICdwbGF5aW5nJykge1xuICAgICAgICB0aGlzLmluY2lkZW50LnBsYXkoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChtaWxsaXNlY29uZCA+PSB0aGlzLmluY2lkZW50LmR1cmF0aW9uKSB7XG4gICAgICAgICAgdGhpcy5pbmNpZGVudC5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMubWVtb3J5LnB1c2godGhpcy5leHBvcnRKb3VybmV5TG9nKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXhwb3J0Sm91cm5leUxvZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBleHBvcnRKb3VybmV5TG9nKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnRNaWxsaXNlY29uZDogdGhpcy5zdGFydE1pbGxpc2Vjb25kLFxuICAgICAgICBzdGFydFN0YXRlOiB0aGlzLnN0YXJ0U3RhdGUsXG4gICAgICAgIHN0YXRpb25zOiB0aGlzLnN0YXRpb25zXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBKb3VybmV5O1xufSgpO1xuXG52YXIgVGltZUNhcHN1bGUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUaW1lQ2Fwc3VsZSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVGltZUNhcHN1bGUpO1xuXG4gICAgdGhpcy5tZW1vcnkgPSBbXTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhUaW1lQ2Fwc3VsZSwgW3tcbiAgICBrZXk6IFwic3RhcnRKb3VybmV5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0Sm91cm5leShpbmNpZGVudCkge1xuICAgICAgaWYgKCFpbmNpZGVudCkge1xuICAgICAgICBoZWxwZXIuZXJyb3IoJ3N0YXJ0Sm91cm5leSBleHBlY3RzIGFuIEluY2lkZW50IGFzIGFuIGFyZ3VtZW50Jyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBKb3VybmV5KHtcbiAgICAgICAgaW5jaWRlbnQ6IGluY2lkZW50LFxuICAgICAgICBjYWxwdWxlTWVtb3J5OiB0aGlzLm1lbW9yeVxuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFRpbWVDYXBzdWxlO1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRpbWVDYXBzdWxlOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/_coreUtils/TimeCapsule.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/_responsiveness/AttributeAwareIncident.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/_responsiveness/AttributeAwareIncident.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar Group = __webpack_require__(/*! ../_BaseClasses/Group */ \"./node_modules/@kissmybutton/motorcortex/dist/_BaseClasses/Group.js\");\n\nvar ContextAwareIncident = __webpack_require__(/*! ./ContextAwareIncident */ \"./node_modules/@kissmybutton/motorcortex/dist/_responsiveness/ContextAwareIncident.js\");\n\nvar AttributesAwareIncident =\n/*#__PURE__*/\nfunction (_Group) {\n  _inherits(AttributesAwareIncident, _Group);\n\n  function AttributesAwareIncident(descriptiveIncident, contextData, mcid, selector) {\n    var _this;\n\n    _classCallCheck(this, AttributesAwareIncident);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(AttributesAwareIncident).call(this, {}, {\n      id: \"\".concat(descriptiveIncident.id, \"_\").concat(mcid)\n    }));\n    _this.mcid = mcid;\n    _this.selector = selector;\n\n    _this.setUp(descriptiveIncident, contextData);\n\n    return _this;\n  }\n\n  _createClass(AttributesAwareIncident, [{\n    key: \"setUp\",\n    value: function setUp(descriptiveIncident, contextData) {\n      for (var attr in descriptiveIncident.attrs.animatedAttrs) {\n        var singleAnimatedAttrs = {};\n        singleAnimatedAttrs[attr] = descriptiveIncident.attrs.animatedAttrs[attr];\n\n        var attrsToPass = _objectSpread({}, descriptiveIncident.attrs, {\n          animatedAttrs: singleAnimatedAttrs\n        });\n\n        var propsToPass = _objectSpread({}, descriptiveIncident.props, {\n          selector: this.selector\n        });\n\n        var constructionIngredients = {\n          incidentId: descriptiveIncident.id,\n          attrs: attrsToPass,\n          props: propsToPass,\n          Incident: descriptiveIncident.constructor.Incident,\n          plugin_npm_name: descriptiveIncident.constructor.plugin_npm_name,\n          Channel: descriptiveIncident.constructor.Channel\n        };\n        var contextAwareIncident = new ContextAwareIncident(constructionIngredients, contextData, this.mcid, attr);\n        this.addChild(contextAwareIncident, 0);\n      }\n    }\n  }]);\n\n  return AttributesAwareIncident;\n}(Group);\n\nmodule.exports = AttributesAwareIncident;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19yZXNwb25zaXZlbmVzcy9BdHRyaWJ1dGVBd2FyZUluY2lkZW50LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvZGlzdC9fcmVzcG9uc2l2ZW5lc3MvQXR0cmlidXRlQXdhcmVJbmNpZGVudC5qcz81MjQ1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgdmFyIG93bktleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpOyBpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09ICdmdW5jdGlvbicpIHsgb3duS2V5cyA9IG93bktleXMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKS5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIHN5bSkuZW51bWVyYWJsZTsgfSkpOyB9IG93bktleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG52YXIgR3JvdXAgPSByZXF1aXJlKCcuLi9fQmFzZUNsYXNzZXMvR3JvdXAnKTtcblxudmFyIENvbnRleHRBd2FyZUluY2lkZW50ID0gcmVxdWlyZSgnLi9Db250ZXh0QXdhcmVJbmNpZGVudCcpO1xuXG52YXIgQXR0cmlidXRlc0F3YXJlSW5jaWRlbnQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9Hcm91cCkge1xuICBfaW5oZXJpdHMoQXR0cmlidXRlc0F3YXJlSW5jaWRlbnQsIF9Hcm91cCk7XG5cbiAgZnVuY3Rpb24gQXR0cmlidXRlc0F3YXJlSW5jaWRlbnQoZGVzY3JpcHRpdmVJbmNpZGVudCwgY29udGV4dERhdGEsIG1jaWQsIHNlbGVjdG9yKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEF0dHJpYnV0ZXNBd2FyZUluY2lkZW50KTtcblxuICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKEF0dHJpYnV0ZXNBd2FyZUluY2lkZW50KS5jYWxsKHRoaXMsIHt9LCB7XG4gICAgICBpZDogXCJcIi5jb25jYXQoZGVzY3JpcHRpdmVJbmNpZGVudC5pZCwgXCJfXCIpLmNvbmNhdChtY2lkKVxuICAgIH0pKTtcbiAgICBfdGhpcy5tY2lkID0gbWNpZDtcbiAgICBfdGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yO1xuXG4gICAgX3RoaXMuc2V0VXAoZGVzY3JpcHRpdmVJbmNpZGVudCwgY29udGV4dERhdGEpO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEF0dHJpYnV0ZXNBd2FyZUluY2lkZW50LCBbe1xuICAgIGtleTogXCJzZXRVcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRVcChkZXNjcmlwdGl2ZUluY2lkZW50LCBjb250ZXh0RGF0YSkge1xuICAgICAgZm9yICh2YXIgYXR0ciBpbiBkZXNjcmlwdGl2ZUluY2lkZW50LmF0dHJzLmFuaW1hdGVkQXR0cnMpIHtcbiAgICAgICAgdmFyIHNpbmdsZUFuaW1hdGVkQXR0cnMgPSB7fTtcbiAgICAgICAgc2luZ2xlQW5pbWF0ZWRBdHRyc1thdHRyXSA9IGRlc2NyaXB0aXZlSW5jaWRlbnQuYXR0cnMuYW5pbWF0ZWRBdHRyc1thdHRyXTtcblxuICAgICAgICB2YXIgYXR0cnNUb1Bhc3MgPSBfb2JqZWN0U3ByZWFkKHt9LCBkZXNjcmlwdGl2ZUluY2lkZW50LmF0dHJzLCB7XG4gICAgICAgICAgYW5pbWF0ZWRBdHRyczogc2luZ2xlQW5pbWF0ZWRBdHRyc1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgcHJvcHNUb1Bhc3MgPSBfb2JqZWN0U3ByZWFkKHt9LCBkZXNjcmlwdGl2ZUluY2lkZW50LnByb3BzLCB7XG4gICAgICAgICAgc2VsZWN0b3I6IHRoaXMuc2VsZWN0b3JcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGNvbnN0cnVjdGlvbkluZ3JlZGllbnRzID0ge1xuICAgICAgICAgIGluY2lkZW50SWQ6IGRlc2NyaXB0aXZlSW5jaWRlbnQuaWQsXG4gICAgICAgICAgYXR0cnM6IGF0dHJzVG9QYXNzLFxuICAgICAgICAgIHByb3BzOiBwcm9wc1RvUGFzcyxcbiAgICAgICAgICBJbmNpZGVudDogZGVzY3JpcHRpdmVJbmNpZGVudC5jb25zdHJ1Y3Rvci5JbmNpZGVudCxcbiAgICAgICAgICBwbHVnaW5fbnBtX25hbWU6IGRlc2NyaXB0aXZlSW5jaWRlbnQuY29uc3RydWN0b3IucGx1Z2luX25wbV9uYW1lLFxuICAgICAgICAgIENoYW5uZWw6IGRlc2NyaXB0aXZlSW5jaWRlbnQuY29uc3RydWN0b3IuQ2hhbm5lbFxuICAgICAgICB9O1xuICAgICAgICB2YXIgY29udGV4dEF3YXJlSW5jaWRlbnQgPSBuZXcgQ29udGV4dEF3YXJlSW5jaWRlbnQoY29uc3RydWN0aW9uSW5ncmVkaWVudHMsIGNvbnRleHREYXRhLCB0aGlzLm1jaWQsIGF0dHIpO1xuICAgICAgICB0aGlzLmFkZENoaWxkKGNvbnRleHRBd2FyZUluY2lkZW50LCAwKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQXR0cmlidXRlc0F3YXJlSW5jaWRlbnQ7XG59KEdyb3VwKTtcblxubW9kdWxlLmV4cG9ydHMgPSBBdHRyaWJ1dGVzQXdhcmVJbmNpZGVudDsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/_responsiveness/AttributeAwareIncident.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/_responsiveness/ContextAwareClipIncident.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/_responsiveness/ContextAwareClipIncident.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _decorate(decorators, factory, superClass, mixins) { var api = _getDecoratorsApi(); if (mixins) { for (var i = 0; i < mixins.length; i++) { api = mixins[i](api); } } var r = factory(function initialize(O) { api.initializeInstanceElements(O, decorated.elements); }, superClass); var decorated = api.decorateClass(_coalesceClassElements(r.d.map(_createElementDescriptor)), decorators); api.initializeClassElements(r.F, decorated.elements); return api.runClassFinishers(r.F, decorated.finishers); }\n\nfunction _getDecoratorsApi() { _getDecoratorsApi = function _getDecoratorsApi() { return api; }; var api = { elementsDefinitionOrder: [[\"method\"], [\"field\"]], initializeInstanceElements: function initializeInstanceElements(O, elements) { [\"method\", \"field\"].forEach(function (kind) { elements.forEach(function (element) { if (element.kind === kind && element.placement === \"own\") { this.defineClassElement(O, element); } }, this); }, this); }, initializeClassElements: function initializeClassElements(F, elements) { var proto = F.prototype; [\"method\", \"field\"].forEach(function (kind) { elements.forEach(function (element) { var placement = element.placement; if (element.kind === kind && (placement === \"static\" || placement === \"prototype\")) { var receiver = placement === \"static\" ? F : proto; this.defineClassElement(receiver, element); } }, this); }, this); }, defineClassElement: function defineClassElement(receiver, element) { var descriptor = element.descriptor; if (element.kind === \"field\") { var initializer = element.initializer; descriptor = { enumerable: descriptor.enumerable, writable: descriptor.writable, configurable: descriptor.configurable, value: initializer === void 0 ? void 0 : initializer.call(receiver) }; } Object.defineProperty(receiver, element.key, descriptor); }, decorateClass: function decorateClass(elements, decorators) { var newElements = []; var finishers = []; var placements = { \"static\": [], prototype: [], own: [] }; elements.forEach(function (element) { this.addElementPlacement(element, placements); }, this); elements.forEach(function (element) { if (!_hasDecorators(element)) return newElements.push(element); var elementFinishersExtras = this.decorateElement(element, placements); newElements.push(elementFinishersExtras.element); newElements.push.apply(newElements, elementFinishersExtras.extras); finishers.push.apply(finishers, elementFinishersExtras.finishers); }, this); if (!decorators) { return { elements: newElements, finishers: finishers }; } var result = this.decorateConstructor(newElements, decorators); finishers.push.apply(finishers, result.finishers); result.finishers = finishers; return result; }, addElementPlacement: function addElementPlacement(element, placements, silent) { var keys = placements[element.placement]; if (!silent && keys.indexOf(element.key) !== -1) { throw new TypeError(\"Duplicated element (\" + element.key + \")\"); } keys.push(element.key); }, decorateElement: function decorateElement(element, placements) { var extras = []; var finishers = []; for (var decorators = element.decorators, i = decorators.length - 1; i >= 0; i--) { var keys = placements[element.placement]; keys.splice(keys.indexOf(element.key), 1); var elementObject = this.fromElementDescriptor(element); var elementFinisherExtras = this.toElementFinisherExtras((0, decorators[i])(elementObject) || elementObject); element = elementFinisherExtras.element; this.addElementPlacement(element, placements); if (elementFinisherExtras.finisher) { finishers.push(elementFinisherExtras.finisher); } var newExtras = elementFinisherExtras.extras; if (newExtras) { for (var j = 0; j < newExtras.length; j++) { this.addElementPlacement(newExtras[j], placements); } extras.push.apply(extras, newExtras); } } return { element: element, finishers: finishers, extras: extras }; }, decorateConstructor: function decorateConstructor(elements, decorators) { var finishers = []; for (var i = decorators.length - 1; i >= 0; i--) { var obj = this.fromClassDescriptor(elements); var elementsAndFinisher = this.toClassDescriptor((0, decorators[i])(obj) || obj); if (elementsAndFinisher.finisher !== undefined) { finishers.push(elementsAndFinisher.finisher); } if (elementsAndFinisher.elements !== undefined) { elements = elementsAndFinisher.elements; for (var j = 0; j < elements.length - 1; j++) { for (var k = j + 1; k < elements.length; k++) { if (elements[j].key === elements[k].key && elements[j].placement === elements[k].placement) { throw new TypeError(\"Duplicated element (\" + elements[j].key + \")\"); } } } } } return { elements: elements, finishers: finishers }; }, fromElementDescriptor: function fromElementDescriptor(element) { var obj = { kind: element.kind, key: element.key, placement: element.placement, descriptor: element.descriptor }; var desc = { value: \"Descriptor\", configurable: true }; Object.defineProperty(obj, Symbol.toStringTag, desc); if (element.kind === \"field\") obj.initializer = element.initializer; return obj; }, toElementDescriptors: function toElementDescriptors(elementObjects) { if (elementObjects === undefined) return; return _toArray(elementObjects).map(function (elementObject) { var element = this.toElementDescriptor(elementObject); this.disallowProperty(elementObject, \"finisher\", \"An element descriptor\"); this.disallowProperty(elementObject, \"extras\", \"An element descriptor\"); return element; }, this); }, toElementDescriptor: function toElementDescriptor(elementObject) { var kind = String(elementObject.kind); if (kind !== \"method\" && kind !== \"field\") { throw new TypeError('An element descriptor\\'s .kind property must be either \"method\" or' + ' \"field\", but a decorator created an element descriptor with' + ' .kind \"' + kind + '\"'); } var key = _toPropertyKey(elementObject.key); var placement = String(elementObject.placement); if (placement !== \"static\" && placement !== \"prototype\" && placement !== \"own\") { throw new TypeError('An element descriptor\\'s .placement property must be one of \"static\",' + ' \"prototype\" or \"own\", but a decorator created an element descriptor' + ' with .placement \"' + placement + '\"'); } var descriptor = elementObject.descriptor; this.disallowProperty(elementObject, \"elements\", \"An element descriptor\"); var element = { kind: kind, key: key, placement: placement, descriptor: Object.assign({}, descriptor) }; if (kind !== \"field\") { this.disallowProperty(elementObject, \"initializer\", \"A method descriptor\"); } else { this.disallowProperty(descriptor, \"get\", \"The property descriptor of a field descriptor\"); this.disallowProperty(descriptor, \"set\", \"The property descriptor of a field descriptor\"); this.disallowProperty(descriptor, \"value\", \"The property descriptor of a field descriptor\"); element.initializer = elementObject.initializer; } return element; }, toElementFinisherExtras: function toElementFinisherExtras(elementObject) { var element = this.toElementDescriptor(elementObject); var finisher = _optionalCallableProperty(elementObject, \"finisher\"); var extras = this.toElementDescriptors(elementObject.extras); return { element: element, finisher: finisher, extras: extras }; }, fromClassDescriptor: function fromClassDescriptor(elements) { var obj = { kind: \"class\", elements: elements.map(this.fromElementDescriptor, this) }; var desc = { value: \"Descriptor\", configurable: true }; Object.defineProperty(obj, Symbol.toStringTag, desc); return obj; }, toClassDescriptor: function toClassDescriptor(obj) { var kind = String(obj.kind); if (kind !== \"class\") { throw new TypeError('A class descriptor\\'s .kind property must be \"class\", but a decorator' + ' created a class descriptor with .kind \"' + kind + '\"'); } this.disallowProperty(obj, \"key\", \"A class descriptor\"); this.disallowProperty(obj, \"placement\", \"A class descriptor\"); this.disallowProperty(obj, \"descriptor\", \"A class descriptor\"); this.disallowProperty(obj, \"initializer\", \"A class descriptor\"); this.disallowProperty(obj, \"extras\", \"A class descriptor\"); var finisher = _optionalCallableProperty(obj, \"finisher\"); var elements = this.toElementDescriptors(obj.elements); return { elements: elements, finisher: finisher }; }, runClassFinishers: function runClassFinishers(constructor, finishers) { for (var i = 0; i < finishers.length; i++) { var newConstructor = (0, finishers[i])(constructor); if (newConstructor !== undefined) { if (typeof newConstructor !== \"function\") { throw new TypeError(\"Finishers must return a constructor.\"); } constructor = newConstructor; } } return constructor; }, disallowProperty: function disallowProperty(obj, name, objectType) { if (obj[name] !== undefined) { throw new TypeError(objectType + \" can't have a .\" + name + \" property.\"); } } }; return api; }\n\nfunction _createElementDescriptor(def) { var key = _toPropertyKey(def.key); var descriptor; if (def.kind === \"method\") { descriptor = { value: def.value, writable: true, configurable: true, enumerable: false }; } else if (def.kind === \"get\") { descriptor = { get: def.value, configurable: true, enumerable: false }; } else if (def.kind === \"set\") { descriptor = { set: def.value, configurable: true, enumerable: false }; } else if (def.kind === \"field\") { descriptor = { configurable: true, writable: true, enumerable: true }; } var element = { kind: def.kind === \"field\" ? \"field\" : \"method\", key: key, placement: def[\"static\"] ? \"static\" : def.kind === \"field\" ? \"own\" : \"prototype\", descriptor: descriptor }; if (def.decorators) element.decorators = def.decorators; if (def.kind === \"field\") element.initializer = def.value; return element; }\n\nfunction _coalesceGetterSetter(element, other) { if (element.descriptor.get !== undefined) { other.descriptor.get = element.descriptor.get; } else { other.descriptor.set = element.descriptor.set; } }\n\nfunction _coalesceClassElements(elements) { var newElements = []; var isSameElement = function isSameElement(other) { return other.kind === \"method\" && other.key === element.key && other.placement === element.placement; }; for (var i = 0; i < elements.length; i++) { var element = elements[i]; var other; if (element.kind === \"method\" && (other = newElements.find(isSameElement))) { if (_isDataDescriptor(element.descriptor) || _isDataDescriptor(other.descriptor)) { if (_hasDecorators(element) || _hasDecorators(other)) { throw new ReferenceError(\"Duplicated methods (\" + element.key + \") can't be decorated.\"); } other.descriptor = element.descriptor; } else { if (_hasDecorators(element)) { if (_hasDecorators(other)) { throw new ReferenceError(\"Decorators can't be placed on different accessors with for \" + \"the same property (\" + element.key + \").\"); } other.decorators = element.decorators; } _coalesceGetterSetter(element, other); } } else { newElements.push(element); } } return newElements; }\n\nfunction _hasDecorators(element) { return element.decorators && element.decorators.length; }\n\nfunction _isDataDescriptor(desc) { return desc !== undefined && !(desc.value === undefined && desc.writable === undefined); }\n\nfunction _optionalCallableProperty(obj, name) { var value = obj[name]; if (value !== undefined && typeof value !== \"function\") { throw new TypeError(\"Expected '\" + name + \"' to be a function\"); } return value; }\n\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\n\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\nfunction _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nvar Leaf = __webpack_require__(/*! ../_Tree/Leaf */ \"./node_modules/@kissmybutton/motorcortex/dist/_Tree/Leaf.js\");\n\nvar incidentFromIngredients = __webpack_require__(/*! ../IncidentFromDefinition/incidentFromIngredients */ \"./node_modules/@kissmybutton/motorcortex/dist/IncidentFromDefinition/incidentFromIngredients.js\");\n\nvar ClipCopy = __webpack_require__(/*! ../_Clip/ClipCopy */ \"./node_modules/@kissmybutton/motorcortex/dist/_Clip/ClipCopy.js\");\n\nvar getIncidentsByChannel = __webpack_require__(/*! ../decorators/getIncidentsByChannel */ \"./node_modules/@kissmybutton/motorcortex/dist/decorators/getIncidentsByChannel.js\");\n\nvar _TREECONST = __webpack_require__(/*! ../_Tree/_CONST */ \"./node_modules/@kissmybutton/motorcortex/dist/_Tree/_CONST.js\");\n\nvar ContextAwareClipIncident = _decorate(null, function (_initialize, _Leaf) {\n  var ContextAwareClipIncident =\n  /*#__PURE__*/\n  function (_Leaf2) {\n    _inherits(ContextAwareClipIncident, _Leaf2);\n\n    function ContextAwareClipIncident(constructionIngredients, contextData, mcid, descriptiveIncident) {\n      var _this;\n\n      _classCallCheck(this, ContextAwareClipIncident);\n\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(ContextAwareClipIncident).call(this, {\n        id: \"\".concat(constructionIngredients.incidentId, \"_\").concat(mcid)\n      })); // a property to hold all of the contexts\n\n      _initialize(_assertThisInitialized(_this));\n\n      _this.contexts = {};\n      _this.constructionIngredients = constructionIngredients;\n      _this.mcid = mcid;\n      _this._duration = descriptiveIncident.realClip.duration;\n      _this.descriptiveIncident = descriptiveIncident;\n      _this.mc_plugin_npm_name = constructionIngredients.plugin_npm_name;\n      _this.plugin_channel_class = constructionIngredients.Channel;\n\n      _this.addContext(contextData);\n\n      descriptiveIncident.realClip.subscribeToDurationChange(function (newDuration) {\n        _this._duration = newDuration;\n\n        _this.putMessageOnPipe('recalcDuration', {}, 'Groups', {\n          selfExecute: true,\n          direction: _TREECONST._DIRECTIONS._UP\n        });\n      });\n      return _this;\n    }\n\n    return ContextAwareClipIncident;\n  }(_Leaf);\n\n  return {\n    F: ContextAwareClipIncident,\n    d: [{\n      kind: \"get\",\n      key: \"originalContext\",\n      value: function originalContext() {\n        return this.contexts[this.originalContextKey];\n      }\n    }, {\n      kind: \"get\",\n      key: \"duration\",\n      value: function duration() {\n        return this._duration;\n      }\n    }, {\n      kind: \"method\",\n      key: \"onProgress\",\n      value: function onProgress(fraction, milliseconds, contextId) {\n        var forceReset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n        this.contexts[contextId].onProgress(fraction, milliseconds, forceReset);\n      }\n    }, {\n      kind: \"method\",\n      key: \"addContext\",\n      value: function addContext(contextData) {\n        var forceGetContext = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n        // if it's the first context to be added then it's the original\n        if (Object.keys(this.contexts).length === 0) {\n          this.originalContextKey = contextData.clipId;\n        } // instantiates the Clip so it renders\n\n\n        var ingredientsToPass = _objectSpread({}, this.constructionIngredients, {\n          context: contextData.context,\n          mcid: this.mcid,\n          Incident: ClipCopy,\n          dnaExtras: {\n            descriptiveIncident: this.descriptiveIncident\n          }\n        }); // and puts it on the corresponding context key\n\n\n        this.contexts[contextData.clipId] = incidentFromIngredients(ingredientsToPass);\n\n        if (forceGetContext === true) {\n          this.contexts[contextData.clipId]._onGetContextOnce();\n        }\n      }\n    }, {\n      kind: \"method\",\n      key: \"handleAddContext\",\n      value: function handleAddContext(target, payload) {\n        this.addContext(payload, true);\n        return true;\n      }\n    }, {\n      kind: \"method\",\n      decorators: [getIncidentsByChannel],\n      key: \"getIncidentsByChannel\",\n      value: function getIncidentsByChannel() {} // massive editing methods that apply the request massively to all of the\n      // Incidents of all of the contexts\n\n    }, {\n      kind: \"method\",\n      key: \"gotContext\",\n      value: function gotContext() {\n        for (var context in this.contexts) {\n          this.contexts[context].gotContext();\n        }\n      }\n    }, {\n      kind: \"method\",\n      key: \"_onGetContextOnce\",\n      value: function _onGetContextOnce() {\n        for (var context in this.contexts) {\n          this.contexts[context]._onGetContextOnce();\n        }\n      }\n    }, {\n      kind: \"method\",\n      key: \"lastWish\",\n      value: function lastWish() {\n        for (var context in this.contexts) {\n          this.contexts[context].lastWish();\n        }\n      }\n    }, {\n      kind: \"method\",\n      key: \"onGetContext\",\n      value: function onGetContext() {\n        for (var context in this.contexts) {\n          this.contexts[context].onGetContext();\n        }\n      }\n    }]\n  };\n}, Leaf);\n\nmodule.exports = ContextAwareClipIncident;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19yZXNwb25zaXZlbmVzcy9Db250ZXh0QXdhcmVDbGlwSW5jaWRlbnQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19yZXNwb25zaXZlbmVzcy9Db250ZXh0QXdhcmVDbGlwSW5jaWRlbnQuanM/Y2MwMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IHZhciBvd25LZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTsgaWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSAnZnVuY3Rpb24nKSB7IG93bktleXMgPSBvd25LZXlzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSkuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBzeW0pLmVudW1lcmFibGU7IH0pKTsgfSBvd25LZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9kZWNvcmF0ZShkZWNvcmF0b3JzLCBmYWN0b3J5LCBzdXBlckNsYXNzLCBtaXhpbnMpIHsgdmFyIGFwaSA9IF9nZXREZWNvcmF0b3JzQXBpKCk7IGlmIChtaXhpbnMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBtaXhpbnMubGVuZ3RoOyBpKyspIHsgYXBpID0gbWl4aW5zW2ldKGFwaSk7IH0gfSB2YXIgciA9IGZhY3RvcnkoZnVuY3Rpb24gaW5pdGlhbGl6ZShPKSB7IGFwaS5pbml0aWFsaXplSW5zdGFuY2VFbGVtZW50cyhPLCBkZWNvcmF0ZWQuZWxlbWVudHMpOyB9LCBzdXBlckNsYXNzKTsgdmFyIGRlY29yYXRlZCA9IGFwaS5kZWNvcmF0ZUNsYXNzKF9jb2FsZXNjZUNsYXNzRWxlbWVudHMoci5kLm1hcChfY3JlYXRlRWxlbWVudERlc2NyaXB0b3IpKSwgZGVjb3JhdG9ycyk7IGFwaS5pbml0aWFsaXplQ2xhc3NFbGVtZW50cyhyLkYsIGRlY29yYXRlZC5lbGVtZW50cyk7IHJldHVybiBhcGkucnVuQ2xhc3NGaW5pc2hlcnMoci5GLCBkZWNvcmF0ZWQuZmluaXNoZXJzKTsgfVxuXG5mdW5jdGlvbiBfZ2V0RGVjb3JhdG9yc0FwaSgpIHsgX2dldERlY29yYXRvcnNBcGkgPSBmdW5jdGlvbiBfZ2V0RGVjb3JhdG9yc0FwaSgpIHsgcmV0dXJuIGFwaTsgfTsgdmFyIGFwaSA9IHsgZWxlbWVudHNEZWZpbml0aW9uT3JkZXI6IFtbXCJtZXRob2RcIl0sIFtcImZpZWxkXCJdXSwgaW5pdGlhbGl6ZUluc3RhbmNlRWxlbWVudHM6IGZ1bmN0aW9uIGluaXRpYWxpemVJbnN0YW5jZUVsZW1lbnRzKE8sIGVsZW1lbnRzKSB7IFtcIm1ldGhvZFwiLCBcImZpZWxkXCJdLmZvckVhY2goZnVuY3Rpb24gKGtpbmQpIHsgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkgeyBpZiAoZWxlbWVudC5raW5kID09PSBraW5kICYmIGVsZW1lbnQucGxhY2VtZW50ID09PSBcIm93blwiKSB7IHRoaXMuZGVmaW5lQ2xhc3NFbGVtZW50KE8sIGVsZW1lbnQpOyB9IH0sIHRoaXMpOyB9LCB0aGlzKTsgfSwgaW5pdGlhbGl6ZUNsYXNzRWxlbWVudHM6IGZ1bmN0aW9uIGluaXRpYWxpemVDbGFzc0VsZW1lbnRzKEYsIGVsZW1lbnRzKSB7IHZhciBwcm90byA9IEYucHJvdG90eXBlOyBbXCJtZXRob2RcIiwgXCJmaWVsZFwiXS5mb3JFYWNoKGZ1bmN0aW9uIChraW5kKSB7IGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHsgdmFyIHBsYWNlbWVudCA9IGVsZW1lbnQucGxhY2VtZW50OyBpZiAoZWxlbWVudC5raW5kID09PSBraW5kICYmIChwbGFjZW1lbnQgPT09IFwic3RhdGljXCIgfHwgcGxhY2VtZW50ID09PSBcInByb3RvdHlwZVwiKSkgeyB2YXIgcmVjZWl2ZXIgPSBwbGFjZW1lbnQgPT09IFwic3RhdGljXCIgPyBGIDogcHJvdG87IHRoaXMuZGVmaW5lQ2xhc3NFbGVtZW50KHJlY2VpdmVyLCBlbGVtZW50KTsgfSB9LCB0aGlzKTsgfSwgdGhpcyk7IH0sIGRlZmluZUNsYXNzRWxlbWVudDogZnVuY3Rpb24gZGVmaW5lQ2xhc3NFbGVtZW50KHJlY2VpdmVyLCBlbGVtZW50KSB7IHZhciBkZXNjcmlwdG9yID0gZWxlbWVudC5kZXNjcmlwdG9yOyBpZiAoZWxlbWVudC5raW5kID09PSBcImZpZWxkXCIpIHsgdmFyIGluaXRpYWxpemVyID0gZWxlbWVudC5pbml0aWFsaXplcjsgZGVzY3JpcHRvciA9IHsgZW51bWVyYWJsZTogZGVzY3JpcHRvci5lbnVtZXJhYmxlLCB3cml0YWJsZTogZGVzY3JpcHRvci53cml0YWJsZSwgY29uZmlndXJhYmxlOiBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSwgdmFsdWU6IGluaXRpYWxpemVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbml0aWFsaXplci5jYWxsKHJlY2VpdmVyKSB9OyB9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZWNlaXZlciwgZWxlbWVudC5rZXksIGRlc2NyaXB0b3IpOyB9LCBkZWNvcmF0ZUNsYXNzOiBmdW5jdGlvbiBkZWNvcmF0ZUNsYXNzKGVsZW1lbnRzLCBkZWNvcmF0b3JzKSB7IHZhciBuZXdFbGVtZW50cyA9IFtdOyB2YXIgZmluaXNoZXJzID0gW107IHZhciBwbGFjZW1lbnRzID0geyBcInN0YXRpY1wiOiBbXSwgcHJvdG90eXBlOiBbXSwgb3duOiBbXSB9OyBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7IHRoaXMuYWRkRWxlbWVudFBsYWNlbWVudChlbGVtZW50LCBwbGFjZW1lbnRzKTsgfSwgdGhpcyk7IGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHsgaWYgKCFfaGFzRGVjb3JhdG9ycyhlbGVtZW50KSkgcmV0dXJuIG5ld0VsZW1lbnRzLnB1c2goZWxlbWVudCk7IHZhciBlbGVtZW50RmluaXNoZXJzRXh0cmFzID0gdGhpcy5kZWNvcmF0ZUVsZW1lbnQoZWxlbWVudCwgcGxhY2VtZW50cyk7IG5ld0VsZW1lbnRzLnB1c2goZWxlbWVudEZpbmlzaGVyc0V4dHJhcy5lbGVtZW50KTsgbmV3RWxlbWVudHMucHVzaC5hcHBseShuZXdFbGVtZW50cywgZWxlbWVudEZpbmlzaGVyc0V4dHJhcy5leHRyYXMpOyBmaW5pc2hlcnMucHVzaC5hcHBseShmaW5pc2hlcnMsIGVsZW1lbnRGaW5pc2hlcnNFeHRyYXMuZmluaXNoZXJzKTsgfSwgdGhpcyk7IGlmICghZGVjb3JhdG9ycykgeyByZXR1cm4geyBlbGVtZW50czogbmV3RWxlbWVudHMsIGZpbmlzaGVyczogZmluaXNoZXJzIH07IH0gdmFyIHJlc3VsdCA9IHRoaXMuZGVjb3JhdGVDb25zdHJ1Y3RvcihuZXdFbGVtZW50cywgZGVjb3JhdG9ycyk7IGZpbmlzaGVycy5wdXNoLmFwcGx5KGZpbmlzaGVycywgcmVzdWx0LmZpbmlzaGVycyk7IHJlc3VsdC5maW5pc2hlcnMgPSBmaW5pc2hlcnM7IHJldHVybiByZXN1bHQ7IH0sIGFkZEVsZW1lbnRQbGFjZW1lbnQ6IGZ1bmN0aW9uIGFkZEVsZW1lbnRQbGFjZW1lbnQoZWxlbWVudCwgcGxhY2VtZW50cywgc2lsZW50KSB7IHZhciBrZXlzID0gcGxhY2VtZW50c1tlbGVtZW50LnBsYWNlbWVudF07IGlmICghc2lsZW50ICYmIGtleXMuaW5kZXhPZihlbGVtZW50LmtleSkgIT09IC0xKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEdXBsaWNhdGVkIGVsZW1lbnQgKFwiICsgZWxlbWVudC5rZXkgKyBcIilcIik7IH0ga2V5cy5wdXNoKGVsZW1lbnQua2V5KTsgfSwgZGVjb3JhdGVFbGVtZW50OiBmdW5jdGlvbiBkZWNvcmF0ZUVsZW1lbnQoZWxlbWVudCwgcGxhY2VtZW50cykgeyB2YXIgZXh0cmFzID0gW107IHZhciBmaW5pc2hlcnMgPSBbXTsgZm9yICh2YXIgZGVjb3JhdG9ycyA9IGVsZW1lbnQuZGVjb3JhdG9ycywgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHsgdmFyIGtleXMgPSBwbGFjZW1lbnRzW2VsZW1lbnQucGxhY2VtZW50XTsga2V5cy5zcGxpY2Uoa2V5cy5pbmRleE9mKGVsZW1lbnQua2V5KSwgMSk7IHZhciBlbGVtZW50T2JqZWN0ID0gdGhpcy5mcm9tRWxlbWVudERlc2NyaXB0b3IoZWxlbWVudCk7IHZhciBlbGVtZW50RmluaXNoZXJFeHRyYXMgPSB0aGlzLnRvRWxlbWVudEZpbmlzaGVyRXh0cmFzKCgwLCBkZWNvcmF0b3JzW2ldKShlbGVtZW50T2JqZWN0KSB8fCBlbGVtZW50T2JqZWN0KTsgZWxlbWVudCA9IGVsZW1lbnRGaW5pc2hlckV4dHJhcy5lbGVtZW50OyB0aGlzLmFkZEVsZW1lbnRQbGFjZW1lbnQoZWxlbWVudCwgcGxhY2VtZW50cyk7IGlmIChlbGVtZW50RmluaXNoZXJFeHRyYXMuZmluaXNoZXIpIHsgZmluaXNoZXJzLnB1c2goZWxlbWVudEZpbmlzaGVyRXh0cmFzLmZpbmlzaGVyKTsgfSB2YXIgbmV3RXh0cmFzID0gZWxlbWVudEZpbmlzaGVyRXh0cmFzLmV4dHJhczsgaWYgKG5ld0V4dHJhcykgeyBmb3IgKHZhciBqID0gMDsgaiA8IG5ld0V4dHJhcy5sZW5ndGg7IGorKykgeyB0aGlzLmFkZEVsZW1lbnRQbGFjZW1lbnQobmV3RXh0cmFzW2pdLCBwbGFjZW1lbnRzKTsgfSBleHRyYXMucHVzaC5hcHBseShleHRyYXMsIG5ld0V4dHJhcyk7IH0gfSByZXR1cm4geyBlbGVtZW50OiBlbGVtZW50LCBmaW5pc2hlcnM6IGZpbmlzaGVycywgZXh0cmFzOiBleHRyYXMgfTsgfSwgZGVjb3JhdGVDb25zdHJ1Y3RvcjogZnVuY3Rpb24gZGVjb3JhdGVDb25zdHJ1Y3RvcihlbGVtZW50cywgZGVjb3JhdG9ycykgeyB2YXIgZmluaXNoZXJzID0gW107IGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7IHZhciBvYmogPSB0aGlzLmZyb21DbGFzc0Rlc2NyaXB0b3IoZWxlbWVudHMpOyB2YXIgZWxlbWVudHNBbmRGaW5pc2hlciA9IHRoaXMudG9DbGFzc0Rlc2NyaXB0b3IoKDAsIGRlY29yYXRvcnNbaV0pKG9iaikgfHwgb2JqKTsgaWYgKGVsZW1lbnRzQW5kRmluaXNoZXIuZmluaXNoZXIgIT09IHVuZGVmaW5lZCkgeyBmaW5pc2hlcnMucHVzaChlbGVtZW50c0FuZEZpbmlzaGVyLmZpbmlzaGVyKTsgfSBpZiAoZWxlbWVudHNBbmRGaW5pc2hlci5lbGVtZW50cyAhPT0gdW5kZWZpbmVkKSB7IGVsZW1lbnRzID0gZWxlbWVudHNBbmRGaW5pc2hlci5lbGVtZW50czsgZm9yICh2YXIgaiA9IDA7IGogPCBlbGVtZW50cy5sZW5ndGggLSAxOyBqKyspIHsgZm9yICh2YXIgayA9IGogKyAxOyBrIDwgZWxlbWVudHMubGVuZ3RoOyBrKyspIHsgaWYgKGVsZW1lbnRzW2pdLmtleSA9PT0gZWxlbWVudHNba10ua2V5ICYmIGVsZW1lbnRzW2pdLnBsYWNlbWVudCA9PT0gZWxlbWVudHNba10ucGxhY2VtZW50KSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEdXBsaWNhdGVkIGVsZW1lbnQgKFwiICsgZWxlbWVudHNbal0ua2V5ICsgXCIpXCIpOyB9IH0gfSB9IH0gcmV0dXJuIHsgZWxlbWVudHM6IGVsZW1lbnRzLCBmaW5pc2hlcnM6IGZpbmlzaGVycyB9OyB9LCBmcm9tRWxlbWVudERlc2NyaXB0b3I6IGZ1bmN0aW9uIGZyb21FbGVtZW50RGVzY3JpcHRvcihlbGVtZW50KSB7IHZhciBvYmogPSB7IGtpbmQ6IGVsZW1lbnQua2luZCwga2V5OiBlbGVtZW50LmtleSwgcGxhY2VtZW50OiBlbGVtZW50LnBsYWNlbWVudCwgZGVzY3JpcHRvcjogZWxlbWVudC5kZXNjcmlwdG9yIH07IHZhciBkZXNjID0geyB2YWx1ZTogXCJEZXNjcmlwdG9yXCIsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9OyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBTeW1ib2wudG9TdHJpbmdUYWcsIGRlc2MpOyBpZiAoZWxlbWVudC5raW5kID09PSBcImZpZWxkXCIpIG9iai5pbml0aWFsaXplciA9IGVsZW1lbnQuaW5pdGlhbGl6ZXI7IHJldHVybiBvYmo7IH0sIHRvRWxlbWVudERlc2NyaXB0b3JzOiBmdW5jdGlvbiB0b0VsZW1lbnREZXNjcmlwdG9ycyhlbGVtZW50T2JqZWN0cykgeyBpZiAoZWxlbWVudE9iamVjdHMgPT09IHVuZGVmaW5lZCkgcmV0dXJuOyByZXR1cm4gX3RvQXJyYXkoZWxlbWVudE9iamVjdHMpLm1hcChmdW5jdGlvbiAoZWxlbWVudE9iamVjdCkgeyB2YXIgZWxlbWVudCA9IHRoaXMudG9FbGVtZW50RGVzY3JpcHRvcihlbGVtZW50T2JqZWN0KTsgdGhpcy5kaXNhbGxvd1Byb3BlcnR5KGVsZW1lbnRPYmplY3QsIFwiZmluaXNoZXJcIiwgXCJBbiBlbGVtZW50IGRlc2NyaXB0b3JcIik7IHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShlbGVtZW50T2JqZWN0LCBcImV4dHJhc1wiLCBcIkFuIGVsZW1lbnQgZGVzY3JpcHRvclwiKTsgcmV0dXJuIGVsZW1lbnQ7IH0sIHRoaXMpOyB9LCB0b0VsZW1lbnREZXNjcmlwdG9yOiBmdW5jdGlvbiB0b0VsZW1lbnREZXNjcmlwdG9yKGVsZW1lbnRPYmplY3QpIHsgdmFyIGtpbmQgPSBTdHJpbmcoZWxlbWVudE9iamVjdC5raW5kKTsgaWYgKGtpbmQgIT09IFwibWV0aG9kXCIgJiYga2luZCAhPT0gXCJmaWVsZFwiKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0FuIGVsZW1lbnQgZGVzY3JpcHRvclxcJ3MgLmtpbmQgcHJvcGVydHkgbXVzdCBiZSBlaXRoZXIgXCJtZXRob2RcIiBvcicgKyAnIFwiZmllbGRcIiwgYnV0IGEgZGVjb3JhdG9yIGNyZWF0ZWQgYW4gZWxlbWVudCBkZXNjcmlwdG9yIHdpdGgnICsgJyAua2luZCBcIicgKyBraW5kICsgJ1wiJyk7IH0gdmFyIGtleSA9IF90b1Byb3BlcnR5S2V5KGVsZW1lbnRPYmplY3Qua2V5KTsgdmFyIHBsYWNlbWVudCA9IFN0cmluZyhlbGVtZW50T2JqZWN0LnBsYWNlbWVudCk7IGlmIChwbGFjZW1lbnQgIT09IFwic3RhdGljXCIgJiYgcGxhY2VtZW50ICE9PSBcInByb3RvdHlwZVwiICYmIHBsYWNlbWVudCAhPT0gXCJvd25cIikgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdBbiBlbGVtZW50IGRlc2NyaXB0b3JcXCdzIC5wbGFjZW1lbnQgcHJvcGVydHkgbXVzdCBiZSBvbmUgb2YgXCJzdGF0aWNcIiwnICsgJyBcInByb3RvdHlwZVwiIG9yIFwib3duXCIsIGJ1dCBhIGRlY29yYXRvciBjcmVhdGVkIGFuIGVsZW1lbnQgZGVzY3JpcHRvcicgKyAnIHdpdGggLnBsYWNlbWVudCBcIicgKyBwbGFjZW1lbnQgKyAnXCInKTsgfSB2YXIgZGVzY3JpcHRvciA9IGVsZW1lbnRPYmplY3QuZGVzY3JpcHRvcjsgdGhpcy5kaXNhbGxvd1Byb3BlcnR5KGVsZW1lbnRPYmplY3QsIFwiZWxlbWVudHNcIiwgXCJBbiBlbGVtZW50IGRlc2NyaXB0b3JcIik7IHZhciBlbGVtZW50ID0geyBraW5kOiBraW5kLCBrZXk6IGtleSwgcGxhY2VtZW50OiBwbGFjZW1lbnQsIGRlc2NyaXB0b3I6IE9iamVjdC5hc3NpZ24oe30sIGRlc2NyaXB0b3IpIH07IGlmIChraW5kICE9PSBcImZpZWxkXCIpIHsgdGhpcy5kaXNhbGxvd1Byb3BlcnR5KGVsZW1lbnRPYmplY3QsIFwiaW5pdGlhbGl6ZXJcIiwgXCJBIG1ldGhvZCBkZXNjcmlwdG9yXCIpOyB9IGVsc2UgeyB0aGlzLmRpc2FsbG93UHJvcGVydHkoZGVzY3JpcHRvciwgXCJnZXRcIiwgXCJUaGUgcHJvcGVydHkgZGVzY3JpcHRvciBvZiBhIGZpZWxkIGRlc2NyaXB0b3JcIik7IHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShkZXNjcmlwdG9yLCBcInNldFwiLCBcIlRoZSBwcm9wZXJ0eSBkZXNjcmlwdG9yIG9mIGEgZmllbGQgZGVzY3JpcHRvclwiKTsgdGhpcy5kaXNhbGxvd1Byb3BlcnR5KGRlc2NyaXB0b3IsIFwidmFsdWVcIiwgXCJUaGUgcHJvcGVydHkgZGVzY3JpcHRvciBvZiBhIGZpZWxkIGRlc2NyaXB0b3JcIik7IGVsZW1lbnQuaW5pdGlhbGl6ZXIgPSBlbGVtZW50T2JqZWN0LmluaXRpYWxpemVyOyB9IHJldHVybiBlbGVtZW50OyB9LCB0b0VsZW1lbnRGaW5pc2hlckV4dHJhczogZnVuY3Rpb24gdG9FbGVtZW50RmluaXNoZXJFeHRyYXMoZWxlbWVudE9iamVjdCkgeyB2YXIgZWxlbWVudCA9IHRoaXMudG9FbGVtZW50RGVzY3JpcHRvcihlbGVtZW50T2JqZWN0KTsgdmFyIGZpbmlzaGVyID0gX29wdGlvbmFsQ2FsbGFibGVQcm9wZXJ0eShlbGVtZW50T2JqZWN0LCBcImZpbmlzaGVyXCIpOyB2YXIgZXh0cmFzID0gdGhpcy50b0VsZW1lbnREZXNjcmlwdG9ycyhlbGVtZW50T2JqZWN0LmV4dHJhcyk7IHJldHVybiB7IGVsZW1lbnQ6IGVsZW1lbnQsIGZpbmlzaGVyOiBmaW5pc2hlciwgZXh0cmFzOiBleHRyYXMgfTsgfSwgZnJvbUNsYXNzRGVzY3JpcHRvcjogZnVuY3Rpb24gZnJvbUNsYXNzRGVzY3JpcHRvcihlbGVtZW50cykgeyB2YXIgb2JqID0geyBraW5kOiBcImNsYXNzXCIsIGVsZW1lbnRzOiBlbGVtZW50cy5tYXAodGhpcy5mcm9tRWxlbWVudERlc2NyaXB0b3IsIHRoaXMpIH07IHZhciBkZXNjID0geyB2YWx1ZTogXCJEZXNjcmlwdG9yXCIsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9OyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBTeW1ib2wudG9TdHJpbmdUYWcsIGRlc2MpOyByZXR1cm4gb2JqOyB9LCB0b0NsYXNzRGVzY3JpcHRvcjogZnVuY3Rpb24gdG9DbGFzc0Rlc2NyaXB0b3Iob2JqKSB7IHZhciBraW5kID0gU3RyaW5nKG9iai5raW5kKTsgaWYgKGtpbmQgIT09IFwiY2xhc3NcIikgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdBIGNsYXNzIGRlc2NyaXB0b3JcXCdzIC5raW5kIHByb3BlcnR5IG11c3QgYmUgXCJjbGFzc1wiLCBidXQgYSBkZWNvcmF0b3InICsgJyBjcmVhdGVkIGEgY2xhc3MgZGVzY3JpcHRvciB3aXRoIC5raW5kIFwiJyArIGtpbmQgKyAnXCInKTsgfSB0aGlzLmRpc2FsbG93UHJvcGVydHkob2JqLCBcImtleVwiLCBcIkEgY2xhc3MgZGVzY3JpcHRvclwiKTsgdGhpcy5kaXNhbGxvd1Byb3BlcnR5KG9iaiwgXCJwbGFjZW1lbnRcIiwgXCJBIGNsYXNzIGRlc2NyaXB0b3JcIik7IHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShvYmosIFwiZGVzY3JpcHRvclwiLCBcIkEgY2xhc3MgZGVzY3JpcHRvclwiKTsgdGhpcy5kaXNhbGxvd1Byb3BlcnR5KG9iaiwgXCJpbml0aWFsaXplclwiLCBcIkEgY2xhc3MgZGVzY3JpcHRvclwiKTsgdGhpcy5kaXNhbGxvd1Byb3BlcnR5KG9iaiwgXCJleHRyYXNcIiwgXCJBIGNsYXNzIGRlc2NyaXB0b3JcIik7IHZhciBmaW5pc2hlciA9IF9vcHRpb25hbENhbGxhYmxlUHJvcGVydHkob2JqLCBcImZpbmlzaGVyXCIpOyB2YXIgZWxlbWVudHMgPSB0aGlzLnRvRWxlbWVudERlc2NyaXB0b3JzKG9iai5lbGVtZW50cyk7IHJldHVybiB7IGVsZW1lbnRzOiBlbGVtZW50cywgZmluaXNoZXI6IGZpbmlzaGVyIH07IH0sIHJ1bkNsYXNzRmluaXNoZXJzOiBmdW5jdGlvbiBydW5DbGFzc0ZpbmlzaGVycyhjb25zdHJ1Y3RvciwgZmluaXNoZXJzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgZmluaXNoZXJzLmxlbmd0aDsgaSsrKSB7IHZhciBuZXdDb25zdHJ1Y3RvciA9ICgwLCBmaW5pc2hlcnNbaV0pKGNvbnN0cnVjdG9yKTsgaWYgKG5ld0NvbnN0cnVjdG9yICE9PSB1bmRlZmluZWQpIHsgaWYgKHR5cGVvZiBuZXdDb25zdHJ1Y3RvciAhPT0gXCJmdW5jdGlvblwiKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaW5pc2hlcnMgbXVzdCByZXR1cm4gYSBjb25zdHJ1Y3Rvci5cIik7IH0gY29uc3RydWN0b3IgPSBuZXdDb25zdHJ1Y3RvcjsgfSB9IHJldHVybiBjb25zdHJ1Y3RvcjsgfSwgZGlzYWxsb3dQcm9wZXJ0eTogZnVuY3Rpb24gZGlzYWxsb3dQcm9wZXJ0eShvYmosIG5hbWUsIG9iamVjdFR5cGUpIHsgaWYgKG9ialtuYW1lXSAhPT0gdW5kZWZpbmVkKSB7IHRocm93IG5ldyBUeXBlRXJyb3Iob2JqZWN0VHlwZSArIFwiIGNhbid0IGhhdmUgYSAuXCIgKyBuYW1lICsgXCIgcHJvcGVydHkuXCIpOyB9IH0gfTsgcmV0dXJuIGFwaTsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlRWxlbWVudERlc2NyaXB0b3IoZGVmKSB7IHZhciBrZXkgPSBfdG9Qcm9wZXJ0eUtleShkZWYua2V5KTsgdmFyIGRlc2NyaXB0b3I7IGlmIChkZWYua2luZCA9PT0gXCJtZXRob2RcIikgeyBkZXNjcmlwdG9yID0geyB2YWx1ZTogZGVmLnZhbHVlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCBlbnVtZXJhYmxlOiBmYWxzZSB9OyB9IGVsc2UgaWYgKGRlZi5raW5kID09PSBcImdldFwiKSB7IGRlc2NyaXB0b3IgPSB7IGdldDogZGVmLnZhbHVlLCBjb25maWd1cmFibGU6IHRydWUsIGVudW1lcmFibGU6IGZhbHNlIH07IH0gZWxzZSBpZiAoZGVmLmtpbmQgPT09IFwic2V0XCIpIHsgZGVzY3JpcHRvciA9IHsgc2V0OiBkZWYudmFsdWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZW51bWVyYWJsZTogZmFsc2UgfTsgfSBlbHNlIGlmIChkZWYua2luZCA9PT0gXCJmaWVsZFwiKSB7IGRlc2NyaXB0b3IgPSB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIGVudW1lcmFibGU6IHRydWUgfTsgfSB2YXIgZWxlbWVudCA9IHsga2luZDogZGVmLmtpbmQgPT09IFwiZmllbGRcIiA/IFwiZmllbGRcIiA6IFwibWV0aG9kXCIsIGtleToga2V5LCBwbGFjZW1lbnQ6IGRlZltcInN0YXRpY1wiXSA/IFwic3RhdGljXCIgOiBkZWYua2luZCA9PT0gXCJmaWVsZFwiID8gXCJvd25cIiA6IFwicHJvdG90eXBlXCIsIGRlc2NyaXB0b3I6IGRlc2NyaXB0b3IgfTsgaWYgKGRlZi5kZWNvcmF0b3JzKSBlbGVtZW50LmRlY29yYXRvcnMgPSBkZWYuZGVjb3JhdG9yczsgaWYgKGRlZi5raW5kID09PSBcImZpZWxkXCIpIGVsZW1lbnQuaW5pdGlhbGl6ZXIgPSBkZWYudmFsdWU7IHJldHVybiBlbGVtZW50OyB9XG5cbmZ1bmN0aW9uIF9jb2FsZXNjZUdldHRlclNldHRlcihlbGVtZW50LCBvdGhlcikgeyBpZiAoZWxlbWVudC5kZXNjcmlwdG9yLmdldCAhPT0gdW5kZWZpbmVkKSB7IG90aGVyLmRlc2NyaXB0b3IuZ2V0ID0gZWxlbWVudC5kZXNjcmlwdG9yLmdldDsgfSBlbHNlIHsgb3RoZXIuZGVzY3JpcHRvci5zZXQgPSBlbGVtZW50LmRlc2NyaXB0b3Iuc2V0OyB9IH1cblxuZnVuY3Rpb24gX2NvYWxlc2NlQ2xhc3NFbGVtZW50cyhlbGVtZW50cykgeyB2YXIgbmV3RWxlbWVudHMgPSBbXTsgdmFyIGlzU2FtZUVsZW1lbnQgPSBmdW5jdGlvbiBpc1NhbWVFbGVtZW50KG90aGVyKSB7IHJldHVybiBvdGhlci5raW5kID09PSBcIm1ldGhvZFwiICYmIG90aGVyLmtleSA9PT0gZWxlbWVudC5rZXkgJiYgb3RoZXIucGxhY2VtZW50ID09PSBlbGVtZW50LnBsYWNlbWVudDsgfTsgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgZWxlbWVudCA9IGVsZW1lbnRzW2ldOyB2YXIgb3RoZXI7IGlmIChlbGVtZW50LmtpbmQgPT09IFwibWV0aG9kXCIgJiYgKG90aGVyID0gbmV3RWxlbWVudHMuZmluZChpc1NhbWVFbGVtZW50KSkpIHsgaWYgKF9pc0RhdGFEZXNjcmlwdG9yKGVsZW1lbnQuZGVzY3JpcHRvcikgfHwgX2lzRGF0YURlc2NyaXB0b3Iob3RoZXIuZGVzY3JpcHRvcikpIHsgaWYgKF9oYXNEZWNvcmF0b3JzKGVsZW1lbnQpIHx8IF9oYXNEZWNvcmF0b3JzKG90aGVyKSkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJEdXBsaWNhdGVkIG1ldGhvZHMgKFwiICsgZWxlbWVudC5rZXkgKyBcIikgY2FuJ3QgYmUgZGVjb3JhdGVkLlwiKTsgfSBvdGhlci5kZXNjcmlwdG9yID0gZWxlbWVudC5kZXNjcmlwdG9yOyB9IGVsc2UgeyBpZiAoX2hhc0RlY29yYXRvcnMoZWxlbWVudCkpIHsgaWYgKF9oYXNEZWNvcmF0b3JzKG90aGVyKSkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJEZWNvcmF0b3JzIGNhbid0IGJlIHBsYWNlZCBvbiBkaWZmZXJlbnQgYWNjZXNzb3JzIHdpdGggZm9yIFwiICsgXCJ0aGUgc2FtZSBwcm9wZXJ0eSAoXCIgKyBlbGVtZW50LmtleSArIFwiKS5cIik7IH0gb3RoZXIuZGVjb3JhdG9ycyA9IGVsZW1lbnQuZGVjb3JhdG9yczsgfSBfY29hbGVzY2VHZXR0ZXJTZXR0ZXIoZWxlbWVudCwgb3RoZXIpOyB9IH0gZWxzZSB7IG5ld0VsZW1lbnRzLnB1c2goZWxlbWVudCk7IH0gfSByZXR1cm4gbmV3RWxlbWVudHM7IH1cblxuZnVuY3Rpb24gX2hhc0RlY29yYXRvcnMoZWxlbWVudCkgeyByZXR1cm4gZWxlbWVudC5kZWNvcmF0b3JzICYmIGVsZW1lbnQuZGVjb3JhdG9ycy5sZW5ndGg7IH1cblxuZnVuY3Rpb24gX2lzRGF0YURlc2NyaXB0b3IoZGVzYykgeyByZXR1cm4gZGVzYyAhPT0gdW5kZWZpbmVkICYmICEoZGVzYy52YWx1ZSA9PT0gdW5kZWZpbmVkICYmIGRlc2Mud3JpdGFibGUgPT09IHVuZGVmaW5lZCk7IH1cblxuZnVuY3Rpb24gX29wdGlvbmFsQ2FsbGFibGVQcm9wZXJ0eShvYmosIG5hbWUpIHsgdmFyIHZhbHVlID0gb2JqW25hbWVdOyBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIikgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgJ1wiICsgbmFtZSArIFwiJyB0byBiZSBhIGZ1bmN0aW9uXCIpOyB9IHJldHVybiB2YWx1ZTsgfVxuXG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleShhcmcpIHsgdmFyIGtleSA9IF90b1ByaW1pdGl2ZShhcmcsIFwic3RyaW5nXCIpOyByZXR1cm4gX3R5cGVvZihrZXkpID09PSBcInN5bWJvbFwiID8ga2V5IDogU3RyaW5nKGtleSk7IH1cblxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKGlucHV0LCBoaW50KSB7IGlmIChfdHlwZW9mKGlucHV0KSAhPT0gXCJvYmplY3RcIiB8fCBpbnB1dCA9PT0gbnVsbCkgcmV0dXJuIGlucHV0OyB2YXIgcHJpbSA9IGlucHV0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmIChwcmltICE9PSB1bmRlZmluZWQpIHsgdmFyIHJlcyA9IHByaW0uY2FsbChpbnB1dCwgaGludCB8fCBcImRlZmF1bHRcIik7IGlmIChfdHlwZW9mKHJlcykgIT09IFwib2JqZWN0XCIpIHJldHVybiByZXM7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKGhpbnQgPT09IFwic3RyaW5nXCIgPyBTdHJpbmcgOiBOdW1iZXIpKGlucHV0KTsgfVxuXG5mdW5jdGlvbiBfdG9BcnJheShhcnIpIHsgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7IH1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7IGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGl0ZXIpIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpdGVyKSA9PT0gXCJbb2JqZWN0IEFyZ3VtZW50c11cIikgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7IH1cblxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyOyB9XG5cbnZhciBMZWFmID0gcmVxdWlyZSgnLi4vX1RyZWUvTGVhZicpO1xuXG52YXIgaW5jaWRlbnRGcm9tSW5ncmVkaWVudHMgPSByZXF1aXJlKCcuLi9JbmNpZGVudEZyb21EZWZpbml0aW9uL2luY2lkZW50RnJvbUluZ3JlZGllbnRzJyk7XG5cbnZhciBDbGlwQ29weSA9IHJlcXVpcmUoJy4uL19DbGlwL0NsaXBDb3B5Jyk7XG5cbnZhciBnZXRJbmNpZGVudHNCeUNoYW5uZWwgPSByZXF1aXJlKCcuLi9kZWNvcmF0b3JzL2dldEluY2lkZW50c0J5Q2hhbm5lbCcpO1xuXG52YXIgX1RSRUVDT05TVCA9IHJlcXVpcmUoJy4uL19UcmVlL19DT05TVCcpO1xuXG52YXIgQ29udGV4dEF3YXJlQ2xpcEluY2lkZW50ID0gX2RlY29yYXRlKG51bGwsIGZ1bmN0aW9uIChfaW5pdGlhbGl6ZSwgX0xlYWYpIHtcbiAgdmFyIENvbnRleHRBd2FyZUNsaXBJbmNpZGVudCA9XG4gIC8qI19fUFVSRV9fKi9cbiAgZnVuY3Rpb24gKF9MZWFmMikge1xuICAgIF9pbmhlcml0cyhDb250ZXh0QXdhcmVDbGlwSW5jaWRlbnQsIF9MZWFmMik7XG5cbiAgICBmdW5jdGlvbiBDb250ZXh0QXdhcmVDbGlwSW5jaWRlbnQoY29uc3RydWN0aW9uSW5ncmVkaWVudHMsIGNvbnRleHREYXRhLCBtY2lkLCBkZXNjcmlwdGl2ZUluY2lkZW50KSB7XG4gICAgICB2YXIgX3RoaXM7XG5cbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb250ZXh0QXdhcmVDbGlwSW5jaWRlbnQpO1xuXG4gICAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihDb250ZXh0QXdhcmVDbGlwSW5jaWRlbnQpLmNhbGwodGhpcywge1xuICAgICAgICBpZDogXCJcIi5jb25jYXQoY29uc3RydWN0aW9uSW5ncmVkaWVudHMuaW5jaWRlbnRJZCwgXCJfXCIpLmNvbmNhdChtY2lkKVxuICAgICAgfSkpOyAvLyBhIHByb3BlcnR5IHRvIGhvbGQgYWxsIG9mIHRoZSBjb250ZXh0c1xuXG4gICAgICBfaW5pdGlhbGl6ZShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG5cbiAgICAgIF90aGlzLmNvbnRleHRzID0ge307XG4gICAgICBfdGhpcy5jb25zdHJ1Y3Rpb25JbmdyZWRpZW50cyA9IGNvbnN0cnVjdGlvbkluZ3JlZGllbnRzO1xuICAgICAgX3RoaXMubWNpZCA9IG1jaWQ7XG4gICAgICBfdGhpcy5fZHVyYXRpb24gPSBkZXNjcmlwdGl2ZUluY2lkZW50LnJlYWxDbGlwLmR1cmF0aW9uO1xuICAgICAgX3RoaXMuZGVzY3JpcHRpdmVJbmNpZGVudCA9IGRlc2NyaXB0aXZlSW5jaWRlbnQ7XG4gICAgICBfdGhpcy5tY19wbHVnaW5fbnBtX25hbWUgPSBjb25zdHJ1Y3Rpb25JbmdyZWRpZW50cy5wbHVnaW5fbnBtX25hbWU7XG4gICAgICBfdGhpcy5wbHVnaW5fY2hhbm5lbF9jbGFzcyA9IGNvbnN0cnVjdGlvbkluZ3JlZGllbnRzLkNoYW5uZWw7XG5cbiAgICAgIF90aGlzLmFkZENvbnRleHQoY29udGV4dERhdGEpO1xuXG4gICAgICBkZXNjcmlwdGl2ZUluY2lkZW50LnJlYWxDbGlwLnN1YnNjcmliZVRvRHVyYXRpb25DaGFuZ2UoZnVuY3Rpb24gKG5ld0R1cmF0aW9uKSB7XG4gICAgICAgIF90aGlzLl9kdXJhdGlvbiA9IG5ld0R1cmF0aW9uO1xuXG4gICAgICAgIF90aGlzLnB1dE1lc3NhZ2VPblBpcGUoJ3JlY2FsY0R1cmF0aW9uJywge30sICdHcm91cHMnLCB7XG4gICAgICAgICAgc2VsZkV4ZWN1dGU6IHRydWUsXG4gICAgICAgICAgZGlyZWN0aW9uOiBfVFJFRUNPTlNULl9ESVJFQ1RJT05TLl9VUFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIHJldHVybiBDb250ZXh0QXdhcmVDbGlwSW5jaWRlbnQ7XG4gIH0oX0xlYWYpO1xuXG4gIHJldHVybiB7XG4gICAgRjogQ29udGV4dEF3YXJlQ2xpcEluY2lkZW50LFxuICAgIGQ6IFt7XG4gICAgICBraW5kOiBcImdldFwiLFxuICAgICAga2V5OiBcIm9yaWdpbmFsQ29udGV4dFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9yaWdpbmFsQ29udGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dHNbdGhpcy5vcmlnaW5hbENvbnRleHRLZXldO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtpbmQ6IFwiZ2V0XCIsXG4gICAgICBrZXk6IFwiZHVyYXRpb25cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkdXJhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2R1cmF0aW9uO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtpbmQ6IFwibWV0aG9kXCIsXG4gICAgICBrZXk6IFwib25Qcm9ncmVzc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uUHJvZ3Jlc3MoZnJhY3Rpb24sIG1pbGxpc2Vjb25kcywgY29udGV4dElkKSB7XG4gICAgICAgIHZhciBmb3JjZVJlc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBmYWxzZTtcbiAgICAgICAgdGhpcy5jb250ZXh0c1tjb250ZXh0SWRdLm9uUHJvZ3Jlc3MoZnJhY3Rpb24sIG1pbGxpc2Vjb25kcywgZm9yY2VSZXNldCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2luZDogXCJtZXRob2RcIixcbiAgICAgIGtleTogXCJhZGRDb250ZXh0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkQ29udGV4dChjb250ZXh0RGF0YSkge1xuICAgICAgICB2YXIgZm9yY2VHZXRDb250ZXh0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICAgICAgICAvLyBpZiBpdCdzIHRoZSBmaXJzdCBjb250ZXh0IHRvIGJlIGFkZGVkIHRoZW4gaXQncyB0aGUgb3JpZ2luYWxcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuY29udGV4dHMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMub3JpZ2luYWxDb250ZXh0S2V5ID0gY29udGV4dERhdGEuY2xpcElkO1xuICAgICAgICB9IC8vIGluc3RhbnRpYXRlcyB0aGUgQ2xpcCBzbyBpdCByZW5kZXJzXG5cblxuICAgICAgICB2YXIgaW5ncmVkaWVudHNUb1Bhc3MgPSBfb2JqZWN0U3ByZWFkKHt9LCB0aGlzLmNvbnN0cnVjdGlvbkluZ3JlZGllbnRzLCB7XG4gICAgICAgICAgY29udGV4dDogY29udGV4dERhdGEuY29udGV4dCxcbiAgICAgICAgICBtY2lkOiB0aGlzLm1jaWQsXG4gICAgICAgICAgSW5jaWRlbnQ6IENsaXBDb3B5LFxuICAgICAgICAgIGRuYUV4dHJhczoge1xuICAgICAgICAgICAgZGVzY3JpcHRpdmVJbmNpZGVudDogdGhpcy5kZXNjcmlwdGl2ZUluY2lkZW50XG4gICAgICAgICAgfVxuICAgICAgICB9KTsgLy8gYW5kIHB1dHMgaXQgb24gdGhlIGNvcnJlc3BvbmRpbmcgY29udGV4dCBrZXlcblxuXG4gICAgICAgIHRoaXMuY29udGV4dHNbY29udGV4dERhdGEuY2xpcElkXSA9IGluY2lkZW50RnJvbUluZ3JlZGllbnRzKGluZ3JlZGllbnRzVG9QYXNzKTtcblxuICAgICAgICBpZiAoZm9yY2VHZXRDb250ZXh0ID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5jb250ZXh0c1tjb250ZXh0RGF0YS5jbGlwSWRdLl9vbkdldENvbnRleHRPbmNlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBraW5kOiBcIm1ldGhvZFwiLFxuICAgICAga2V5OiBcImhhbmRsZUFkZENvbnRleHRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVBZGRDb250ZXh0KHRhcmdldCwgcGF5bG9hZCkge1xuICAgICAgICB0aGlzLmFkZENvbnRleHQocGF5bG9hZCwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtpbmQ6IFwibWV0aG9kXCIsXG4gICAgICBkZWNvcmF0b3JzOiBbZ2V0SW5jaWRlbnRzQnlDaGFubmVsXSxcbiAgICAgIGtleTogXCJnZXRJbmNpZGVudHNCeUNoYW5uZWxcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJbmNpZGVudHNCeUNoYW5uZWwoKSB7fSAvLyBtYXNzaXZlIGVkaXRpbmcgbWV0aG9kcyB0aGF0IGFwcGx5IHRoZSByZXF1ZXN0IG1hc3NpdmVseSB0byBhbGwgb2YgdGhlXG4gICAgICAvLyBJbmNpZGVudHMgb2YgYWxsIG9mIHRoZSBjb250ZXh0c1xuXG4gICAgfSwge1xuICAgICAga2luZDogXCJtZXRob2RcIixcbiAgICAgIGtleTogXCJnb3RDb250ZXh0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ290Q29udGV4dCgpIHtcbiAgICAgICAgZm9yICh2YXIgY29udGV4dCBpbiB0aGlzLmNvbnRleHRzKSB7XG4gICAgICAgICAgdGhpcy5jb250ZXh0c1tjb250ZXh0XS5nb3RDb250ZXh0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBraW5kOiBcIm1ldGhvZFwiLFxuICAgICAga2V5OiBcIl9vbkdldENvbnRleHRPbmNlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX29uR2V0Q29udGV4dE9uY2UoKSB7XG4gICAgICAgIGZvciAodmFyIGNvbnRleHQgaW4gdGhpcy5jb250ZXh0cykge1xuICAgICAgICAgIHRoaXMuY29udGV4dHNbY29udGV4dF0uX29uR2V0Q29udGV4dE9uY2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtpbmQ6IFwibWV0aG9kXCIsXG4gICAgICBrZXk6IFwibGFzdFdpc2hcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBsYXN0V2lzaCgpIHtcbiAgICAgICAgZm9yICh2YXIgY29udGV4dCBpbiB0aGlzLmNvbnRleHRzKSB7XG4gICAgICAgICAgdGhpcy5jb250ZXh0c1tjb250ZXh0XS5sYXN0V2lzaCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2luZDogXCJtZXRob2RcIixcbiAgICAgIGtleTogXCJvbkdldENvbnRleHRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBvbkdldENvbnRleHQoKSB7XG4gICAgICAgIGZvciAodmFyIGNvbnRleHQgaW4gdGhpcy5jb250ZXh0cykge1xuICAgICAgICAgIHRoaXMuY29udGV4dHNbY29udGV4dF0ub25HZXRDb250ZXh0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XVxuICB9O1xufSwgTGVhZik7XG5cbm1vZHVsZS5leHBvcnRzID0gQ29udGV4dEF3YXJlQ2xpcEluY2lkZW50OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/_responsiveness/ContextAwareClipIncident.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/_responsiveness/ContextAwareIncident.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/_responsiveness/ContextAwareIncident.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _decorate(decorators, factory, superClass, mixins) { var api = _getDecoratorsApi(); if (mixins) { for (var i = 0; i < mixins.length; i++) { api = mixins[i](api); } } var r = factory(function initialize(O) { api.initializeInstanceElements(O, decorated.elements); }, superClass); var decorated = api.decorateClass(_coalesceClassElements(r.d.map(_createElementDescriptor)), decorators); api.initializeClassElements(r.F, decorated.elements); return api.runClassFinishers(r.F, decorated.finishers); }\n\nfunction _getDecoratorsApi() { _getDecoratorsApi = function _getDecoratorsApi() { return api; }; var api = { elementsDefinitionOrder: [[\"method\"], [\"field\"]], initializeInstanceElements: function initializeInstanceElements(O, elements) { [\"method\", \"field\"].forEach(function (kind) { elements.forEach(function (element) { if (element.kind === kind && element.placement === \"own\") { this.defineClassElement(O, element); } }, this); }, this); }, initializeClassElements: function initializeClassElements(F, elements) { var proto = F.prototype; [\"method\", \"field\"].forEach(function (kind) { elements.forEach(function (element) { var placement = element.placement; if (element.kind === kind && (placement === \"static\" || placement === \"prototype\")) { var receiver = placement === \"static\" ? F : proto; this.defineClassElement(receiver, element); } }, this); }, this); }, defineClassElement: function defineClassElement(receiver, element) { var descriptor = element.descriptor; if (element.kind === \"field\") { var initializer = element.initializer; descriptor = { enumerable: descriptor.enumerable, writable: descriptor.writable, configurable: descriptor.configurable, value: initializer === void 0 ? void 0 : initializer.call(receiver) }; } Object.defineProperty(receiver, element.key, descriptor); }, decorateClass: function decorateClass(elements, decorators) { var newElements = []; var finishers = []; var placements = { \"static\": [], prototype: [], own: [] }; elements.forEach(function (element) { this.addElementPlacement(element, placements); }, this); elements.forEach(function (element) { if (!_hasDecorators(element)) return newElements.push(element); var elementFinishersExtras = this.decorateElement(element, placements); newElements.push(elementFinishersExtras.element); newElements.push.apply(newElements, elementFinishersExtras.extras); finishers.push.apply(finishers, elementFinishersExtras.finishers); }, this); if (!decorators) { return { elements: newElements, finishers: finishers }; } var result = this.decorateConstructor(newElements, decorators); finishers.push.apply(finishers, result.finishers); result.finishers = finishers; return result; }, addElementPlacement: function addElementPlacement(element, placements, silent) { var keys = placements[element.placement]; if (!silent && keys.indexOf(element.key) !== -1) { throw new TypeError(\"Duplicated element (\" + element.key + \")\"); } keys.push(element.key); }, decorateElement: function decorateElement(element, placements) { var extras = []; var finishers = []; for (var decorators = element.decorators, i = decorators.length - 1; i >= 0; i--) { var keys = placements[element.placement]; keys.splice(keys.indexOf(element.key), 1); var elementObject = this.fromElementDescriptor(element); var elementFinisherExtras = this.toElementFinisherExtras((0, decorators[i])(elementObject) || elementObject); element = elementFinisherExtras.element; this.addElementPlacement(element, placements); if (elementFinisherExtras.finisher) { finishers.push(elementFinisherExtras.finisher); } var newExtras = elementFinisherExtras.extras; if (newExtras) { for (var j = 0; j < newExtras.length; j++) { this.addElementPlacement(newExtras[j], placements); } extras.push.apply(extras, newExtras); } } return { element: element, finishers: finishers, extras: extras }; }, decorateConstructor: function decorateConstructor(elements, decorators) { var finishers = []; for (var i = decorators.length - 1; i >= 0; i--) { var obj = this.fromClassDescriptor(elements); var elementsAndFinisher = this.toClassDescriptor((0, decorators[i])(obj) || obj); if (elementsAndFinisher.finisher !== undefined) { finishers.push(elementsAndFinisher.finisher); } if (elementsAndFinisher.elements !== undefined) { elements = elementsAndFinisher.elements; for (var j = 0; j < elements.length - 1; j++) { for (var k = j + 1; k < elements.length; k++) { if (elements[j].key === elements[k].key && elements[j].placement === elements[k].placement) { throw new TypeError(\"Duplicated element (\" + elements[j].key + \")\"); } } } } } return { elements: elements, finishers: finishers }; }, fromElementDescriptor: function fromElementDescriptor(element) { var obj = { kind: element.kind, key: element.key, placement: element.placement, descriptor: element.descriptor }; var desc = { value: \"Descriptor\", configurable: true }; Object.defineProperty(obj, Symbol.toStringTag, desc); if (element.kind === \"field\") obj.initializer = element.initializer; return obj; }, toElementDescriptors: function toElementDescriptors(elementObjects) { if (elementObjects === undefined) return; return _toArray(elementObjects).map(function (elementObject) { var element = this.toElementDescriptor(elementObject); this.disallowProperty(elementObject, \"finisher\", \"An element descriptor\"); this.disallowProperty(elementObject, \"extras\", \"An element descriptor\"); return element; }, this); }, toElementDescriptor: function toElementDescriptor(elementObject) { var kind = String(elementObject.kind); if (kind !== \"method\" && kind !== \"field\") { throw new TypeError('An element descriptor\\'s .kind property must be either \"method\" or' + ' \"field\", but a decorator created an element descriptor with' + ' .kind \"' + kind + '\"'); } var key = _toPropertyKey(elementObject.key); var placement = String(elementObject.placement); if (placement !== \"static\" && placement !== \"prototype\" && placement !== \"own\") { throw new TypeError('An element descriptor\\'s .placement property must be one of \"static\",' + ' \"prototype\" or \"own\", but a decorator created an element descriptor' + ' with .placement \"' + placement + '\"'); } var descriptor = elementObject.descriptor; this.disallowProperty(elementObject, \"elements\", \"An element descriptor\"); var element = { kind: kind, key: key, placement: placement, descriptor: Object.assign({}, descriptor) }; if (kind !== \"field\") { this.disallowProperty(elementObject, \"initializer\", \"A method descriptor\"); } else { this.disallowProperty(descriptor, \"get\", \"The property descriptor of a field descriptor\"); this.disallowProperty(descriptor, \"set\", \"The property descriptor of a field descriptor\"); this.disallowProperty(descriptor, \"value\", \"The property descriptor of a field descriptor\"); element.initializer = elementObject.initializer; } return element; }, toElementFinisherExtras: function toElementFinisherExtras(elementObject) { var element = this.toElementDescriptor(elementObject); var finisher = _optionalCallableProperty(elementObject, \"finisher\"); var extras = this.toElementDescriptors(elementObject.extras); return { element: element, finisher: finisher, extras: extras }; }, fromClassDescriptor: function fromClassDescriptor(elements) { var obj = { kind: \"class\", elements: elements.map(this.fromElementDescriptor, this) }; var desc = { value: \"Descriptor\", configurable: true }; Object.defineProperty(obj, Symbol.toStringTag, desc); return obj; }, toClassDescriptor: function toClassDescriptor(obj) { var kind = String(obj.kind); if (kind !== \"class\") { throw new TypeError('A class descriptor\\'s .kind property must be \"class\", but a decorator' + ' created a class descriptor with .kind \"' + kind + '\"'); } this.disallowProperty(obj, \"key\", \"A class descriptor\"); this.disallowProperty(obj, \"placement\", \"A class descriptor\"); this.disallowProperty(obj, \"descriptor\", \"A class descriptor\"); this.disallowProperty(obj, \"initializer\", \"A class descriptor\"); this.disallowProperty(obj, \"extras\", \"A class descriptor\"); var finisher = _optionalCallableProperty(obj, \"finisher\"); var elements = this.toElementDescriptors(obj.elements); return { elements: elements, finisher: finisher }; }, runClassFinishers: function runClassFinishers(constructor, finishers) { for (var i = 0; i < finishers.length; i++) { var newConstructor = (0, finishers[i])(constructor); if (newConstructor !== undefined) { if (typeof newConstructor !== \"function\") { throw new TypeError(\"Finishers must return a constructor.\"); } constructor = newConstructor; } } return constructor; }, disallowProperty: function disallowProperty(obj, name, objectType) { if (obj[name] !== undefined) { throw new TypeError(objectType + \" can't have a .\" + name + \" property.\"); } } }; return api; }\n\nfunction _createElementDescriptor(def) { var key = _toPropertyKey(def.key); var descriptor; if (def.kind === \"method\") { descriptor = { value: def.value, writable: true, configurable: true, enumerable: false }; } else if (def.kind === \"get\") { descriptor = { get: def.value, configurable: true, enumerable: false }; } else if (def.kind === \"set\") { descriptor = { set: def.value, configurable: true, enumerable: false }; } else if (def.kind === \"field\") { descriptor = { configurable: true, writable: true, enumerable: true }; } var element = { kind: def.kind === \"field\" ? \"field\" : \"method\", key: key, placement: def[\"static\"] ? \"static\" : def.kind === \"field\" ? \"own\" : \"prototype\", descriptor: descriptor }; if (def.decorators) element.decorators = def.decorators; if (def.kind === \"field\") element.initializer = def.value; return element; }\n\nfunction _coalesceGetterSetter(element, other) { if (element.descriptor.get !== undefined) { other.descriptor.get = element.descriptor.get; } else { other.descriptor.set = element.descriptor.set; } }\n\nfunction _coalesceClassElements(elements) { var newElements = []; var isSameElement = function isSameElement(other) { return other.kind === \"method\" && other.key === element.key && other.placement === element.placement; }; for (var i = 0; i < elements.length; i++) { var element = elements[i]; var other; if (element.kind === \"method\" && (other = newElements.find(isSameElement))) { if (_isDataDescriptor(element.descriptor) || _isDataDescriptor(other.descriptor)) { if (_hasDecorators(element) || _hasDecorators(other)) { throw new ReferenceError(\"Duplicated methods (\" + element.key + \") can't be decorated.\"); } other.descriptor = element.descriptor; } else { if (_hasDecorators(element)) { if (_hasDecorators(other)) { throw new ReferenceError(\"Decorators can't be placed on different accessors with for \" + \"the same property (\" + element.key + \").\"); } other.decorators = element.decorators; } _coalesceGetterSetter(element, other); } } else { newElements.push(element); } } return newElements; }\n\nfunction _hasDecorators(element) { return element.decorators && element.decorators.length; }\n\nfunction _isDataDescriptor(desc) { return desc !== undefined && !(desc.value === undefined && desc.writable === undefined); }\n\nfunction _optionalCallableProperty(obj, name) { var value = obj[name]; if (value !== undefined && typeof value !== \"function\") { throw new TypeError(\"Expected '\" + name + \"' to be a function\"); } return value; }\n\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\n\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\nfunction _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nvar Leaf = __webpack_require__(/*! ../_Tree/Leaf */ \"./node_modules/@kissmybutton/motorcortex/dist/_Tree/Leaf.js\");\n\nvar incidentFromIngredients = __webpack_require__(/*! ../IncidentFromDefinition/incidentFromIngredients */ \"./node_modules/@kissmybutton/motorcortex/dist/IncidentFromDefinition/incidentFromIngredients.js\");\n\nvar getIncidentsByChannel = __webpack_require__(/*! ../decorators/getIncidentsByChannel */ \"./node_modules/@kissmybutton/motorcortex/dist/decorators/getIncidentsByChannel.js\");\n\nvar ContextAwareIncident = _decorate(null, function (_initialize, _Leaf) {\n  var ContextAwareIncident =\n  /*#__PURE__*/\n  function (_Leaf2) {\n    _inherits(ContextAwareIncident, _Leaf2);\n\n    function ContextAwareIncident(constructionIngredients, contextData, mcid, attribute) {\n      var _this;\n\n      _classCallCheck(this, ContextAwareIncident);\n\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(ContextAwareIncident).call(this, {\n        id: \"\".concat(constructionIngredients.incidentId, \"_\").concat(mcid, \"_\").concat(attribute)\n      })); // a property to hold all of the contexts\n\n      _initialize(_assertThisInitialized(_this));\n\n      _this.contexts = {};\n      _this.constructionIngredients = constructionIngredients;\n      _this.mcid = mcid;\n      _this.attribute = attribute;\n      _this._duration = constructionIngredients.props.duration;\n      _this.mc_plugin_npm_name = constructionIngredients.plugin_npm_name;\n      _this.plugin_channel_class = constructionIngredients.Channel;\n\n      _this.addContext(contextData);\n\n      if (_typeof(_this.constructionIngredients.attrs.animatedAttrs[_this.attribute]) === 'object') {\n        _this.originalAnimatedAttributeValue = Object.assign({}, _this.constructionIngredients.attrs.animatedAttrs[_this.attribute]);\n      } else {\n        _this.originalAnimatedAttributeValue = _this.constructionIngredients.attrs.animatedAttrs[_this.attribute];\n      }\n\n      return _this;\n    }\n\n    return ContextAwareIncident;\n  }(_Leaf);\n\n  return {\n    F: ContextAwareIncident,\n    d: [{\n      kind: \"get\",\n      key: \"originalContext\",\n      value: function originalContext() {\n        return this.contexts[this.originalContextKey];\n      }\n    }, {\n      kind: \"get\",\n      key: \"duration\",\n      value: function duration() {\n        return this._duration;\n      }\n    }, {\n      kind: \"set\",\n      key: \"duration\",\n      value: function duration(milliseconds) {\n        this._duration = milliseconds;\n\n        for (var context in this.contexts) {\n          this.contexts[context].duration = milliseconds;\n        }\n      }\n    }, {\n      kind: \"method\",\n      key: \"addContext\",\n      value: function addContext(contextData) {\n        var forceGetContext = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        // if it's the first context to be added then it's the original\n        var isTheOriginalContext = false;\n\n        if (Object.keys(this.contexts).length === 0) {\n          this.originalContextKey = contextData.clipId;\n          isTheOriginalContext = true;\n        }\n\n        var ingredientsToPass = _objectSpread({}, this.constructionIngredients, {\n          context: contextData.context,\n          mcid: this.mcid\n        });\n\n        var whatToAdd = incidentFromIngredients(ingredientsToPass);\n        this.contexts[contextData.clipId] = whatToAdd; // when we add a new context we must set the inital value of the newly added Incidents\n\n        if (!isTheOriginalContext) {\n          this.contexts[contextData.clipId].setInitialValue(this.getInitialValue());\n        }\n\n        if (forceGetContext === true) {\n          this.contexts[contextData.clipId]._onGetContextOnce();\n        }\n      }\n    }, {\n      kind: \"method\",\n      key: \"handleAddContext\",\n      value: function handleAddContext(target, payload) {\n        this.addContext(payload, true);\n        return true;\n      }\n    }, {\n      kind: \"method\",\n      decorators: [getIncidentsByChannel],\n      key: \"getIncidentsByChannel\",\n      value: function getIncidentsByChannel() {}\n    }, {\n      kind: \"method\",\n      key: \"onProgress\",\n      value: function onProgress(fraction, milliseconds, contextId) {\n        if (contextId === undefined) {\n          for (var context in this.contexts) {\n            this.contexts[context].onProgress(fraction, milliseconds);\n          }\n\n          return;\n        }\n\n        try {\n          this.contexts[contextId].onProgress(fraction, milliseconds);\n        } catch (e) {\n          console.log('--------- ERROR -----------');\n          console.log(e);\n        }\n      }\n      /** METHODS THAT ACT AS \"PROXY\" TO ALL OF THE INCIDENTS BELONGING TO\n       * THE INCIDENTS COLLECTION OF THE CONTEXT AWARE INCIDENT\n       **/\n      // sample methods. Return the required information out of the Incident of\n      // the originalContext\n\n    }, {\n      kind: \"method\",\n      key: \"hasInitialValue\",\n      value: function hasInitialValue() {\n        return this.originalContext.hasInitialValue();\n      }\n    }, {\n      kind: \"method\",\n      key: \"getInitialValue\",\n      value: function getInitialValue() {\n        var attribute = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n        if (attribute === null) {\n          attribute = this.attribute;\n        }\n\n        return this.originalContext.getInitialValue();\n      }\n    }, {\n      kind: \"get\",\n      key: \"animatedAttributeValue\",\n      value: function animatedAttributeValue() {\n        return this.constructionIngredients.attrs.animatedAttrs[this.attribute];\n      }\n    }, {\n      kind: \"method\",\n      key: \"getScratchValue\",\n      value: function getScratchValue() {\n        return this.originalContext.getScratchValue();\n      } // massive editing methods that apply the request massively to all of the\n      // Incidents of all of the contexts\n\n    }, {\n      kind: \"method\",\n      key: \"gotContext\",\n      value: function gotContext() {\n        for (var context in this.contexts) {\n          this.contexts[context].gotContext();\n        }\n      }\n    }, {\n      kind: \"method\",\n      key: \"_onGetContextOnce\",\n      value: function _onGetContextOnce() {\n        for (var context in this.contexts) {\n          this.contexts[context]._onGetContextOnce();\n        }\n      }\n    }, {\n      kind: \"method\",\n      key: \"lastWish\",\n      value: function lastWish() {\n        for (var context in this.contexts) {\n          this.contexts[context].lastWish();\n        }\n      }\n    }, {\n      kind: \"method\",\n      key: \"onGetContext\",\n      value: function onGetContext() {\n        for (var context in this.contexts) {\n          this.contexts[context].onGetContext();\n        }\n      }\n    }, {\n      kind: \"method\",\n      key: \"setInitialValue\",\n      value: function setInitialValue(value) {\n        for (var context in this.contexts) {\n          this.contexts[context].setInitialValue(value);\n        }\n      }\n    }, {\n      kind: \"method\",\n      key: \"setCompoAttrKeyValue\",\n      value: function setCompoAttrKeyValue(key, value) {\n        for (var context in this.contexts) {\n          this.contexts[context].attrs.animatedAttrs[this.attribute][key] = value;\n          this.contexts[context].lastWish();\n          this.contexts[context].onGetContext();\n        }\n      }\n    }]\n  };\n}, Leaf);\n\nmodule.exports = ContextAwareIncident;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19yZXNwb25zaXZlbmVzcy9Db250ZXh0QXdhcmVJbmNpZGVudC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Aa2lzc215YnV0dG9uL21vdG9yY29ydGV4L2Rpc3QvX3Jlc3BvbnNpdmVuZXNzL0NvbnRleHRBd2FyZUluY2lkZW50LmpzPzE0ZTMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyB2YXIgb3duS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IGlmICh0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gJ2Z1bmN0aW9uJykgeyBvd25LZXlzID0gb3duS2V5cy5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwgc3ltKS5lbnVtZXJhYmxlOyB9KSk7IH0gb3duS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfZGVjb3JhdGUoZGVjb3JhdG9ycywgZmFjdG9yeSwgc3VwZXJDbGFzcywgbWl4aW5zKSB7IHZhciBhcGkgPSBfZ2V0RGVjb3JhdG9yc0FwaSgpOyBpZiAobWl4aW5zKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgbWl4aW5zLmxlbmd0aDsgaSsrKSB7IGFwaSA9IG1peGluc1tpXShhcGkpOyB9IH0gdmFyIHIgPSBmYWN0b3J5KGZ1bmN0aW9uIGluaXRpYWxpemUoTykgeyBhcGkuaW5pdGlhbGl6ZUluc3RhbmNlRWxlbWVudHMoTywgZGVjb3JhdGVkLmVsZW1lbnRzKTsgfSwgc3VwZXJDbGFzcyk7IHZhciBkZWNvcmF0ZWQgPSBhcGkuZGVjb3JhdGVDbGFzcyhfY29hbGVzY2VDbGFzc0VsZW1lbnRzKHIuZC5tYXAoX2NyZWF0ZUVsZW1lbnREZXNjcmlwdG9yKSksIGRlY29yYXRvcnMpOyBhcGkuaW5pdGlhbGl6ZUNsYXNzRWxlbWVudHMoci5GLCBkZWNvcmF0ZWQuZWxlbWVudHMpOyByZXR1cm4gYXBpLnJ1bkNsYXNzRmluaXNoZXJzKHIuRiwgZGVjb3JhdGVkLmZpbmlzaGVycyk7IH1cblxuZnVuY3Rpb24gX2dldERlY29yYXRvcnNBcGkoKSB7IF9nZXREZWNvcmF0b3JzQXBpID0gZnVuY3Rpb24gX2dldERlY29yYXRvcnNBcGkoKSB7IHJldHVybiBhcGk7IH07IHZhciBhcGkgPSB7IGVsZW1lbnRzRGVmaW5pdGlvbk9yZGVyOiBbW1wibWV0aG9kXCJdLCBbXCJmaWVsZFwiXV0sIGluaXRpYWxpemVJbnN0YW5jZUVsZW1lbnRzOiBmdW5jdGlvbiBpbml0aWFsaXplSW5zdGFuY2VFbGVtZW50cyhPLCBlbGVtZW50cykgeyBbXCJtZXRob2RcIiwgXCJmaWVsZFwiXS5mb3JFYWNoKGZ1bmN0aW9uIChraW5kKSB7IGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHsgaWYgKGVsZW1lbnQua2luZCA9PT0ga2luZCAmJiBlbGVtZW50LnBsYWNlbWVudCA9PT0gXCJvd25cIikgeyB0aGlzLmRlZmluZUNsYXNzRWxlbWVudChPLCBlbGVtZW50KTsgfSB9LCB0aGlzKTsgfSwgdGhpcyk7IH0sIGluaXRpYWxpemVDbGFzc0VsZW1lbnRzOiBmdW5jdGlvbiBpbml0aWFsaXplQ2xhc3NFbGVtZW50cyhGLCBlbGVtZW50cykgeyB2YXIgcHJvdG8gPSBGLnByb3RvdHlwZTsgW1wibWV0aG9kXCIsIFwiZmllbGRcIl0uZm9yRWFjaChmdW5jdGlvbiAoa2luZCkgeyBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7IHZhciBwbGFjZW1lbnQgPSBlbGVtZW50LnBsYWNlbWVudDsgaWYgKGVsZW1lbnQua2luZCA9PT0ga2luZCAmJiAocGxhY2VtZW50ID09PSBcInN0YXRpY1wiIHx8IHBsYWNlbWVudCA9PT0gXCJwcm90b3R5cGVcIikpIHsgdmFyIHJlY2VpdmVyID0gcGxhY2VtZW50ID09PSBcInN0YXRpY1wiID8gRiA6IHByb3RvOyB0aGlzLmRlZmluZUNsYXNzRWxlbWVudChyZWNlaXZlciwgZWxlbWVudCk7IH0gfSwgdGhpcyk7IH0sIHRoaXMpOyB9LCBkZWZpbmVDbGFzc0VsZW1lbnQ6IGZ1bmN0aW9uIGRlZmluZUNsYXNzRWxlbWVudChyZWNlaXZlciwgZWxlbWVudCkgeyB2YXIgZGVzY3JpcHRvciA9IGVsZW1lbnQuZGVzY3JpcHRvcjsgaWYgKGVsZW1lbnQua2luZCA9PT0gXCJmaWVsZFwiKSB7IHZhciBpbml0aWFsaXplciA9IGVsZW1lbnQuaW5pdGlhbGl6ZXI7IGRlc2NyaXB0b3IgPSB7IGVudW1lcmFibGU6IGRlc2NyaXB0b3IuZW51bWVyYWJsZSwgd3JpdGFibGU6IGRlc2NyaXB0b3Iud3JpdGFibGUsIGNvbmZpZ3VyYWJsZTogZGVzY3JpcHRvci5jb25maWd1cmFibGUsIHZhbHVlOiBpbml0aWFsaXplciA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5pdGlhbGl6ZXIuY2FsbChyZWNlaXZlcikgfTsgfSBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVjZWl2ZXIsIGVsZW1lbnQua2V5LCBkZXNjcmlwdG9yKTsgfSwgZGVjb3JhdGVDbGFzczogZnVuY3Rpb24gZGVjb3JhdGVDbGFzcyhlbGVtZW50cywgZGVjb3JhdG9ycykgeyB2YXIgbmV3RWxlbWVudHMgPSBbXTsgdmFyIGZpbmlzaGVycyA9IFtdOyB2YXIgcGxhY2VtZW50cyA9IHsgXCJzdGF0aWNcIjogW10sIHByb3RvdHlwZTogW10sIG93bjogW10gfTsgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkgeyB0aGlzLmFkZEVsZW1lbnRQbGFjZW1lbnQoZWxlbWVudCwgcGxhY2VtZW50cyk7IH0sIHRoaXMpOyBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7IGlmICghX2hhc0RlY29yYXRvcnMoZWxlbWVudCkpIHJldHVybiBuZXdFbGVtZW50cy5wdXNoKGVsZW1lbnQpOyB2YXIgZWxlbWVudEZpbmlzaGVyc0V4dHJhcyA9IHRoaXMuZGVjb3JhdGVFbGVtZW50KGVsZW1lbnQsIHBsYWNlbWVudHMpOyBuZXdFbGVtZW50cy5wdXNoKGVsZW1lbnRGaW5pc2hlcnNFeHRyYXMuZWxlbWVudCk7IG5ld0VsZW1lbnRzLnB1c2guYXBwbHkobmV3RWxlbWVudHMsIGVsZW1lbnRGaW5pc2hlcnNFeHRyYXMuZXh0cmFzKTsgZmluaXNoZXJzLnB1c2guYXBwbHkoZmluaXNoZXJzLCBlbGVtZW50RmluaXNoZXJzRXh0cmFzLmZpbmlzaGVycyk7IH0sIHRoaXMpOyBpZiAoIWRlY29yYXRvcnMpIHsgcmV0dXJuIHsgZWxlbWVudHM6IG5ld0VsZW1lbnRzLCBmaW5pc2hlcnM6IGZpbmlzaGVycyB9OyB9IHZhciByZXN1bHQgPSB0aGlzLmRlY29yYXRlQ29uc3RydWN0b3IobmV3RWxlbWVudHMsIGRlY29yYXRvcnMpOyBmaW5pc2hlcnMucHVzaC5hcHBseShmaW5pc2hlcnMsIHJlc3VsdC5maW5pc2hlcnMpOyByZXN1bHQuZmluaXNoZXJzID0gZmluaXNoZXJzOyByZXR1cm4gcmVzdWx0OyB9LCBhZGRFbGVtZW50UGxhY2VtZW50OiBmdW5jdGlvbiBhZGRFbGVtZW50UGxhY2VtZW50KGVsZW1lbnQsIHBsYWNlbWVudHMsIHNpbGVudCkgeyB2YXIga2V5cyA9IHBsYWNlbWVudHNbZWxlbWVudC5wbGFjZW1lbnRdOyBpZiAoIXNpbGVudCAmJiBrZXlzLmluZGV4T2YoZWxlbWVudC5rZXkpICE9PSAtMSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRHVwbGljYXRlZCBlbGVtZW50IChcIiArIGVsZW1lbnQua2V5ICsgXCIpXCIpOyB9IGtleXMucHVzaChlbGVtZW50LmtleSk7IH0sIGRlY29yYXRlRWxlbWVudDogZnVuY3Rpb24gZGVjb3JhdGVFbGVtZW50KGVsZW1lbnQsIHBsYWNlbWVudHMpIHsgdmFyIGV4dHJhcyA9IFtdOyB2YXIgZmluaXNoZXJzID0gW107IGZvciAodmFyIGRlY29yYXRvcnMgPSBlbGVtZW50LmRlY29yYXRvcnMsIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7IHZhciBrZXlzID0gcGxhY2VtZW50c1tlbGVtZW50LnBsYWNlbWVudF07IGtleXMuc3BsaWNlKGtleXMuaW5kZXhPZihlbGVtZW50LmtleSksIDEpOyB2YXIgZWxlbWVudE9iamVjdCA9IHRoaXMuZnJvbUVsZW1lbnREZXNjcmlwdG9yKGVsZW1lbnQpOyB2YXIgZWxlbWVudEZpbmlzaGVyRXh0cmFzID0gdGhpcy50b0VsZW1lbnRGaW5pc2hlckV4dHJhcygoMCwgZGVjb3JhdG9yc1tpXSkoZWxlbWVudE9iamVjdCkgfHwgZWxlbWVudE9iamVjdCk7IGVsZW1lbnQgPSBlbGVtZW50RmluaXNoZXJFeHRyYXMuZWxlbWVudDsgdGhpcy5hZGRFbGVtZW50UGxhY2VtZW50KGVsZW1lbnQsIHBsYWNlbWVudHMpOyBpZiAoZWxlbWVudEZpbmlzaGVyRXh0cmFzLmZpbmlzaGVyKSB7IGZpbmlzaGVycy5wdXNoKGVsZW1lbnRGaW5pc2hlckV4dHJhcy5maW5pc2hlcik7IH0gdmFyIG5ld0V4dHJhcyA9IGVsZW1lbnRGaW5pc2hlckV4dHJhcy5leHRyYXM7IGlmIChuZXdFeHRyYXMpIHsgZm9yICh2YXIgaiA9IDA7IGogPCBuZXdFeHRyYXMubGVuZ3RoOyBqKyspIHsgdGhpcy5hZGRFbGVtZW50UGxhY2VtZW50KG5ld0V4dHJhc1tqXSwgcGxhY2VtZW50cyk7IH0gZXh0cmFzLnB1c2guYXBwbHkoZXh0cmFzLCBuZXdFeHRyYXMpOyB9IH0gcmV0dXJuIHsgZWxlbWVudDogZWxlbWVudCwgZmluaXNoZXJzOiBmaW5pc2hlcnMsIGV4dHJhczogZXh0cmFzIH07IH0sIGRlY29yYXRlQ29uc3RydWN0b3I6IGZ1bmN0aW9uIGRlY29yYXRlQ29uc3RydWN0b3IoZWxlbWVudHMsIGRlY29yYXRvcnMpIHsgdmFyIGZpbmlzaGVycyA9IFtdOyBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgeyB2YXIgb2JqID0gdGhpcy5mcm9tQ2xhc3NEZXNjcmlwdG9yKGVsZW1lbnRzKTsgdmFyIGVsZW1lbnRzQW5kRmluaXNoZXIgPSB0aGlzLnRvQ2xhc3NEZXNjcmlwdG9yKCgwLCBkZWNvcmF0b3JzW2ldKShvYmopIHx8IG9iaik7IGlmIChlbGVtZW50c0FuZEZpbmlzaGVyLmZpbmlzaGVyICE9PSB1bmRlZmluZWQpIHsgZmluaXNoZXJzLnB1c2goZWxlbWVudHNBbmRGaW5pc2hlci5maW5pc2hlcik7IH0gaWYgKGVsZW1lbnRzQW5kRmluaXNoZXIuZWxlbWVudHMgIT09IHVuZGVmaW5lZCkgeyBlbGVtZW50cyA9IGVsZW1lbnRzQW5kRmluaXNoZXIuZWxlbWVudHM7IGZvciAodmFyIGogPSAwOyBqIDwgZWxlbWVudHMubGVuZ3RoIC0gMTsgaisrKSB7IGZvciAodmFyIGsgPSBqICsgMTsgayA8IGVsZW1lbnRzLmxlbmd0aDsgaysrKSB7IGlmIChlbGVtZW50c1tqXS5rZXkgPT09IGVsZW1lbnRzW2tdLmtleSAmJiBlbGVtZW50c1tqXS5wbGFjZW1lbnQgPT09IGVsZW1lbnRzW2tdLnBsYWNlbWVudCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRHVwbGljYXRlZCBlbGVtZW50IChcIiArIGVsZW1lbnRzW2pdLmtleSArIFwiKVwiKTsgfSB9IH0gfSB9IHJldHVybiB7IGVsZW1lbnRzOiBlbGVtZW50cywgZmluaXNoZXJzOiBmaW5pc2hlcnMgfTsgfSwgZnJvbUVsZW1lbnREZXNjcmlwdG9yOiBmdW5jdGlvbiBmcm9tRWxlbWVudERlc2NyaXB0b3IoZWxlbWVudCkgeyB2YXIgb2JqID0geyBraW5kOiBlbGVtZW50LmtpbmQsIGtleTogZWxlbWVudC5rZXksIHBsYWNlbWVudDogZWxlbWVudC5wbGFjZW1lbnQsIGRlc2NyaXB0b3I6IGVsZW1lbnQuZGVzY3JpcHRvciB9OyB2YXIgZGVzYyA9IHsgdmFsdWU6IFwiRGVzY3JpcHRvclwiLCBjb25maWd1cmFibGU6IHRydWUgfTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgU3ltYm9sLnRvU3RyaW5nVGFnLCBkZXNjKTsgaWYgKGVsZW1lbnQua2luZCA9PT0gXCJmaWVsZFwiKSBvYmouaW5pdGlhbGl6ZXIgPSBlbGVtZW50LmluaXRpYWxpemVyOyByZXR1cm4gb2JqOyB9LCB0b0VsZW1lbnREZXNjcmlwdG9yczogZnVuY3Rpb24gdG9FbGVtZW50RGVzY3JpcHRvcnMoZWxlbWVudE9iamVjdHMpIHsgaWYgKGVsZW1lbnRPYmplY3RzID09PSB1bmRlZmluZWQpIHJldHVybjsgcmV0dXJuIF90b0FycmF5KGVsZW1lbnRPYmplY3RzKS5tYXAoZnVuY3Rpb24gKGVsZW1lbnRPYmplY3QpIHsgdmFyIGVsZW1lbnQgPSB0aGlzLnRvRWxlbWVudERlc2NyaXB0b3IoZWxlbWVudE9iamVjdCk7IHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShlbGVtZW50T2JqZWN0LCBcImZpbmlzaGVyXCIsIFwiQW4gZWxlbWVudCBkZXNjcmlwdG9yXCIpOyB0aGlzLmRpc2FsbG93UHJvcGVydHkoZWxlbWVudE9iamVjdCwgXCJleHRyYXNcIiwgXCJBbiBlbGVtZW50IGRlc2NyaXB0b3JcIik7IHJldHVybiBlbGVtZW50OyB9LCB0aGlzKTsgfSwgdG9FbGVtZW50RGVzY3JpcHRvcjogZnVuY3Rpb24gdG9FbGVtZW50RGVzY3JpcHRvcihlbGVtZW50T2JqZWN0KSB7IHZhciBraW5kID0gU3RyaW5nKGVsZW1lbnRPYmplY3Qua2luZCk7IGlmIChraW5kICE9PSBcIm1ldGhvZFwiICYmIGtpbmQgIT09IFwiZmllbGRcIikgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdBbiBlbGVtZW50IGRlc2NyaXB0b3JcXCdzIC5raW5kIHByb3BlcnR5IG11c3QgYmUgZWl0aGVyIFwibWV0aG9kXCIgb3InICsgJyBcImZpZWxkXCIsIGJ1dCBhIGRlY29yYXRvciBjcmVhdGVkIGFuIGVsZW1lbnQgZGVzY3JpcHRvciB3aXRoJyArICcgLmtpbmQgXCInICsga2luZCArICdcIicpOyB9IHZhciBrZXkgPSBfdG9Qcm9wZXJ0eUtleShlbGVtZW50T2JqZWN0LmtleSk7IHZhciBwbGFjZW1lbnQgPSBTdHJpbmcoZWxlbWVudE9iamVjdC5wbGFjZW1lbnQpOyBpZiAocGxhY2VtZW50ICE9PSBcInN0YXRpY1wiICYmIHBsYWNlbWVudCAhPT0gXCJwcm90b3R5cGVcIiAmJiBwbGFjZW1lbnQgIT09IFwib3duXCIpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQW4gZWxlbWVudCBkZXNjcmlwdG9yXFwncyAucGxhY2VtZW50IHByb3BlcnR5IG11c3QgYmUgb25lIG9mIFwic3RhdGljXCIsJyArICcgXCJwcm90b3R5cGVcIiBvciBcIm93blwiLCBidXQgYSBkZWNvcmF0b3IgY3JlYXRlZCBhbiBlbGVtZW50IGRlc2NyaXB0b3InICsgJyB3aXRoIC5wbGFjZW1lbnQgXCInICsgcGxhY2VtZW50ICsgJ1wiJyk7IH0gdmFyIGRlc2NyaXB0b3IgPSBlbGVtZW50T2JqZWN0LmRlc2NyaXB0b3I7IHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShlbGVtZW50T2JqZWN0LCBcImVsZW1lbnRzXCIsIFwiQW4gZWxlbWVudCBkZXNjcmlwdG9yXCIpOyB2YXIgZWxlbWVudCA9IHsga2luZDoga2luZCwga2V5OiBrZXksIHBsYWNlbWVudDogcGxhY2VtZW50LCBkZXNjcmlwdG9yOiBPYmplY3QuYXNzaWduKHt9LCBkZXNjcmlwdG9yKSB9OyBpZiAoa2luZCAhPT0gXCJmaWVsZFwiKSB7IHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShlbGVtZW50T2JqZWN0LCBcImluaXRpYWxpemVyXCIsIFwiQSBtZXRob2QgZGVzY3JpcHRvclwiKTsgfSBlbHNlIHsgdGhpcy5kaXNhbGxvd1Byb3BlcnR5KGRlc2NyaXB0b3IsIFwiZ2V0XCIsIFwiVGhlIHByb3BlcnR5IGRlc2NyaXB0b3Igb2YgYSBmaWVsZCBkZXNjcmlwdG9yXCIpOyB0aGlzLmRpc2FsbG93UHJvcGVydHkoZGVzY3JpcHRvciwgXCJzZXRcIiwgXCJUaGUgcHJvcGVydHkgZGVzY3JpcHRvciBvZiBhIGZpZWxkIGRlc2NyaXB0b3JcIik7IHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShkZXNjcmlwdG9yLCBcInZhbHVlXCIsIFwiVGhlIHByb3BlcnR5IGRlc2NyaXB0b3Igb2YgYSBmaWVsZCBkZXNjcmlwdG9yXCIpOyBlbGVtZW50LmluaXRpYWxpemVyID0gZWxlbWVudE9iamVjdC5pbml0aWFsaXplcjsgfSByZXR1cm4gZWxlbWVudDsgfSwgdG9FbGVtZW50RmluaXNoZXJFeHRyYXM6IGZ1bmN0aW9uIHRvRWxlbWVudEZpbmlzaGVyRXh0cmFzKGVsZW1lbnRPYmplY3QpIHsgdmFyIGVsZW1lbnQgPSB0aGlzLnRvRWxlbWVudERlc2NyaXB0b3IoZWxlbWVudE9iamVjdCk7IHZhciBmaW5pc2hlciA9IF9vcHRpb25hbENhbGxhYmxlUHJvcGVydHkoZWxlbWVudE9iamVjdCwgXCJmaW5pc2hlclwiKTsgdmFyIGV4dHJhcyA9IHRoaXMudG9FbGVtZW50RGVzY3JpcHRvcnMoZWxlbWVudE9iamVjdC5leHRyYXMpOyByZXR1cm4geyBlbGVtZW50OiBlbGVtZW50LCBmaW5pc2hlcjogZmluaXNoZXIsIGV4dHJhczogZXh0cmFzIH07IH0sIGZyb21DbGFzc0Rlc2NyaXB0b3I6IGZ1bmN0aW9uIGZyb21DbGFzc0Rlc2NyaXB0b3IoZWxlbWVudHMpIHsgdmFyIG9iaiA9IHsga2luZDogXCJjbGFzc1wiLCBlbGVtZW50czogZWxlbWVudHMubWFwKHRoaXMuZnJvbUVsZW1lbnREZXNjcmlwdG9yLCB0aGlzKSB9OyB2YXIgZGVzYyA9IHsgdmFsdWU6IFwiRGVzY3JpcHRvclwiLCBjb25maWd1cmFibGU6IHRydWUgfTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgU3ltYm9sLnRvU3RyaW5nVGFnLCBkZXNjKTsgcmV0dXJuIG9iajsgfSwgdG9DbGFzc0Rlc2NyaXB0b3I6IGZ1bmN0aW9uIHRvQ2xhc3NEZXNjcmlwdG9yKG9iaikgeyB2YXIga2luZCA9IFN0cmluZyhvYmoua2luZCk7IGlmIChraW5kICE9PSBcImNsYXNzXCIpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQSBjbGFzcyBkZXNjcmlwdG9yXFwncyAua2luZCBwcm9wZXJ0eSBtdXN0IGJlIFwiY2xhc3NcIiwgYnV0IGEgZGVjb3JhdG9yJyArICcgY3JlYXRlZCBhIGNsYXNzIGRlc2NyaXB0b3Igd2l0aCAua2luZCBcIicgKyBraW5kICsgJ1wiJyk7IH0gdGhpcy5kaXNhbGxvd1Byb3BlcnR5KG9iaiwgXCJrZXlcIiwgXCJBIGNsYXNzIGRlc2NyaXB0b3JcIik7IHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShvYmosIFwicGxhY2VtZW50XCIsIFwiQSBjbGFzcyBkZXNjcmlwdG9yXCIpOyB0aGlzLmRpc2FsbG93UHJvcGVydHkob2JqLCBcImRlc2NyaXB0b3JcIiwgXCJBIGNsYXNzIGRlc2NyaXB0b3JcIik7IHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShvYmosIFwiaW5pdGlhbGl6ZXJcIiwgXCJBIGNsYXNzIGRlc2NyaXB0b3JcIik7IHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShvYmosIFwiZXh0cmFzXCIsIFwiQSBjbGFzcyBkZXNjcmlwdG9yXCIpOyB2YXIgZmluaXNoZXIgPSBfb3B0aW9uYWxDYWxsYWJsZVByb3BlcnR5KG9iaiwgXCJmaW5pc2hlclwiKTsgdmFyIGVsZW1lbnRzID0gdGhpcy50b0VsZW1lbnREZXNjcmlwdG9ycyhvYmouZWxlbWVudHMpOyByZXR1cm4geyBlbGVtZW50czogZWxlbWVudHMsIGZpbmlzaGVyOiBmaW5pc2hlciB9OyB9LCBydW5DbGFzc0ZpbmlzaGVyczogZnVuY3Rpb24gcnVuQ2xhc3NGaW5pc2hlcnMoY29uc3RydWN0b3IsIGZpbmlzaGVycykgeyBmb3IgKHZhciBpID0gMDsgaSA8IGZpbmlzaGVycy5sZW5ndGg7IGkrKykgeyB2YXIgbmV3Q29uc3RydWN0b3IgPSAoMCwgZmluaXNoZXJzW2ldKShjb25zdHJ1Y3Rvcik7IGlmIChuZXdDb25zdHJ1Y3RvciAhPT0gdW5kZWZpbmVkKSB7IGlmICh0eXBlb2YgbmV3Q29uc3RydWN0b3IgIT09IFwiZnVuY3Rpb25cIikgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmluaXNoZXJzIG11c3QgcmV0dXJuIGEgY29uc3RydWN0b3IuXCIpOyB9IGNvbnN0cnVjdG9yID0gbmV3Q29uc3RydWN0b3I7IH0gfSByZXR1cm4gY29uc3RydWN0b3I7IH0sIGRpc2FsbG93UHJvcGVydHk6IGZ1bmN0aW9uIGRpc2FsbG93UHJvcGVydHkob2JqLCBuYW1lLCBvYmplY3RUeXBlKSB7IGlmIChvYmpbbmFtZV0gIT09IHVuZGVmaW5lZCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKG9iamVjdFR5cGUgKyBcIiBjYW4ndCBoYXZlIGEgLlwiICsgbmFtZSArIFwiIHByb3BlcnR5LlwiKTsgfSB9IH07IHJldHVybiBhcGk7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUVsZW1lbnREZXNjcmlwdG9yKGRlZikgeyB2YXIga2V5ID0gX3RvUHJvcGVydHlLZXkoZGVmLmtleSk7IHZhciBkZXNjcmlwdG9yOyBpZiAoZGVmLmtpbmQgPT09IFwibWV0aG9kXCIpIHsgZGVzY3JpcHRvciA9IHsgdmFsdWU6IGRlZi52YWx1ZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZW51bWVyYWJsZTogZmFsc2UgfTsgfSBlbHNlIGlmIChkZWYua2luZCA9PT0gXCJnZXRcIikgeyBkZXNjcmlwdG9yID0geyBnZXQ6IGRlZi52YWx1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCBlbnVtZXJhYmxlOiBmYWxzZSB9OyB9IGVsc2UgaWYgKGRlZi5raW5kID09PSBcInNldFwiKSB7IGRlc2NyaXB0b3IgPSB7IHNldDogZGVmLnZhbHVlLCBjb25maWd1cmFibGU6IHRydWUsIGVudW1lcmFibGU6IGZhbHNlIH07IH0gZWxzZSBpZiAoZGVmLmtpbmQgPT09IFwiZmllbGRcIikgeyBkZXNjcmlwdG9yID0geyBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCBlbnVtZXJhYmxlOiB0cnVlIH07IH0gdmFyIGVsZW1lbnQgPSB7IGtpbmQ6IGRlZi5raW5kID09PSBcImZpZWxkXCIgPyBcImZpZWxkXCIgOiBcIm1ldGhvZFwiLCBrZXk6IGtleSwgcGxhY2VtZW50OiBkZWZbXCJzdGF0aWNcIl0gPyBcInN0YXRpY1wiIDogZGVmLmtpbmQgPT09IFwiZmllbGRcIiA/IFwib3duXCIgOiBcInByb3RvdHlwZVwiLCBkZXNjcmlwdG9yOiBkZXNjcmlwdG9yIH07IGlmIChkZWYuZGVjb3JhdG9ycykgZWxlbWVudC5kZWNvcmF0b3JzID0gZGVmLmRlY29yYXRvcnM7IGlmIChkZWYua2luZCA9PT0gXCJmaWVsZFwiKSBlbGVtZW50LmluaXRpYWxpemVyID0gZGVmLnZhbHVlOyByZXR1cm4gZWxlbWVudDsgfVxuXG5mdW5jdGlvbiBfY29hbGVzY2VHZXR0ZXJTZXR0ZXIoZWxlbWVudCwgb3RoZXIpIHsgaWYgKGVsZW1lbnQuZGVzY3JpcHRvci5nZXQgIT09IHVuZGVmaW5lZCkgeyBvdGhlci5kZXNjcmlwdG9yLmdldCA9IGVsZW1lbnQuZGVzY3JpcHRvci5nZXQ7IH0gZWxzZSB7IG90aGVyLmRlc2NyaXB0b3Iuc2V0ID0gZWxlbWVudC5kZXNjcmlwdG9yLnNldDsgfSB9XG5cbmZ1bmN0aW9uIF9jb2FsZXNjZUNsYXNzRWxlbWVudHMoZWxlbWVudHMpIHsgdmFyIG5ld0VsZW1lbnRzID0gW107IHZhciBpc1NhbWVFbGVtZW50ID0gZnVuY3Rpb24gaXNTYW1lRWxlbWVudChvdGhlcikgeyByZXR1cm4gb3RoZXIua2luZCA9PT0gXCJtZXRob2RcIiAmJiBvdGhlci5rZXkgPT09IGVsZW1lbnQua2V5ICYmIG90aGVyLnBsYWNlbWVudCA9PT0gZWxlbWVudC5wbGFjZW1lbnQ7IH07IGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIGVsZW1lbnQgPSBlbGVtZW50c1tpXTsgdmFyIG90aGVyOyBpZiAoZWxlbWVudC5raW5kID09PSBcIm1ldGhvZFwiICYmIChvdGhlciA9IG5ld0VsZW1lbnRzLmZpbmQoaXNTYW1lRWxlbWVudCkpKSB7IGlmIChfaXNEYXRhRGVzY3JpcHRvcihlbGVtZW50LmRlc2NyaXB0b3IpIHx8IF9pc0RhdGFEZXNjcmlwdG9yKG90aGVyLmRlc2NyaXB0b3IpKSB7IGlmIChfaGFzRGVjb3JhdG9ycyhlbGVtZW50KSB8fCBfaGFzRGVjb3JhdG9ycyhvdGhlcikpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwiRHVwbGljYXRlZCBtZXRob2RzIChcIiArIGVsZW1lbnQua2V5ICsgXCIpIGNhbid0IGJlIGRlY29yYXRlZC5cIik7IH0gb3RoZXIuZGVzY3JpcHRvciA9IGVsZW1lbnQuZGVzY3JpcHRvcjsgfSBlbHNlIHsgaWYgKF9oYXNEZWNvcmF0b3JzKGVsZW1lbnQpKSB7IGlmIChfaGFzRGVjb3JhdG9ycyhvdGhlcikpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwiRGVjb3JhdG9ycyBjYW4ndCBiZSBwbGFjZWQgb24gZGlmZmVyZW50IGFjY2Vzc29ycyB3aXRoIGZvciBcIiArIFwidGhlIHNhbWUgcHJvcGVydHkgKFwiICsgZWxlbWVudC5rZXkgKyBcIikuXCIpOyB9IG90aGVyLmRlY29yYXRvcnMgPSBlbGVtZW50LmRlY29yYXRvcnM7IH0gX2NvYWxlc2NlR2V0dGVyU2V0dGVyKGVsZW1lbnQsIG90aGVyKTsgfSB9IGVsc2UgeyBuZXdFbGVtZW50cy5wdXNoKGVsZW1lbnQpOyB9IH0gcmV0dXJuIG5ld0VsZW1lbnRzOyB9XG5cbmZ1bmN0aW9uIF9oYXNEZWNvcmF0b3JzKGVsZW1lbnQpIHsgcmV0dXJuIGVsZW1lbnQuZGVjb3JhdG9ycyAmJiBlbGVtZW50LmRlY29yYXRvcnMubGVuZ3RoOyB9XG5cbmZ1bmN0aW9uIF9pc0RhdGFEZXNjcmlwdG9yKGRlc2MpIHsgcmV0dXJuIGRlc2MgIT09IHVuZGVmaW5lZCAmJiAhKGRlc2MudmFsdWUgPT09IHVuZGVmaW5lZCAmJiBkZXNjLndyaXRhYmxlID09PSB1bmRlZmluZWQpOyB9XG5cbmZ1bmN0aW9uIF9vcHRpb25hbENhbGxhYmxlUHJvcGVydHkob2JqLCBuYW1lKSB7IHZhciB2YWx1ZSA9IG9ialtuYW1lXTsgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkICdcIiArIG5hbWUgKyBcIicgdG8gYmUgYSBmdW5jdGlvblwiKTsgfSByZXR1cm4gdmFsdWU7IH1cblxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkoYXJnKSB7IHZhciBrZXkgPSBfdG9QcmltaXRpdmUoYXJnLCBcInN0cmluZ1wiKTsgcmV0dXJuIF90eXBlb2Yoa2V5KSA9PT0gXCJzeW1ib2xcIiA/IGtleSA6IFN0cmluZyhrZXkpOyB9XG5cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZShpbnB1dCwgaGludCkgeyBpZiAoX3R5cGVvZihpbnB1dCkgIT09IFwib2JqZWN0XCIgfHwgaW5wdXQgPT09IG51bGwpIHJldHVybiBpbnB1dDsgdmFyIHByaW0gPSBpbnB1dFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAocHJpbSAhPT0gdW5kZWZpbmVkKSB7IHZhciByZXMgPSBwcmltLmNhbGwoaW5wdXQsIGhpbnQgfHwgXCJkZWZhdWx0XCIpOyBpZiAoX3R5cGVvZihyZXMpICE9PSBcIm9iamVjdFwiKSByZXR1cm4gcmVzOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChoaW50ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShpbnB1dCk7IH1cblxuZnVuY3Rpb24gX3RvQXJyYXkoYXJyKSB7IHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlUmVzdCgpOyB9XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpOyB9XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikgeyBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChpdGVyKSB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaXRlcikgPT09IFwiW29iamVjdCBBcmd1bWVudHNdXCIpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpOyB9XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjsgfVxuXG52YXIgTGVhZiA9IHJlcXVpcmUoJy4uL19UcmVlL0xlYWYnKTtcblxudmFyIGluY2lkZW50RnJvbUluZ3JlZGllbnRzID0gcmVxdWlyZSgnLi4vSW5jaWRlbnRGcm9tRGVmaW5pdGlvbi9pbmNpZGVudEZyb21JbmdyZWRpZW50cycpO1xuXG52YXIgZ2V0SW5jaWRlbnRzQnlDaGFubmVsID0gcmVxdWlyZSgnLi4vZGVjb3JhdG9ycy9nZXRJbmNpZGVudHNCeUNoYW5uZWwnKTtcblxudmFyIENvbnRleHRBd2FyZUluY2lkZW50ID0gX2RlY29yYXRlKG51bGwsIGZ1bmN0aW9uIChfaW5pdGlhbGl6ZSwgX0xlYWYpIHtcbiAgdmFyIENvbnRleHRBd2FyZUluY2lkZW50ID1cbiAgLyojX19QVVJFX18qL1xuICBmdW5jdGlvbiAoX0xlYWYyKSB7XG4gICAgX2luaGVyaXRzKENvbnRleHRBd2FyZUluY2lkZW50LCBfTGVhZjIpO1xuXG4gICAgZnVuY3Rpb24gQ29udGV4dEF3YXJlSW5jaWRlbnQoY29uc3RydWN0aW9uSW5ncmVkaWVudHMsIGNvbnRleHREYXRhLCBtY2lkLCBhdHRyaWJ1dGUpIHtcbiAgICAgIHZhciBfdGhpcztcblxuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbnRleHRBd2FyZUluY2lkZW50KTtcblxuICAgICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoQ29udGV4dEF3YXJlSW5jaWRlbnQpLmNhbGwodGhpcywge1xuICAgICAgICBpZDogXCJcIi5jb25jYXQoY29uc3RydWN0aW9uSW5ncmVkaWVudHMuaW5jaWRlbnRJZCwgXCJfXCIpLmNvbmNhdChtY2lkLCBcIl9cIikuY29uY2F0KGF0dHJpYnV0ZSlcbiAgICAgIH0pKTsgLy8gYSBwcm9wZXJ0eSB0byBob2xkIGFsbCBvZiB0aGUgY29udGV4dHNcblxuICAgICAgX2luaXRpYWxpemUoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuXG4gICAgICBfdGhpcy5jb250ZXh0cyA9IHt9O1xuICAgICAgX3RoaXMuY29uc3RydWN0aW9uSW5ncmVkaWVudHMgPSBjb25zdHJ1Y3Rpb25JbmdyZWRpZW50cztcbiAgICAgIF90aGlzLm1jaWQgPSBtY2lkO1xuICAgICAgX3RoaXMuYXR0cmlidXRlID0gYXR0cmlidXRlO1xuICAgICAgX3RoaXMuX2R1cmF0aW9uID0gY29uc3RydWN0aW9uSW5ncmVkaWVudHMucHJvcHMuZHVyYXRpb247XG4gICAgICBfdGhpcy5tY19wbHVnaW5fbnBtX25hbWUgPSBjb25zdHJ1Y3Rpb25JbmdyZWRpZW50cy5wbHVnaW5fbnBtX25hbWU7XG4gICAgICBfdGhpcy5wbHVnaW5fY2hhbm5lbF9jbGFzcyA9IGNvbnN0cnVjdGlvbkluZ3JlZGllbnRzLkNoYW5uZWw7XG5cbiAgICAgIF90aGlzLmFkZENvbnRleHQoY29udGV4dERhdGEpO1xuXG4gICAgICBpZiAoX3R5cGVvZihfdGhpcy5jb25zdHJ1Y3Rpb25JbmdyZWRpZW50cy5hdHRycy5hbmltYXRlZEF0dHJzW190aGlzLmF0dHJpYnV0ZV0pID09PSAnb2JqZWN0Jykge1xuICAgICAgICBfdGhpcy5vcmlnaW5hbEFuaW1hdGVkQXR0cmlidXRlVmFsdWUgPSBPYmplY3QuYXNzaWduKHt9LCBfdGhpcy5jb25zdHJ1Y3Rpb25JbmdyZWRpZW50cy5hdHRycy5hbmltYXRlZEF0dHJzW190aGlzLmF0dHJpYnV0ZV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3RoaXMub3JpZ2luYWxBbmltYXRlZEF0dHJpYnV0ZVZhbHVlID0gX3RoaXMuY29uc3RydWN0aW9uSW5ncmVkaWVudHMuYXR0cnMuYW5pbWF0ZWRBdHRyc1tfdGhpcy5hdHRyaWJ1dGVdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIENvbnRleHRBd2FyZUluY2lkZW50O1xuICB9KF9MZWFmKTtcblxuICByZXR1cm4ge1xuICAgIEY6IENvbnRleHRBd2FyZUluY2lkZW50LFxuICAgIGQ6IFt7XG4gICAgICBraW5kOiBcImdldFwiLFxuICAgICAga2V5OiBcIm9yaWdpbmFsQ29udGV4dFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9yaWdpbmFsQ29udGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dHNbdGhpcy5vcmlnaW5hbENvbnRleHRLZXldO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtpbmQ6IFwiZ2V0XCIsXG4gICAgICBrZXk6IFwiZHVyYXRpb25cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkdXJhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2R1cmF0aW9uO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtpbmQ6IFwic2V0XCIsXG4gICAgICBrZXk6IFwiZHVyYXRpb25cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkdXJhdGlvbihtaWxsaXNlY29uZHMpIHtcbiAgICAgICAgdGhpcy5fZHVyYXRpb24gPSBtaWxsaXNlY29uZHM7XG5cbiAgICAgICAgZm9yICh2YXIgY29udGV4dCBpbiB0aGlzLmNvbnRleHRzKSB7XG4gICAgICAgICAgdGhpcy5jb250ZXh0c1tjb250ZXh0XS5kdXJhdGlvbiA9IG1pbGxpc2Vjb25kcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtpbmQ6IFwibWV0aG9kXCIsXG4gICAgICBrZXk6IFwiYWRkQ29udGV4dFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFkZENvbnRleHQoY29udGV4dERhdGEpIHtcbiAgICAgICAgdmFyIGZvcmNlR2V0Q29udGV4dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gICAgICAgIC8vIGlmIGl0J3MgdGhlIGZpcnN0IGNvbnRleHQgdG8gYmUgYWRkZWQgdGhlbiBpdCdzIHRoZSBvcmlnaW5hbFxuICAgICAgICB2YXIgaXNUaGVPcmlnaW5hbENvbnRleHQgPSBmYWxzZTtcblxuICAgICAgICBpZiAoT2JqZWN0LmtleXModGhpcy5jb250ZXh0cykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5vcmlnaW5hbENvbnRleHRLZXkgPSBjb250ZXh0RGF0YS5jbGlwSWQ7XG4gICAgICAgICAgaXNUaGVPcmlnaW5hbENvbnRleHQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGluZ3JlZGllbnRzVG9QYXNzID0gX29iamVjdFNwcmVhZCh7fSwgdGhpcy5jb25zdHJ1Y3Rpb25JbmdyZWRpZW50cywge1xuICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHREYXRhLmNvbnRleHQsXG4gICAgICAgICAgbWNpZDogdGhpcy5tY2lkXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciB3aGF0VG9BZGQgPSBpbmNpZGVudEZyb21JbmdyZWRpZW50cyhpbmdyZWRpZW50c1RvUGFzcyk7XG4gICAgICAgIHRoaXMuY29udGV4dHNbY29udGV4dERhdGEuY2xpcElkXSA9IHdoYXRUb0FkZDsgLy8gd2hlbiB3ZSBhZGQgYSBuZXcgY29udGV4dCB3ZSBtdXN0IHNldCB0aGUgaW5pdGFsIHZhbHVlIG9mIHRoZSBuZXdseSBhZGRlZCBJbmNpZGVudHNcblxuICAgICAgICBpZiAoIWlzVGhlT3JpZ2luYWxDb250ZXh0KSB7XG4gICAgICAgICAgdGhpcy5jb250ZXh0c1tjb250ZXh0RGF0YS5jbGlwSWRdLnNldEluaXRpYWxWYWx1ZSh0aGlzLmdldEluaXRpYWxWYWx1ZSgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmb3JjZUdldENvbnRleHQgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLmNvbnRleHRzW2NvbnRleHREYXRhLmNsaXBJZF0uX29uR2V0Q29udGV4dE9uY2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtpbmQ6IFwibWV0aG9kXCIsXG4gICAgICBrZXk6IFwiaGFuZGxlQWRkQ29udGV4dFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZUFkZENvbnRleHQodGFyZ2V0LCBwYXlsb2FkKSB7XG4gICAgICAgIHRoaXMuYWRkQ29udGV4dChwYXlsb2FkLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2luZDogXCJtZXRob2RcIixcbiAgICAgIGRlY29yYXRvcnM6IFtnZXRJbmNpZGVudHNCeUNoYW5uZWxdLFxuICAgICAga2V5OiBcImdldEluY2lkZW50c0J5Q2hhbm5lbFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEluY2lkZW50c0J5Q2hhbm5lbCgpIHt9XG4gICAgfSwge1xuICAgICAga2luZDogXCJtZXRob2RcIixcbiAgICAgIGtleTogXCJvblByb2dyZXNzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gb25Qcm9ncmVzcyhmcmFjdGlvbiwgbWlsbGlzZWNvbmRzLCBjb250ZXh0SWQpIHtcbiAgICAgICAgaWYgKGNvbnRleHRJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZm9yICh2YXIgY29udGV4dCBpbiB0aGlzLmNvbnRleHRzKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHRzW2NvbnRleHRdLm9uUHJvZ3Jlc3MoZnJhY3Rpb24sIG1pbGxpc2Vjb25kcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLmNvbnRleHRzW2NvbnRleHRJZF0ub25Qcm9ncmVzcyhmcmFjdGlvbiwgbWlsbGlzZWNvbmRzKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCctLS0tLS0tLS0gRVJST1IgLS0tLS0tLS0tLS0nKTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLyoqIE1FVEhPRFMgVEhBVCBBQ1QgQVMgXCJQUk9YWVwiIFRPIEFMTCBPRiBUSEUgSU5DSURFTlRTIEJFTE9OR0lORyBUT1xuICAgICAgICogVEhFIElOQ0lERU5UUyBDT0xMRUNUSU9OIE9GIFRIRSBDT05URVhUIEFXQVJFIElOQ0lERU5UXG4gICAgICAgKiovXG4gICAgICAvLyBzYW1wbGUgbWV0aG9kcy4gUmV0dXJuIHRoZSByZXF1aXJlZCBpbmZvcm1hdGlvbiBvdXQgb2YgdGhlIEluY2lkZW50IG9mXG4gICAgICAvLyB0aGUgb3JpZ2luYWxDb250ZXh0XG5cbiAgICB9LCB7XG4gICAgICBraW5kOiBcIm1ldGhvZFwiLFxuICAgICAga2V5OiBcImhhc0luaXRpYWxWYWx1ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhhc0luaXRpYWxWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3JpZ2luYWxDb250ZXh0Lmhhc0luaXRpYWxWYWx1ZSgpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtpbmQ6IFwibWV0aG9kXCIsXG4gICAgICBrZXk6IFwiZ2V0SW5pdGlhbFZhbHVlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SW5pdGlhbFZhbHVlKCkge1xuICAgICAgICB2YXIgYXR0cmlidXRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBudWxsO1xuXG4gICAgICAgIGlmIChhdHRyaWJ1dGUgPT09IG51bGwpIHtcbiAgICAgICAgICBhdHRyaWJ1dGUgPSB0aGlzLmF0dHJpYnV0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLm9yaWdpbmFsQ29udGV4dC5nZXRJbml0aWFsVmFsdWUoKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBraW5kOiBcImdldFwiLFxuICAgICAga2V5OiBcImFuaW1hdGVkQXR0cmlidXRlVmFsdWVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBhbmltYXRlZEF0dHJpYnV0ZVZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rpb25JbmdyZWRpZW50cy5hdHRycy5hbmltYXRlZEF0dHJzW3RoaXMuYXR0cmlidXRlXTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBraW5kOiBcIm1ldGhvZFwiLFxuICAgICAga2V5OiBcImdldFNjcmF0Y2hWYWx1ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNjcmF0Y2hWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3JpZ2luYWxDb250ZXh0LmdldFNjcmF0Y2hWYWx1ZSgpO1xuICAgICAgfSAvLyBtYXNzaXZlIGVkaXRpbmcgbWV0aG9kcyB0aGF0IGFwcGx5IHRoZSByZXF1ZXN0IG1hc3NpdmVseSB0byBhbGwgb2YgdGhlXG4gICAgICAvLyBJbmNpZGVudHMgb2YgYWxsIG9mIHRoZSBjb250ZXh0c1xuXG4gICAgfSwge1xuICAgICAga2luZDogXCJtZXRob2RcIixcbiAgICAgIGtleTogXCJnb3RDb250ZXh0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ290Q29udGV4dCgpIHtcbiAgICAgICAgZm9yICh2YXIgY29udGV4dCBpbiB0aGlzLmNvbnRleHRzKSB7XG4gICAgICAgICAgdGhpcy5jb250ZXh0c1tjb250ZXh0XS5nb3RDb250ZXh0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBraW5kOiBcIm1ldGhvZFwiLFxuICAgICAga2V5OiBcIl9vbkdldENvbnRleHRPbmNlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX29uR2V0Q29udGV4dE9uY2UoKSB7XG4gICAgICAgIGZvciAodmFyIGNvbnRleHQgaW4gdGhpcy5jb250ZXh0cykge1xuICAgICAgICAgIHRoaXMuY29udGV4dHNbY29udGV4dF0uX29uR2V0Q29udGV4dE9uY2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtpbmQ6IFwibWV0aG9kXCIsXG4gICAgICBrZXk6IFwibGFzdFdpc2hcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBsYXN0V2lzaCgpIHtcbiAgICAgICAgZm9yICh2YXIgY29udGV4dCBpbiB0aGlzLmNvbnRleHRzKSB7XG4gICAgICAgICAgdGhpcy5jb250ZXh0c1tjb250ZXh0XS5sYXN0V2lzaCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2luZDogXCJtZXRob2RcIixcbiAgICAgIGtleTogXCJvbkdldENvbnRleHRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBvbkdldENvbnRleHQoKSB7XG4gICAgICAgIGZvciAodmFyIGNvbnRleHQgaW4gdGhpcy5jb250ZXh0cykge1xuICAgICAgICAgIHRoaXMuY29udGV4dHNbY29udGV4dF0ub25HZXRDb250ZXh0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBraW5kOiBcIm1ldGhvZFwiLFxuICAgICAga2V5OiBcInNldEluaXRpYWxWYWx1ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldEluaXRpYWxWYWx1ZSh2YWx1ZSkge1xuICAgICAgICBmb3IgKHZhciBjb250ZXh0IGluIHRoaXMuY29udGV4dHMpIHtcbiAgICAgICAgICB0aGlzLmNvbnRleHRzW2NvbnRleHRdLnNldEluaXRpYWxWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBraW5kOiBcIm1ldGhvZFwiLFxuICAgICAga2V5OiBcInNldENvbXBvQXR0cktleVZhbHVlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Q29tcG9BdHRyS2V5VmFsdWUoa2V5LCB2YWx1ZSkge1xuICAgICAgICBmb3IgKHZhciBjb250ZXh0IGluIHRoaXMuY29udGV4dHMpIHtcbiAgICAgICAgICB0aGlzLmNvbnRleHRzW2NvbnRleHRdLmF0dHJzLmFuaW1hdGVkQXR0cnNbdGhpcy5hdHRyaWJ1dGVdW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICB0aGlzLmNvbnRleHRzW2NvbnRleHRdLmxhc3RXaXNoKCk7XG4gICAgICAgICAgdGhpcy5jb250ZXh0c1tjb250ZXh0XS5vbkdldENvbnRleHQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1dXG4gIH07XG59LCBMZWFmKTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb250ZXh0QXdhcmVJbmNpZGVudDsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/_responsiveness/ContextAwareIncident.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/_responsiveness/DOMAwareClipIncident.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/_responsiveness/DOMAwareClipIncident.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar DWI = __webpack_require__(/*! ./DOMAwareIncident */ \"./node_modules/@kissmybutton/motorcortex/dist/_responsiveness/DOMAwareIncident.js\");\n\nvar ContextAwareClipIncident = __webpack_require__(/*! ./ContextAwareClipIncident */ \"./node_modules/@kissmybutton/motorcortex/dist/_responsiveness/ContextAwareClipIncident.js\");\n\nvar Channel = __webpack_require__(/*! ../_Channels/_Clip/ClipsChannel */ \"./node_modules/@kissmybutton/motorcortex/dist/_Channels/_Clip/ClipsChannel.js\");\n/**\n * This Class acts as the DOM Aware Incident for Clips. When constructed the Incident passed to\n * it is a Clip with FragmentHTML context handler.\n * On addition, edit or deletion of Incidents on the Fragmented Clip's tree, of the\n * Descriptive Clip this DOMAwareClipIncident implements, all updates on lanes\n * and everything that these clips need in order to run are made directly to the\n * ContextAwareIncidents of the DescriptiveClip's real Clip.\n */\n\n\nvar DOMAwareClipIncident =\n/*#__PURE__*/\nfunction (_DWI) {\n  _inherits(DOMAwareClipIncident, _DWI);\n\n  function DOMAwareClipIncident(descriptiveIncident, contextData) {\n    var _this;\n\n    _classCallCheck(this, DOMAwareClipIncident);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(DOMAwareClipIncident).call(this, descriptiveIncident, contextData));\n    _this.realClip = descriptiveIncident.realClip;\n    return _this;\n  }\n\n  _createClass(DOMAwareClipIncident, [{\n    key: \"_createElementIncident\",\n    value: function _createElementIncident(element, descriptiveIncident, contextData, elementIndex, totalElements, mcid) {\n      var constructionArguments = descriptiveIncident.realClip.exportConstructionArguments();\n      var constructionIngredients = {\n        incidentId: descriptiveIncident.id,\n        attrs: constructionArguments.attrs,\n        props: _objectSpread({}, constructionArguments.props, {\n          selector: contextData.context.getElementSelectorByMCID(mcid)\n        }),\n        Incident: descriptiveIncident.constructor.Incident,\n        plugin_npm_name: descriptiveIncident.constructor.plugin_npm_name,\n        Channel: Channel\n      };\n      var contextAwareClipIncident = new ContextAwareClipIncident(constructionIngredients, contextData, mcid, descriptiveIncident);\n      this.addChild(contextAwareClipIncident, 0);\n    }\n  }, {\n    key: \"duration\",\n    get: function get() {\n      return _get(_getPrototypeOf(DOMAwareClipIncident.prototype), \"duration\", this);\n    }\n    /*\n    DOMAwareClipIncidents split the DescriptiveClip to element ContextAwareIncidents\n    All of the element ContextAwareClipIncidents instantiated share the same\n    DescriptiveClip and thus the same realClip. So DOMAwareClipIncidents are\n    the Node from where a realClip starts to get copies.\n    Resizing though means resizing the realClip. In order to avoid redunduncy we\n    manage the resize here and we don't pass further down to the ContextAwareClipIncidents\n    the resizing command.\n    */\n    ,\n    set: function set(milliseconds) {\n      this.realClip._resize(milliseconds / this.realClip.duration);\n\n      this._duration = milliseconds;\n    }\n  }]);\n\n  return DOMAwareClipIncident;\n}(DWI);\n\nmodule.exports = DOMAwareClipIncident;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19yZXNwb25zaXZlbmVzcy9ET01Bd2FyZUNsaXBJbmNpZGVudC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Aa2lzc215YnV0dG9uL21vdG9yY29ydGV4L2Rpc3QvX3Jlc3BvbnNpdmVuZXNzL0RPTUF3YXJlQ2xpcEluY2lkZW50LmpzP2JlNzAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyB2YXIgb3duS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IGlmICh0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gJ2Z1bmN0aW9uJykgeyBvd25LZXlzID0gb3duS2V5cy5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwgc3ltKS5lbnVtZXJhYmxlOyB9KSk7IH0gb3duS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LmdldCkgeyBfZ2V0ID0gUmVmbGVjdC5nZXQ7IH0gZWxzZSB7IF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IHZhciBiYXNlID0gX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7IGlmICghYmFzZSkgcmV0dXJuOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpOyBpZiAoZGVzYy5nZXQpIHsgcmV0dXJuIGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpOyB9IHJldHVybiBkZXNjLnZhbHVlOyB9OyB9IHJldHVybiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyIHx8IHRhcmdldCk7IH1cblxuZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkgeyB3aGlsZSAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkgeyBvYmplY3QgPSBfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7IH0gcmV0dXJuIG9iamVjdDsgfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbnZhciBEV0kgPSByZXF1aXJlKCcuL0RPTUF3YXJlSW5jaWRlbnQnKTtcblxudmFyIENvbnRleHRBd2FyZUNsaXBJbmNpZGVudCA9IHJlcXVpcmUoJy4vQ29udGV4dEF3YXJlQ2xpcEluY2lkZW50Jyk7XG5cbnZhciBDaGFubmVsID0gcmVxdWlyZSgnLi4vX0NoYW5uZWxzL19DbGlwL0NsaXBzQ2hhbm5lbCcpO1xuLyoqXG4gKiBUaGlzIENsYXNzIGFjdHMgYXMgdGhlIERPTSBBd2FyZSBJbmNpZGVudCBmb3IgQ2xpcHMuIFdoZW4gY29uc3RydWN0ZWQgdGhlIEluY2lkZW50IHBhc3NlZCB0b1xuICogaXQgaXMgYSBDbGlwIHdpdGggRnJhZ21lbnRIVE1MIGNvbnRleHQgaGFuZGxlci5cbiAqIE9uIGFkZGl0aW9uLCBlZGl0IG9yIGRlbGV0aW9uIG9mIEluY2lkZW50cyBvbiB0aGUgRnJhZ21lbnRlZCBDbGlwJ3MgdHJlZSwgb2YgdGhlXG4gKiBEZXNjcmlwdGl2ZSBDbGlwIHRoaXMgRE9NQXdhcmVDbGlwSW5jaWRlbnQgaW1wbGVtZW50cywgYWxsIHVwZGF0ZXMgb24gbGFuZXNcbiAqIGFuZCBldmVyeXRoaW5nIHRoYXQgdGhlc2UgY2xpcHMgbmVlZCBpbiBvcmRlciB0byBydW4gYXJlIG1hZGUgZGlyZWN0bHkgdG8gdGhlXG4gKiBDb250ZXh0QXdhcmVJbmNpZGVudHMgb2YgdGhlIERlc2NyaXB0aXZlQ2xpcCdzIHJlYWwgQ2xpcC5cbiAqL1xuXG5cbnZhciBET01Bd2FyZUNsaXBJbmNpZGVudCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0RXSSkge1xuICBfaW5oZXJpdHMoRE9NQXdhcmVDbGlwSW5jaWRlbnQsIF9EV0kpO1xuXG4gIGZ1bmN0aW9uIERPTUF3YXJlQ2xpcEluY2lkZW50KGRlc2NyaXB0aXZlSW5jaWRlbnQsIGNvbnRleHREYXRhKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERPTUF3YXJlQ2xpcEluY2lkZW50KTtcblxuICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKERPTUF3YXJlQ2xpcEluY2lkZW50KS5jYWxsKHRoaXMsIGRlc2NyaXB0aXZlSW5jaWRlbnQsIGNvbnRleHREYXRhKSk7XG4gICAgX3RoaXMucmVhbENsaXAgPSBkZXNjcmlwdGl2ZUluY2lkZW50LnJlYWxDbGlwO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhET01Bd2FyZUNsaXBJbmNpZGVudCwgW3tcbiAgICBrZXk6IFwiX2NyZWF0ZUVsZW1lbnRJbmNpZGVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlRWxlbWVudEluY2lkZW50KGVsZW1lbnQsIGRlc2NyaXB0aXZlSW5jaWRlbnQsIGNvbnRleHREYXRhLCBlbGVtZW50SW5kZXgsIHRvdGFsRWxlbWVudHMsIG1jaWQpIHtcbiAgICAgIHZhciBjb25zdHJ1Y3Rpb25Bcmd1bWVudHMgPSBkZXNjcmlwdGl2ZUluY2lkZW50LnJlYWxDbGlwLmV4cG9ydENvbnN0cnVjdGlvbkFyZ3VtZW50cygpO1xuICAgICAgdmFyIGNvbnN0cnVjdGlvbkluZ3JlZGllbnRzID0ge1xuICAgICAgICBpbmNpZGVudElkOiBkZXNjcmlwdGl2ZUluY2lkZW50LmlkLFxuICAgICAgICBhdHRyczogY29uc3RydWN0aW9uQXJndW1lbnRzLmF0dHJzLFxuICAgICAgICBwcm9wczogX29iamVjdFNwcmVhZCh7fSwgY29uc3RydWN0aW9uQXJndW1lbnRzLnByb3BzLCB7XG4gICAgICAgICAgc2VsZWN0b3I6IGNvbnRleHREYXRhLmNvbnRleHQuZ2V0RWxlbWVudFNlbGVjdG9yQnlNQ0lEKG1jaWQpXG4gICAgICAgIH0pLFxuICAgICAgICBJbmNpZGVudDogZGVzY3JpcHRpdmVJbmNpZGVudC5jb25zdHJ1Y3Rvci5JbmNpZGVudCxcbiAgICAgICAgcGx1Z2luX25wbV9uYW1lOiBkZXNjcmlwdGl2ZUluY2lkZW50LmNvbnN0cnVjdG9yLnBsdWdpbl9ucG1fbmFtZSxcbiAgICAgICAgQ2hhbm5lbDogQ2hhbm5lbFxuICAgICAgfTtcbiAgICAgIHZhciBjb250ZXh0QXdhcmVDbGlwSW5jaWRlbnQgPSBuZXcgQ29udGV4dEF3YXJlQ2xpcEluY2lkZW50KGNvbnN0cnVjdGlvbkluZ3JlZGllbnRzLCBjb250ZXh0RGF0YSwgbWNpZCwgZGVzY3JpcHRpdmVJbmNpZGVudCk7XG4gICAgICB0aGlzLmFkZENoaWxkKGNvbnRleHRBd2FyZUNsaXBJbmNpZGVudCwgMCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImR1cmF0aW9uXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gX2dldChfZ2V0UHJvdG90eXBlT2YoRE9NQXdhcmVDbGlwSW5jaWRlbnQucHJvdG90eXBlKSwgXCJkdXJhdGlvblwiLCB0aGlzKTtcbiAgICB9XG4gICAgLypcbiAgICBET01Bd2FyZUNsaXBJbmNpZGVudHMgc3BsaXQgdGhlIERlc2NyaXB0aXZlQ2xpcCB0byBlbGVtZW50IENvbnRleHRBd2FyZUluY2lkZW50c1xuICAgIEFsbCBvZiB0aGUgZWxlbWVudCBDb250ZXh0QXdhcmVDbGlwSW5jaWRlbnRzIGluc3RhbnRpYXRlZCBzaGFyZSB0aGUgc2FtZVxuICAgIERlc2NyaXB0aXZlQ2xpcCBhbmQgdGh1cyB0aGUgc2FtZSByZWFsQ2xpcC4gU28gRE9NQXdhcmVDbGlwSW5jaWRlbnRzIGFyZVxuICAgIHRoZSBOb2RlIGZyb20gd2hlcmUgYSByZWFsQ2xpcCBzdGFydHMgdG8gZ2V0IGNvcGllcy5cbiAgICBSZXNpemluZyB0aG91Z2ggbWVhbnMgcmVzaXppbmcgdGhlIHJlYWxDbGlwLiBJbiBvcmRlciB0byBhdm9pZCByZWR1bmR1bmN5IHdlXG4gICAgbWFuYWdlIHRoZSByZXNpemUgaGVyZSBhbmQgd2UgZG9uJ3QgcGFzcyBmdXJ0aGVyIGRvd24gdG8gdGhlIENvbnRleHRBd2FyZUNsaXBJbmNpZGVudHNcbiAgICB0aGUgcmVzaXppbmcgY29tbWFuZC5cbiAgICAqL1xuICAgICxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChtaWxsaXNlY29uZHMpIHtcbiAgICAgIHRoaXMucmVhbENsaXAuX3Jlc2l6ZShtaWxsaXNlY29uZHMgLyB0aGlzLnJlYWxDbGlwLmR1cmF0aW9uKTtcblxuICAgICAgdGhpcy5fZHVyYXRpb24gPSBtaWxsaXNlY29uZHM7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIERPTUF3YXJlQ2xpcEluY2lkZW50O1xufShEV0kpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERPTUF3YXJlQ2xpcEluY2lkZW50OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/_responsiveness/DOMAwareClipIncident.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/_responsiveness/DOMAwareIncident.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/_responsiveness/DOMAwareIncident.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar Group = __webpack_require__(/*! ../_BaseClasses/Group */ \"./node_modules/@kissmybutton/motorcortex/dist/_BaseClasses/Group.js\");\n\nvar AttributesAwareIncident = __webpack_require__(/*! ./AttributeAwareIncident */ \"./node_modules/@kissmybutton/motorcortex/dist/_responsiveness/AttributeAwareIncident.js\");\n\nvar Helper = __webpack_require__(/*! ../_coreUtils/Helper */ \"./node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\");\n\nvar helper = new Helper();\n\nvar DOMAwareIncident =\n/*#__PURE__*/\nfunction (_Group) {\n  _inherits(DOMAwareIncident, _Group);\n\n  function DOMAwareIncident(descriptiveIncident, contextData) {\n    var _this;\n\n    _classCallCheck(this, DOMAwareIncident);\n\n    // we make sure the DOMAwareIncident takes the same id as the Descriptive Incident\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(DOMAwareIncident).call(this, {}, {\n      id: descriptiveIncident.id\n    })); // a property to hold all of the contexts\n\n    _this.contexts = {};\n    _this.contexts[contextData.clipId] = contextData.context;\n    _this.originalContextKey = contextData.clipId;\n    _this.instantiatedCopiesContexts = contextData.instantiatedCopiesContexts;\n\n    _this.setUp(descriptiveIncident, contextData);\n\n    return _this;\n  }\n\n  _createClass(DOMAwareIncident, [{\n    key: \"setUp\",\n    value: function setUp(descriptiveIncident, contextData) {\n      // the elements of the original context\n      var elements = Array.from(this.originalContext.rootElement.querySelectorAll(descriptiveIncident.selector())); // the elements for each of the copied contexts\n\n      var copiesElements = {};\n\n      for (var contextKey in this.instantiatedCopiesContexts) {\n        copiesElements[contextKey] = Array.from(this.instantiatedCopiesContexts[contextKey].rootElement.querySelectorAll(descriptiveIncident.props.selector));\n      }\n\n      var totalElements = elements.length;\n\n      for (var i = 0; i < elements.length; i++) {\n        var element = elements[i]; // set the mcid of the element on index i of the original context\n\n        var mcid = this._getElementMCID(element); // set the same mcid for the elements of the same context in all of the instantiatedCopiesContexts\n\n\n        for (var _contextKey in this.instantiatedCopiesContexts) {\n          this._setElementMCID(this.instantiatedCopiesContexts[_contextKey], this.instantiatedCopiesContexts[_contextKey][i], mcid);\n        }\n\n        this._createElementIncident(element, descriptiveIncident, contextData, i, totalElements, mcid);\n      }\n    }\n  }, {\n    key: \"_getElementMCID\",\n    value: function _getElementMCID(element) {\n      var mcid = this.originalContext.getMCID(element);\n\n      if (!mcid) {\n        mcid = helper.getAnId(true);\n        this.originalContext.setMCID(element, mcid);\n      }\n\n      return mcid;\n    }\n  }, {\n    key: \"_setElementMCID\",\n    value: function _setElementMCID(context, element, mcid) {\n      var existingMCID = context.getMCID(element);\n\n      if (!existingMCID) {\n        context.setMCID(element, mcid);\n      }\n    }\n  }, {\n    key: \"_createElementIncident\",\n    value: function _createElementIncident(element, descriptiveIncident, contextData, elementIndex, totalElements, mcid) {\n      var attributeAwareIncident = new AttributesAwareIncident(descriptiveIncident, contextData, mcid, contextData.context.getElementSelectorByMCID(mcid));\n      this.addChild(attributeAwareIncident, 0);\n    }\n  }, {\n    key: \"originalContext\",\n    get: function get() {\n      return this.contexts[this.originalContextKey];\n    }\n  }]);\n\n  return DOMAwareIncident;\n}(Group);\n\nmodule.exports = DOMAwareIncident;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19yZXNwb25zaXZlbmVzcy9ET01Bd2FyZUluY2lkZW50LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvZGlzdC9fcmVzcG9uc2l2ZW5lc3MvRE9NQXdhcmVJbmNpZGVudC5qcz84MDY1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxudmFyIEdyb3VwID0gcmVxdWlyZSgnLi4vX0Jhc2VDbGFzc2VzL0dyb3VwJyk7XG5cbnZhciBBdHRyaWJ1dGVzQXdhcmVJbmNpZGVudCA9IHJlcXVpcmUoJy4vQXR0cmlidXRlQXdhcmVJbmNpZGVudCcpO1xuXG52YXIgSGVscGVyID0gcmVxdWlyZSgnLi4vX2NvcmVVdGlscy9IZWxwZXInKTtcblxudmFyIGhlbHBlciA9IG5ldyBIZWxwZXIoKTtcblxudmFyIERPTUF3YXJlSW5jaWRlbnQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9Hcm91cCkge1xuICBfaW5oZXJpdHMoRE9NQXdhcmVJbmNpZGVudCwgX0dyb3VwKTtcblxuICBmdW5jdGlvbiBET01Bd2FyZUluY2lkZW50KGRlc2NyaXB0aXZlSW5jaWRlbnQsIGNvbnRleHREYXRhKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERPTUF3YXJlSW5jaWRlbnQpO1xuXG4gICAgLy8gd2UgbWFrZSBzdXJlIHRoZSBET01Bd2FyZUluY2lkZW50IHRha2VzIHRoZSBzYW1lIGlkIGFzIHRoZSBEZXNjcmlwdGl2ZSBJbmNpZGVudFxuICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKERPTUF3YXJlSW5jaWRlbnQpLmNhbGwodGhpcywge30sIHtcbiAgICAgIGlkOiBkZXNjcmlwdGl2ZUluY2lkZW50LmlkXG4gICAgfSkpOyAvLyBhIHByb3BlcnR5IHRvIGhvbGQgYWxsIG9mIHRoZSBjb250ZXh0c1xuXG4gICAgX3RoaXMuY29udGV4dHMgPSB7fTtcbiAgICBfdGhpcy5jb250ZXh0c1tjb250ZXh0RGF0YS5jbGlwSWRdID0gY29udGV4dERhdGEuY29udGV4dDtcbiAgICBfdGhpcy5vcmlnaW5hbENvbnRleHRLZXkgPSBjb250ZXh0RGF0YS5jbGlwSWQ7XG4gICAgX3RoaXMuaW5zdGFudGlhdGVkQ29waWVzQ29udGV4dHMgPSBjb250ZXh0RGF0YS5pbnN0YW50aWF0ZWRDb3BpZXNDb250ZXh0cztcblxuICAgIF90aGlzLnNldFVwKGRlc2NyaXB0aXZlSW5jaWRlbnQsIGNvbnRleHREYXRhKTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhET01Bd2FyZUluY2lkZW50LCBbe1xuICAgIGtleTogXCJzZXRVcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRVcChkZXNjcmlwdGl2ZUluY2lkZW50LCBjb250ZXh0RGF0YSkge1xuICAgICAgLy8gdGhlIGVsZW1lbnRzIG9mIHRoZSBvcmlnaW5hbCBjb250ZXh0XG4gICAgICB2YXIgZWxlbWVudHMgPSBBcnJheS5mcm9tKHRoaXMub3JpZ2luYWxDb250ZXh0LnJvb3RFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoZGVzY3JpcHRpdmVJbmNpZGVudC5zZWxlY3RvcigpKSk7IC8vIHRoZSBlbGVtZW50cyBmb3IgZWFjaCBvZiB0aGUgY29waWVkIGNvbnRleHRzXG5cbiAgICAgIHZhciBjb3BpZXNFbGVtZW50cyA9IHt9O1xuXG4gICAgICBmb3IgKHZhciBjb250ZXh0S2V5IGluIHRoaXMuaW5zdGFudGlhdGVkQ29waWVzQ29udGV4dHMpIHtcbiAgICAgICAgY29waWVzRWxlbWVudHNbY29udGV4dEtleV0gPSBBcnJheS5mcm9tKHRoaXMuaW5zdGFudGlhdGVkQ29waWVzQ29udGV4dHNbY29udGV4dEtleV0ucm9vdEVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChkZXNjcmlwdGl2ZUluY2lkZW50LnByb3BzLnNlbGVjdG9yKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciB0b3RhbEVsZW1lbnRzID0gZWxlbWVudHMubGVuZ3RoO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gZWxlbWVudHNbaV07IC8vIHNldCB0aGUgbWNpZCBvZiB0aGUgZWxlbWVudCBvbiBpbmRleCBpIG9mIHRoZSBvcmlnaW5hbCBjb250ZXh0XG5cbiAgICAgICAgdmFyIG1jaWQgPSB0aGlzLl9nZXRFbGVtZW50TUNJRChlbGVtZW50KTsgLy8gc2V0IHRoZSBzYW1lIG1jaWQgZm9yIHRoZSBlbGVtZW50cyBvZiB0aGUgc2FtZSBjb250ZXh0IGluIGFsbCBvZiB0aGUgaW5zdGFudGlhdGVkQ29waWVzQ29udGV4dHNcblxuXG4gICAgICAgIGZvciAodmFyIF9jb250ZXh0S2V5IGluIHRoaXMuaW5zdGFudGlhdGVkQ29waWVzQ29udGV4dHMpIHtcbiAgICAgICAgICB0aGlzLl9zZXRFbGVtZW50TUNJRCh0aGlzLmluc3RhbnRpYXRlZENvcGllc0NvbnRleHRzW19jb250ZXh0S2V5XSwgdGhpcy5pbnN0YW50aWF0ZWRDb3BpZXNDb250ZXh0c1tfY29udGV4dEtleV1baV0sIG1jaWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY3JlYXRlRWxlbWVudEluY2lkZW50KGVsZW1lbnQsIGRlc2NyaXB0aXZlSW5jaWRlbnQsIGNvbnRleHREYXRhLCBpLCB0b3RhbEVsZW1lbnRzLCBtY2lkKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldEVsZW1lbnRNQ0lEXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRFbGVtZW50TUNJRChlbGVtZW50KSB7XG4gICAgICB2YXIgbWNpZCA9IHRoaXMub3JpZ2luYWxDb250ZXh0LmdldE1DSUQoZWxlbWVudCk7XG5cbiAgICAgIGlmICghbWNpZCkge1xuICAgICAgICBtY2lkID0gaGVscGVyLmdldEFuSWQodHJ1ZSk7XG4gICAgICAgIHRoaXMub3JpZ2luYWxDb250ZXh0LnNldE1DSUQoZWxlbWVudCwgbWNpZCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtY2lkO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfc2V0RWxlbWVudE1DSURcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldEVsZW1lbnRNQ0lEKGNvbnRleHQsIGVsZW1lbnQsIG1jaWQpIHtcbiAgICAgIHZhciBleGlzdGluZ01DSUQgPSBjb250ZXh0LmdldE1DSUQoZWxlbWVudCk7XG5cbiAgICAgIGlmICghZXhpc3RpbmdNQ0lEKSB7XG4gICAgICAgIGNvbnRleHQuc2V0TUNJRChlbGVtZW50LCBtY2lkKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2NyZWF0ZUVsZW1lbnRJbmNpZGVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlRWxlbWVudEluY2lkZW50KGVsZW1lbnQsIGRlc2NyaXB0aXZlSW5jaWRlbnQsIGNvbnRleHREYXRhLCBlbGVtZW50SW5kZXgsIHRvdGFsRWxlbWVudHMsIG1jaWQpIHtcbiAgICAgIHZhciBhdHRyaWJ1dGVBd2FyZUluY2lkZW50ID0gbmV3IEF0dHJpYnV0ZXNBd2FyZUluY2lkZW50KGRlc2NyaXB0aXZlSW5jaWRlbnQsIGNvbnRleHREYXRhLCBtY2lkLCBjb250ZXh0RGF0YS5jb250ZXh0LmdldEVsZW1lbnRTZWxlY3RvckJ5TUNJRChtY2lkKSk7XG4gICAgICB0aGlzLmFkZENoaWxkKGF0dHJpYnV0ZUF3YXJlSW5jaWRlbnQsIDApO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvcmlnaW5hbENvbnRleHRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRleHRzW3RoaXMub3JpZ2luYWxDb250ZXh0S2V5XTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRE9NQXdhcmVJbmNpZGVudDtcbn0oR3JvdXApO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERPTUF3YXJlSW5jaWRlbnQ7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/_responsiveness/DOMAwareIncident.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/configuration/generalConf.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/configuration/generalConf.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/*\nknown events:\n- state-change / meta: the name of the new state\n- attribute-rejection / meta: animationID, attributes\n- animation-rejection / meta: animationID\n- conflicts-on-edit\n*/\nvar conf = {\n  keyframe_sec_key: 'sec_',\n  elements_data_attribute_name: 'data-motorcortex2-id',\n  selfContainedContextHandler: 'closed',\n  logLevel: 1,\n  testMode: true,\n  logTypes: [{\n    key: 'info',\n    style: 'color: #666;',\n    level: 5\n  }, {\n    key: 'notice',\n    style: 'background: rgba(0, 0, 0, 0.8); color:white; padding:8px;',\n    level: 4\n  }, {\n    key: 'warning',\n    style: 'color: black; background: orange;',\n    level: 2\n  }, {\n    key: 'error',\n    style: 'color: black; background: red;',\n    level: 1\n  }]\n};\nmodule.exports = conf;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L2NvbmZpZ3VyYXRpb24vZ2VuZXJhbENvbmYuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L2NvbmZpZ3VyYXRpb24vZ2VuZXJhbENvbmYuanM/MWUzOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuLypcbmtub3duIGV2ZW50czpcbi0gc3RhdGUtY2hhbmdlIC8gbWV0YTogdGhlIG5hbWUgb2YgdGhlIG5ldyBzdGF0ZVxuLSBhdHRyaWJ1dGUtcmVqZWN0aW9uIC8gbWV0YTogYW5pbWF0aW9uSUQsIGF0dHJpYnV0ZXNcbi0gYW5pbWF0aW9uLXJlamVjdGlvbiAvIG1ldGE6IGFuaW1hdGlvbklEXG4tIGNvbmZsaWN0cy1vbi1lZGl0XG4qL1xudmFyIGNvbmYgPSB7XG4gIGtleWZyYW1lX3NlY19rZXk6ICdzZWNfJyxcbiAgZWxlbWVudHNfZGF0YV9hdHRyaWJ1dGVfbmFtZTogJ2RhdGEtbW90b3Jjb3J0ZXgyLWlkJyxcbiAgc2VsZkNvbnRhaW5lZENvbnRleHRIYW5kbGVyOiAnY2xvc2VkJyxcbiAgbG9nTGV2ZWw6IDEsXG4gIHRlc3RNb2RlOiB0cnVlLFxuICBsb2dUeXBlczogW3tcbiAgICBrZXk6ICdpbmZvJyxcbiAgICBzdHlsZTogJ2NvbG9yOiAjNjY2OycsXG4gICAgbGV2ZWw6IDVcbiAgfSwge1xuICAgIGtleTogJ25vdGljZScsXG4gICAgc3R5bGU6ICdiYWNrZ3JvdW5kOiByZ2JhKDAsIDAsIDAsIDAuOCk7IGNvbG9yOndoaXRlOyBwYWRkaW5nOjhweDsnLFxuICAgIGxldmVsOiA0XG4gIH0sIHtcbiAgICBrZXk6ICd3YXJuaW5nJyxcbiAgICBzdHlsZTogJ2NvbG9yOiBibGFjazsgYmFja2dyb3VuZDogb3JhbmdlOycsXG4gICAgbGV2ZWw6IDJcbiAgfSwge1xuICAgIGtleTogJ2Vycm9yJyxcbiAgICBzdHlsZTogJ2NvbG9yOiBibGFjazsgYmFja2dyb3VuZDogcmVkOycsXG4gICAgbGV2ZWw6IDFcbiAgfV1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IGNvbmY7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/configuration/generalConf.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/decorators/getIncidentsByChannel.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/decorators/getIncidentsByChannel.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction getIncidentsByChannel(pld) {\n  pld.descriptor.value = function () {\n    var adjustMillisecond = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var parentMillisecond = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var incidentsByPlugin = {};\n    incidentsByPlugin[this.mc_plugin_npm_name] = [{\n      millisecond: adjustMillisecond,\n      parentMillisecond: parentMillisecond,\n      incident: this,\n      id: this.id\n    }];\n    return incidentsByPlugin;\n  };\n}\n\nmodule.exports = getIncidentsByChannel;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L2RlY29yYXRvcnMvZ2V0SW5jaWRlbnRzQnlDaGFubmVsLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvZGlzdC9kZWNvcmF0b3JzL2dldEluY2lkZW50c0J5Q2hhbm5lbC5qcz84MWZkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBnZXRJbmNpZGVudHNCeUNoYW5uZWwocGxkKSB7XG4gIHBsZC5kZXNjcmlwdG9yLnZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhZGp1c3RNaWxsaXNlY29uZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcbiAgICB2YXIgcGFyZW50TWlsbGlzZWNvbmQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gICAgdmFyIGluY2lkZW50c0J5UGx1Z2luID0ge307XG4gICAgaW5jaWRlbnRzQnlQbHVnaW5bdGhpcy5tY19wbHVnaW5fbnBtX25hbWVdID0gW3tcbiAgICAgIG1pbGxpc2Vjb25kOiBhZGp1c3RNaWxsaXNlY29uZCxcbiAgICAgIHBhcmVudE1pbGxpc2Vjb25kOiBwYXJlbnRNaWxsaXNlY29uZCxcbiAgICAgIGluY2lkZW50OiB0aGlzLFxuICAgICAgaWQ6IHRoaXMuaWRcbiAgICB9XTtcbiAgICByZXR1cm4gaW5jaWRlbnRzQnlQbHVnaW47XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0SW5jaWRlbnRzQnlDaGFubmVsOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/decorators/getIncidentsByChannel.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/main.js":
/*!*************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/main.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar Validator = __webpack_require__(/*! fastest-validator */ \"./node_modules/fastest-validator/dist/index.min.js\");\n\nvar DescriptiveIncident = __webpack_require__(/*! ./_DescriptiveIncidents/DescriptiveIncident */ \"./node_modules/@kissmybutton/motorcortex/dist/_DescriptiveIncidents/DescriptiveIncident.js\");\n\nvar DescriptiveGroup = __webpack_require__(/*! ./_DescriptiveIncidents/DescriptiveGroup */ \"./node_modules/@kissmybutton/motorcortex/dist/_DescriptiveIncidents/DescriptiveGroup.js\");\n\nvar DescriptiveClip = __webpack_require__(/*! ./_DescriptiveIncidents/DescriptiveClip */ \"./node_modules/@kissmybutton/motorcortex/dist/_DescriptiveIncidents/DescriptiveClip.js\");\n\nvar Incident = __webpack_require__(/*! ./_BaseClasses/Incident */ \"./node_modules/@kissmybutton/motorcortex/dist/_BaseClasses/Incident.js\");\n\nvar AttributeChannel = __webpack_require__(/*! ./_Channels/_Attribute/AttributeChannel */ \"./node_modules/@kissmybutton/motorcortex/dist/_Channels/_Attribute/AttributeChannel.js\");\n\nvar TimeCapsule = __webpack_require__(/*! ./_coreUtils/TimeCapsule */ \"./node_modules/@kissmybutton/motorcortex/dist/_coreUtils/TimeCapsule.js\");\n\nvar Helper = __webpack_require__(/*! ./_coreUtils/Helper */ \"./node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\");\n\nvar helper = new Helper();\n\nvar checkPlugin = function checkPlugin(main) {\n  if (Object.prototype.hasOwnProperty.call(main, \"default\")) {\n    main = main[\"default\"];\n  }\n\n  var plugin_name = main.npm_name;\n  var check = true;\n\n  if (!Object.prototype.hasOwnProperty.call(main, \"name\")) {\n    helper.error(\"Warning on plugin \".concat(plugin_name, \". A plugin is always good to have its name on\\n        its main.js file, under the key \\\"name\\\". It's missing from this plugin\"));\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(main, \"incidents\")) {\n    helper.error(\"Error on plugin \".concat(plugin_name, \". A plugin must expose at least one Incident.\\n        Exposed plugin Incidents should be defined on the \\\"incidents\\\" key of the main.js file.\"));\n    check = false;\n  }\n\n  if (!helper.isArray(main.incidents)) {\n    helper.error(\"Error on plugin \".concat(plugin_name, \". thePlugin exposed Incidents are defined on the \\\"incidents\\\" key of the main.js file in array format.\\n        Please refer to the documentation\"));\n    check = false;\n  } else {\n    for (var i = 0; i < main.incidents.length; i++) {\n      var exposedIncidentDefinition = main.incidents[i];\n\n      if (_typeof(exposedIncidentDefinition.exportable) === \"object\") {\n        if (Object.prototype.hasOwnProperty.call(exposedIncidentDefinition.exportable, \"default\")) {\n          exposedIncidentDefinition.exportable = exposedIncidentDefinition.exportable[\"default\"];\n        }\n      }\n\n      if (!(exposedIncidentDefinition.exportable.prototype instanceof DescriptiveGroup) && !(exposedIncidentDefinition.exportable.prototype instanceof DescriptiveClip) && !(exposedIncidentDefinition.exportable.prototype instanceof Incident)) {\n        helper.error(\"Error on plugin \".concat(plugin_name, \". Exportable Incidents by any plugin must extend one of the base classes provided by MotorCortex.\\n                \").concat(exposedIncidentDefinition.exportable.constructor.name, \" doesn't.\\n                Please refer to documentation\"));\n        check = false;\n      }\n\n      if (!Object.prototype.hasOwnProperty.call(exposedIncidentDefinition, \"name\")) {\n        helper.error(\"Error on plugin \".concat(plugin_name, \". Exportable Incidents by any plugin must have the \\\"name\\\" key which defines the name of the exported Incident.\\n                Please refer to documentation\"));\n        check = false;\n      }\n\n      if (!Object.prototype.hasOwnProperty.call(exposedIncidentDefinition, \"propTypes\")) {\n        helper.log(\"Warning on plugin \".concat(plugin_name, \".\\n                It's always good for plugins to define the supported propTypes of their exposed Incidents' supported properties.\\n                \").concat(exposedIncidentDefinition.exportable.constructor.name, \" doesn't.\\n                Please refer to documentation\"), 'warning');\n      }\n    }\n  }\n\n  return check;\n}; // plugin_name is the unique name of the plugin\n\n\nfunction loadPlugin(plugin) {\n  if (Object.prototype.hasOwnProperty.call(plugin, \"default\")) {\n    plugin = plugin[\"default\"];\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(plugin, \"npm_name\")) {\n    plugin.npm_name = \"plugin_\".concat(new Date().getTime());\n  }\n\n  if (!checkPlugin(plugin)) {\n    return false;\n  } else {\n    // thePlugin is the plugin object which will hold on its keys\n    // the names of the exposed Incidents of its. The keys of this object\n    // are going to be identical with the names of the classes exposed\n    var thePlugin = {};\n\n    if (Object.prototype.hasOwnProperty.call(plugin, \"clip\")) {} // TODO Custom Clips strategy\n    // if the plugin definition has compositeAttributes then we dynamically\n    // create a new Channel class extending AttributeChannel setting the\n    // composite Attributes on the fly. We can then use this Channel class\n    // for all Incidents exposed by the plugin\n\n\n    var AttributeChannelToUse = AttributeChannel;\n\n    if (Object.prototype.hasOwnProperty.call(plugin, \"compositeAttributes\")) {\n      AttributeChannelToUse =\n      /*#__PURE__*/\n      function (_AttributeChannel) {\n        _inherits(AttributeChannelToUse, _AttributeChannel);\n\n        function AttributeChannelToUse(props) {\n          _classCallCheck(this, AttributeChannelToUse);\n\n          props.comboAttributes = plugin.compositeAttributes;\n          return _possibleConstructorReturn(this, _getPrototypeOf(AttributeChannelToUse).call(this, props));\n        }\n\n        return AttributeChannelToUse;\n      }(AttributeChannel);\n    } // for each of the exposed Incidents\n\n\n    var _loop = function _loop(i) {\n      var incidentClass = plugin.incidents[i].exportable;\n      var DynamicDescriptiveIncident = void 0; // the exportable Incident can be either a Clip, a Compo or an Incident\n      // if it is an Incident\n\n      if (incidentClass.prototype instanceof Incident) {\n        var _class, _temp;\n\n        DynamicDescriptiveIncident = (_temp = _class =\n        /*#__PURE__*/\n        function (_DescriptiveIncident) {\n          _inherits(DynamicDescriptiveIncident, _DescriptiveIncident);\n\n          function DynamicDescriptiveIncident() {\n            _classCallCheck(this, DynamicDescriptiveIncident);\n\n            return _possibleConstructorReturn(this, _getPrototypeOf(DynamicDescriptiveIncident).apply(this, arguments));\n          }\n\n          return DynamicDescriptiveIncident;\n        }(DescriptiveIncident), _defineProperty(_class, \"Incident\", incidentClass), _defineProperty(_class, \"plugin_npm_name\", plugin.npm_name), _defineProperty(_class, \"plugin\", plugin.name), _defineProperty(_class, \"ClassName\", plugin.incidents[i].name), _defineProperty(_class, \"Channel\", AttributeChannelToUse), _temp);\n      } // else if it is a Clip\n      else if (incidentClass.prototype instanceof DescriptiveClip) {\n          var _class2, _temp2;\n\n          DynamicDescriptiveIncident = (_temp2 = _class2 =\n          /*#__PURE__*/\n          function (_incidentClass) {\n            _inherits(DynamicDescriptiveIncident, _incidentClass);\n\n            function DynamicDescriptiveIncident() {\n              _classCallCheck(this, DynamicDescriptiveIncident);\n\n              return _possibleConstructorReturn(this, _getPrototypeOf(DynamicDescriptiveIncident).apply(this, arguments));\n            }\n\n            return DynamicDescriptiveIncident;\n          }(incidentClass), _defineProperty(_class2, \"plugin\", plugin.name), _defineProperty(_class2, \"ClassName\", plugin.incidents[i].name), _temp2);\n        } else if (incidentClass.prototype instanceof DescriptiveGroup) {\n          var _class3, _temp3;\n\n          DynamicDescriptiveIncident = (_temp3 = _class3 =\n          /*#__PURE__*/\n          function (_incidentClass2) {\n            _inherits(DynamicDescriptiveIncident, _incidentClass2);\n\n            function DynamicDescriptiveIncident() {\n              _classCallCheck(this, DynamicDescriptiveIncident);\n\n              return _possibleConstructorReturn(this, _getPrototypeOf(DynamicDescriptiveIncident).apply(this, arguments));\n            }\n\n            return DynamicDescriptiveIncident;\n          }(incidentClass), _defineProperty(_class3, \"plugin\", plugin.name), _defineProperty(_class3, \"ClassName\", plugin.incidents[i].name), _temp3);\n        }\n\n      Object.defineProperty(thePlugin, plugin.incidents[i].name, {\n        get: function get() {\n          // the getter will construct a wrapper class which on the constructor will instantiate an object of the\n          // exposed class, set to it the plugin name and channel class parameters and return\n          // it from the constructor\n          var WrapperClass = function WrapperClass(attrs, props) {\n            _classCallCheck(this, WrapperClass);\n\n            var instantiatedIncident = new DynamicDescriptiveIncident(attrs, props);\n\n            if (Object.prototype.hasOwnProperty.call(plugin.incidents[i], \"attributesValidationRules\")) {\n              var v = new Validator();\n              var validationResult = v.validate(attrs, plugin.incidents[i].attributesValidationRules);\n\n              if (validationResult.length > 0) {\n                return {\n                  result: false,\n                  errors: validationResult\n                };\n              }\n            } else {\n              helper.warning(\"It's always good to provide attributesValidationRules to the exported incidents. \".concat(plugin.npm_name, \".\").concat(instantiatedIncident.constructor.name, \" doesn't provide it\"));\n            }\n\n            return instantiatedIncident;\n          };\n\n          return WrapperClass;\n        }\n      });\n    };\n\n    for (var i = 0; i < plugin.incidents.length; i++) {\n      _loop(i);\n    }\n\n    return thePlugin;\n  }\n}\n\nmodule.exports = {\n  API: {\n    Incident: Incident,\n    Group: DescriptiveGroup,\n    Clip: DescriptiveClip\n  },\n  Group: DescriptiveGroup,\n  Clip: DescriptiveClip,\n  loadPlugin: loadPlugin,\n  TimeCapsule: TimeCapsule\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L21haW4uanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L21haW4uanM/MzAyZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG52YXIgVmFsaWRhdG9yID0gcmVxdWlyZShcImZhc3Rlc3QtdmFsaWRhdG9yXCIpO1xuXG52YXIgRGVzY3JpcHRpdmVJbmNpZGVudCA9IHJlcXVpcmUoJy4vX0Rlc2NyaXB0aXZlSW5jaWRlbnRzL0Rlc2NyaXB0aXZlSW5jaWRlbnQnKTtcblxudmFyIERlc2NyaXB0aXZlR3JvdXAgPSByZXF1aXJlKCcuL19EZXNjcmlwdGl2ZUluY2lkZW50cy9EZXNjcmlwdGl2ZUdyb3VwJyk7XG5cbnZhciBEZXNjcmlwdGl2ZUNsaXAgPSByZXF1aXJlKCcuL19EZXNjcmlwdGl2ZUluY2lkZW50cy9EZXNjcmlwdGl2ZUNsaXAnKTtcblxudmFyIEluY2lkZW50ID0gcmVxdWlyZSgnLi9fQmFzZUNsYXNzZXMvSW5jaWRlbnQnKTtcblxudmFyIEF0dHJpYnV0ZUNoYW5uZWwgPSByZXF1aXJlKCcuL19DaGFubmVscy9fQXR0cmlidXRlL0F0dHJpYnV0ZUNoYW5uZWwnKTtcblxudmFyIFRpbWVDYXBzdWxlID0gcmVxdWlyZSgnLi9fY29yZVV0aWxzL1RpbWVDYXBzdWxlJyk7XG5cbnZhciBIZWxwZXIgPSByZXF1aXJlKCcuL19jb3JlVXRpbHMvSGVscGVyJyk7XG5cbnZhciBoZWxwZXIgPSBuZXcgSGVscGVyKCk7XG5cbnZhciBjaGVja1BsdWdpbiA9IGZ1bmN0aW9uIGNoZWNrUGx1Z2luKG1haW4pIHtcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtYWluLCBcImRlZmF1bHRcIikpIHtcbiAgICBtYWluID0gbWFpbltcImRlZmF1bHRcIl07XG4gIH1cblxuICB2YXIgcGx1Z2luX25hbWUgPSBtYWluLm5wbV9uYW1lO1xuICB2YXIgY2hlY2sgPSB0cnVlO1xuXG4gIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1haW4sIFwibmFtZVwiKSkge1xuICAgIGhlbHBlci5lcnJvcihcIldhcm5pbmcgb24gcGx1Z2luIFwiLmNvbmNhdChwbHVnaW5fbmFtZSwgXCIuIEEgcGx1Z2luIGlzIGFsd2F5cyBnb29kIHRvIGhhdmUgaXRzIG5hbWUgb25cXG4gICAgICAgIGl0cyBtYWluLmpzIGZpbGUsIHVuZGVyIHRoZSBrZXkgXFxcIm5hbWVcXFwiLiBJdCdzIG1pc3NpbmcgZnJvbSB0aGlzIHBsdWdpblwiKSk7XG4gIH1cblxuICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtYWluLCBcImluY2lkZW50c1wiKSkge1xuICAgIGhlbHBlci5lcnJvcihcIkVycm9yIG9uIHBsdWdpbiBcIi5jb25jYXQocGx1Z2luX25hbWUsIFwiLiBBIHBsdWdpbiBtdXN0IGV4cG9zZSBhdCBsZWFzdCBvbmUgSW5jaWRlbnQuXFxuICAgICAgICBFeHBvc2VkIHBsdWdpbiBJbmNpZGVudHMgc2hvdWxkIGJlIGRlZmluZWQgb24gdGhlIFxcXCJpbmNpZGVudHNcXFwiIGtleSBvZiB0aGUgbWFpbi5qcyBmaWxlLlwiKSk7XG4gICAgY2hlY2sgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICghaGVscGVyLmlzQXJyYXkobWFpbi5pbmNpZGVudHMpKSB7XG4gICAgaGVscGVyLmVycm9yKFwiRXJyb3Igb24gcGx1Z2luIFwiLmNvbmNhdChwbHVnaW5fbmFtZSwgXCIuIHRoZVBsdWdpbiBleHBvc2VkIEluY2lkZW50cyBhcmUgZGVmaW5lZCBvbiB0aGUgXFxcImluY2lkZW50c1xcXCIga2V5IG9mIHRoZSBtYWluLmpzIGZpbGUgaW4gYXJyYXkgZm9ybWF0LlxcbiAgICAgICAgUGxlYXNlIHJlZmVyIHRvIHRoZSBkb2N1bWVudGF0aW9uXCIpKTtcbiAgICBjaGVjayA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFpbi5pbmNpZGVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBleHBvc2VkSW5jaWRlbnREZWZpbml0aW9uID0gbWFpbi5pbmNpZGVudHNbaV07XG5cbiAgICAgIGlmIChfdHlwZW9mKGV4cG9zZWRJbmNpZGVudERlZmluaXRpb24uZXhwb3J0YWJsZSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvc2VkSW5jaWRlbnREZWZpbml0aW9uLmV4cG9ydGFibGUsIFwiZGVmYXVsdFwiKSkge1xuICAgICAgICAgIGV4cG9zZWRJbmNpZGVudERlZmluaXRpb24uZXhwb3J0YWJsZSA9IGV4cG9zZWRJbmNpZGVudERlZmluaXRpb24uZXhwb3J0YWJsZVtcImRlZmF1bHRcIl07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCEoZXhwb3NlZEluY2lkZW50RGVmaW5pdGlvbi5leHBvcnRhYmxlLnByb3RvdHlwZSBpbnN0YW5jZW9mIERlc2NyaXB0aXZlR3JvdXApICYmICEoZXhwb3NlZEluY2lkZW50RGVmaW5pdGlvbi5leHBvcnRhYmxlLnByb3RvdHlwZSBpbnN0YW5jZW9mIERlc2NyaXB0aXZlQ2xpcCkgJiYgIShleHBvc2VkSW5jaWRlbnREZWZpbml0aW9uLmV4cG9ydGFibGUucHJvdG90eXBlIGluc3RhbmNlb2YgSW5jaWRlbnQpKSB7XG4gICAgICAgIGhlbHBlci5lcnJvcihcIkVycm9yIG9uIHBsdWdpbiBcIi5jb25jYXQocGx1Z2luX25hbWUsIFwiLiBFeHBvcnRhYmxlIEluY2lkZW50cyBieSBhbnkgcGx1Z2luIG11c3QgZXh0ZW5kIG9uZSBvZiB0aGUgYmFzZSBjbGFzc2VzIHByb3ZpZGVkIGJ5IE1vdG9yQ29ydGV4LlxcbiAgICAgICAgICAgICAgICBcIikuY29uY2F0KGV4cG9zZWRJbmNpZGVudERlZmluaXRpb24uZXhwb3J0YWJsZS5jb25zdHJ1Y3Rvci5uYW1lLCBcIiBkb2Vzbid0LlxcbiAgICAgICAgICAgICAgICBQbGVhc2UgcmVmZXIgdG8gZG9jdW1lbnRhdGlvblwiKSk7XG4gICAgICAgIGNoZWNrID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9zZWRJbmNpZGVudERlZmluaXRpb24sIFwibmFtZVwiKSkge1xuICAgICAgICBoZWxwZXIuZXJyb3IoXCJFcnJvciBvbiBwbHVnaW4gXCIuY29uY2F0KHBsdWdpbl9uYW1lLCBcIi4gRXhwb3J0YWJsZSBJbmNpZGVudHMgYnkgYW55IHBsdWdpbiBtdXN0IGhhdmUgdGhlIFxcXCJuYW1lXFxcIiBrZXkgd2hpY2ggZGVmaW5lcyB0aGUgbmFtZSBvZiB0aGUgZXhwb3J0ZWQgSW5jaWRlbnQuXFxuICAgICAgICAgICAgICAgIFBsZWFzZSByZWZlciB0byBkb2N1bWVudGF0aW9uXCIpKTtcbiAgICAgICAgY2hlY2sgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3NlZEluY2lkZW50RGVmaW5pdGlvbiwgXCJwcm9wVHlwZXNcIikpIHtcbiAgICAgICAgaGVscGVyLmxvZyhcIldhcm5pbmcgb24gcGx1Z2luIFwiLmNvbmNhdChwbHVnaW5fbmFtZSwgXCIuXFxuICAgICAgICAgICAgICAgIEl0J3MgYWx3YXlzIGdvb2QgZm9yIHBsdWdpbnMgdG8gZGVmaW5lIHRoZSBzdXBwb3J0ZWQgcHJvcFR5cGVzIG9mIHRoZWlyIGV4cG9zZWQgSW5jaWRlbnRzJyBzdXBwb3J0ZWQgcHJvcGVydGllcy5cXG4gICAgICAgICAgICAgICAgXCIpLmNvbmNhdChleHBvc2VkSW5jaWRlbnREZWZpbml0aW9uLmV4cG9ydGFibGUuY29uc3RydWN0b3IubmFtZSwgXCIgZG9lc24ndC5cXG4gICAgICAgICAgICAgICAgUGxlYXNlIHJlZmVyIHRvIGRvY3VtZW50YXRpb25cIiksICd3YXJuaW5nJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNoZWNrO1xufTsgLy8gcGx1Z2luX25hbWUgaXMgdGhlIHVuaXF1ZSBuYW1lIG9mIHRoZSBwbHVnaW5cblxuXG5mdW5jdGlvbiBsb2FkUGx1Z2luKHBsdWdpbikge1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHBsdWdpbiwgXCJkZWZhdWx0XCIpKSB7XG4gICAgcGx1Z2luID0gcGx1Z2luW1wiZGVmYXVsdFwiXTtcbiAgfVxuXG4gIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHBsdWdpbiwgXCJucG1fbmFtZVwiKSkge1xuICAgIHBsdWdpbi5ucG1fbmFtZSA9IFwicGx1Z2luX1wiLmNvbmNhdChuZXcgRGF0ZSgpLmdldFRpbWUoKSk7XG4gIH1cblxuICBpZiAoIWNoZWNrUGx1Z2luKHBsdWdpbikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgLy8gdGhlUGx1Z2luIGlzIHRoZSBwbHVnaW4gb2JqZWN0IHdoaWNoIHdpbGwgaG9sZCBvbiBpdHMga2V5c1xuICAgIC8vIHRoZSBuYW1lcyBvZiB0aGUgZXhwb3NlZCBJbmNpZGVudHMgb2YgaXRzLiBUaGUga2V5cyBvZiB0aGlzIG9iamVjdFxuICAgIC8vIGFyZSBnb2luZyB0byBiZSBpZGVudGljYWwgd2l0aCB0aGUgbmFtZXMgb2YgdGhlIGNsYXNzZXMgZXhwb3NlZFxuICAgIHZhciB0aGVQbHVnaW4gPSB7fTtcblxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocGx1Z2luLCBcImNsaXBcIikpIHt9IC8vIFRPRE8gQ3VzdG9tIENsaXBzIHN0cmF0ZWd5XG4gICAgLy8gaWYgdGhlIHBsdWdpbiBkZWZpbml0aW9uIGhhcyBjb21wb3NpdGVBdHRyaWJ1dGVzIHRoZW4gd2UgZHluYW1pY2FsbHlcbiAgICAvLyBjcmVhdGUgYSBuZXcgQ2hhbm5lbCBjbGFzcyBleHRlbmRpbmcgQXR0cmlidXRlQ2hhbm5lbCBzZXR0aW5nIHRoZVxuICAgIC8vIGNvbXBvc2l0ZSBBdHRyaWJ1dGVzIG9uIHRoZSBmbHkuIFdlIGNhbiB0aGVuIHVzZSB0aGlzIENoYW5uZWwgY2xhc3NcbiAgICAvLyBmb3IgYWxsIEluY2lkZW50cyBleHBvc2VkIGJ5IHRoZSBwbHVnaW5cblxuXG4gICAgdmFyIEF0dHJpYnV0ZUNoYW5uZWxUb1VzZSA9IEF0dHJpYnV0ZUNoYW5uZWw7XG5cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHBsdWdpbiwgXCJjb21wb3NpdGVBdHRyaWJ1dGVzXCIpKSB7XG4gICAgICBBdHRyaWJ1dGVDaGFubmVsVG9Vc2UgPVxuICAgICAgLyojX19QVVJFX18qL1xuICAgICAgZnVuY3Rpb24gKF9BdHRyaWJ1dGVDaGFubmVsKSB7XG4gICAgICAgIF9pbmhlcml0cyhBdHRyaWJ1dGVDaGFubmVsVG9Vc2UsIF9BdHRyaWJ1dGVDaGFubmVsKTtcblxuICAgICAgICBmdW5jdGlvbiBBdHRyaWJ1dGVDaGFubmVsVG9Vc2UocHJvcHMpIHtcbiAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQXR0cmlidXRlQ2hhbm5lbFRvVXNlKTtcblxuICAgICAgICAgIHByb3BzLmNvbWJvQXR0cmlidXRlcyA9IHBsdWdpbi5jb21wb3NpdGVBdHRyaWJ1dGVzO1xuICAgICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoQXR0cmlidXRlQ2hhbm5lbFRvVXNlKS5jYWxsKHRoaXMsIHByb3BzKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gQXR0cmlidXRlQ2hhbm5lbFRvVXNlO1xuICAgICAgfShBdHRyaWJ1dGVDaGFubmVsKTtcbiAgICB9IC8vIGZvciBlYWNoIG9mIHRoZSBleHBvc2VkIEluY2lkZW50c1xuXG5cbiAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChpKSB7XG4gICAgICB2YXIgaW5jaWRlbnRDbGFzcyA9IHBsdWdpbi5pbmNpZGVudHNbaV0uZXhwb3J0YWJsZTtcbiAgICAgIHZhciBEeW5hbWljRGVzY3JpcHRpdmVJbmNpZGVudCA9IHZvaWQgMDsgLy8gdGhlIGV4cG9ydGFibGUgSW5jaWRlbnQgY2FuIGJlIGVpdGhlciBhIENsaXAsIGEgQ29tcG8gb3IgYW4gSW5jaWRlbnRcbiAgICAgIC8vIGlmIGl0IGlzIGFuIEluY2lkZW50XG5cbiAgICAgIGlmIChpbmNpZGVudENsYXNzLnByb3RvdHlwZSBpbnN0YW5jZW9mIEluY2lkZW50KSB7XG4gICAgICAgIHZhciBfY2xhc3MsIF90ZW1wO1xuXG4gICAgICAgIER5bmFtaWNEZXNjcmlwdGl2ZUluY2lkZW50ID0gKF90ZW1wID0gX2NsYXNzID1cbiAgICAgICAgLyojX19QVVJFX18qL1xuICAgICAgICBmdW5jdGlvbiAoX0Rlc2NyaXB0aXZlSW5jaWRlbnQpIHtcbiAgICAgICAgICBfaW5oZXJpdHMoRHluYW1pY0Rlc2NyaXB0aXZlSW5jaWRlbnQsIF9EZXNjcmlwdGl2ZUluY2lkZW50KTtcblxuICAgICAgICAgIGZ1bmN0aW9uIER5bmFtaWNEZXNjcmlwdGl2ZUluY2lkZW50KCkge1xuICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIER5bmFtaWNEZXNjcmlwdGl2ZUluY2lkZW50KTtcblxuICAgICAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihEeW5hbWljRGVzY3JpcHRpdmVJbmNpZGVudCkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIER5bmFtaWNEZXNjcmlwdGl2ZUluY2lkZW50O1xuICAgICAgICB9KERlc2NyaXB0aXZlSW5jaWRlbnQpLCBfZGVmaW5lUHJvcGVydHkoX2NsYXNzLCBcIkluY2lkZW50XCIsIGluY2lkZW50Q2xhc3MpLCBfZGVmaW5lUHJvcGVydHkoX2NsYXNzLCBcInBsdWdpbl9ucG1fbmFtZVwiLCBwbHVnaW4ubnBtX25hbWUpLCBfZGVmaW5lUHJvcGVydHkoX2NsYXNzLCBcInBsdWdpblwiLCBwbHVnaW4ubmFtZSksIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3MsIFwiQ2xhc3NOYW1lXCIsIHBsdWdpbi5pbmNpZGVudHNbaV0ubmFtZSksIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3MsIFwiQ2hhbm5lbFwiLCBBdHRyaWJ1dGVDaGFubmVsVG9Vc2UpLCBfdGVtcCk7XG4gICAgICB9IC8vIGVsc2UgaWYgaXQgaXMgYSBDbGlwXG4gICAgICBlbHNlIGlmIChpbmNpZGVudENsYXNzLnByb3RvdHlwZSBpbnN0YW5jZW9mIERlc2NyaXB0aXZlQ2xpcCkge1xuICAgICAgICAgIHZhciBfY2xhc3MyLCBfdGVtcDI7XG5cbiAgICAgICAgICBEeW5hbWljRGVzY3JpcHRpdmVJbmNpZGVudCA9IChfdGVtcDIgPSBfY2xhc3MyID1cbiAgICAgICAgICAvKiNfX1BVUkVfXyovXG4gICAgICAgICAgZnVuY3Rpb24gKF9pbmNpZGVudENsYXNzKSB7XG4gICAgICAgICAgICBfaW5oZXJpdHMoRHluYW1pY0Rlc2NyaXB0aXZlSW5jaWRlbnQsIF9pbmNpZGVudENsYXNzKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gRHluYW1pY0Rlc2NyaXB0aXZlSW5jaWRlbnQoKSB7XG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEeW5hbWljRGVzY3JpcHRpdmVJbmNpZGVudCk7XG5cbiAgICAgICAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihEeW5hbWljRGVzY3JpcHRpdmVJbmNpZGVudCkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBEeW5hbWljRGVzY3JpcHRpdmVJbmNpZGVudDtcbiAgICAgICAgICB9KGluY2lkZW50Q2xhc3MpLCBfZGVmaW5lUHJvcGVydHkoX2NsYXNzMiwgXCJwbHVnaW5cIiwgcGx1Z2luLm5hbWUpLCBfZGVmaW5lUHJvcGVydHkoX2NsYXNzMiwgXCJDbGFzc05hbWVcIiwgcGx1Z2luLmluY2lkZW50c1tpXS5uYW1lKSwgX3RlbXAyKTtcbiAgICAgICAgfSBlbHNlIGlmIChpbmNpZGVudENsYXNzLnByb3RvdHlwZSBpbnN0YW5jZW9mIERlc2NyaXB0aXZlR3JvdXApIHtcbiAgICAgICAgICB2YXIgX2NsYXNzMywgX3RlbXAzO1xuXG4gICAgICAgICAgRHluYW1pY0Rlc2NyaXB0aXZlSW5jaWRlbnQgPSAoX3RlbXAzID0gX2NsYXNzMyA9XG4gICAgICAgICAgLyojX19QVVJFX18qL1xuICAgICAgICAgIGZ1bmN0aW9uIChfaW5jaWRlbnRDbGFzczIpIHtcbiAgICAgICAgICAgIF9pbmhlcml0cyhEeW5hbWljRGVzY3JpcHRpdmVJbmNpZGVudCwgX2luY2lkZW50Q2xhc3MyKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gRHluYW1pY0Rlc2NyaXB0aXZlSW5jaWRlbnQoKSB7XG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEeW5hbWljRGVzY3JpcHRpdmVJbmNpZGVudCk7XG5cbiAgICAgICAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihEeW5hbWljRGVzY3JpcHRpdmVJbmNpZGVudCkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBEeW5hbWljRGVzY3JpcHRpdmVJbmNpZGVudDtcbiAgICAgICAgICB9KGluY2lkZW50Q2xhc3MpLCBfZGVmaW5lUHJvcGVydHkoX2NsYXNzMywgXCJwbHVnaW5cIiwgcGx1Z2luLm5hbWUpLCBfZGVmaW5lUHJvcGVydHkoX2NsYXNzMywgXCJDbGFzc05hbWVcIiwgcGx1Z2luLmluY2lkZW50c1tpXS5uYW1lKSwgX3RlbXAzKTtcbiAgICAgICAgfVxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhlUGx1Z2luLCBwbHVnaW4uaW5jaWRlbnRzW2ldLm5hbWUsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgLy8gdGhlIGdldHRlciB3aWxsIGNvbnN0cnVjdCBhIHdyYXBwZXIgY2xhc3Mgd2hpY2ggb24gdGhlIGNvbnN0cnVjdG9yIHdpbGwgaW5zdGFudGlhdGUgYW4gb2JqZWN0IG9mIHRoZVxuICAgICAgICAgIC8vIGV4cG9zZWQgY2xhc3MsIHNldCB0byBpdCB0aGUgcGx1Z2luIG5hbWUgYW5kIGNoYW5uZWwgY2xhc3MgcGFyYW1ldGVycyBhbmQgcmV0dXJuXG4gICAgICAgICAgLy8gaXQgZnJvbSB0aGUgY29uc3RydWN0b3JcbiAgICAgICAgICB2YXIgV3JhcHBlckNsYXNzID0gZnVuY3Rpb24gV3JhcHBlckNsYXNzKGF0dHJzLCBwcm9wcykge1xuICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFdyYXBwZXJDbGFzcyk7XG5cbiAgICAgICAgICAgIHZhciBpbnN0YW50aWF0ZWRJbmNpZGVudCA9IG5ldyBEeW5hbWljRGVzY3JpcHRpdmVJbmNpZGVudChhdHRycywgcHJvcHMpO1xuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHBsdWdpbi5pbmNpZGVudHNbaV0sIFwiYXR0cmlidXRlc1ZhbGlkYXRpb25SdWxlc1wiKSkge1xuICAgICAgICAgICAgICB2YXIgdiA9IG5ldyBWYWxpZGF0b3IoKTtcbiAgICAgICAgICAgICAgdmFyIHZhbGlkYXRpb25SZXN1bHQgPSB2LnZhbGlkYXRlKGF0dHJzLCBwbHVnaW4uaW5jaWRlbnRzW2ldLmF0dHJpYnV0ZXNWYWxpZGF0aW9uUnVsZXMpO1xuXG4gICAgICAgICAgICAgIGlmICh2YWxpZGF0aW9uUmVzdWx0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgIGVycm9yczogdmFsaWRhdGlvblJlc3VsdFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGhlbHBlci53YXJuaW5nKFwiSXQncyBhbHdheXMgZ29vZCB0byBwcm92aWRlIGF0dHJpYnV0ZXNWYWxpZGF0aW9uUnVsZXMgdG8gdGhlIGV4cG9ydGVkIGluY2lkZW50cy4gXCIuY29uY2F0KHBsdWdpbi5ucG1fbmFtZSwgXCIuXCIpLmNvbmNhdChpbnN0YW50aWF0ZWRJbmNpZGVudC5jb25zdHJ1Y3Rvci5uYW1lLCBcIiBkb2Vzbid0IHByb3ZpZGUgaXRcIikpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gaW5zdGFudGlhdGVkSW5jaWRlbnQ7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHJldHVybiBXcmFwcGVyQ2xhc3M7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBsdWdpbi5pbmNpZGVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIF9sb29wKGkpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGVQbHVnaW47XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEFQSToge1xuICAgIEluY2lkZW50OiBJbmNpZGVudCxcbiAgICBHcm91cDogRGVzY3JpcHRpdmVHcm91cCxcbiAgICBDbGlwOiBEZXNjcmlwdGl2ZUNsaXBcbiAgfSxcbiAgR3JvdXA6IERlc2NyaXB0aXZlR3JvdXAsXG4gIENsaXA6IERlc2NyaXB0aXZlQ2xpcCxcbiAgbG9hZFBsdWdpbjogbG9hZFBsdWdpbixcbiAgVGltZUNhcHN1bGU6IFRpbWVDYXBzdWxlXG59OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/main.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.filter/index.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.filter/index.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, module) {/**\n * Lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize include=\"filter,sortBy,findIndex,find,forEach,cloneDeep\" exports=\"npm\"`\n * Copyright JS Foundation and other contributors <https://js.foundation/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used as the maximum memoize cache size. */\nvar MAX_MEMOIZE_SIZE = 500;\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0,\n    MAX_SAFE_INTEGER = 9007199254740991;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    asyncTag = '[object AsyncFunction]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    nullTag = '[object Null]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    proxyTag = '[object Proxy]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]',\n    undefinedTag = '[object Undefined]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/,\n    rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Detect free variable `exports`. */\nvar freeExports =  true && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * A specialized version of `_.filter` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction arrayFilter(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      resIndex = 0,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index];\n    if (predicate(value, index, array)) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\n\n/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction arrayMap(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\n\n/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\n/**\n * A specialized version of `_.some` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */\nfunction arraySome(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (predicate(array[index], index, array)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction baseProperty(key) {\n  return function(object) {\n    return object == null ? undefined : object[key];\n  };\n}\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\n/**\n * Checks if a `cache` value for `key` exists.\n *\n * @private\n * @param {Object} cache The cache to query.\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction cacheHas(cache, key) {\n  return cache.has(key);\n}\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined,\n    Symbol = root.Symbol,\n    Uint8Array = root.Uint8Array,\n    propertyIsEnumerable = objectProto.propertyIsEnumerable,\n    splice = arrayProto.splice,\n    symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols,\n    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\n    nativeKeys = overArg(Object.keys, Object);\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView'),\n    Map = getNative(root, 'Map'),\n    Promise = getNative(root, 'Promise'),\n    Set = getNative(root, 'Set'),\n    WeakMap = getNative(root, 'WeakMap'),\n    nativeCreate = getNative(Object, 'create');\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n *\n * Creates an array cache object to store unique values.\n *\n * @private\n * @constructor\n * @param {Array} [values] The values to cache.\n */\nfunction SetCache(values) {\n  var index = -1,\n      length = values == null ? 0 : values.length;\n\n  this.__data__ = new MapCache;\n  while (++index < length) {\n    this.add(values[index]);\n  }\n}\n\n/**\n * Adds `value` to the array cache.\n *\n * @private\n * @name add\n * @memberOf SetCache\n * @alias push\n * @param {*} value The value to cache.\n * @returns {Object} Returns the cache instance.\n */\nfunction setCacheAdd(value) {\n  this.__data__.set(value, HASH_UNDEFINED);\n  return this;\n}\n\n/**\n * Checks if `value` is in the array cache.\n *\n * @private\n * @name has\n * @memberOf SetCache\n * @param {*} value The value to search for.\n * @returns {number} Returns `true` if `value` is found, else `false`.\n */\nfunction setCacheHas(value) {\n  return this.__data__.has(value);\n}\n\n// Add methods to `SetCache`.\nSetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\nSetCache.prototype.has = setCacheHas;\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  var data = this.__data__ = new ListCache(entries);\n  this.size = data.size;\n}\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  var data = this.__data__,\n      result = data['delete'](key);\n\n  this.size = data.size;\n  return result;\n}\n\n/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\n/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var data = this.__data__;\n  if (data instanceof ListCache) {\n    var pairs = data.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      this.size = ++data.size;\n      return this;\n    }\n    data = this.__data__ = new MapCache(pairs);\n  }\n  data.set(key, value);\n  this.size = data.size;\n  return this;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.forEach` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array|Object} Returns `collection`.\n */\nvar baseEach = createBaseEach(baseForOwn);\n\n/**\n * The base implementation of `_.filter` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction baseFilter(collection, predicate) {\n  var result = [];\n  baseEach(collection, function(value, index, collection) {\n    if (predicate(value, index, collection)) {\n      result.push(value);\n    }\n  });\n  return result;\n}\n\n/**\n * The base implementation of `baseForOwn` which iterates over `object`\n * properties returned by `keysFunc` and invokes `iteratee` for each property.\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @returns {Object} Returns `object`.\n */\nvar baseFor = createBaseFor();\n\n/**\n * The base implementation of `_.forOwn` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Object} Returns `object`.\n */\nfunction baseForOwn(object, iteratee) {\n  return object && baseFor(object, iteratee, keys);\n}\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = castPath(path, object);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n}\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\n/**\n * The base implementation of `_.hasIn` without support for deep paths.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {Array|string} key The key to check.\n * @returns {boolean} Returns `true` if `key` exists, else `false`.\n */\nfunction baseHasIn(object, key) {\n  return object != null && key in Object(object);\n}\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\n/**\n * The base implementation of `_.isEqual` which supports partial comparisons\n * and tracks traversed objects.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Unordered comparison\n *  2 - Partial comparison\n * @param {Function} [customizer] The function to customize comparisons.\n * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n */\nfunction baseIsEqual(value, other, bitmask, customizer, stack) {\n  if (value === other) {\n    return true;\n  }\n  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {\n    return value !== value && other !== other;\n  }\n  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n}\n\n/**\n * A specialized version of `baseIsEqual` for arrays and objects which performs\n * deep comparisons and tracks traversed objects enabling objects with circular\n * references to be compared.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n  var objIsArr = isArray(object),\n      othIsArr = isArray(other),\n      objTag = objIsArr ? arrayTag : getTag(object),\n      othTag = othIsArr ? arrayTag : getTag(other);\n\n  objTag = objTag == argsTag ? objectTag : objTag;\n  othTag = othTag == argsTag ? objectTag : othTag;\n\n  var objIsObj = objTag == objectTag,\n      othIsObj = othTag == objectTag,\n      isSameTag = objTag == othTag;\n\n  if (isSameTag && isBuffer(object)) {\n    if (!isBuffer(other)) {\n      return false;\n    }\n    objIsArr = true;\n    objIsObj = false;\n  }\n  if (isSameTag && !objIsObj) {\n    stack || (stack = new Stack);\n    return (objIsArr || isTypedArray(object))\n      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)\n      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n  }\n  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\n    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n    if (objIsWrapped || othIsWrapped) {\n      var objUnwrapped = objIsWrapped ? object.value() : object,\n          othUnwrapped = othIsWrapped ? other.value() : other;\n\n      stack || (stack = new Stack);\n      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n    }\n  }\n  if (!isSameTag) {\n    return false;\n  }\n  stack || (stack = new Stack);\n  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n}\n\n/**\n * The base implementation of `_.isMatch` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to inspect.\n * @param {Object} source The object of property values to match.\n * @param {Array} matchData The property names, values, and compare flags to match.\n * @param {Function} [customizer] The function to customize comparisons.\n * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n */\nfunction baseIsMatch(object, source, matchData, customizer) {\n  var index = matchData.length,\n      length = index,\n      noCustomizer = !customizer;\n\n  if (object == null) {\n    return !length;\n  }\n  object = Object(object);\n  while (index--) {\n    var data = matchData[index];\n    if ((noCustomizer && data[2])\n          ? data[1] !== object[data[0]]\n          : !(data[0] in object)\n        ) {\n      return false;\n    }\n  }\n  while (++index < length) {\n    data = matchData[index];\n    var key = data[0],\n        objValue = object[key],\n        srcValue = data[1];\n\n    if (noCustomizer && data[2]) {\n      if (objValue === undefined && !(key in object)) {\n        return false;\n      }\n    } else {\n      var stack = new Stack;\n      if (customizer) {\n        var result = customizer(objValue, srcValue, key, object, source, stack);\n      }\n      if (!(result === undefined\n            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)\n            : result\n          )) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\n/**\n * The base implementation of `_.iteratee`.\n *\n * @private\n * @param {*} [value=_.identity] The value to convert to an iteratee.\n * @returns {Function} Returns the iteratee.\n */\nfunction baseIteratee(value) {\n  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n  if (typeof value == 'function') {\n    return value;\n  }\n  if (value == null) {\n    return identity;\n  }\n  if (typeof value == 'object') {\n    return isArray(value)\n      ? baseMatchesProperty(value[0], value[1])\n      : baseMatches(value);\n  }\n  return property(value);\n}\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.matches` which doesn't clone `source`.\n *\n * @private\n * @param {Object} source The object of property values to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatches(source) {\n  var matchData = getMatchData(source);\n  if (matchData.length == 1 && matchData[0][2]) {\n    return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n  }\n  return function(object) {\n    return object === source || baseIsMatch(object, source, matchData);\n  };\n}\n\n/**\n * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n *\n * @private\n * @param {string} path The path of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatchesProperty(path, srcValue) {\n  if (isKey(path) && isStrictComparable(srcValue)) {\n    return matchesStrictComparable(toKey(path), srcValue);\n  }\n  return function(object) {\n    var objValue = get(object, path);\n    return (objValue === undefined && objValue === srcValue)\n      ? hasIn(object, path)\n      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);\n  };\n}\n\n/**\n * A specialized version of `baseProperty` which supports deep paths.\n *\n * @private\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction basePropertyDeep(path) {\n  return function(object) {\n    return baseGet(object, path);\n  };\n}\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isArray(value)) {\n    // Recursively convert values (susceptible to call stack limits).\n    return arrayMap(value, baseToString) + '';\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @param {Object} [object] The object to query keys on.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value, object) {\n  if (isArray(value)) {\n    return value;\n  }\n  return isKey(value, object) ? [value] : stringToPath(toString(value));\n}\n\n/**\n * Creates a `baseEach` or `baseEachRight` function.\n *\n * @private\n * @param {Function} eachFunc The function to iterate over a collection.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseEach(eachFunc, fromRight) {\n  return function(collection, iteratee) {\n    if (collection == null) {\n      return collection;\n    }\n    if (!isArrayLike(collection)) {\n      return eachFunc(collection, iteratee);\n    }\n    var length = collection.length,\n        index = fromRight ? length : -1,\n        iterable = Object(collection);\n\n    while ((fromRight ? index-- : ++index < length)) {\n      if (iteratee(iterable[index], index, iterable) === false) {\n        break;\n      }\n    }\n    return collection;\n  };\n}\n\n/**\n * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseFor(fromRight) {\n  return function(object, iteratee, keysFunc) {\n    var index = -1,\n        iterable = Object(object),\n        props = keysFunc(object),\n        length = props.length;\n\n    while (length--) {\n      var key = props[fromRight ? length : ++index];\n      if (iteratee(iterable[key], key, iterable) === false) {\n        break;\n      }\n    }\n    return object;\n  };\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for arrays with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Array} array The array to compare.\n * @param {Array} other The other array to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `array` and `other` objects.\n * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n */\nfunction equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      arrLength = array.length,\n      othLength = other.length;\n\n  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n    return false;\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(array);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var index = -1,\n      result = true,\n      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;\n\n  stack.set(array, other);\n  stack.set(other, array);\n\n  // Ignore non-index properties.\n  while (++index < arrLength) {\n    var arrValue = array[index],\n        othValue = other[index];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, arrValue, index, other, array, stack)\n        : customizer(arrValue, othValue, index, array, other, stack);\n    }\n    if (compared !== undefined) {\n      if (compared) {\n        continue;\n      }\n      result = false;\n      break;\n    }\n    // Recursively compare arrays (susceptible to call stack limits).\n    if (seen) {\n      if (!arraySome(other, function(othValue, othIndex) {\n            if (!cacheHas(seen, othIndex) &&\n                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n              return seen.push(othIndex);\n            }\n          })) {\n        result = false;\n        break;\n      }\n    } else if (!(\n          arrValue === othValue ||\n            equalFunc(arrValue, othValue, bitmask, customizer, stack)\n        )) {\n      result = false;\n      break;\n    }\n  }\n  stack['delete'](array);\n  stack['delete'](other);\n  return result;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for comparing objects of\n * the same `toStringTag`.\n *\n * **Note:** This function only supports comparing values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {string} tag The `toStringTag` of the objects to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n  switch (tag) {\n    case dataViewTag:\n      if ((object.byteLength != other.byteLength) ||\n          (object.byteOffset != other.byteOffset)) {\n        return false;\n      }\n      object = object.buffer;\n      other = other.buffer;\n\n    case arrayBufferTag:\n      if ((object.byteLength != other.byteLength) ||\n          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n        return false;\n      }\n      return true;\n\n    case boolTag:\n    case dateTag:\n    case numberTag:\n      // Coerce booleans to `1` or `0` and dates to milliseconds.\n      // Invalid dates are coerced to `NaN`.\n      return eq(+object, +other);\n\n    case errorTag:\n      return object.name == other.name && object.message == other.message;\n\n    case regexpTag:\n    case stringTag:\n      // Coerce regexes to strings and treat strings, primitives and objects,\n      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n      // for more details.\n      return object == (other + '');\n\n    case mapTag:\n      var convert = mapToArray;\n\n    case setTag:\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\n      convert || (convert = setToArray);\n\n      if (object.size != other.size && !isPartial) {\n        return false;\n      }\n      // Assume cyclic values are equal.\n      var stacked = stack.get(object);\n      if (stacked) {\n        return stacked == other;\n      }\n      bitmask |= COMPARE_UNORDERED_FLAG;\n\n      // Recursively compare objects (susceptible to call stack limits).\n      stack.set(object, other);\n      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n      stack['delete'](object);\n      return result;\n\n    case symbolTag:\n      if (symbolValueOf) {\n        return symbolValueOf.call(object) == symbolValueOf.call(other);\n      }\n  }\n  return false;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for objects with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      objProps = getAllKeys(object),\n      objLength = objProps.length,\n      othProps = getAllKeys(other),\n      othLength = othProps.length;\n\n  if (objLength != othLength && !isPartial) {\n    return false;\n  }\n  var index = objLength;\n  while (index--) {\n    var key = objProps[index];\n    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n      return false;\n    }\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(object);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var result = true;\n  stack.set(object, other);\n  stack.set(other, object);\n\n  var skipCtor = isPartial;\n  while (++index < objLength) {\n    key = objProps[index];\n    var objValue = object[key],\n        othValue = other[key];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, objValue, key, other, object, stack)\n        : customizer(objValue, othValue, key, object, other, stack);\n    }\n    // Recursively compare objects (susceptible to call stack limits).\n    if (!(compared === undefined\n          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))\n          : compared\n        )) {\n      result = false;\n      break;\n    }\n    skipCtor || (skipCtor = key == 'constructor');\n  }\n  if (result && !skipCtor) {\n    var objCtor = object.constructor,\n        othCtor = other.constructor;\n\n    // Non `Object` object instances with different constructors are not equal.\n    if (objCtor != othCtor &&\n        ('constructor' in object && 'constructor' in other) &&\n        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n          typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n      result = false;\n    }\n  }\n  stack['delete'](object);\n  stack['delete'](other);\n  return result;\n}\n\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n  return baseGetAllKeys(object, keys, getSymbols);\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the property names, values, and compare flags of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the match data of `object`.\n */\nfunction getMatchData(object) {\n  var result = keys(object),\n      length = result.length;\n\n  while (length--) {\n    var key = result[length],\n        value = object[key];\n\n    result[length] = [key, value, isStrictComparable(value)];\n  }\n  return result;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\n/**\n * Creates an array of the own enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = !nativeGetSymbols ? stubArray : function(object) {\n  if (object == null) {\n    return [];\n  }\n  object = Object(object);\n  return arrayFilter(nativeGetSymbols(object), function(symbol) {\n    return propertyIsEnumerable.call(object, symbol);\n  });\n};\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = baseGetTag(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : '';\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\n/**\n * Checks if `path` exists on `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @param {Function} hasFunc The function to check properties.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n */\nfunction hasPath(object, path, hasFunc) {\n  path = castPath(path, object);\n\n  var index = -1,\n      length = path.length,\n      result = false;\n\n  while (++index < length) {\n    var key = toKey(path[index]);\n    if (!(result = object != null && hasFunc(object, key))) {\n      break;\n    }\n    object = object[key];\n  }\n  if (result || ++index != length) {\n    return result;\n  }\n  length = object == null ? 0 : object.length;\n  return !!length && isLength(length) && isIndex(key, length) &&\n    (isArray(object) || isArguments(object));\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  var type = typeof value;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n\n  return !!length &&\n    (type == 'number' ||\n      (type != 'symbol' && reIsUint.test(value))) &&\n        (value > -1 && value % 1 == 0 && value < length);\n}\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\n/**\n * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` if suitable for strict\n *  equality comparisons, else `false`.\n */\nfunction isStrictComparable(value) {\n  return value === value && !isObject(value);\n}\n\n/**\n * A specialized version of `matchesProperty` for source values suitable\n * for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction matchesStrictComparable(key, srcValue) {\n  return function(object) {\n    if (object == null) {\n      return false;\n    }\n    return object[key] === srcValue &&\n      (srcValue !== undefined || (key in Object(object)));\n  };\n}\n\n/**\n * A specialized version of `_.memoize` which clears the memoized function's\n * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n *\n * @private\n * @param {Function} func The function to have its output memoized.\n * @returns {Function} Returns the new memoized function.\n */\nfunction memoizeCapped(func) {\n  var result = memoize(func, function(key) {\n    if (cache.size === MAX_MEMOIZE_SIZE) {\n      cache.clear();\n    }\n    return key;\n  });\n\n  var cache = result.cache;\n  return result;\n}\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoizeCapped(function(string) {\n  var result = [];\n  if (string.charCodeAt(0) === 46 /* . */) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, subString) {\n    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * Iterates over elements of `collection`, returning an array of all elements\n * `predicate` returns truthy for. The predicate is invoked with three\n * arguments: (value, index|key, collection).\n *\n * **Note:** Unlike `_.remove`, this method returns a new array.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n * @see _.reject\n * @example\n *\n * var users = [\n *   { 'user': 'barney', 'age': 36, 'active': true },\n *   { 'user': 'fred',   'age': 40, 'active': false }\n * ];\n *\n * _.filter(users, function(o) { return !o.active; });\n * // => objects for ['fred']\n *\n * // The `_.matches` iteratee shorthand.\n * _.filter(users, { 'age': 36, 'active': true });\n * // => objects for ['barney']\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.filter(users, ['active', false]);\n * // => objects for ['fred']\n *\n * // The `_.property` iteratee shorthand.\n * _.filter(users, 'active');\n * // => objects for ['barney']\n */\nfunction filter(collection, predicate) {\n  var func = isArray(collection) ? arrayFilter : baseFilter;\n  return func(collection, baseIteratee(predicate, 3));\n}\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result) || cache;\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Expose `MapCache`.\nmemoize.Cache = MapCache;\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get(object, path, defaultValue) {\n  var result = object == null ? undefined : baseGet(object, path);\n  return result === undefined ? defaultValue : result;\n}\n\n/**\n * Checks if `path` is a direct or inherited property of `object`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n * @example\n *\n * var object = _.create({ 'a': _.create({ 'b': 2 }) });\n *\n * _.hasIn(object, 'a');\n * // => true\n *\n * _.hasIn(object, 'a.b');\n * // => true\n *\n * _.hasIn(object, ['a', 'b']);\n * // => true\n *\n * _.hasIn(object, 'b');\n * // => false\n */\nfunction hasIn(object, path) {\n  return object != null && hasPath(object, path, baseHasIn);\n}\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\n/**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\n/**\n * Creates a function that returns the value at `path` of a given object.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n * @example\n *\n * var objects = [\n *   { 'a': { 'b': 2 } },\n *   { 'a': { 'b': 1 } }\n * ];\n *\n * _.map(objects, _.property('a.b'));\n * // => [2, 1]\n *\n * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n * // => [1, 2]\n */\nfunction property(path) {\n  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n}\n\n/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n  return [];\n}\n\n/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = filter;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../../../../../webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9sb2Rhc2gtY3VzdG9tLWJ1aWxkL21vZHVsYXJpemUvbG9kYXNoLmZpbHRlci9pbmRleC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Aa2lzc215YnV0dG9uL21vdG9yY29ydGV4L2xvZGFzaC1jdXN0b20tYnVpbGQvbW9kdWxhcml6ZS9sb2Rhc2guZmlsdGVyL2luZGV4LmpzP2MyNTQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBMb2Rhc2ggKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGluY2x1ZGU9XCJmaWx0ZXIsc29ydEJ5LGZpbmRJbmRleCxmaW5kLGZvckVhY2gsY2xvbmVEZWVwXCIgZXhwb3J0cz1cIm5wbVwiYFxuICogQ29weXJpZ2h0IEpTIEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9qcy5mb3VuZGF0aW9uLz5cbiAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqL1xuXG4vKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbnZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4vKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKiBVc2VkIGFzIHRoZSBtYXhpbXVtIG1lbW9pemUgY2FjaGUgc2l6ZS4gKi9cbnZhciBNQVhfTUVNT0laRV9TSVpFID0gNTAwO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDAsXG4gICAgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGFzeW5jVGFnID0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICBudWxsVGFnID0gJ1tvYmplY3QgTnVsbF0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHByb21pc2VUYWcgPSAnW29iamVjdCBQcm9taXNlXScsXG4gICAgcHJveHlUYWcgPSAnW29iamVjdCBQcm94eV0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nLFxuICAgIHVuZGVmaW5lZFRhZyA9ICdbb2JqZWN0IFVuZGVmaW5lZF0nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKiogVXNlZCB0byBtYXRjaCBwcm9wZXJ0eSBuYW1lcyB3aXRoaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVJc0RlZXBQcm9wID0gL1xcLnxcXFsoPzpbXltcXF1dKnwoW1wiJ10pKD86KD8hXFwxKVteXFxcXF18XFxcXC4pKj9cXDEpXFxdLyxcbiAgICByZUlzUGxhaW5Qcm9wID0gL15cXHcqJC8sXG4gICAgcmVQcm9wTmFtZSA9IC9bXi5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXFxcXXxcXFxcLikqPylcXDIpXFxdfCg/PSg/OlxcLnxcXFtcXF0pKD86XFwufFxcW1xcXXwkKSkvZztcblxuLyoqXG4gKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgXG4gKiBbc3ludGF4IGNoYXJhY3RlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXBhdHRlcm5zKS5cbiAqL1xudmFyIHJlUmVnRXhwQ2hhciA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggYmFja3NsYXNoZXMgaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVFc2NhcGVDaGFyID0gL1xcXFwoXFxcXCk/L2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovXG52YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbnR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xudHlwZWRBcnJheVRhZ3NbYXJnc1RhZ10gPSB0eXBlZEFycmF5VGFnc1thcnJheVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZXJyb3JUYWddID0gdHlwZWRBcnJheVRhZ3NbZnVuY1RhZ10gPVxudHlwZWRBcnJheVRhZ3NbbWFwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW251bWJlclRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPVxudHlwZWRBcnJheVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0cyAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XG5cbi8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xudmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHJldHVybiBmcmVlUHJvY2VzcyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKTtcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzVHlwZWRBcnJheSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzVHlwZWRBcnJheTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZmlsdGVyYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5RmlsdGVyKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tYXBgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlNYXAoYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEFwcGVuZHMgdGhlIGVsZW1lbnRzIG9mIGB2YWx1ZXNgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhcHBlbmQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlQdXNoKGFycmF5LCB2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgb2Zmc2V0ID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbb2Zmc2V0ICsgaW5kZXhdID0gdmFsdWVzW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNvbWVgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBhcnJheVNvbWUoYXJyYXksIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5KGtleSkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gIH07XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udGltZXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kc1xuICogb3IgbWF4IGFycmF5IGxlbmd0aCBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5hcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RvcmluZyBtZXRhZGF0YS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBgY2FjaGVgIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBjYWNoZSBUaGUgY2FjaGUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gY2FjaGVIYXMoY2FjaGUsIGtleSkge1xuICByZXR1cm4gY2FjaGUuaGFzKGtleSk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGBtYXBgIHRvIGl0cyBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXG4gKi9cbmZ1bmN0aW9uIG1hcFRvQXJyYXkobWFwKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobWFwLnNpemUpO1xuXG4gIG1hcC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSBba2V5LCB2YWx1ZV07XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgc2V0YCB0byBhbiBhcnJheSBvZiBpdHMgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBzZXRUb0FycmF5KHNldCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KHNldC5zaXplKTtcblxuICBzZXQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGUsXG4gICAgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xudmFyIGNvcmVKc0RhdGEgPSByb290WydfX2NvcmUtanNfc2hhcmVkX18nXTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cbnZhciBtYXNrU3JjS2V5ID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdWlkID0gL1teLl0rJC8uZXhlYyhjb3JlSnNEYXRhICYmIGNvcmVKc0RhdGEua2V5cyAmJiBjb3JlSnNEYXRhLmtleXMuSUVfUFJPVE8gfHwgJycpO1xuICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XG59KCkpO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbnZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gIGZ1bmNUb1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IHJvb3QuQnVmZmVyIDogdW5kZWZpbmVkLFxuICAgIFN5bWJvbCA9IHJvb3QuU3ltYm9sLFxuICAgIFVpbnQ4QXJyYXkgPSByb290LlVpbnQ4QXJyYXksXG4gICAgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZSxcbiAgICBzcGxpY2UgPSBhcnJheVByb3RvLnNwbGljZSxcbiAgICBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUdldFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLFxuICAgIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyID8gQnVmZmVyLmlzQnVmZmVyIDogdW5kZWZpbmVkLFxuICAgIG5hdGl2ZUtleXMgPSBvdmVyQXJnKE9iamVjdC5rZXlzLCBPYmplY3QpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgRGF0YVZpZXcgPSBnZXROYXRpdmUocm9vdCwgJ0RhdGFWaWV3JyksXG4gICAgTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdNYXAnKSxcbiAgICBQcm9taXNlID0gZ2V0TmF0aXZlKHJvb3QsICdQcm9taXNlJyksXG4gICAgU2V0ID0gZ2V0TmF0aXZlKHJvb3QsICdTZXQnKSxcbiAgICBXZWFrTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdXZWFrTWFwJyksXG4gICAgbmF0aXZlQ3JlYXRlID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2NyZWF0ZScpO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWFwcywgc2V0cywgYW5kIHdlYWttYXBzLiAqL1xudmFyIGRhdGFWaWV3Q3RvclN0cmluZyA9IHRvU291cmNlKERhdGFWaWV3KSxcbiAgICBtYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoTWFwKSxcbiAgICBwcm9taXNlQ3RvclN0cmluZyA9IHRvU291cmNlKFByb21pc2UpLFxuICAgIHNldEN0b3JTdHJpbmcgPSB0b1NvdXJjZShTZXQpLFxuICAgIHdlYWtNYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoV2Vha01hcCk7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xWYWx1ZU9mID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by52YWx1ZU9mIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFRvU3RyaW5nID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by50b1N0cmluZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgaGFzaCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIEhhc2goZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgSGFzaFxuICovXG5mdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtPYmplY3R9IGhhc2ggVGhlIGhhc2ggdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBoYXNoIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGhhc2hHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKG5hdGl2ZUNyZWF0ZSkge1xuICAgIHZhciByZXN1bHQgPSBkYXRhW2tleV07XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gSEFTSF9VTkRFRklORUQgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KSA/IGRhdGFba2V5XSA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBoYXNoIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoSGFzKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHJldHVybiBuYXRpdmVDcmVhdGUgPyAoZGF0YVtrZXldICE9PSB1bmRlZmluZWQpIDogaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIGhhc2ggYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBoYXNoIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBoYXNoU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICB0aGlzLnNpemUgKz0gdGhpcy5oYXMoa2V5KSA/IDAgOiAxO1xuICBkYXRhW2tleV0gPSAobmF0aXZlQ3JlYXRlICYmIHZhbHVlID09PSB1bmRlZmluZWQpID8gSEFTSF9VTkRFRklORUQgOiB2YWx1ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBIYXNoYC5cbkhhc2gucHJvdG90eXBlLmNsZWFyID0gaGFzaENsZWFyO1xuSGFzaC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gaGFzaERlbGV0ZTtcbkhhc2gucHJvdG90eXBlLmdldCA9IGhhc2hHZXQ7XG5IYXNoLnByb3RvdHlwZS5oYXMgPSBoYXNoSGFzO1xuSGFzaC5wcm90b3R5cGUuc2V0ID0gaGFzaFNldDtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGxpc3QgY2FjaGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBMaXN0Q2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUNsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gW107XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBsYXN0SW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7XG4gIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcbiAgICBkYXRhLnBvcCgpO1xuICB9IGVsc2Uge1xuICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4LCAxKTtcbiAgfVxuICAtLXRoaXMuc2l6ZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICByZXR1cm4gaW5kZXggPCAwID8gdW5kZWZpbmVkIDogZGF0YVtpbmRleF1bMV07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBhc3NvY0luZGV4T2YodGhpcy5fX2RhdGFfXywga2V5KSA+IC0xO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIGxpc3QgY2FjaGUgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGxpc3QgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgICsrdGhpcy5zaXplO1xuICAgIGRhdGEucHVzaChba2V5LCB2YWx1ZV0pO1xuICB9IGVsc2Uge1xuICAgIGRhdGFbaW5kZXhdWzFdID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBMaXN0Q2FjaGVgLlxuTGlzdENhY2hlLnByb3RvdHlwZS5jbGVhciA9IGxpc3RDYWNoZUNsZWFyO1xuTGlzdENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBsaXN0Q2FjaGVEZWxldGU7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDtcbkxpc3RDYWNoZS5wcm90b3R5cGUuaGFzID0gbGlzdENhY2hlSGFzO1xuTGlzdENhY2hlLnByb3RvdHlwZS5zZXQgPSBsaXN0Q2FjaGVTZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hcCBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBNYXBDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuc2l6ZSA9IDA7XG4gIHRoaXMuX19kYXRhX18gPSB7XG4gICAgJ2hhc2gnOiBuZXcgSGFzaCxcbiAgICAnbWFwJzogbmV3IChNYXAgfHwgTGlzdENhY2hlKSxcbiAgICAnc3RyaW5nJzogbmV3IEhhc2hcbiAgfTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpWydkZWxldGUnXShrZXkpO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbWFwIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUdldChrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5nZXQoa2V5KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5oYXMoa2V5KTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBtYXAgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbWFwIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLFxuICAgICAgc2l6ZSA9IGRhdGEuc2l6ZTtcblxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplICs9IGRhdGEuc2l6ZSA9PSBzaXplID8gMCA6IDE7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTWFwQ2FjaGVgLlxuTWFwQ2FjaGUucHJvdG90eXBlLmNsZWFyID0gbWFwQ2FjaGVDbGVhcjtcbk1hcENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBtYXBDYWNoZURlbGV0ZTtcbk1hcENhY2hlLnByb3RvdHlwZS5nZXQgPSBtYXBDYWNoZUdldDtcbk1hcENhY2hlLnByb3RvdHlwZS5oYXMgPSBtYXBDYWNoZUhhcztcbk1hcENhY2hlLnByb3RvdHlwZS5zZXQgPSBtYXBDYWNoZVNldDtcblxuLyoqXG4gKlxuICogQ3JlYXRlcyBhbiBhcnJheSBjYWNoZSBvYmplY3QgdG8gc3RvcmUgdW5pcXVlIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTZXRDYWNoZSh2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMgPT0gbnVsbCA/IDAgOiB2YWx1ZXMubGVuZ3RoO1xuXG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGU7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdGhpcy5hZGQodmFsdWVzW2luZGV4XSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBZGRzIGB2YWx1ZWAgdG8gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBhZGRcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQGFsaWFzIHB1c2hcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNhY2hlLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHNldENhY2hlQWRkKHZhbHVlKSB7XG4gIHRoaXMuX19kYXRhX18uc2V0KHZhbHVlLCBIQVNIX1VOREVGSU5FRCk7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGluIHRoZSBhcnJheSBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHNldENhY2hlSGFzKHZhbHVlKSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyh2YWx1ZSk7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTZXRDYWNoZWAuXG5TZXRDYWNoZS5wcm90b3R5cGUuYWRkID0gU2V0Q2FjaGUucHJvdG90eXBlLnB1c2ggPSBzZXRDYWNoZUFkZDtcblNldENhY2hlLnByb3RvdHlwZS5oYXMgPSBzZXRDYWNoZUhhcztcblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RhY2sgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gU3RhY2soZW50cmllcykge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlKGVudHJpZXMpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqL1xuZnVuY3Rpb24gc3RhY2tDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGU7XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICByZXN1bHQgPSBkYXRhWydkZWxldGUnXShrZXkpO1xuXG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBzdGFjayB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tHZXQoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmdldChrZXkpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIHN0YWNrIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tIYXMoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyhrZXkpO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIHN0YWNrIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIHN0YWNrIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzdGFja1NldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBMaXN0Q2FjaGUpIHtcbiAgICB2YXIgcGFpcnMgPSBkYXRhLl9fZGF0YV9fO1xuICAgIGlmICghTWFwIHx8IChwYWlycy5sZW5ndGggPCBMQVJHRV9BUlJBWV9TSVpFIC0gMSkpIHtcbiAgICAgIHBhaXJzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgIHRoaXMuc2l6ZSA9ICsrZGF0YS5zaXplO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlKHBhaXJzKTtcbiAgfVxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFN0YWNrYC5cblN0YWNrLnByb3RvdHlwZS5jbGVhciA9IHN0YWNrQ2xlYXI7XG5TdGFjay5wcm90b3R5cGVbJ2RlbGV0ZSddID0gc3RhY2tEZWxldGU7XG5TdGFjay5wcm90b3R5cGUuZ2V0ID0gc3RhY2tHZXQ7XG5TdGFjay5wcm90b3R5cGUuaGFzID0gc3RhY2tIYXM7XG5TdGFjay5wcm90b3R5cGUuc2V0ID0gc3RhY2tTZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiB0aGUgYXJyYXktbGlrZSBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5oZXJpdGVkIFNwZWNpZnkgcmV0dXJuaW5nIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lcy5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TGlrZUtleXModmFsdWUsIGluaGVyaXRlZCkge1xuICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKSxcbiAgICAgIGlzQXJnID0gIWlzQXJyICYmIGlzQXJndW1lbnRzKHZhbHVlKSxcbiAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiAhaXNBcmcgJiYgaXNCdWZmZXIodmFsdWUpLFxuICAgICAgaXNUeXBlID0gIWlzQXJyICYmICFpc0FyZyAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheSh2YWx1ZSksXG4gICAgICBza2lwSW5kZXhlcyA9IGlzQXJyIHx8IGlzQXJnIHx8IGlzQnVmZiB8fCBpc1R5cGUsXG4gICAgICByZXN1bHQgPSBza2lwSW5kZXhlcyA/IGJhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZykgOiBbXSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKChpbmhlcml0ZWQgfHwgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkgJiZcbiAgICAgICAgIShza2lwSW5kZXhlcyAmJiAoXG4gICAgICAgICAgIC8vIFNhZmFyaSA5IGhhcyBlbnVtZXJhYmxlIGBhcmd1bWVudHMubGVuZ3RoYCBpbiBzdHJpY3QgbW9kZS5cbiAgICAgICAgICAga2V5ID09ICdsZW5ndGgnIHx8XG4gICAgICAgICAgIC8vIE5vZGUuanMgMC4xMCBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiBidWZmZXJzLlxuICAgICAgICAgICAoaXNCdWZmICYmIChrZXkgPT0gJ29mZnNldCcgfHwga2V5ID09ICdwYXJlbnQnKSkgfHxcbiAgICAgICAgICAgLy8gUGhhbnRvbUpTIDIgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gdHlwZWQgYXJyYXlzLlxuICAgICAgICAgICAoaXNUeXBlICYmIChrZXkgPT0gJ2J1ZmZlcicgfHwga2V5ID09ICdieXRlTGVuZ3RoJyB8fCBrZXkgPT0gJ2J5dGVPZmZzZXQnKSkgfHxcbiAgICAgICAgICAgLy8gU2tpcCBpbmRleCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICBpc0luZGV4KGtleSwgbGVuZ3RoKVxuICAgICAgICApKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYXNzb2NJbmRleE9mKGFycmF5LCBrZXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgaWYgKGVxKGFycmF5W2xlbmd0aF1bMF0sIGtleSkpIHtcbiAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JFYWNoYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAqL1xudmFyIGJhc2VFYWNoID0gY3JlYXRlQmFzZUVhY2goYmFzZUZvck93bik7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmlsdGVyYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGaWx0ZXIoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pKSB7XG4gICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYmFzZUZvck93bmAgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgb2JqZWN0YFxuICogcHJvcGVydGllcyByZXR1cm5lZCBieSBga2V5c0Z1bmNgIGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggcHJvcGVydHkuXG4gKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbnZhciBiYXNlRm9yID0gY3JlYXRlQmFzZUZvcigpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvck93bmAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGb3JPd24ob2JqZWN0LCBpdGVyYXRlZSkge1xuICByZXR1cm4gb2JqZWN0ICYmIGJhc2VGb3Iob2JqZWN0LCBpdGVyYXRlZSwga2V5cyk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZ2V0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZmF1bHQgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0KG9iamVjdCwgcGF0aCkge1xuICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICB2YXIgaW5kZXggPSAwLFxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG5cbiAgd2hpbGUgKG9iamVjdCAhPSBudWxsICYmIGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgb2JqZWN0ID0gb2JqZWN0W3RvS2V5KHBhdGhbaW5kZXgrK10pXTtcbiAgfVxuICByZXR1cm4gKGluZGV4ICYmIGluZGV4ID09IGxlbmd0aCkgPyBvYmplY3QgOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldEFsbEtleXNgIGFuZCBgZ2V0QWxsS2V5c0luYCB3aGljaCB1c2VzXG4gKiBga2V5c0Z1bmNgIGFuZCBgc3ltYm9sc0Z1bmNgIHRvIGdldCB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzeW1ib2xzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzRnVuYywgc3ltYm9sc0Z1bmMpIHtcbiAgdmFyIHJlc3VsdCA9IGtleXNGdW5jKG9iamVjdCk7XG4gIHJldHVybiBpc0FycmF5KG9iamVjdCkgPyByZXN1bHQgOiBhcnJheVB1c2gocmVzdWx0LCBzeW1ib2xzRnVuYyhvYmplY3QpKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYCB3aXRob3V0IGZhbGxiYWNrcyBmb3IgYnVnZ3kgZW52aXJvbm1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZFRhZyA6IG51bGxUYWc7XG4gIH1cbiAgcmV0dXJuIChzeW1Ub1N0cmluZ1RhZyAmJiBzeW1Ub1N0cmluZ1RhZyBpbiBPYmplY3QodmFsdWUpKVxuICAgID8gZ2V0UmF3VGFnKHZhbHVlKVxuICAgIDogb2JqZWN0VG9TdHJpbmcodmFsdWUpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmhhc0luYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IGtleSBUaGUga2V5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSGFzSW4ob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGtleSBpbiBPYmplY3Qob2JqZWN0KTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0FyZ3VtZW50c2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICovXG5mdW5jdGlvbiBiYXNlSXNBcmd1bWVudHModmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYXJnc1RhZztcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0VxdWFsYCB3aGljaCBzdXBwb3J0cyBwYXJ0aWFsIGNvbXBhcmlzb25zXG4gKiBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAqICAxIC0gVW5vcmRlcmVkIGNvbXBhcmlzb25cbiAqICAyIC0gUGFydGlhbCBjb21wYXJpc29uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYHZhbHVlYCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykge1xuICBpZiAodmFsdWUgPT09IG90aGVyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwgfHwgb3RoZXIgPT0gbnVsbCB8fCAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgIWlzT2JqZWN0TGlrZShvdGhlcikpKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXI7XG4gIH1cbiAgcmV0dXJuIGJhc2VJc0VxdWFsRGVlcCh2YWx1ZSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGJhc2VJc0VxdWFsLCBzdGFjayk7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbGAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xuICogZGVlcCBjb21wYXJpc29ucyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxuICogcmVmZXJlbmNlcyB0byBiZSBjb21wYXJlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzRXF1YWxEZWVwKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgdmFyIG9iaklzQXJyID0gaXNBcnJheShvYmplY3QpLFxuICAgICAgb3RoSXNBcnIgPSBpc0FycmF5KG90aGVyKSxcbiAgICAgIG9ialRhZyA9IG9iaklzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob2JqZWN0KSxcbiAgICAgIG90aFRhZyA9IG90aElzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob3RoZXIpO1xuXG4gIG9ialRhZyA9IG9ialRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb2JqVGFnO1xuICBvdGhUYWcgPSBvdGhUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG90aFRhZztcblxuICB2YXIgb2JqSXNPYmogPSBvYmpUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgb3RoSXNPYmogPSBvdGhUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgaXNTYW1lVGFnID0gb2JqVGFnID09IG90aFRhZztcblxuICBpZiAoaXNTYW1lVGFnICYmIGlzQnVmZmVyKG9iamVjdCkpIHtcbiAgICBpZiAoIWlzQnVmZmVyKG90aGVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBvYmpJc0FyciA9IHRydWU7XG4gICAgb2JqSXNPYmogPSBmYWxzZTtcbiAgfVxuICBpZiAoaXNTYW1lVGFnICYmICFvYmpJc09iaikge1xuICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgcmV0dXJuIChvYmpJc0FyciB8fCBpc1R5cGVkQXJyYXkob2JqZWN0KSlcbiAgICAgID8gZXF1YWxBcnJheXMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaylcbiAgICAgIDogZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCBvYmpUYWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICB9XG4gIGlmICghKGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRykpIHtcbiAgICB2YXIgb2JqSXNXcmFwcGVkID0gb2JqSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsICdfX3dyYXBwZWRfXycpLFxuICAgICAgICBvdGhJc1dyYXBwZWQgPSBvdGhJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCAnX193cmFwcGVkX18nKTtcblxuICAgIGlmIChvYmpJc1dyYXBwZWQgfHwgb3RoSXNXcmFwcGVkKSB7XG4gICAgICB2YXIgb2JqVW53cmFwcGVkID0gb2JqSXNXcmFwcGVkID8gb2JqZWN0LnZhbHVlKCkgOiBvYmplY3QsXG4gICAgICAgICAgb3RoVW53cmFwcGVkID0gb3RoSXNXcmFwcGVkID8gb3RoZXIudmFsdWUoKSA6IG90aGVyO1xuXG4gICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgICAgcmV0dXJuIGVxdWFsRnVuYyhvYmpVbndyYXBwZWQsIG90aFVud3JhcHBlZCwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spO1xuICAgIH1cbiAgfVxuICBpZiAoIWlzU2FtZVRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICByZXR1cm4gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTWF0Y2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICogQHBhcmFtIHtBcnJheX0gbWF0Y2hEYXRhIFRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyB0byBtYXRjaC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGlzIGEgbWF0Y2gsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSwgY3VzdG9taXplcikge1xuICB2YXIgaW5kZXggPSBtYXRjaERhdGEubGVuZ3RoLFxuICAgICAgbGVuZ3RoID0gaW5kZXgsXG4gICAgICBub0N1c3RvbWl6ZXIgPSAhY3VzdG9taXplcjtcblxuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gIWxlbmd0aDtcbiAgfVxuICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICB2YXIgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgaWYgKChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSlcbiAgICAgICAgICA/IGRhdGFbMV0gIT09IG9iamVjdFtkYXRhWzBdXVxuICAgICAgICAgIDogIShkYXRhWzBdIGluIG9iamVjdClcbiAgICAgICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgdmFyIGtleSA9IGRhdGFbMF0sXG4gICAgICAgIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgIHNyY1ZhbHVlID0gZGF0YVsxXTtcblxuICAgIGlmIChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSkge1xuICAgICAgaWYgKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzdGFjayA9IG5ldyBTdGFjaztcbiAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSwgc3RhY2spO1xuICAgICAgfVxuICAgICAgaWYgKCEocmVzdWx0ID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBDT01QQVJFX1BBUlRJQUxfRkxBRyB8IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcsIGN1c3RvbWl6ZXIsIHN0YWNrKVxuICAgICAgICAgICAgOiByZXN1bHRcbiAgICAgICAgICApKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYXRpdmVgIHdpdGhvdXQgYmFkIHNoaW0gY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTmF0aXZlKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpIHx8IGlzTWFza2VkKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcGF0dGVybiA9IGlzRnVuY3Rpb24odmFsdWUpID8gcmVJc05hdGl2ZSA6IHJlSXNIb3N0Q3RvcjtcbiAgcmV0dXJuIHBhdHRlcm4udGVzdCh0b1NvdXJjZSh2YWx1ZSkpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzVHlwZWRBcnJheWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmXG4gICAgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhIXR5cGVkQXJyYXlUYWdzW2Jhc2VHZXRUYWcodmFsdWUpXTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pdGVyYXRlZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gW3ZhbHVlPV8uaWRlbnRpdHldIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGFuIGl0ZXJhdGVlLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBpdGVyYXRlZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUl0ZXJhdGVlKHZhbHVlKSB7XG4gIC8vIERvbid0IHN0b3JlIHRoZSBgdHlwZW9mYCByZXN1bHQgaW4gYSB2YXJpYWJsZSB0byBhdm9pZCBhIEpJVCBidWcgaW4gU2FmYXJpIDkuXG4gIC8vIFNlZSBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTU2MDM0IGZvciBtb3JlIGRldGFpbHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiBpZGVudGl0eTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpXG4gICAgICA/IGJhc2VNYXRjaGVzUHJvcGVydHkodmFsdWVbMF0sIHZhbHVlWzFdKVxuICAgICAgOiBiYXNlTWF0Y2hlcyh2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHByb3BlcnR5KHZhbHVlKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzKG9iamVjdCkge1xuICBpZiAoIWlzUHJvdG90eXBlKG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5cyhvYmplY3QpO1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSAnY29uc3RydWN0b3InKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hdGNoZXNgIHdoaWNoIGRvZXNuJ3QgY2xvbmUgYHNvdXJjZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlTWF0Y2hlcyhzb3VyY2UpIHtcbiAgdmFyIG1hdGNoRGF0YSA9IGdldE1hdGNoRGF0YShzb3VyY2UpO1xuICBpZiAobWF0Y2hEYXRhLmxlbmd0aCA9PSAxICYmIG1hdGNoRGF0YVswXVsyXSkge1xuICAgIHJldHVybiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZShtYXRjaERhdGFbMF1bMF0sIG1hdGNoRGF0YVswXVsxXSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgPT09IHNvdXJjZSB8fCBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgbWF0Y2hEYXRhKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzUHJvcGVydHlgIHdoaWNoIGRvZXNuJ3QgY2xvbmUgYHNyY1ZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hdGNoZXNQcm9wZXJ0eShwYXRoLCBzcmNWYWx1ZSkge1xuICBpZiAoaXNLZXkocGF0aCkgJiYgaXNTdHJpY3RDb21wYXJhYmxlKHNyY1ZhbHVlKSkge1xuICAgIHJldHVybiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSh0b0tleShwYXRoKSwgc3JjVmFsdWUpO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIgb2JqVmFsdWUgPSBnZXQob2JqZWN0LCBwYXRoKTtcbiAgICByZXR1cm4gKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgb2JqVmFsdWUgPT09IHNyY1ZhbHVlKVxuICAgICAgPyBoYXNJbihvYmplY3QsIHBhdGgpXG4gICAgICA6IGJhc2VJc0VxdWFsKHNyY1ZhbHVlLCBvYmpWYWx1ZSwgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgfCBDT01QQVJFX1VOT1JERVJFRF9GTEFHKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VQcm9wZXJ0eWAgd2hpY2ggc3VwcG9ydHMgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gIH07XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udG9TdHJpbmdgIHdoaWNoIGRvZXNuJ3QgY29udmVydCBudWxsaXNoXG4gKiB2YWx1ZXMgdG8gZW1wdHkgc3RyaW5ncy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRvU3RyaW5nKHZhbHVlKSB7XG4gIC8vIEV4aXQgZWFybHkgZm9yIHN0cmluZ3MgdG8gYXZvaWQgYSBwZXJmb3JtYW5jZSBoaXQgaW4gc29tZSBlbnZpcm9ubWVudHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgLy8gUmVjdXJzaXZlbHkgY29udmVydCB2YWx1ZXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICByZXR1cm4gYXJyYXlNYXAodmFsdWUsIGJhc2VUb1N0cmluZykgKyAnJztcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN5bWJvbFRvU3RyaW5nID8gc3ltYm9sVG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcbiAgfVxuICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ2FzdHMgYHZhbHVlYCB0byBhIHBhdGggYXJyYXkgaWYgaXQncyBub3Qgb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY2FzdCBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG5mdW5jdGlvbiBjYXN0UGF0aCh2YWx1ZSwgb2JqZWN0KSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gaXNLZXkodmFsdWUsIG9iamVjdCkgPyBbdmFsdWVdIDogc3RyaW5nVG9QYXRoKHRvU3RyaW5nKHZhbHVlKSk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGBiYXNlRWFjaGAgb3IgYGJhc2VFYWNoUmlnaHRgIGZ1bmN0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGEgY29sbGVjdGlvbi5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmFzZUVhY2goZWFjaEZ1bmMsIGZyb21SaWdodCkge1xuICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICB9XG4gICAgaWYgKCFpc0FycmF5TGlrZShjb2xsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKTtcbiAgICB9XG4gICAgdmFyIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoLFxuICAgICAgICBpbmRleCA9IGZyb21SaWdodCA/IGxlbmd0aCA6IC0xLFxuICAgICAgICBpdGVyYWJsZSA9IE9iamVjdChjb2xsZWN0aW9uKTtcblxuICAgIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVbaW5kZXhdLCBpbmRleCwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gIH07XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGJhc2UgZnVuY3Rpb24gZm9yIG1ldGhvZHMgbGlrZSBgXy5mb3JJbmAgYW5kIGBfLmZvck93bmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmFzZUZvcihmcm9tUmlnaHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCwgaXRlcmF0ZWUsIGtleXNGdW5jKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGl0ZXJhYmxlID0gT2JqZWN0KG9iamVjdCksXG4gICAgICAgIHByb3BzID0ga2V5c0Z1bmMob2JqZWN0KSxcbiAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICB2YXIga2V5ID0gcHJvcHNbZnJvbVJpZ2h0ID8gbGVuZ3RoIDogKytpbmRleF07XG4gICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVba2V5XSwga2V5LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9O1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgYXJyYXlzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0FycmF5fSBvdGhlciBUaGUgb3RoZXIgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYGFycmF5YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcnJheXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxBcnJheXMoYXJyYXksIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICBhcnJMZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBvdGhMZW5ndGggPSBvdGhlci5sZW5ndGg7XG5cbiAgaWYgKGFyckxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIShpc1BhcnRpYWwgJiYgb3RoTGVuZ3RoID4gYXJyTGVuZ3RoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KGFycmF5KTtcbiAgaWYgKHN0YWNrZWQgJiYgc3RhY2suZ2V0KG90aGVyKSkge1xuICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICB9XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gdHJ1ZSxcbiAgICAgIHNlZW4gPSAoYml0bWFzayAmIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcpID8gbmV3IFNldENhY2hlIDogdW5kZWZpbmVkO1xuXG4gIHN0YWNrLnNldChhcnJheSwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIGFycmF5KTtcblxuICAvLyBJZ25vcmUgbm9uLWluZGV4IHByb3BlcnRpZXMuXG4gIHdoaWxlICgrK2luZGV4IDwgYXJyTGVuZ3RoKSB7XG4gICAgdmFyIGFyclZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2luZGV4XTtcblxuICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBhcnJWYWx1ZSwgaW5kZXgsIG90aGVyLCBhcnJheSwgc3RhY2spXG4gICAgICAgIDogY3VzdG9taXplcihhcnJWYWx1ZSwgb3RoVmFsdWUsIGluZGV4LCBhcnJheSwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgaWYgKGNvbXBhcmVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChjb21wYXJlZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKHNlZW4pIHtcbiAgICAgIGlmICghYXJyYXlTb21lKG90aGVyLCBmdW5jdGlvbihvdGhWYWx1ZSwgb3RoSW5kZXgpIHtcbiAgICAgICAgICAgIGlmICghY2FjaGVIYXMoc2Vlbiwgb3RoSW5kZXgpICYmXG4gICAgICAgICAgICAgICAgKGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzZWVuLnB1c2gob3RoSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKSB7XG4gICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEoXG4gICAgICAgICAgYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8XG4gICAgICAgICAgICBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaylcbiAgICAgICAgKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgc3RhY2tbJ2RlbGV0ZSddKGFycmF5KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGNvbXBhcmluZyBvYmplY3RzIG9mXG4gKiB0aGUgc2FtZSBgdG9TdHJpbmdUYWdgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY29tcGFyaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIG9yIGBTdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3RzIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCB0YWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlIGRhdGFWaWV3VGFnOlxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgIChvYmplY3QuYnl0ZU9mZnNldCAhPSBvdGhlci5ieXRlT2Zmc2V0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBvYmplY3QgPSBvYmplY3QuYnVmZmVyO1xuICAgICAgb3RoZXIgPSBvdGhlci5idWZmZXI7XG5cbiAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgICFlcXVhbEZ1bmMobmV3IFVpbnQ4QXJyYXkob2JqZWN0KSwgbmV3IFVpbnQ4QXJyYXkob3RoZXIpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGNhc2UgYm9vbFRhZzpcbiAgICBjYXNlIGRhdGVUYWc6XG4gICAgY2FzZSBudW1iZXJUYWc6XG4gICAgICAvLyBDb2VyY2UgYm9vbGVhbnMgdG8gYDFgIG9yIGAwYCBhbmQgZGF0ZXMgdG8gbWlsbGlzZWNvbmRzLlxuICAgICAgLy8gSW52YWxpZCBkYXRlcyBhcmUgY29lcmNlZCB0byBgTmFOYC5cbiAgICAgIHJldHVybiBlcSgrb2JqZWN0LCArb3RoZXIpO1xuXG4gICAgY2FzZSBlcnJvclRhZzpcbiAgICAgIHJldHVybiBvYmplY3QubmFtZSA9PSBvdGhlci5uYW1lICYmIG9iamVjdC5tZXNzYWdlID09IG90aGVyLm1lc3NhZ2U7XG5cbiAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgIC8vIENvZXJjZSByZWdleGVzIHRvIHN0cmluZ3MgYW5kIHRyZWF0IHN0cmluZ3MsIHByaW1pdGl2ZXMgYW5kIG9iamVjdHMsXG4gICAgICAvLyBhcyBlcXVhbC4gU2VlIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1yZWdleHAucHJvdG90eXBlLnRvc3RyaW5nXG4gICAgICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgcmV0dXJuIG9iamVjdCA9PSAob3RoZXIgKyAnJyk7XG5cbiAgICBjYXNlIG1hcFRhZzpcbiAgICAgIHZhciBjb252ZXJ0ID0gbWFwVG9BcnJheTtcblxuICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRztcbiAgICAgIGNvbnZlcnQgfHwgKGNvbnZlcnQgPSBzZXRUb0FycmF5KTtcblxuICAgICAgaWYgKG9iamVjdC5zaXplICE9IG90aGVyLnNpemUgJiYgIWlzUGFydGlhbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICAgICAgaWYgKHN0YWNrZWQpIHtcbiAgICAgICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gICAgICB9XG4gICAgICBiaXRtYXNrIHw9IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUc7XG5cbiAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICAgICAgdmFyIHJlc3VsdCA9IGVxdWFsQXJyYXlzKGNvbnZlcnQob2JqZWN0KSwgY29udmVydChvdGhlciksIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICAgICAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICBpZiAoc3ltYm9sVmFsdWVPZikge1xuICAgICAgICByZXR1cm4gc3ltYm9sVmFsdWVPZi5jYWxsKG9iamVjdCkgPT0gc3ltYm9sVmFsdWVPZi5jYWxsKG90aGVyKTtcbiAgICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBvYmplY3RzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICBvYmpQcm9wcyA9IGdldEFsbEtleXMob2JqZWN0KSxcbiAgICAgIG9iakxlbmd0aCA9IG9ialByb3BzLmxlbmd0aCxcbiAgICAgIG90aFByb3BzID0gZ2V0QWxsS2V5cyhvdGhlciksXG4gICAgICBvdGhMZW5ndGggPSBvdGhQcm9wcy5sZW5ndGg7XG5cbiAgaWYgKG9iakxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIWlzUGFydGlhbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgaW5kZXggPSBvYmpMZW5ndGg7XG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgdmFyIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICBpZiAoIShpc1BhcnRpYWwgPyBrZXkgaW4gb3RoZXIgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCBrZXkpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gIGlmIChzdGFja2VkICYmIHN0YWNrLmdldChvdGhlcikpIHtcbiAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgfVxuICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIG9iamVjdCk7XG5cbiAgdmFyIHNraXBDdG9yID0gaXNQYXJ0aWFsO1xuICB3aGlsZSAoKytpbmRleCA8IG9iakxlbmd0aCkge1xuICAgIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltrZXldO1xuXG4gICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIG9ialZhbHVlLCBrZXksIG90aGVyLCBvYmplY3QsIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIob2JqVmFsdWUsIG90aFZhbHVlLCBrZXksIG9iamVjdCwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKCEoY29tcGFyZWQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gKG9ialZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMob2JqVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpXG4gICAgICAgICAgOiBjb21wYXJlZFxuICAgICAgICApKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBza2lwQ3RvciB8fCAoc2tpcEN0b3IgPSBrZXkgPT0gJ2NvbnN0cnVjdG9yJyk7XG4gIH1cbiAgaWYgKHJlc3VsdCAmJiAhc2tpcEN0b3IpIHtcbiAgICB2YXIgb2JqQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcixcbiAgICAgICAgb3RoQ3RvciA9IG90aGVyLmNvbnN0cnVjdG9yO1xuXG4gICAgLy8gTm9uIGBPYmplY3RgIG9iamVjdCBpbnN0YW5jZXMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1YWwuXG4gICAgaWYgKG9iakN0b3IgIT0gb3RoQ3RvciAmJlxuICAgICAgICAoJ2NvbnN0cnVjdG9yJyBpbiBvYmplY3QgJiYgJ2NvbnN0cnVjdG9yJyBpbiBvdGhlcikgJiZcbiAgICAgICAgISh0eXBlb2Ygb2JqQ3RvciA9PSAnZnVuY3Rpb24nICYmIG9iakN0b3IgaW5zdGFuY2VvZiBvYmpDdG9yICYmXG4gICAgICAgICAgdHlwZW9mIG90aEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvdGhDdG9yIGluc3RhbmNlb2Ygb3RoQ3RvcikpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBnZXRBbGxLZXlzKG9iamVjdCkge1xuICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzLCBnZXRTeW1ib2xzKTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBkYXRhIGZvciBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcmVmZXJlbmNlIGtleS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cbiAqL1xuZnVuY3Rpb24gZ2V0TWFwRGF0YShtYXAsIGtleSkge1xuICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcbiAgcmV0dXJuIGlzS2V5YWJsZShrZXkpXG4gICAgPyBkYXRhW3R5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyAnc3RyaW5nJyA6ICdoYXNoJ11cbiAgICA6IGRhdGEubWFwO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIHByb3BlcnR5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG1hdGNoIGRhdGEgb2YgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGdldE1hdGNoRGF0YShvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IGtleXMob2JqZWN0KSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgdmFyIGtleSA9IHJlc3VsdFtsZW5ndGhdLFxuICAgICAgICB2YWx1ZSA9IG9iamVjdFtrZXldO1xuXG4gICAgcmVzdWx0W2xlbmd0aF0gPSBba2V5LCB2YWx1ZSwgaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKV07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gIHZhciB2YWx1ZSA9IGdldFZhbHVlKG9iamVjdCwga2V5KTtcbiAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gIHRyeSB7XG4gICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBpZiAodW5tYXNrZWQpIHtcbiAgICBpZiAoaXNPd24pIHtcbiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gKi9cbnZhciBnZXRTeW1ib2xzID0gIW5hdGl2ZUdldFN5bWJvbHMgPyBzdHViQXJyYXkgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICByZXR1cm4gYXJyYXlGaWx0ZXIobmF0aXZlR2V0U3ltYm9scyhvYmplY3QpLCBmdW5jdGlvbihzeW1ib2wpIHtcbiAgICByZXR1cm4gcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmplY3QsIHN5bWJvbCk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBgdG9TdHJpbmdUYWdgIG9mIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xudmFyIGdldFRhZyA9IGJhc2VHZXRUYWc7XG5cbi8vIEZhbGxiYWNrIGZvciBkYXRhIHZpZXdzLCBtYXBzLCBzZXRzLCBhbmQgd2VhayBtYXBzIGluIElFIDExIGFuZCBwcm9taXNlcyBpbiBOb2RlLmpzIDwgNi5cbmlmICgoRGF0YVZpZXcgJiYgZ2V0VGFnKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSkpKSAhPSBkYXRhVmlld1RhZykgfHxcbiAgICAoTWFwICYmIGdldFRhZyhuZXcgTWFwKSAhPSBtYXBUYWcpIHx8XG4gICAgKFByb21pc2UgJiYgZ2V0VGFnKFByb21pc2UucmVzb2x2ZSgpKSAhPSBwcm9taXNlVGFnKSB8fFxuICAgIChTZXQgJiYgZ2V0VGFnKG5ldyBTZXQpICE9IHNldFRhZykgfHxcbiAgICAoV2Vha01hcCAmJiBnZXRUYWcobmV3IFdlYWtNYXApICE9IHdlYWtNYXBUYWcpKSB7XG4gIGdldFRhZyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGJhc2VHZXRUYWcodmFsdWUpLFxuICAgICAgICBDdG9yID0gcmVzdWx0ID09IG9iamVjdFRhZyA/IHZhbHVlLmNvbnN0cnVjdG9yIDogdW5kZWZpbmVkLFxuICAgICAgICBjdG9yU3RyaW5nID0gQ3RvciA/IHRvU291cmNlKEN0b3IpIDogJyc7XG5cbiAgICBpZiAoY3RvclN0cmluZykge1xuICAgICAgc3dpdGNoIChjdG9yU3RyaW5nKSB7XG4gICAgICAgIGNhc2UgZGF0YVZpZXdDdG9yU3RyaW5nOiByZXR1cm4gZGF0YVZpZXdUYWc7XG4gICAgICAgIGNhc2UgbWFwQ3RvclN0cmluZzogcmV0dXJuIG1hcFRhZztcbiAgICAgICAgY2FzZSBwcm9taXNlQ3RvclN0cmluZzogcmV0dXJuIHByb21pc2VUYWc7XG4gICAgICAgIGNhc2Ugc2V0Q3RvclN0cmluZzogcmV0dXJuIHNldFRhZztcbiAgICAgICAgY2FzZSB3ZWFrTWFwQ3RvclN0cmluZzogcmV0dXJuIHdlYWtNYXBUYWc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwYXRoYCBleGlzdHMgb24gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFzRnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2sgcHJvcGVydGllcy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBoYXNGdW5jKSB7XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBmYWxzZTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSk7XG4gICAgaWYgKCEocmVzdWx0ID0gb2JqZWN0ICE9IG51bGwgJiYgaGFzRnVuYyhvYmplY3QsIGtleSkpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgb2JqZWN0ID0gb2JqZWN0W2tleV07XG4gIH1cbiAgaWYgKHJlc3VsdCB8fCArK2luZGV4ICE9IGxlbmd0aCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgbGVuZ3RoID0gb2JqZWN0ID09IG51bGwgPyAwIDogb2JqZWN0Lmxlbmd0aDtcbiAgcmV0dXJuICEhbGVuZ3RoICYmIGlzTGVuZ3RoKGxlbmd0aCkgJiYgaXNJbmRleChrZXksIGxlbmd0aCkgJiZcbiAgICAoaXNBcnJheShvYmplY3QpIHx8IGlzQXJndW1lbnRzKG9iamVjdCkpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuXG4gIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICh0eXBlID09ICdudW1iZXInIHx8XG4gICAgICAodHlwZSAhPSAnc3ltYm9sJyAmJiByZUlzVWludC50ZXN0KHZhbHVlKSkpICYmXG4gICAgICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUgYW5kIG5vdCBhIHByb3BlcnR5IHBhdGguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleSh2YWx1ZSwgb2JqZWN0KSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgaWYgKHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJyB8fFxuICAgICAgdmFsdWUgPT0gbnVsbCB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gcmVJc1BsYWluUHJvcC50ZXN0KHZhbHVlKSB8fCAhcmVJc0RlZXBQcm9wLnRlc3QodmFsdWUpIHx8XG4gICAgKG9iamVjdCAhPSBudWxsICYmIHZhbHVlIGluIE9iamVjdChvYmplY3QpKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3IgdXNlIGFzIHVuaXF1ZSBvYmplY3Qga2V5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5YWJsZSh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICh0eXBlID09ICdzdHJpbmcnIHx8IHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJylcbiAgICA/ICh2YWx1ZSAhPT0gJ19fcHJvdG9fXycpXG4gICAgOiAodmFsdWUgPT09IG51bGwpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGl0cyBzb3VyY2UgbWFza2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2VkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzTWFza2VkKGZ1bmMpIHtcbiAgcmV0dXJuICEhbWFza1NyY0tleSAmJiAobWFza1NyY0tleSBpbiBmdW5jKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaWYgc3VpdGFibGUgZm9yIHN0cmljdFxuICogIGVxdWFsaXR5IGNvbXBhcmlzb25zLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IHZhbHVlICYmICFpc09iamVjdCh2YWx1ZSk7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBtYXRjaGVzUHJvcGVydHlgIGZvciBzb3VyY2UgdmFsdWVzIHN1aXRhYmxlXG4gKiBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUoa2V5LCBzcmNWYWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Rba2V5XSA9PT0gc3JjVmFsdWUgJiZcbiAgICAgIChzcmNWYWx1ZSAhPT0gdW5kZWZpbmVkIHx8IChrZXkgaW4gT2JqZWN0KG9iamVjdCkpKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWVtb2l6ZWAgd2hpY2ggY2xlYXJzIHRoZSBtZW1vaXplZCBmdW5jdGlvbidzXG4gKiBjYWNoZSB3aGVuIGl0IGV4Y2VlZHMgYE1BWF9NRU1PSVpFX1NJWkVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZUNhcHBlZChmdW5jKSB7XG4gIHZhciByZXN1bHQgPSBtZW1vaXplKGZ1bmMsIGZ1bmN0aW9uKGtleSkge1xuICAgIGlmIChjYWNoZS5zaXplID09PSBNQVhfTUVNT0laRV9TSVpFKSB7XG4gICAgICBjYWNoZS5jbGVhcigpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5O1xuICB9KTtcblxuICB2YXIgY2FjaGUgPSByZXN1bHQuY2FjaGU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYHN0cmluZ2AgdG8gYSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqL1xudmFyIHN0cmluZ1RvUGF0aCA9IG1lbW9pemVDYXBwZWQoZnVuY3Rpb24oc3RyaW5nKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKHN0cmluZy5jaGFyQ29kZUF0KDApID09PSA0NiAvKiAuICovKSB7XG4gICAgcmVzdWx0LnB1c2goJycpO1xuICB9XG4gIHN0cmluZy5yZXBsYWNlKHJlUHJvcE5hbWUsIGZ1bmN0aW9uKG1hdGNoLCBudW1iZXIsIHF1b3RlLCBzdWJTdHJpbmcpIHtcbiAgICByZXN1bHQucHVzaChxdW90ZSA/IHN1YlN0cmluZy5yZXBsYWNlKHJlRXNjYXBlQ2hhciwgJyQxJykgOiAobnVtYmVyIHx8IG1hdGNoKSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufSk7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyBrZXkgaWYgaXQncyBub3QgYSBzdHJpbmcgb3Igc3ltYm9sLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHJldHVybnMge3N0cmluZ3xzeW1ib2x9IFJldHVybnMgdGhlIGtleS5cbiAqL1xuZnVuY3Rpb24gdG9LZXkodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGBmdW5jYCB0byBpdHMgc291cmNlIGNvZGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzb3VyY2UgY29kZS5cbiAqL1xuZnVuY3Rpb24gdG9Tb3VyY2UoZnVuYykge1xuICBpZiAoZnVuYyAhPSBudWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmdW5jVG9TdHJpbmcuY2FsbChmdW5jKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gKGZ1bmMgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAsIHJldHVybmluZyBhbiBhcnJheSBvZiBhbGwgZWxlbWVudHNcbiAqIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvci4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGggdGhyZWVcbiAqIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICpcbiAqICoqTm90ZToqKiBVbmxpa2UgYF8ucmVtb3ZlYCwgdGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gKiBAc2VlIF8ucmVqZWN0XG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciB1c2VycyA9IFtcbiAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0sXG4gKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfVxuICogXTtcbiAqXG4gKiBfLmZpbHRlcih1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gIW8uYWN0aXZlOyB9KTtcbiAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCddXG4gKlxuICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmlsdGVyKHVzZXJzLCB7ICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXG4gKlxuICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maWx0ZXIodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCddXG4gKlxuICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbHRlcih1c2VycywgJ2FjdGl2ZScpO1xuICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICovXG5mdW5jdGlvbiBmaWx0ZXIoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RmlsdGVyIDogYmFzZUZpbHRlcjtcbiAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgYmFzZUl0ZXJhdGVlKHByZWRpY2F0ZSwgMykpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG1lbW9pemVzIHRoZSByZXN1bHQgb2YgYGZ1bmNgLiBJZiBgcmVzb2x2ZXJgIGlzXG4gKiBwcm92aWRlZCwgaXQgZGV0ZXJtaW5lcyB0aGUgY2FjaGUga2V5IGZvciBzdG9yaW5nIHRoZSByZXN1bHQgYmFzZWQgb24gdGhlXG4gKiBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uLiBCeSBkZWZhdWx0LCB0aGUgZmlyc3QgYXJndW1lbnRcbiAqIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbiBpcyB1c2VkIGFzIHRoZSBtYXAgY2FjaGUga2V5LiBUaGUgYGZ1bmNgXG4gKiBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBtZW1vaXplZCBmdW5jdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogVGhlIGNhY2hlIGlzIGV4cG9zZWQgYXMgdGhlIGBjYWNoZWAgcHJvcGVydHkgb24gdGhlIG1lbW9pemVkXG4gKiBmdW5jdGlvbi4gSXRzIGNyZWF0aW9uIG1heSBiZSBjdXN0b21pemVkIGJ5IHJlcGxhY2luZyB0aGUgYF8ubWVtb2l6ZS5DYWNoZWBcbiAqIGNvbnN0cnVjdG9yIHdpdGggb25lIHdob3NlIGluc3RhbmNlcyBpbXBsZW1lbnQgdGhlXG4gKiBbYE1hcGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXByb3BlcnRpZXMtb2YtdGhlLW1hcC1wcm90b3R5cGUtb2JqZWN0KVxuICogbWV0aG9kIGludGVyZmFjZSBvZiBgY2xlYXJgLCBgZGVsZXRlYCwgYGdldGAsIGBoYXNgLCBhbmQgYHNldGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZXJdIFRoZSBmdW5jdGlvbiB0byByZXNvbHZlIHRoZSBjYWNoZSBrZXkuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2MnOiAzLCAnZCc6IDQgfTtcbiAqXG4gKiB2YXIgdmFsdWVzID0gXy5tZW1vaXplKF8udmFsdWVzKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogdmFsdWVzKG90aGVyKTtcbiAqIC8vID0+IFszLCA0XVxuICpcbiAqIG9iamVjdC5hID0gMjtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogLy8gTW9kaWZ5IHRoZSByZXN1bHQgY2FjaGUuXG4gKiB2YWx1ZXMuY2FjaGUuc2V0KG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsnYScsICdiJ11cbiAqXG4gKiAvLyBSZXBsYWNlIGBfLm1lbW9pemUuQ2FjaGVgLlxuICogXy5tZW1vaXplLkNhY2hlID0gV2Vha01hcDtcbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZShmdW5jLCByZXNvbHZlcikge1xuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJyB8fCAocmVzb2x2ZXIgIT0gbnVsbCAmJiB0eXBlb2YgcmVzb2x2ZXIgIT0gJ2Z1bmN0aW9uJykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgdmFyIG1lbW9pemVkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGtleSA9IHJlc29sdmVyID8gcmVzb2x2ZXIuYXBwbHkodGhpcywgYXJncykgOiBhcmdzWzBdLFxuICAgICAgICBjYWNoZSA9IG1lbW9pemVkLmNhY2hlO1xuXG4gICAgaWYgKGNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIG1lbW9pemVkLmNhY2hlID0gY2FjaGUuc2V0KGtleSwgcmVzdWx0KSB8fCBjYWNoZTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBtZW1vaXplZC5jYWNoZSA9IG5ldyAobWVtb2l6ZS5DYWNoZSB8fCBNYXBDYWNoZSk7XG4gIHJldHVybiBtZW1vaXplZDtcbn1cblxuLy8gRXhwb3NlIGBNYXBDYWNoZWAuXG5tZW1vaXplLkNhY2hlID0gTWFwQ2FjaGU7XG5cbi8qKlxuICogUGVyZm9ybXMgYVxuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAqXG4gKiBfLmVxKG9iamVjdCwgb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKCdhJywgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKCdhJywgT2JqZWN0KCdhJykpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKE5hTiwgTmFOKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gZXEodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPyBiYXNlSXNBcmd1bWVudHMgOiBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgIWlzRnVuY3Rpb24odmFsdWUpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IEJ1ZmZlcigyKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgVWludDhBcnJheSgyKSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2U7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0xlbmd0aCgzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aCgnMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KG5ldyBVaW50OEFycmF5KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShbXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNUeXBlZEFycmF5ID0gbm9kZUlzVHlwZWRBcnJheSA/IGJhc2VVbmFyeShub2RlSXNUeXBlZEFycmF5KSA6IGJhc2VJc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZy4gQW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkIGZvciBgbnVsbGBcbiAqIGFuZCBgdW5kZWZpbmVkYCB2YWx1ZXMuIFRoZSBzaWduIG9mIGAtMGAgaXMgcHJlc2VydmVkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b1N0cmluZyhudWxsKTtcbiAqIC8vID0+ICcnXG4gKlxuICogXy50b1N0cmluZygtMCk7XG4gKiAvLyA9PiAnLTAnXG4gKlxuICogXy50b1N0cmluZyhbMSwgMiwgM10pO1xuICogLy8gPT4gJzEsMiwzJ1xuICovXG5mdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogYmFzZVRvU3RyaW5nKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuIElmIHRoZSByZXNvbHZlZCB2YWx1ZSBpc1xuICogYHVuZGVmaW5lZGAsIHRoZSBgZGVmYXVsdFZhbHVlYCBpcyByZXR1cm5lZCBpbiBpdHMgcGxhY2UuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjcuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRWYWx1ZV0gVGhlIHZhbHVlIHJldHVybmVkIGZvciBgdW5kZWZpbmVkYCByZXNvbHZlZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH1dIH07XG4gKlxuICogXy5nZXQob2JqZWN0LCAnYVswXS5iLmMnKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLmdldChvYmplY3QsIFsnYScsICcwJywgJ2InLCAnYyddKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLmdldChvYmplY3QsICdhLmIuYycsICdkZWZhdWx0Jyk7XG4gKiAvLyA9PiAnZGVmYXVsdCdcbiAqL1xuZnVuY3Rpb24gZ2V0KG9iamVjdCwgcGF0aCwgZGVmYXVsdFZhbHVlKSB7XG4gIHZhciByZXN1bHQgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcbiAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdFZhbHVlIDogcmVzdWx0O1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgcGF0aGAgaXMgYSBkaXJlY3Qgb3IgaW5oZXJpdGVkIHByb3BlcnR5IG9mIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IF8uY3JlYXRlKHsgJ2EnOiBfLmNyZWF0ZSh7ICdiJzogMiB9KSB9KTtcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2EuYicpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2InKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGhhc0luKG9iamVjdCwgcGF0aCkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgaGFzUGF0aChvYmplY3QsIHBhdGgsIGJhc2VIYXNJbik7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGVcbiAqIFtFUyBzcGVjXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8ua2V5cygnaGknKTtcbiAqIC8vID0+IFsnMCcsICcxJ11cbiAqL1xuZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCkgOiBiYXNlS2V5cyhvYmplY3QpO1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IGl0IHJlY2VpdmVzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlIEFueSB2YWx1ZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICpcbiAqIGNvbnNvbGUubG9nKF8uaWRlbnRpdHkob2JqZWN0KSA9PT0gb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBhIGdpdmVuIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IFtcbiAqICAgeyAnYSc6IHsgJ2InOiAyIH0gfSxcbiAqICAgeyAnYSc6IHsgJ2InOiAxIH0gfVxuICogXTtcbiAqXG4gKiBfLm1hcChvYmplY3RzLCBfLnByb3BlcnR5KCdhLmInKSk7XG4gKiAvLyA9PiBbMiwgMV1cbiAqXG4gKiBfLm1hcChfLnNvcnRCeShvYmplY3RzLCBfLnByb3BlcnR5KFsnYScsICdiJ10pKSwgJ2EuYicpO1xuICogLy8gPT4gWzEsIDJdXG4gKi9cbmZ1bmN0aW9uIHByb3BlcnR5KHBhdGgpIHtcbiAgcmV0dXJuIGlzS2V5KHBhdGgpID8gYmFzZVByb3BlcnR5KHRvS2V5KHBhdGgpKSA6IGJhc2VQcm9wZXJ0eURlZXAocGF0aCk7XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBlbXB0eSBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGVtcHR5IGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgYXJyYXlzID0gXy50aW1lcygyLCBfLnN0dWJBcnJheSk7XG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzKTtcbiAqIC8vID0+IFtbXSwgW11dXG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzWzBdID09PSBhcnJheXNbMV0pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gc3R1YkFycmF5KCkge1xuICByZXR1cm4gW107XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7XG4gKiAvLyA9PiBbZmFsc2UsIGZhbHNlXVxuICovXG5mdW5jdGlvbiBzdHViRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmaWx0ZXI7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.filter/index.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.findindex/index.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.findindex/index.js ***!
  \*********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, module) {/**\n * Lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize include=\"filter,sortBy,findIndex,find,forEach,cloneDeep\" exports=\"npm\"`\n * Copyright JS Foundation and other contributors <https://js.foundation/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used as the maximum memoize cache size. */\nvar MAX_MEMOIZE_SIZE = 500;\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0,\n    MAX_SAFE_INTEGER = 9007199254740991,\n    MAX_INTEGER = 1.7976931348623157e+308,\n    NAN = 0 / 0;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    asyncTag = '[object AsyncFunction]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    nullTag = '[object Null]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    proxyTag = '[object Proxy]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]',\n    undefinedTag = '[object Undefined]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/,\n    rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Detect free variable `exports`. */\nvar freeExports =  true && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * A specialized version of `_.filter` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction arrayFilter(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      resIndex = 0,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index];\n    if (predicate(value, index, array)) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\n\n/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction arrayMap(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\n\n/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\n/**\n * A specialized version of `_.some` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */\nfunction arraySome(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (predicate(array[index], index, array)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * The base implementation of `_.findIndex` and `_.findLastIndex` without\n * support for iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Function} predicate The function invoked per iteration.\n * @param {number} fromIndex The index to search from.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseFindIndex(array, predicate, fromIndex, fromRight) {\n  var length = array.length,\n      index = fromIndex + (fromRight ? 1 : -1);\n\n  while ((fromRight ? index-- : ++index < length)) {\n    if (predicate(array[index], index, array)) {\n      return index;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction baseProperty(key) {\n  return function(object) {\n    return object == null ? undefined : object[key];\n  };\n}\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\n/**\n * Checks if a `cache` value for `key` exists.\n *\n * @private\n * @param {Object} cache The cache to query.\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction cacheHas(cache, key) {\n  return cache.has(key);\n}\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined,\n    Symbol = root.Symbol,\n    Uint8Array = root.Uint8Array,\n    propertyIsEnumerable = objectProto.propertyIsEnumerable,\n    splice = arrayProto.splice,\n    symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols,\n    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\n    nativeKeys = overArg(Object.keys, Object),\n    nativeMax = Math.max;\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView'),\n    Map = getNative(root, 'Map'),\n    Promise = getNative(root, 'Promise'),\n    Set = getNative(root, 'Set'),\n    WeakMap = getNative(root, 'WeakMap'),\n    nativeCreate = getNative(Object, 'create');\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n *\n * Creates an array cache object to store unique values.\n *\n * @private\n * @constructor\n * @param {Array} [values] The values to cache.\n */\nfunction SetCache(values) {\n  var index = -1,\n      length = values == null ? 0 : values.length;\n\n  this.__data__ = new MapCache;\n  while (++index < length) {\n    this.add(values[index]);\n  }\n}\n\n/**\n * Adds `value` to the array cache.\n *\n * @private\n * @name add\n * @memberOf SetCache\n * @alias push\n * @param {*} value The value to cache.\n * @returns {Object} Returns the cache instance.\n */\nfunction setCacheAdd(value) {\n  this.__data__.set(value, HASH_UNDEFINED);\n  return this;\n}\n\n/**\n * Checks if `value` is in the array cache.\n *\n * @private\n * @name has\n * @memberOf SetCache\n * @param {*} value The value to search for.\n * @returns {number} Returns `true` if `value` is found, else `false`.\n */\nfunction setCacheHas(value) {\n  return this.__data__.has(value);\n}\n\n// Add methods to `SetCache`.\nSetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\nSetCache.prototype.has = setCacheHas;\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  var data = this.__data__ = new ListCache(entries);\n  this.size = data.size;\n}\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  var data = this.__data__,\n      result = data['delete'](key);\n\n  this.size = data.size;\n  return result;\n}\n\n/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\n/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var data = this.__data__;\n  if (data instanceof ListCache) {\n    var pairs = data.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      this.size = ++data.size;\n      return this;\n    }\n    data = this.__data__ = new MapCache(pairs);\n  }\n  data.set(key, value);\n  this.size = data.size;\n  return this;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = castPath(path, object);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n}\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\n/**\n * The base implementation of `_.hasIn` without support for deep paths.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {Array|string} key The key to check.\n * @returns {boolean} Returns `true` if `key` exists, else `false`.\n */\nfunction baseHasIn(object, key) {\n  return object != null && key in Object(object);\n}\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\n/**\n * The base implementation of `_.isEqual` which supports partial comparisons\n * and tracks traversed objects.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Unordered comparison\n *  2 - Partial comparison\n * @param {Function} [customizer] The function to customize comparisons.\n * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n */\nfunction baseIsEqual(value, other, bitmask, customizer, stack) {\n  if (value === other) {\n    return true;\n  }\n  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {\n    return value !== value && other !== other;\n  }\n  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n}\n\n/**\n * A specialized version of `baseIsEqual` for arrays and objects which performs\n * deep comparisons and tracks traversed objects enabling objects with circular\n * references to be compared.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n  var objIsArr = isArray(object),\n      othIsArr = isArray(other),\n      objTag = objIsArr ? arrayTag : getTag(object),\n      othTag = othIsArr ? arrayTag : getTag(other);\n\n  objTag = objTag == argsTag ? objectTag : objTag;\n  othTag = othTag == argsTag ? objectTag : othTag;\n\n  var objIsObj = objTag == objectTag,\n      othIsObj = othTag == objectTag,\n      isSameTag = objTag == othTag;\n\n  if (isSameTag && isBuffer(object)) {\n    if (!isBuffer(other)) {\n      return false;\n    }\n    objIsArr = true;\n    objIsObj = false;\n  }\n  if (isSameTag && !objIsObj) {\n    stack || (stack = new Stack);\n    return (objIsArr || isTypedArray(object))\n      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)\n      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n  }\n  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\n    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n    if (objIsWrapped || othIsWrapped) {\n      var objUnwrapped = objIsWrapped ? object.value() : object,\n          othUnwrapped = othIsWrapped ? other.value() : other;\n\n      stack || (stack = new Stack);\n      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n    }\n  }\n  if (!isSameTag) {\n    return false;\n  }\n  stack || (stack = new Stack);\n  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n}\n\n/**\n * The base implementation of `_.isMatch` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to inspect.\n * @param {Object} source The object of property values to match.\n * @param {Array} matchData The property names, values, and compare flags to match.\n * @param {Function} [customizer] The function to customize comparisons.\n * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n */\nfunction baseIsMatch(object, source, matchData, customizer) {\n  var index = matchData.length,\n      length = index,\n      noCustomizer = !customizer;\n\n  if (object == null) {\n    return !length;\n  }\n  object = Object(object);\n  while (index--) {\n    var data = matchData[index];\n    if ((noCustomizer && data[2])\n          ? data[1] !== object[data[0]]\n          : !(data[0] in object)\n        ) {\n      return false;\n    }\n  }\n  while (++index < length) {\n    data = matchData[index];\n    var key = data[0],\n        objValue = object[key],\n        srcValue = data[1];\n\n    if (noCustomizer && data[2]) {\n      if (objValue === undefined && !(key in object)) {\n        return false;\n      }\n    } else {\n      var stack = new Stack;\n      if (customizer) {\n        var result = customizer(objValue, srcValue, key, object, source, stack);\n      }\n      if (!(result === undefined\n            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)\n            : result\n          )) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\n/**\n * The base implementation of `_.iteratee`.\n *\n * @private\n * @param {*} [value=_.identity] The value to convert to an iteratee.\n * @returns {Function} Returns the iteratee.\n */\nfunction baseIteratee(value) {\n  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n  if (typeof value == 'function') {\n    return value;\n  }\n  if (value == null) {\n    return identity;\n  }\n  if (typeof value == 'object') {\n    return isArray(value)\n      ? baseMatchesProperty(value[0], value[1])\n      : baseMatches(value);\n  }\n  return property(value);\n}\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.matches` which doesn't clone `source`.\n *\n * @private\n * @param {Object} source The object of property values to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatches(source) {\n  var matchData = getMatchData(source);\n  if (matchData.length == 1 && matchData[0][2]) {\n    return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n  }\n  return function(object) {\n    return object === source || baseIsMatch(object, source, matchData);\n  };\n}\n\n/**\n * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n *\n * @private\n * @param {string} path The path of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatchesProperty(path, srcValue) {\n  if (isKey(path) && isStrictComparable(srcValue)) {\n    return matchesStrictComparable(toKey(path), srcValue);\n  }\n  return function(object) {\n    var objValue = get(object, path);\n    return (objValue === undefined && objValue === srcValue)\n      ? hasIn(object, path)\n      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);\n  };\n}\n\n/**\n * A specialized version of `baseProperty` which supports deep paths.\n *\n * @private\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction basePropertyDeep(path) {\n  return function(object) {\n    return baseGet(object, path);\n  };\n}\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isArray(value)) {\n    // Recursively convert values (susceptible to call stack limits).\n    return arrayMap(value, baseToString) + '';\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @param {Object} [object] The object to query keys on.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value, object) {\n  if (isArray(value)) {\n    return value;\n  }\n  return isKey(value, object) ? [value] : stringToPath(toString(value));\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for arrays with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Array} array The array to compare.\n * @param {Array} other The other array to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `array` and `other` objects.\n * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n */\nfunction equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      arrLength = array.length,\n      othLength = other.length;\n\n  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n    return false;\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(array);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var index = -1,\n      result = true,\n      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;\n\n  stack.set(array, other);\n  stack.set(other, array);\n\n  // Ignore non-index properties.\n  while (++index < arrLength) {\n    var arrValue = array[index],\n        othValue = other[index];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, arrValue, index, other, array, stack)\n        : customizer(arrValue, othValue, index, array, other, stack);\n    }\n    if (compared !== undefined) {\n      if (compared) {\n        continue;\n      }\n      result = false;\n      break;\n    }\n    // Recursively compare arrays (susceptible to call stack limits).\n    if (seen) {\n      if (!arraySome(other, function(othValue, othIndex) {\n            if (!cacheHas(seen, othIndex) &&\n                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n              return seen.push(othIndex);\n            }\n          })) {\n        result = false;\n        break;\n      }\n    } else if (!(\n          arrValue === othValue ||\n            equalFunc(arrValue, othValue, bitmask, customizer, stack)\n        )) {\n      result = false;\n      break;\n    }\n  }\n  stack['delete'](array);\n  stack['delete'](other);\n  return result;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for comparing objects of\n * the same `toStringTag`.\n *\n * **Note:** This function only supports comparing values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {string} tag The `toStringTag` of the objects to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n  switch (tag) {\n    case dataViewTag:\n      if ((object.byteLength != other.byteLength) ||\n          (object.byteOffset != other.byteOffset)) {\n        return false;\n      }\n      object = object.buffer;\n      other = other.buffer;\n\n    case arrayBufferTag:\n      if ((object.byteLength != other.byteLength) ||\n          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n        return false;\n      }\n      return true;\n\n    case boolTag:\n    case dateTag:\n    case numberTag:\n      // Coerce booleans to `1` or `0` and dates to milliseconds.\n      // Invalid dates are coerced to `NaN`.\n      return eq(+object, +other);\n\n    case errorTag:\n      return object.name == other.name && object.message == other.message;\n\n    case regexpTag:\n    case stringTag:\n      // Coerce regexes to strings and treat strings, primitives and objects,\n      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n      // for more details.\n      return object == (other + '');\n\n    case mapTag:\n      var convert = mapToArray;\n\n    case setTag:\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\n      convert || (convert = setToArray);\n\n      if (object.size != other.size && !isPartial) {\n        return false;\n      }\n      // Assume cyclic values are equal.\n      var stacked = stack.get(object);\n      if (stacked) {\n        return stacked == other;\n      }\n      bitmask |= COMPARE_UNORDERED_FLAG;\n\n      // Recursively compare objects (susceptible to call stack limits).\n      stack.set(object, other);\n      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n      stack['delete'](object);\n      return result;\n\n    case symbolTag:\n      if (symbolValueOf) {\n        return symbolValueOf.call(object) == symbolValueOf.call(other);\n      }\n  }\n  return false;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for objects with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      objProps = getAllKeys(object),\n      objLength = objProps.length,\n      othProps = getAllKeys(other),\n      othLength = othProps.length;\n\n  if (objLength != othLength && !isPartial) {\n    return false;\n  }\n  var index = objLength;\n  while (index--) {\n    var key = objProps[index];\n    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n      return false;\n    }\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(object);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var result = true;\n  stack.set(object, other);\n  stack.set(other, object);\n\n  var skipCtor = isPartial;\n  while (++index < objLength) {\n    key = objProps[index];\n    var objValue = object[key],\n        othValue = other[key];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, objValue, key, other, object, stack)\n        : customizer(objValue, othValue, key, object, other, stack);\n    }\n    // Recursively compare objects (susceptible to call stack limits).\n    if (!(compared === undefined\n          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))\n          : compared\n        )) {\n      result = false;\n      break;\n    }\n    skipCtor || (skipCtor = key == 'constructor');\n  }\n  if (result && !skipCtor) {\n    var objCtor = object.constructor,\n        othCtor = other.constructor;\n\n    // Non `Object` object instances with different constructors are not equal.\n    if (objCtor != othCtor &&\n        ('constructor' in object && 'constructor' in other) &&\n        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n          typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n      result = false;\n    }\n  }\n  stack['delete'](object);\n  stack['delete'](other);\n  return result;\n}\n\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n  return baseGetAllKeys(object, keys, getSymbols);\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the property names, values, and compare flags of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the match data of `object`.\n */\nfunction getMatchData(object) {\n  var result = keys(object),\n      length = result.length;\n\n  while (length--) {\n    var key = result[length],\n        value = object[key];\n\n    result[length] = [key, value, isStrictComparable(value)];\n  }\n  return result;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\n/**\n * Creates an array of the own enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = !nativeGetSymbols ? stubArray : function(object) {\n  if (object == null) {\n    return [];\n  }\n  object = Object(object);\n  return arrayFilter(nativeGetSymbols(object), function(symbol) {\n    return propertyIsEnumerable.call(object, symbol);\n  });\n};\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = baseGetTag(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : '';\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\n/**\n * Checks if `path` exists on `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @param {Function} hasFunc The function to check properties.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n */\nfunction hasPath(object, path, hasFunc) {\n  path = castPath(path, object);\n\n  var index = -1,\n      length = path.length,\n      result = false;\n\n  while (++index < length) {\n    var key = toKey(path[index]);\n    if (!(result = object != null && hasFunc(object, key))) {\n      break;\n    }\n    object = object[key];\n  }\n  if (result || ++index != length) {\n    return result;\n  }\n  length = object == null ? 0 : object.length;\n  return !!length && isLength(length) && isIndex(key, length) &&\n    (isArray(object) || isArguments(object));\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  var type = typeof value;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n\n  return !!length &&\n    (type == 'number' ||\n      (type != 'symbol' && reIsUint.test(value))) &&\n        (value > -1 && value % 1 == 0 && value < length);\n}\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\n/**\n * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` if suitable for strict\n *  equality comparisons, else `false`.\n */\nfunction isStrictComparable(value) {\n  return value === value && !isObject(value);\n}\n\n/**\n * A specialized version of `matchesProperty` for source values suitable\n * for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction matchesStrictComparable(key, srcValue) {\n  return function(object) {\n    if (object == null) {\n      return false;\n    }\n    return object[key] === srcValue &&\n      (srcValue !== undefined || (key in Object(object)));\n  };\n}\n\n/**\n * A specialized version of `_.memoize` which clears the memoized function's\n * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n *\n * @private\n * @param {Function} func The function to have its output memoized.\n * @returns {Function} Returns the new memoized function.\n */\nfunction memoizeCapped(func) {\n  var result = memoize(func, function(key) {\n    if (cache.size === MAX_MEMOIZE_SIZE) {\n      cache.clear();\n    }\n    return key;\n  });\n\n  var cache = result.cache;\n  return result;\n}\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoizeCapped(function(string) {\n  var result = [];\n  if (string.charCodeAt(0) === 46 /* . */) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, subString) {\n    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * This method is like `_.find` except that it returns the index of the first\n * element `predicate` returns truthy for instead of the element itself.\n *\n * @static\n * @memberOf _\n * @since 1.1.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @param {number} [fromIndex=0] The index to search from.\n * @returns {number} Returns the index of the found element, else `-1`.\n * @example\n *\n * var users = [\n *   { 'user': 'barney',  'active': false },\n *   { 'user': 'fred',    'active': false },\n *   { 'user': 'pebbles', 'active': true }\n * ];\n *\n * _.findIndex(users, function(o) { return o.user == 'barney'; });\n * // => 0\n *\n * // The `_.matches` iteratee shorthand.\n * _.findIndex(users, { 'user': 'fred', 'active': false });\n * // => 1\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.findIndex(users, ['active', false]);\n * // => 0\n *\n * // The `_.property` iteratee shorthand.\n * _.findIndex(users, 'active');\n * // => 2\n */\nfunction findIndex(array, predicate, fromIndex) {\n  var length = array == null ? 0 : array.length;\n  if (!length) {\n    return -1;\n  }\n  var index = fromIndex == null ? 0 : toInteger(fromIndex);\n  if (index < 0) {\n    index = nativeMax(length + index, 0);\n  }\n  return baseFindIndex(array, baseIteratee(predicate, 3), index);\n}\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result) || cache;\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Expose `MapCache`.\nmemoize.Cache = MapCache;\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n/**\n * Converts `value` to a finite number.\n *\n * @static\n * @memberOf _\n * @since 4.12.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted number.\n * @example\n *\n * _.toFinite(3.2);\n * // => 3.2\n *\n * _.toFinite(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toFinite(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toFinite('3.2');\n * // => 3.2\n */\nfunction toFinite(value) {\n  if (!value) {\n    return value === 0 ? value : 0;\n  }\n  value = toNumber(value);\n  if (value === INFINITY || value === -INFINITY) {\n    var sign = (value < 0 ? -1 : 1);\n    return sign * MAX_INTEGER;\n  }\n  return value === value ? value : 0;\n}\n\n/**\n * Converts `value` to an integer.\n *\n * **Note:** This method is loosely based on\n * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted integer.\n * @example\n *\n * _.toInteger(3.2);\n * // => 3\n *\n * _.toInteger(Number.MIN_VALUE);\n * // => 0\n *\n * _.toInteger(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toInteger('3.2');\n * // => 3\n */\nfunction toInteger(value) {\n  var result = toFinite(value),\n      remainder = result % 1;\n\n  return result === result ? (remainder ? result - remainder : result) : 0;\n}\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get(object, path, defaultValue) {\n  var result = object == null ? undefined : baseGet(object, path);\n  return result === undefined ? defaultValue : result;\n}\n\n/**\n * Checks if `path` is a direct or inherited property of `object`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n * @example\n *\n * var object = _.create({ 'a': _.create({ 'b': 2 }) });\n *\n * _.hasIn(object, 'a');\n * // => true\n *\n * _.hasIn(object, 'a.b');\n * // => true\n *\n * _.hasIn(object, ['a', 'b']);\n * // => true\n *\n * _.hasIn(object, 'b');\n * // => false\n */\nfunction hasIn(object, path) {\n  return object != null && hasPath(object, path, baseHasIn);\n}\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\n/**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\n/**\n * Creates a function that returns the value at `path` of a given object.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n * @example\n *\n * var objects = [\n *   { 'a': { 'b': 2 } },\n *   { 'a': { 'b': 1 } }\n * ];\n *\n * _.map(objects, _.property('a.b'));\n * // => [2, 1]\n *\n * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n * // => [1, 2]\n */\nfunction property(path) {\n  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n}\n\n/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n  return [];\n}\n\n/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = findIndex;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../../../../../webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9sb2Rhc2gtY3VzdG9tLWJ1aWxkL21vZHVsYXJpemUvbG9kYXNoLmZpbmRpbmRleC9pbmRleC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Aa2lzc215YnV0dG9uL21vdG9yY29ydGV4L2xvZGFzaC1jdXN0b20tYnVpbGQvbW9kdWxhcml6ZS9sb2Rhc2guZmluZGluZGV4L2luZGV4LmpzP2I3OGUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBMb2Rhc2ggKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGluY2x1ZGU9XCJmaWx0ZXIsc29ydEJ5LGZpbmRJbmRleCxmaW5kLGZvckVhY2gsY2xvbmVEZWVwXCIgZXhwb3J0cz1cIm5wbVwiYFxuICogQ29weXJpZ2h0IEpTIEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9qcy5mb3VuZGF0aW9uLz5cbiAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqL1xuXG4vKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbnZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4vKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKiBVc2VkIGFzIHRoZSBtYXhpbXVtIG1lbW9pemUgY2FjaGUgc2l6ZS4gKi9cbnZhciBNQVhfTUVNT0laRV9TSVpFID0gNTAwO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDAsXG4gICAgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTEsXG4gICAgTUFYX0lOVEVHRVIgPSAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOCxcbiAgICBOQU4gPSAwIC8gMDtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcHJvbWlzZVRhZyA9ICdbb2JqZWN0IFByb21pc2VdJyxcbiAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXScsXG4gICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUlzRGVlcFByb3AgPSAvXFwufFxcWyg/OlteW1xcXV0qfChbXCInXSkoPzooPyFcXDEpW15cXFxcXXxcXFxcLikqP1xcMSlcXF0vLFxuICAgIHJlSXNQbGFpblByb3AgPSAvXlxcdyokLyxcbiAgICByZVByb3BOYW1lID0gL1teLltcXF1dK3xcXFsoPzooLT9cXGQrKD86XFwuXFxkKyk/KXwoW1wiJ10pKCg/Oig/IVxcMilbXlxcXFxdfFxcXFwuKSo/KVxcMilcXF18KD89KD86XFwufFxcW1xcXSkoPzpcXC58XFxbXFxdfCQpKS9nO1xuXG4vKipcbiAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxuICovXG52YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nO1xuXG4vKiogVXNlZCB0byBtYXRjaCBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlLiAqL1xudmFyIHJlVHJpbSA9IC9eXFxzK3xcXHMrJC9nO1xuXG4vKiogVXNlZCB0byBtYXRjaCBiYWNrc2xhc2hlcyBpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUVzY2FwZUNoYXIgPSAvXFxcXChcXFxcKT8vZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJhZCBzaWduZWQgaGV4YWRlY2ltYWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmFkSGV4ID0gL15bLStdMHhbMC05YS1mXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiaW5hcnkgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmluYXJ5ID0gL14wYlswMV0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSkuICovXG52YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG9jdGFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc09jdGFsID0gL14wb1swLTddKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xudmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxkKikkLztcblxuLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgb2YgdHlwZWQgYXJyYXlzLiAqL1xudmFyIHR5cGVkQXJyYXlUYWdzID0ge307XG50eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbnR5cGVkQXJyYXlUYWdzW2FyZ3NUYWddID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddID1cbnR5cGVkQXJyYXlUYWdzW2FycmF5QnVmZmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWddID1cbnR5cGVkQXJyYXlUYWdzW2RhdGFWaWV3VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2RhdGVUYWddID1cbnR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Z1bmNUYWddID1cbnR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPSB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID1cbnR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPSB0eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID1cbnR5cGVkQXJyYXlUYWdzW3NldFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzdHJpbmdUYWddID1cbnR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB3aXRob3V0IGEgZGVwZW5kZW5jeSBvbiBgcm9vdGAuICovXG52YXIgZnJlZVBhcnNlSW50ID0gcGFyc2VJbnQ7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHByb2Nlc3NgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlUHJvY2VzcyA9IG1vZHVsZUV4cG9ydHMgJiYgZnJlZUdsb2JhbC5wcm9jZXNzO1xuXG4vKiogVXNlZCB0byBhY2Nlc3MgZmFzdGVyIE5vZGUuanMgaGVscGVycy4gKi9cbnZhciBub2RlVXRpbCA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZnJlZVByb2Nlc3MgJiYgZnJlZVByb2Nlc3MuYmluZGluZyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCd1dGlsJyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZpbHRlcmAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheUZpbHRlcihhcnJheSwgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXNJbmRleCA9IDAsXG4gICAgICByZXN1bHQgPSBbXTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWFwYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TWFwKGFycmF5LCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBBcHBlbmRzIHRoZSBlbGVtZW50cyBvZiBgdmFsdWVzYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYXBwZW5kLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5UHVzaChhcnJheSwgdmFsdWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIG9mZnNldCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W29mZnNldCArIGluZGV4XSA9IHZhbHVlc1tpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zb21lYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlTb21lKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZpbmRJbmRleGAgYW5kIGBfLmZpbmRMYXN0SW5kZXhgIHdpdGhvdXRcbiAqIHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUZpbmRJbmRleChhcnJheSwgcHJlZGljYXRlLCBmcm9tSW5kZXgsIGZyb21SaWdodCkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgaW5kZXggPSBmcm9tSW5kZXggKyAoZnJvbVJpZ2h0ID8gMSA6IC0xKTtcblxuICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wcm9wZXJ0eWAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHkoa2V5KSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50aW1lc2Agd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzXG4gKiBvciBtYXggYXJyYXkgbGVuZ3RoIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUaW1lcyhuLCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG4pO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShpbmRleCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmFyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBzdG9yaW5nIG1ldGFkYXRhLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVVuYXJ5KGZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmModmFsdWUpO1xuICB9O1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIGBjYWNoZWAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGNhY2hlIFRoZSBjYWNoZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBjYWNoZUhhcyhjYWNoZSwga2V5KSB7XG4gIHJldHVybiBjYWNoZS5oYXMoa2V5KTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0VmFsdWUob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG59XG5cbi8qKlxuICogQ29udmVydHMgYG1hcGAgdG8gaXRzIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAqL1xuZnVuY3Rpb24gbWFwVG9BcnJheShtYXApIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShtYXAuc2l6ZSk7XG5cbiAgbWFwLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IFtrZXksIHZhbHVlXTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHVuYXJ5IGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnQgdHJhbnNmb3JtZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xuICB9O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGBzZXRgIHRvIGFuIGFycmF5IG9mIGl0cyB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXQgVGhlIHNldCB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIHNldFRvQXJyYXkoc2V0KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkoc2V0LnNpemUpO1xuXG4gIHNldC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gdmFsdWU7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZSxcbiAgICBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb3ZlcnJlYWNoaW5nIGNvcmUtanMgc2hpbXMuICovXG52YXIgY29yZUpzRGF0YSA9IHJvb3RbJ19fY29yZS1qc19zaGFyZWRfXyddO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWV0aG9kcyBtYXNxdWVyYWRpbmcgYXMgbmF0aXZlLiAqL1xudmFyIG1hc2tTcmNLZXkgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB1aWQgPSAvW14uXSskLy5leGVjKGNvcmVKc0RhdGEgJiYgY29yZUpzRGF0YS5rZXlzICYmIGNvcmVKc0RhdGEua2V5cy5JRV9QUk9UTyB8fCAnJyk7XG4gIHJldHVybiB1aWQgPyAoJ1N5bWJvbChzcmMpXzEuJyArIHVpZCkgOiAnJztcbn0oKSk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xudmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgZnVuY1RvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4pO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gcm9vdC5CdWZmZXIgOiB1bmRlZmluZWQsXG4gICAgU3ltYm9sID0gcm9vdC5TeW1ib2wsXG4gICAgVWludDhBcnJheSA9IHJvb3QuVWludDhBcnJheSxcbiAgICBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlLFxuICAgIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlLFxuICAgIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlR2V0U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsXG4gICAgbmF0aXZlSXNCdWZmZXIgPSBCdWZmZXIgPyBCdWZmZXIuaXNCdWZmZXIgOiB1bmRlZmluZWQsXG4gICAgbmF0aXZlS2V5cyA9IG92ZXJBcmcoT2JqZWN0LmtleXMsIE9iamVjdCksXG4gICAgbmF0aXZlTWF4ID0gTWF0aC5tYXg7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBEYXRhVmlldyA9IGdldE5hdGl2ZShyb290LCAnRGF0YVZpZXcnKSxcbiAgICBNYXAgPSBnZXROYXRpdmUocm9vdCwgJ01hcCcpLFxuICAgIFByb21pc2UgPSBnZXROYXRpdmUocm9vdCwgJ1Byb21pc2UnKSxcbiAgICBTZXQgPSBnZXROYXRpdmUocm9vdCwgJ1NldCcpLFxuICAgIFdlYWtNYXAgPSBnZXROYXRpdmUocm9vdCwgJ1dlYWtNYXAnKSxcbiAgICBuYXRpdmVDcmVhdGUgPSBnZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtYXBzLCBzZXRzLCBhbmQgd2Vha21hcHMuICovXG52YXIgZGF0YVZpZXdDdG9yU3RyaW5nID0gdG9Tb3VyY2UoRGF0YVZpZXcpLFxuICAgIG1hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShNYXApLFxuICAgIHByb21pc2VDdG9yU3RyaW5nID0gdG9Tb3VyY2UoUHJvbWlzZSksXG4gICAgc2V0Q3RvclN0cmluZyA9IHRvU291cmNlKFNldCksXG4gICAgd2Vha01hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShXZWFrTWFwKTtcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFZhbHVlT2YgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnZhbHVlT2YgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKi9cbmZ1bmN0aW9uIGhhc2hDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5hdGl2ZUNyZWF0ZSA/IG5hdGl2ZUNyZWF0ZShudWxsKSA6IHt9O1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaERlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGhhc2ggdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gaGFzaEdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAobmF0aXZlQ3JlYXRlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGRhdGFba2V5XTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSBIQVNIX1VOREVGSU5FRCA/IHVuZGVmaW5lZCA6IHJlc3VsdDtcbiAgfVxuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIGhhc2ggdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hIYXMoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgcmV0dXJuIG5hdGl2ZUNyZWF0ZSA/IChkYXRhW2tleV0gIT09IHVuZGVmaW5lZCkgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHRoaXMuc2l6ZSArPSB0aGlzLmhhcyhrZXkpID8gMCA6IDE7XG4gIGRhdGFba2V5XSA9IChuYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCA6IHZhbHVlO1xuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG5IYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBoYXNoRGVsZXRlO1xuSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbkhhc2gucHJvdG90eXBlLmhhcyA9IGhhc2hIYXM7XG5IYXNoLnByb3RvdHlwZS5zZXQgPSBoYXNoU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIExpc3RDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBbXTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGxhc3RJbmRleCA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgaWYgKGluZGV4ID09IGxhc3RJbmRleCkge1xuICAgIGRhdGEucG9wKCk7XG4gIH0gZWxzZSB7XG4gICAgc3BsaWNlLmNhbGwoZGF0YSwgaW5kZXgsIDEpO1xuICB9XG4gIC0tdGhpcy5zaXplO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGFzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgbGlzdCBjYWNoZSBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgKyt0aGlzLnNpemU7XG4gICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0gZWxzZSB7XG4gICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXG5MaXN0Q2FjaGUucHJvdG90eXBlLmNsZWFyID0gbGlzdENhY2hlQ2xlYXI7XG5MaXN0Q2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IGxpc3RDYWNoZURlbGV0ZTtcbkxpc3RDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbGlzdENhY2hlR2V0O1xuTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBsaXN0Q2FjaGVIYXM7XG5MaXN0Q2FjaGUucHJvdG90eXBlLnNldCA9IGxpc3RDYWNoZVNldDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVDbGVhcigpIHtcbiAgdGhpcy5zaXplID0gMDtcbiAgdGhpcy5fX2RhdGFfXyA9IHtcbiAgICAnaGFzaCc6IG5ldyBIYXNoLFxuICAgICdtYXAnOiBuZXcgKE1hcCB8fCBMaXN0Q2FjaGUpLFxuICAgICdzdHJpbmcnOiBuZXcgSGFzaFxuICB9O1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSlbJ2RlbGV0ZSddKGtleSk7XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBtYXAgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlR2V0KGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmdldChrZXkpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIG1hcCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmhhcyhrZXkpO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIG1hcCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBtYXAgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSksXG4gICAgICBzaXplID0gZGF0YS5zaXplO1xuXG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgKz0gZGF0YS5zaXplID09IHNpemUgPyAwIDogMTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBNYXBDYWNoZWAuXG5NYXBDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBtYXBDYWNoZUNsZWFyO1xuTWFwQ2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IG1hcENhY2hlRGVsZXRlO1xuTWFwQ2FjaGUucHJvdG90eXBlLmdldCA9IG1hcENhY2hlR2V0O1xuTWFwQ2FjaGUucHJvdG90eXBlLmhhcyA9IG1hcENhY2hlSGFzO1xuTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IG1hcENhY2hlU2V0O1xuXG4vKipcbiAqXG4gKiBDcmVhdGVzIGFuIGFycmF5IGNhY2hlIG9iamVjdCB0byBzdG9yZSB1bmlxdWUgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFNldENhY2hlKHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcyA9PSBudWxsID8gMCA6IHZhbHVlcy5sZW5ndGg7XG5cbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB0aGlzLmFkZCh2YWx1ZXNbaW5kZXhdKTtcbiAgfVxufVxuXG4vKipcbiAqIEFkZHMgYHZhbHVlYCB0byB0aGUgYXJyYXkgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGFkZFxuICogQG1lbWJlck9mIFNldENhY2hlXG4gKiBAYWxpYXMgcHVzaFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2FjaGUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVBZGQodmFsdWUpIHtcbiAgdGhpcy5fX2RhdGFfXy5zZXQodmFsdWUsIEhBU0hfVU5ERUZJTkVEKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgaW4gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVIYXModmFsdWUpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKHZhbHVlKTtcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFNldENhY2hlYC5cblNldENhY2hlLnByb3RvdHlwZS5hZGQgPSBTZXRDYWNoZS5wcm90b3R5cGUucHVzaCA9IHNldENhY2hlQWRkO1xuU2V0Q2FjaGUucHJvdG90eXBlLmhhcyA9IHNldENhY2hlSGFzO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzdGFjayBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTdGFjayhlbnRyaWVzKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGUoZW50cmllcyk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBTdGFja1xuICovXG5mdW5jdGlvbiBzdGFja0NsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIHJlc3VsdCA9IGRhdGFbJ2RlbGV0ZSddKGtleSk7XG5cbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIHN0YWNrIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBzdGFja0dldChrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uZ2V0KGtleSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgc3RhY2sgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0hhcyhrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKGtleSk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgc3RhY2sgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgc3RhY2sgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAoZGF0YSBpbnN0YW5jZW9mIExpc3RDYWNoZSkge1xuICAgIHZhciBwYWlycyA9IGRhdGEuX19kYXRhX187XG4gICAgaWYgKCFNYXAgfHwgKHBhaXJzLmxlbmd0aCA8IExBUkdFX0FSUkFZX1NJWkUgLSAxKSkge1xuICAgICAgcGFpcnMucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgdGhpcy5zaXplID0gKytkYXRhLnNpemU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGUocGFpcnMpO1xuICB9XG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU3RhY2tgLlxuU3RhY2sucHJvdG90eXBlLmNsZWFyID0gc3RhY2tDbGVhcjtcblN0YWNrLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBzdGFja0RlbGV0ZTtcblN0YWNrLnByb3RvdHlwZS5nZXQgPSBzdGFja0dldDtcblN0YWNrLnByb3RvdHlwZS5oYXMgPSBzdGFja0hhcztcblN0YWNrLnByb3RvdHlwZS5zZXQgPSBzdGFja1NldDtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XG4gIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpLFxuICAgICAgaXNBcmcgPSAhaXNBcnIgJiYgaXNBcmd1bWVudHModmFsdWUpLFxuICAgICAgaXNCdWZmID0gIWlzQXJyICYmICFpc0FyZyAmJiBpc0J1ZmZlcih2YWx1ZSksXG4gICAgICBpc1R5cGUgPSAhaXNBcnIgJiYgIWlzQXJnICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHZhbHVlKSxcbiAgICAgIHNraXBJbmRleGVzID0gaXNBcnIgfHwgaXNBcmcgfHwgaXNCdWZmIHx8IGlzVHlwZSxcbiAgICAgIHJlc3VsdCA9IHNraXBJbmRleGVzID8gYmFzZVRpbWVzKHZhbHVlLmxlbmd0aCwgU3RyaW5nKSA6IFtdLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSAmJlxuICAgICAgICAhKHNraXBJbmRleGVzICYmIChcbiAgICAgICAgICAgLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLlxuICAgICAgICAgICBrZXkgPT0gJ2xlbmd0aCcgfHxcbiAgICAgICAgICAgLy8gTm9kZS5qcyAwLjEwIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIGJ1ZmZlcnMuXG4gICAgICAgICAgIChpc0J1ZmYgJiYgKGtleSA9PSAnb2Zmc2V0JyB8fCBrZXkgPT0gJ3BhcmVudCcpKSB8fFxuICAgICAgICAgICAvLyBQaGFudG9tSlMgMiBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiB0eXBlZCBhcnJheXMuXG4gICAgICAgICAgIChpc1R5cGUgJiYgKGtleSA9PSAnYnVmZmVyJyB8fCBrZXkgPT0gJ2J5dGVMZW5ndGgnIHx8IGtleSA9PSAnYnl0ZU9mZnNldCcpKSB8fFxuICAgICAgICAgICAvLyBTa2lwIGluZGV4IHByb3BlcnRpZXMuXG4gICAgICAgICAgIGlzSW5kZXgoa2V5LCBsZW5ndGgpXG4gICAgICAgICkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBga2V5YCBpcyBmb3VuZCBpbiBgYXJyYXlgIG9mIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IGtleSBUaGUga2V5IHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBhc3NvY0luZGV4T2YoYXJyYXksIGtleSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBpZiAoZXEoYXJyYXlbbGVuZ3RoXVswXSwga2V5KSkge1xuICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmdldGAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWZhdWx0IHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldChvYmplY3QsIHBhdGgpIHtcbiAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gMCxcbiAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXG4gIHdoaWxlIChvYmplY3QgIT0gbnVsbCAmJiBpbmRleCA8IGxlbmd0aCkge1xuICAgIG9iamVjdCA9IG9iamVjdFt0b0tleShwYXRoW2luZGV4KytdKV07XG4gIH1cbiAgcmV0dXJuIChpbmRleCAmJiBpbmRleCA9PSBsZW5ndGgpID8gb2JqZWN0IDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRBbGxLZXlzYCBhbmQgYGdldEFsbEtleXNJbmAgd2hpY2ggdXNlc1xuICogYGtleXNGdW5jYCBhbmQgYHN5bWJvbHNGdW5jYCB0byBnZXQgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gKiBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3ltYm9sc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0Z1bmMsIHN5bWJvbHNGdW5jKSB7XG4gIHZhciByZXN1bHQgPSBrZXlzRnVuYyhvYmplY3QpO1xuICByZXR1cm4gaXNBcnJheShvYmplY3QpID8gcmVzdWx0IDogYXJyYXlQdXNoKHJlc3VsdCwgc3ltYm9sc0Z1bmMob2JqZWN0KSk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2Agd2l0aG91dCBmYWxsYmFja3MgZm9yIGJ1Z2d5IGVudmlyb25tZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICB9XG4gIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICA/IGdldFJhd1RhZyh2YWx1ZSlcbiAgICA6IG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5oYXNJbmAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBrZXkgVGhlIGtleSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUhhc0luKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBrZXkgaW4gT2JqZWN0KG9iamVjdCk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcmd1bWVudHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqL1xuZnVuY3Rpb24gYmFzZUlzQXJndW1lbnRzKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFyZ3NUYWc7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNFcXVhbGAgd2hpY2ggc3VwcG9ydHMgcGFydGlhbCBjb21wYXJpc29uc1xuICogYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuXG4gKiAgMSAtIFVub3JkZXJlZCBjb21wYXJpc29uXG4gKiAgMiAtIFBhcnRpYWwgY29tcGFyaXNvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGB2YWx1ZWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spIHtcbiAgaWYgKHZhbHVlID09PSBvdGhlcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsIHx8IG90aGVyID09IG51bGwgfHwgKCFpc09iamVjdExpa2UodmFsdWUpICYmICFpc09iamVjdExpa2Uob3RoZXIpKSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyO1xuICB9XG4gIHJldHVybiBiYXNlSXNFcXVhbERlZXAodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBiYXNlSXNFcXVhbCwgc3RhY2spO1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcbiAqIGRlZXAgY29tcGFyaXNvbnMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAqIHJlZmVyZW5jZXMgdG8gYmUgY29tcGFyZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsRGVlcChvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBvYmpJc0FyciA9IGlzQXJyYXkob2JqZWN0KSxcbiAgICAgIG90aElzQXJyID0gaXNBcnJheShvdGhlciksXG4gICAgICBvYmpUYWcgPSBvYmpJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnKG9iamVjdCksXG4gICAgICBvdGhUYWcgPSBvdGhJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnKG90aGVyKTtcblxuICBvYmpUYWcgPSBvYmpUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG9ialRhZztcbiAgb3RoVGFnID0gb3RoVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvdGhUYWc7XG5cbiAgdmFyIG9iaklzT2JqID0gb2JqVGFnID09IG9iamVjdFRhZyxcbiAgICAgIG90aElzT2JqID0gb3RoVGFnID09IG9iamVjdFRhZyxcbiAgICAgIGlzU2FtZVRhZyA9IG9ialRhZyA9PSBvdGhUYWc7XG5cbiAgaWYgKGlzU2FtZVRhZyAmJiBpc0J1ZmZlcihvYmplY3QpKSB7XG4gICAgaWYgKCFpc0J1ZmZlcihvdGhlcikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgb2JqSXNBcnIgPSB0cnVlO1xuICAgIG9iaklzT2JqID0gZmFsc2U7XG4gIH1cbiAgaWYgKGlzU2FtZVRhZyAmJiAhb2JqSXNPYmopIHtcbiAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgIHJldHVybiAob2JqSXNBcnIgfHwgaXNUeXBlZEFycmF5KG9iamVjdCkpXG4gICAgICA/IGVxdWFsQXJyYXlzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spXG4gICAgICA6IGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgb2JqVGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgfVxuICBpZiAoIShiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcpKSB7XG4gICAgdmFyIG9iaklzV3JhcHBlZCA9IG9iaklzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCAnX193cmFwcGVkX18nKSxcbiAgICAgICAgb3RoSXNXcmFwcGVkID0gb3RoSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwgJ19fd3JhcHBlZF9fJyk7XG5cbiAgICBpZiAob2JqSXNXcmFwcGVkIHx8IG90aElzV3JhcHBlZCkge1xuICAgICAgdmFyIG9ialVud3JhcHBlZCA9IG9iaklzV3JhcHBlZCA/IG9iamVjdC52YWx1ZSgpIDogb2JqZWN0LFxuICAgICAgICAgIG90aFVud3JhcHBlZCA9IG90aElzV3JhcHBlZCA/IG90aGVyLnZhbHVlKCkgOiBvdGhlcjtcblxuICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgIHJldHVybiBlcXVhbEZ1bmMob2JqVW53cmFwcGVkLCBvdGhVbndyYXBwZWQsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFpc1NhbWVUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgcmV0dXJuIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc01hdGNoYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAqIEBwYXJhbSB7QXJyYXl9IG1hdGNoRGF0YSBUaGUgcHJvcGVydHkgbmFtZXMsIHZhbHVlcywgYW5kIGNvbXBhcmUgZmxhZ3MgdG8gbWF0Y2guXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgb2JqZWN0YCBpcyBhIG1hdGNoLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEsIGN1c3RvbWl6ZXIpIHtcbiAgdmFyIGluZGV4ID0gbWF0Y2hEYXRhLmxlbmd0aCxcbiAgICAgIGxlbmd0aCA9IGluZGV4LFxuICAgICAgbm9DdXN0b21pemVyID0gIWN1c3RvbWl6ZXI7XG5cbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuICFsZW5ndGg7XG4gIH1cbiAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgdmFyIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgIGlmICgobm9DdXN0b21pemVyICYmIGRhdGFbMl0pXG4gICAgICAgICAgPyBkYXRhWzFdICE9PSBvYmplY3RbZGF0YVswXV1cbiAgICAgICAgICA6ICEoZGF0YVswXSBpbiBvYmplY3QpXG4gICAgICAgICkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgIHZhciBrZXkgPSBkYXRhWzBdLFxuICAgICAgICBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICBzcmNWYWx1ZSA9IGRhdGFbMV07XG5cbiAgICBpZiAobm9DdXN0b21pemVyICYmIGRhdGFbMl0pIHtcbiAgICAgIGlmIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc3RhY2sgPSBuZXcgU3RhY2s7XG4gICAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKTtcbiAgICAgIH1cbiAgICAgIGlmICghKHJlc3VsdCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IGJhc2VJc0VxdWFsKHNyY1ZhbHVlLCBvYmpWYWx1ZSwgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgfCBDT01QQVJFX1VOT1JERVJFRF9GTEFHLCBjdXN0b21pemVyLCBzdGFjaylcbiAgICAgICAgICAgIDogcmVzdWx0XG4gICAgICAgICAgKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHBhdHRlcm4gPSBpc0Z1bmN0aW9uKHZhbHVlKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1R5cGVkQXJyYXlgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzVHlwZWRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJlxuICAgIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tiYXNlR2V0VGFnKHZhbHVlKV07XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXRlcmF0ZWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IFt2YWx1ZT1fLmlkZW50aXR5XSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhbiBpdGVyYXRlZS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgaXRlcmF0ZWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJdGVyYXRlZSh2YWx1ZSkge1xuICAvLyBEb24ndCBzdG9yZSB0aGUgYHR5cGVvZmAgcmVzdWx0IGluIGEgdmFyaWFibGUgdG8gYXZvaWQgYSBKSVQgYnVnIGluIFNhZmFyaSA5LlxuICAvLyBTZWUgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE1NjAzNCBmb3IgbW9yZSBkZXRhaWxzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gaWRlbnRpdHk7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBpc0FycmF5KHZhbHVlKVxuICAgICAgPyBiYXNlTWF0Y2hlc1Byb3BlcnR5KHZhbHVlWzBdLCB2YWx1ZVsxXSlcbiAgICAgIDogYmFzZU1hdGNoZXModmFsdWUpO1xuICB9XG4gIHJldHVybiBwcm9wZXJ0eSh2YWx1ZSk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c2Agd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5cyhvYmplY3QpIHtcbiAgaWYgKCFpc1Byb3RvdHlwZShvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBrZXkgIT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzYCB3aGljaCBkb2Vzbid0IGNsb25lIGBzb3VyY2VgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hdGNoZXMoc291cmNlKSB7XG4gIHZhciBtYXRjaERhdGEgPSBnZXRNYXRjaERhdGEoc291cmNlKTtcbiAgaWYgKG1hdGNoRGF0YS5sZW5ndGggPT0gMSAmJiBtYXRjaERhdGFbMF1bMl0pIHtcbiAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUobWF0Y2hEYXRhWzBdWzBdLCBtYXRjaERhdGFbMF1bMV0pO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09PSBzb3VyY2UgfHwgYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSk7XG4gIH07XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc1Byb3BlcnR5YCB3aGljaCBkb2Vzbid0IGNsb25lIGBzcmNWYWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VNYXRjaGVzUHJvcGVydHkocGF0aCwgc3JjVmFsdWUpIHtcbiAgaWYgKGlzS2V5KHBhdGgpICYmIGlzU3RyaWN0Q29tcGFyYWJsZShzcmNWYWx1ZSkpIHtcbiAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUodG9LZXkocGF0aCksIHNyY1ZhbHVlKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIG9ialZhbHVlID0gZ2V0KG9iamVjdCwgcGF0aCk7XG4gICAgcmV0dXJuIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkICYmIG9ialZhbHVlID09PSBzcmNWYWx1ZSlcbiAgICAgID8gaGFzSW4ob2JqZWN0LCBwYXRoKVxuICAgICAgOiBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIENPTVBBUkVfUEFSVElBTF9GTEFHIHwgQ09NUEFSRV9VTk9SREVSRURfRkxBRyk7XG4gIH07XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUHJvcGVydHlgIHdoaWNoIHN1cHBvcnRzIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5RGVlcChwYXRoKSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gYmFzZUdldChvYmplY3QsIHBhdGgpO1xuICB9O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvU3RyaW5nYCB3aGljaCBkb2Vzbid0IGNvbnZlcnQgbnVsbGlzaFxuICogdmFsdWVzIHRvIGVtcHR5IHN0cmluZ3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xuICAvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbnZlcnQgdmFsdWVzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgcmV0dXJuIGFycmF5TWFwKHZhbHVlLCBiYXNlVG9TdHJpbmcpICsgJyc7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBzeW1ib2xUb1N0cmluZyA/IHN5bWJvbFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG4vKipcbiAqIENhc3RzIGB2YWx1ZWAgdG8gYSBwYXRoIGFycmF5IGlmIGl0J3Mgbm90IG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3QgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gY2FzdFBhdGgodmFsdWUsIG9iamVjdCkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIGlzS2V5KHZhbHVlLCBvYmplY3QpID8gW3ZhbHVlXSA6IHN0cmluZ1RvUGF0aCh0b1N0cmluZyh2YWx1ZSkpO1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgYXJyYXlzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0FycmF5fSBvdGhlciBUaGUgb3RoZXIgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYGFycmF5YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcnJheXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxBcnJheXMoYXJyYXksIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICBhcnJMZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBvdGhMZW5ndGggPSBvdGhlci5sZW5ndGg7XG5cbiAgaWYgKGFyckxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIShpc1BhcnRpYWwgJiYgb3RoTGVuZ3RoID4gYXJyTGVuZ3RoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KGFycmF5KTtcbiAgaWYgKHN0YWNrZWQgJiYgc3RhY2suZ2V0KG90aGVyKSkge1xuICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICB9XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gdHJ1ZSxcbiAgICAgIHNlZW4gPSAoYml0bWFzayAmIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcpID8gbmV3IFNldENhY2hlIDogdW5kZWZpbmVkO1xuXG4gIHN0YWNrLnNldChhcnJheSwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIGFycmF5KTtcblxuICAvLyBJZ25vcmUgbm9uLWluZGV4IHByb3BlcnRpZXMuXG4gIHdoaWxlICgrK2luZGV4IDwgYXJyTGVuZ3RoKSB7XG4gICAgdmFyIGFyclZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2luZGV4XTtcblxuICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBhcnJWYWx1ZSwgaW5kZXgsIG90aGVyLCBhcnJheSwgc3RhY2spXG4gICAgICAgIDogY3VzdG9taXplcihhcnJWYWx1ZSwgb3RoVmFsdWUsIGluZGV4LCBhcnJheSwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgaWYgKGNvbXBhcmVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChjb21wYXJlZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKHNlZW4pIHtcbiAgICAgIGlmICghYXJyYXlTb21lKG90aGVyLCBmdW5jdGlvbihvdGhWYWx1ZSwgb3RoSW5kZXgpIHtcbiAgICAgICAgICAgIGlmICghY2FjaGVIYXMoc2Vlbiwgb3RoSW5kZXgpICYmXG4gICAgICAgICAgICAgICAgKGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzZWVuLnB1c2gob3RoSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKSB7XG4gICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEoXG4gICAgICAgICAgYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8XG4gICAgICAgICAgICBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaylcbiAgICAgICAgKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgc3RhY2tbJ2RlbGV0ZSddKGFycmF5KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGNvbXBhcmluZyBvYmplY3RzIG9mXG4gKiB0aGUgc2FtZSBgdG9TdHJpbmdUYWdgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY29tcGFyaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIG9yIGBTdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3RzIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCB0YWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlIGRhdGFWaWV3VGFnOlxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgIChvYmplY3QuYnl0ZU9mZnNldCAhPSBvdGhlci5ieXRlT2Zmc2V0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBvYmplY3QgPSBvYmplY3QuYnVmZmVyO1xuICAgICAgb3RoZXIgPSBvdGhlci5idWZmZXI7XG5cbiAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgICFlcXVhbEZ1bmMobmV3IFVpbnQ4QXJyYXkob2JqZWN0KSwgbmV3IFVpbnQ4QXJyYXkob3RoZXIpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGNhc2UgYm9vbFRhZzpcbiAgICBjYXNlIGRhdGVUYWc6XG4gICAgY2FzZSBudW1iZXJUYWc6XG4gICAgICAvLyBDb2VyY2UgYm9vbGVhbnMgdG8gYDFgIG9yIGAwYCBhbmQgZGF0ZXMgdG8gbWlsbGlzZWNvbmRzLlxuICAgICAgLy8gSW52YWxpZCBkYXRlcyBhcmUgY29lcmNlZCB0byBgTmFOYC5cbiAgICAgIHJldHVybiBlcSgrb2JqZWN0LCArb3RoZXIpO1xuXG4gICAgY2FzZSBlcnJvclRhZzpcbiAgICAgIHJldHVybiBvYmplY3QubmFtZSA9PSBvdGhlci5uYW1lICYmIG9iamVjdC5tZXNzYWdlID09IG90aGVyLm1lc3NhZ2U7XG5cbiAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgIC8vIENvZXJjZSByZWdleGVzIHRvIHN0cmluZ3MgYW5kIHRyZWF0IHN0cmluZ3MsIHByaW1pdGl2ZXMgYW5kIG9iamVjdHMsXG4gICAgICAvLyBhcyBlcXVhbC4gU2VlIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1yZWdleHAucHJvdG90eXBlLnRvc3RyaW5nXG4gICAgICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgcmV0dXJuIG9iamVjdCA9PSAob3RoZXIgKyAnJyk7XG5cbiAgICBjYXNlIG1hcFRhZzpcbiAgICAgIHZhciBjb252ZXJ0ID0gbWFwVG9BcnJheTtcblxuICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRztcbiAgICAgIGNvbnZlcnQgfHwgKGNvbnZlcnQgPSBzZXRUb0FycmF5KTtcblxuICAgICAgaWYgKG9iamVjdC5zaXplICE9IG90aGVyLnNpemUgJiYgIWlzUGFydGlhbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICAgICAgaWYgKHN0YWNrZWQpIHtcbiAgICAgICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gICAgICB9XG4gICAgICBiaXRtYXNrIHw9IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUc7XG5cbiAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICAgICAgdmFyIHJlc3VsdCA9IGVxdWFsQXJyYXlzKGNvbnZlcnQob2JqZWN0KSwgY29udmVydChvdGhlciksIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICAgICAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICBpZiAoc3ltYm9sVmFsdWVPZikge1xuICAgICAgICByZXR1cm4gc3ltYm9sVmFsdWVPZi5jYWxsKG9iamVjdCkgPT0gc3ltYm9sVmFsdWVPZi5jYWxsKG90aGVyKTtcbiAgICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBvYmplY3RzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICBvYmpQcm9wcyA9IGdldEFsbEtleXMob2JqZWN0KSxcbiAgICAgIG9iakxlbmd0aCA9IG9ialByb3BzLmxlbmd0aCxcbiAgICAgIG90aFByb3BzID0gZ2V0QWxsS2V5cyhvdGhlciksXG4gICAgICBvdGhMZW5ndGggPSBvdGhQcm9wcy5sZW5ndGg7XG5cbiAgaWYgKG9iakxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIWlzUGFydGlhbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgaW5kZXggPSBvYmpMZW5ndGg7XG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgdmFyIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICBpZiAoIShpc1BhcnRpYWwgPyBrZXkgaW4gb3RoZXIgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCBrZXkpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gIGlmIChzdGFja2VkICYmIHN0YWNrLmdldChvdGhlcikpIHtcbiAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgfVxuICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIG9iamVjdCk7XG5cbiAgdmFyIHNraXBDdG9yID0gaXNQYXJ0aWFsO1xuICB3aGlsZSAoKytpbmRleCA8IG9iakxlbmd0aCkge1xuICAgIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltrZXldO1xuXG4gICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIG9ialZhbHVlLCBrZXksIG90aGVyLCBvYmplY3QsIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIob2JqVmFsdWUsIG90aFZhbHVlLCBrZXksIG9iamVjdCwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKCEoY29tcGFyZWQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gKG9ialZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMob2JqVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpXG4gICAgICAgICAgOiBjb21wYXJlZFxuICAgICAgICApKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBza2lwQ3RvciB8fCAoc2tpcEN0b3IgPSBrZXkgPT0gJ2NvbnN0cnVjdG9yJyk7XG4gIH1cbiAgaWYgKHJlc3VsdCAmJiAhc2tpcEN0b3IpIHtcbiAgICB2YXIgb2JqQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcixcbiAgICAgICAgb3RoQ3RvciA9IG90aGVyLmNvbnN0cnVjdG9yO1xuXG4gICAgLy8gTm9uIGBPYmplY3RgIG9iamVjdCBpbnN0YW5jZXMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1YWwuXG4gICAgaWYgKG9iakN0b3IgIT0gb3RoQ3RvciAmJlxuICAgICAgICAoJ2NvbnN0cnVjdG9yJyBpbiBvYmplY3QgJiYgJ2NvbnN0cnVjdG9yJyBpbiBvdGhlcikgJiZcbiAgICAgICAgISh0eXBlb2Ygb2JqQ3RvciA9PSAnZnVuY3Rpb24nICYmIG9iakN0b3IgaW5zdGFuY2VvZiBvYmpDdG9yICYmXG4gICAgICAgICAgdHlwZW9mIG90aEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvdGhDdG9yIGluc3RhbmNlb2Ygb3RoQ3RvcikpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBnZXRBbGxLZXlzKG9iamVjdCkge1xuICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzLCBnZXRTeW1ib2xzKTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBkYXRhIGZvciBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcmVmZXJlbmNlIGtleS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cbiAqL1xuZnVuY3Rpb24gZ2V0TWFwRGF0YShtYXAsIGtleSkge1xuICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcbiAgcmV0dXJuIGlzS2V5YWJsZShrZXkpXG4gICAgPyBkYXRhW3R5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyAnc3RyaW5nJyA6ICdoYXNoJ11cbiAgICA6IGRhdGEubWFwO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIHByb3BlcnR5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG1hdGNoIGRhdGEgb2YgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGdldE1hdGNoRGF0YShvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IGtleXMob2JqZWN0KSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgdmFyIGtleSA9IHJlc3VsdFtsZW5ndGhdLFxuICAgICAgICB2YWx1ZSA9IG9iamVjdFtrZXldO1xuXG4gICAgcmVzdWx0W2xlbmd0aF0gPSBba2V5LCB2YWx1ZSwgaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKV07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gIHZhciB2YWx1ZSA9IGdldFZhbHVlKG9iamVjdCwga2V5KTtcbiAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gIHRyeSB7XG4gICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBpZiAodW5tYXNrZWQpIHtcbiAgICBpZiAoaXNPd24pIHtcbiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gKi9cbnZhciBnZXRTeW1ib2xzID0gIW5hdGl2ZUdldFN5bWJvbHMgPyBzdHViQXJyYXkgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICByZXR1cm4gYXJyYXlGaWx0ZXIobmF0aXZlR2V0U3ltYm9scyhvYmplY3QpLCBmdW5jdGlvbihzeW1ib2wpIHtcbiAgICByZXR1cm4gcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmplY3QsIHN5bWJvbCk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBgdG9TdHJpbmdUYWdgIG9mIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xudmFyIGdldFRhZyA9IGJhc2VHZXRUYWc7XG5cbi8vIEZhbGxiYWNrIGZvciBkYXRhIHZpZXdzLCBtYXBzLCBzZXRzLCBhbmQgd2VhayBtYXBzIGluIElFIDExIGFuZCBwcm9taXNlcyBpbiBOb2RlLmpzIDwgNi5cbmlmICgoRGF0YVZpZXcgJiYgZ2V0VGFnKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSkpKSAhPSBkYXRhVmlld1RhZykgfHxcbiAgICAoTWFwICYmIGdldFRhZyhuZXcgTWFwKSAhPSBtYXBUYWcpIHx8XG4gICAgKFByb21pc2UgJiYgZ2V0VGFnKFByb21pc2UucmVzb2x2ZSgpKSAhPSBwcm9taXNlVGFnKSB8fFxuICAgIChTZXQgJiYgZ2V0VGFnKG5ldyBTZXQpICE9IHNldFRhZykgfHxcbiAgICAoV2Vha01hcCAmJiBnZXRUYWcobmV3IFdlYWtNYXApICE9IHdlYWtNYXBUYWcpKSB7XG4gIGdldFRhZyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGJhc2VHZXRUYWcodmFsdWUpLFxuICAgICAgICBDdG9yID0gcmVzdWx0ID09IG9iamVjdFRhZyA/IHZhbHVlLmNvbnN0cnVjdG9yIDogdW5kZWZpbmVkLFxuICAgICAgICBjdG9yU3RyaW5nID0gQ3RvciA/IHRvU291cmNlKEN0b3IpIDogJyc7XG5cbiAgICBpZiAoY3RvclN0cmluZykge1xuICAgICAgc3dpdGNoIChjdG9yU3RyaW5nKSB7XG4gICAgICAgIGNhc2UgZGF0YVZpZXdDdG9yU3RyaW5nOiByZXR1cm4gZGF0YVZpZXdUYWc7XG4gICAgICAgIGNhc2UgbWFwQ3RvclN0cmluZzogcmV0dXJuIG1hcFRhZztcbiAgICAgICAgY2FzZSBwcm9taXNlQ3RvclN0cmluZzogcmV0dXJuIHByb21pc2VUYWc7XG4gICAgICAgIGNhc2Ugc2V0Q3RvclN0cmluZzogcmV0dXJuIHNldFRhZztcbiAgICAgICAgY2FzZSB3ZWFrTWFwQ3RvclN0cmluZzogcmV0dXJuIHdlYWtNYXBUYWc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwYXRoYCBleGlzdHMgb24gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFzRnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2sgcHJvcGVydGllcy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBoYXNGdW5jKSB7XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBmYWxzZTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSk7XG4gICAgaWYgKCEocmVzdWx0ID0gb2JqZWN0ICE9IG51bGwgJiYgaGFzRnVuYyhvYmplY3QsIGtleSkpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgb2JqZWN0ID0gb2JqZWN0W2tleV07XG4gIH1cbiAgaWYgKHJlc3VsdCB8fCArK2luZGV4ICE9IGxlbmd0aCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgbGVuZ3RoID0gb2JqZWN0ID09IG51bGwgPyAwIDogb2JqZWN0Lmxlbmd0aDtcbiAgcmV0dXJuICEhbGVuZ3RoICYmIGlzTGVuZ3RoKGxlbmd0aCkgJiYgaXNJbmRleChrZXksIGxlbmd0aCkgJiZcbiAgICAoaXNBcnJheShvYmplY3QpIHx8IGlzQXJndW1lbnRzKG9iamVjdCkpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuXG4gIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICh0eXBlID09ICdudW1iZXInIHx8XG4gICAgICAodHlwZSAhPSAnc3ltYm9sJyAmJiByZUlzVWludC50ZXN0KHZhbHVlKSkpICYmXG4gICAgICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUgYW5kIG5vdCBhIHByb3BlcnR5IHBhdGguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleSh2YWx1ZSwgb2JqZWN0KSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgaWYgKHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJyB8fFxuICAgICAgdmFsdWUgPT0gbnVsbCB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gcmVJc1BsYWluUHJvcC50ZXN0KHZhbHVlKSB8fCAhcmVJc0RlZXBQcm9wLnRlc3QodmFsdWUpIHx8XG4gICAgKG9iamVjdCAhPSBudWxsICYmIHZhbHVlIGluIE9iamVjdChvYmplY3QpKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3IgdXNlIGFzIHVuaXF1ZSBvYmplY3Qga2V5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5YWJsZSh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICh0eXBlID09ICdzdHJpbmcnIHx8IHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJylcbiAgICA/ICh2YWx1ZSAhPT0gJ19fcHJvdG9fXycpXG4gICAgOiAodmFsdWUgPT09IG51bGwpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGl0cyBzb3VyY2UgbWFza2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2VkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzTWFza2VkKGZ1bmMpIHtcbiAgcmV0dXJuICEhbWFza1NyY0tleSAmJiAobWFza1NyY0tleSBpbiBmdW5jKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaWYgc3VpdGFibGUgZm9yIHN0cmljdFxuICogIGVxdWFsaXR5IGNvbXBhcmlzb25zLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IHZhbHVlICYmICFpc09iamVjdCh2YWx1ZSk7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBtYXRjaGVzUHJvcGVydHlgIGZvciBzb3VyY2UgdmFsdWVzIHN1aXRhYmxlXG4gKiBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUoa2V5LCBzcmNWYWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Rba2V5XSA9PT0gc3JjVmFsdWUgJiZcbiAgICAgIChzcmNWYWx1ZSAhPT0gdW5kZWZpbmVkIHx8IChrZXkgaW4gT2JqZWN0KG9iamVjdCkpKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWVtb2l6ZWAgd2hpY2ggY2xlYXJzIHRoZSBtZW1vaXplZCBmdW5jdGlvbidzXG4gKiBjYWNoZSB3aGVuIGl0IGV4Y2VlZHMgYE1BWF9NRU1PSVpFX1NJWkVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZUNhcHBlZChmdW5jKSB7XG4gIHZhciByZXN1bHQgPSBtZW1vaXplKGZ1bmMsIGZ1bmN0aW9uKGtleSkge1xuICAgIGlmIChjYWNoZS5zaXplID09PSBNQVhfTUVNT0laRV9TSVpFKSB7XG4gICAgICBjYWNoZS5jbGVhcigpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5O1xuICB9KTtcblxuICB2YXIgY2FjaGUgPSByZXN1bHQuY2FjaGU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYHN0cmluZ2AgdG8gYSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqL1xudmFyIHN0cmluZ1RvUGF0aCA9IG1lbW9pemVDYXBwZWQoZnVuY3Rpb24oc3RyaW5nKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKHN0cmluZy5jaGFyQ29kZUF0KDApID09PSA0NiAvKiAuICovKSB7XG4gICAgcmVzdWx0LnB1c2goJycpO1xuICB9XG4gIHN0cmluZy5yZXBsYWNlKHJlUHJvcE5hbWUsIGZ1bmN0aW9uKG1hdGNoLCBudW1iZXIsIHF1b3RlLCBzdWJTdHJpbmcpIHtcbiAgICByZXN1bHQucHVzaChxdW90ZSA/IHN1YlN0cmluZy5yZXBsYWNlKHJlRXNjYXBlQ2hhciwgJyQxJykgOiAobnVtYmVyIHx8IG1hdGNoKSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufSk7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyBrZXkgaWYgaXQncyBub3QgYSBzdHJpbmcgb3Igc3ltYm9sLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHJldHVybnMge3N0cmluZ3xzeW1ib2x9IFJldHVybnMgdGhlIGtleS5cbiAqL1xuZnVuY3Rpb24gdG9LZXkodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGBmdW5jYCB0byBpdHMgc291cmNlIGNvZGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzb3VyY2UgY29kZS5cbiAqL1xuZnVuY3Rpb24gdG9Tb3VyY2UoZnVuYykge1xuICBpZiAoZnVuYyAhPSBudWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmdW5jVG9TdHJpbmcuY2FsbChmdW5jKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gKGZ1bmMgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kYCBleGNlcHQgdGhhdCBpdCByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3RcbiAqIGVsZW1lbnQgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yIGluc3RlYWQgb2YgdGhlIGVsZW1lbnQgaXRzZWxmLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMS4xLjBcbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZm91bmQgZWxlbWVudCwgZWxzZSBgLTFgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgdXNlcnMgPSBbXG4gKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiBmYWxzZSB9LFxuICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcbiAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IHRydWUgfVxuICogXTtcbiAqXG4gKiBfLmZpbmRJbmRleCh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby51c2VyID09ICdiYXJuZXknOyB9KTtcbiAqIC8vID0+IDBcbiAqXG4gKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maW5kSW5kZXgodXNlcnMsIHsgJ3VzZXInOiAnZnJlZCcsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAqIC8vID0+IDFcbiAqXG4gKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbmRJbmRleCh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICogLy8gPT4gMFxuICpcbiAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maW5kSW5kZXgodXNlcnMsICdhY3RpdmUnKTtcbiAqIC8vID0+IDJcbiAqL1xuZnVuY3Rpb24gZmluZEluZGV4KGFycmF5LCBwcmVkaWNhdGUsIGZyb21JbmRleCkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIHZhciBpbmRleCA9IGZyb21JbmRleCA9PSBudWxsID8gMCA6IHRvSW50ZWdlcihmcm9tSW5kZXgpO1xuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgaW5kZXggPSBuYXRpdmVNYXgobGVuZ3RoICsgaW5kZXgsIDApO1xuICB9XG4gIHJldHVybiBiYXNlRmluZEluZGV4KGFycmF5LCBiYXNlSXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgaW5kZXgpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG1lbW9pemVzIHRoZSByZXN1bHQgb2YgYGZ1bmNgLiBJZiBgcmVzb2x2ZXJgIGlzXG4gKiBwcm92aWRlZCwgaXQgZGV0ZXJtaW5lcyB0aGUgY2FjaGUga2V5IGZvciBzdG9yaW5nIHRoZSByZXN1bHQgYmFzZWQgb24gdGhlXG4gKiBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uLiBCeSBkZWZhdWx0LCB0aGUgZmlyc3QgYXJndW1lbnRcbiAqIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbiBpcyB1c2VkIGFzIHRoZSBtYXAgY2FjaGUga2V5LiBUaGUgYGZ1bmNgXG4gKiBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBtZW1vaXplZCBmdW5jdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogVGhlIGNhY2hlIGlzIGV4cG9zZWQgYXMgdGhlIGBjYWNoZWAgcHJvcGVydHkgb24gdGhlIG1lbW9pemVkXG4gKiBmdW5jdGlvbi4gSXRzIGNyZWF0aW9uIG1heSBiZSBjdXN0b21pemVkIGJ5IHJlcGxhY2luZyB0aGUgYF8ubWVtb2l6ZS5DYWNoZWBcbiAqIGNvbnN0cnVjdG9yIHdpdGggb25lIHdob3NlIGluc3RhbmNlcyBpbXBsZW1lbnQgdGhlXG4gKiBbYE1hcGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXByb3BlcnRpZXMtb2YtdGhlLW1hcC1wcm90b3R5cGUtb2JqZWN0KVxuICogbWV0aG9kIGludGVyZmFjZSBvZiBgY2xlYXJgLCBgZGVsZXRlYCwgYGdldGAsIGBoYXNgLCBhbmQgYHNldGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZXJdIFRoZSBmdW5jdGlvbiB0byByZXNvbHZlIHRoZSBjYWNoZSBrZXkuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2MnOiAzLCAnZCc6IDQgfTtcbiAqXG4gKiB2YXIgdmFsdWVzID0gXy5tZW1vaXplKF8udmFsdWVzKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogdmFsdWVzKG90aGVyKTtcbiAqIC8vID0+IFszLCA0XVxuICpcbiAqIG9iamVjdC5hID0gMjtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogLy8gTW9kaWZ5IHRoZSByZXN1bHQgY2FjaGUuXG4gKiB2YWx1ZXMuY2FjaGUuc2V0KG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsnYScsICdiJ11cbiAqXG4gKiAvLyBSZXBsYWNlIGBfLm1lbW9pemUuQ2FjaGVgLlxuICogXy5tZW1vaXplLkNhY2hlID0gV2Vha01hcDtcbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZShmdW5jLCByZXNvbHZlcikge1xuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJyB8fCAocmVzb2x2ZXIgIT0gbnVsbCAmJiB0eXBlb2YgcmVzb2x2ZXIgIT0gJ2Z1bmN0aW9uJykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgdmFyIG1lbW9pemVkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGtleSA9IHJlc29sdmVyID8gcmVzb2x2ZXIuYXBwbHkodGhpcywgYXJncykgOiBhcmdzWzBdLFxuICAgICAgICBjYWNoZSA9IG1lbW9pemVkLmNhY2hlO1xuXG4gICAgaWYgKGNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIG1lbW9pemVkLmNhY2hlID0gY2FjaGUuc2V0KGtleSwgcmVzdWx0KSB8fCBjYWNoZTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBtZW1vaXplZC5jYWNoZSA9IG5ldyAobWVtb2l6ZS5DYWNoZSB8fCBNYXBDYWNoZSk7XG4gIHJldHVybiBtZW1vaXplZDtcbn1cblxuLy8gRXhwb3NlIGBNYXBDYWNoZWAuXG5tZW1vaXplLkNhY2hlID0gTWFwQ2FjaGU7XG5cbi8qKlxuICogUGVyZm9ybXMgYVxuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAqXG4gKiBfLmVxKG9iamVjdCwgb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKCdhJywgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKCdhJywgT2JqZWN0KCdhJykpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKE5hTiwgTmFOKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gZXEodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPyBiYXNlSXNBcmd1bWVudHMgOiBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgIWlzRnVuY3Rpb24odmFsdWUpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IEJ1ZmZlcigyKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgVWludDhBcnJheSgyKSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2U7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0xlbmd0aCgzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aCgnMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KG5ldyBVaW50OEFycmF5KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShbXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNUeXBlZEFycmF5ID0gbm9kZUlzVHlwZWRBcnJheSA/IGJhc2VVbmFyeShub2RlSXNUeXBlZEFycmF5KSA6IGJhc2VJc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIGZpbml0ZSBudW1iZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEyLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b0Zpbml0ZSgzLjIpO1xuICogLy8gPT4gMy4yXG4gKlxuICogXy50b0Zpbml0ZShOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDVlLTMyNFxuICpcbiAqIF8udG9GaW5pdGUoSW5maW5pdHkpO1xuICogLy8gPT4gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDhcbiAqXG4gKiBfLnRvRmluaXRlKCczLjInKTtcbiAqIC8vID0+IDMuMlxuICovXG5mdW5jdGlvbiB0b0Zpbml0ZSh2YWx1ZSkge1xuICBpZiAoIXZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiAwO1xuICB9XG4gIHZhbHVlID0gdG9OdW1iZXIodmFsdWUpO1xuICBpZiAodmFsdWUgPT09IElORklOSVRZIHx8IHZhbHVlID09PSAtSU5GSU5JVFkpIHtcbiAgICB2YXIgc2lnbiA9ICh2YWx1ZSA8IDAgPyAtMSA6IDEpO1xuICAgIHJldHVybiBzaWduICogTUFYX0lOVEVHRVI7XG4gIH1cbiAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSA/IHZhbHVlIDogMDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGFuIGludGVnZXIuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9JbnRlZ2VyYF0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvaW50ZWdlcikuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgaW50ZWdlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b0ludGVnZXIoMy4yKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLnRvSW50ZWdlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDBcbiAqXG4gKiBfLnRvSW50ZWdlcihJbmZpbml0eSk7XG4gKiAvLyA9PiAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOFxuICpcbiAqIF8udG9JbnRlZ2VyKCczLjInKTtcbiAqIC8vID0+IDNcbiAqL1xuZnVuY3Rpb24gdG9JbnRlZ2VyKHZhbHVlKSB7XG4gIHZhciByZXN1bHQgPSB0b0Zpbml0ZSh2YWx1ZSksXG4gICAgICByZW1haW5kZXIgPSByZXN1bHQgJSAxO1xuXG4gIHJldHVybiByZXN1bHQgPT09IHJlc3VsdCA/IChyZW1haW5kZXIgPyByZXN1bHQgLSByZW1haW5kZXIgOiByZXN1bHQpIDogMDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgbnVtYmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbnVtYmVyLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvTnVtYmVyKDMuMik7XG4gKiAvLyA9PiAzLjJcbiAqXG4gKiBfLnRvTnVtYmVyKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gNWUtMzI0XG4gKlxuICogXy50b051bWJlcihJbmZpbml0eSk7XG4gKiAvLyA9PiBJbmZpbml0eVxuICpcbiAqIF8udG9OdW1iZXIoJzMuMicpO1xuICogLy8gPT4gMy4yXG4gKi9cbmZ1bmN0aW9uIHRvTnVtYmVyKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBOQU47XG4gIH1cbiAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHZhciBvdGhlciA9IHR5cGVvZiB2YWx1ZS52YWx1ZU9mID09ICdmdW5jdGlvbicgPyB2YWx1ZS52YWx1ZU9mKCkgOiB2YWx1ZTtcbiAgICB2YWx1ZSA9IGlzT2JqZWN0KG90aGVyKSA/IChvdGhlciArICcnKSA6IG90aGVyO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6ICt2YWx1ZTtcbiAgfVxuICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UocmVUcmltLCAnJyk7XG4gIHZhciBpc0JpbmFyeSA9IHJlSXNCaW5hcnkudGVzdCh2YWx1ZSk7XG4gIHJldHVybiAoaXNCaW5hcnkgfHwgcmVJc09jdGFsLnRlc3QodmFsdWUpKVxuICAgID8gZnJlZVBhcnNlSW50KHZhbHVlLnNsaWNlKDIpLCBpc0JpbmFyeSA/IDIgOiA4KVxuICAgIDogKHJlSXNCYWRIZXgudGVzdCh2YWx1ZSkgPyBOQU4gOiArdmFsdWUpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcuIEFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZCBmb3IgYG51bGxgXG4gKiBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzLiBUaGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9TdHJpbmcobnVsbCk7XG4gKiAvLyA9PiAnJ1xuICpcbiAqIF8udG9TdHJpbmcoLTApO1xuICogLy8gPT4gJy0wJ1xuICpcbiAqIF8udG9TdHJpbmcoWzEsIDIsIDNdKTtcbiAqIC8vID0+ICcxLDIsMydcbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IGJhc2VUb1N0cmluZyh2YWx1ZSk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgLiBJZiB0aGUgcmVzb2x2ZWQgdmFsdWUgaXNcbiAqIGB1bmRlZmluZWRgLCB0aGUgYGRlZmF1bHRWYWx1ZWAgaXMgcmV0dXJuZWQgaW4gaXRzIHBsYWNlLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy43LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IFtkZWZhdWx0VmFsdWVdIFRoZSB2YWx1ZSByZXR1cm5lZCBmb3IgYHVuZGVmaW5lZGAgcmVzb2x2ZWQgdmFsdWVzLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9XSB9O1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgJ2FbMF0uYi5jJyk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5nZXQob2JqZWN0LCBbJ2EnLCAnMCcsICdiJywgJ2MnXSk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5nZXQob2JqZWN0LCAnYS5iLmMnLCAnZGVmYXVsdCcpO1xuICogLy8gPT4gJ2RlZmF1bHQnXG4gKi9cbmZ1bmN0aW9uIGdldChvYmplY3QsIHBhdGgsIGRlZmF1bHRWYWx1ZSkge1xuICB2YXIgcmVzdWx0ID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHBhdGhgIGlzIGEgZGlyZWN0IG9yIGluaGVyaXRlZCBwcm9wZXJ0eSBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSBfLmNyZWF0ZSh7ICdhJzogXy5jcmVhdGUoeyAnYic6IDIgfSkgfSk7XG4gKlxuICogXy5oYXNJbihvYmplY3QsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsICdhLmInKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsICdiJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBoYXNJbihvYmplY3QsIHBhdGgpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBiYXNlSGFzSW4pO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXG4gKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5cyhuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiBfLmtleXMoJ2hpJyk7XG4gKiAvLyA9PiBbJzAnLCAnMSddXG4gKi9cbmZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QpIDogYmFzZUtleXMob2JqZWN0KTtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBpdCByZWNlaXZlcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZSBBbnkgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqXG4gKiBjb25zb2xlLmxvZyhfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlkZW50aXR5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYSBnaXZlbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBbXG4gKiAgIHsgJ2EnOiB7ICdiJzogMiB9IH0sXG4gKiAgIHsgJ2EnOiB7ICdiJzogMSB9IH1cbiAqIF07XG4gKlxuICogXy5tYXAob2JqZWN0cywgXy5wcm9wZXJ0eSgnYS5iJykpO1xuICogLy8gPT4gWzIsIDFdXG4gKlxuICogXy5tYXAoXy5zb3J0Qnkob2JqZWN0cywgXy5wcm9wZXJ0eShbJ2EnLCAnYiddKSksICdhLmInKTtcbiAqIC8vID0+IFsxLCAyXVxuICovXG5mdW5jdGlvbiBwcm9wZXJ0eShwYXRoKSB7XG4gIHJldHVybiBpc0tleShwYXRoKSA/IGJhc2VQcm9wZXJ0eSh0b0tleShwYXRoKSkgOiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpO1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgZW1wdHkgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBlbXB0eSBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIGFycmF5cyA9IF8udGltZXMoMiwgXy5zdHViQXJyYXkpO1xuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5cyk7XG4gKiAvLyA9PiBbW10sIFtdXVxuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5c1swXSA9PT0gYXJyYXlzWzFdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIHN0dWJBcnJheSgpIHtcbiAgcmV0dXJuIFtdO1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5zdHViRmFsc2UpO1xuICogLy8gPT4gW2ZhbHNlLCBmYWxzZV1cbiAqL1xuZnVuY3Rpb24gc3R1YkZhbHNlKCkge1xuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmluZEluZGV4O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.findindex/index.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.sortby/index.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.sortby/index.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, module) {/**\n * Lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize include=\"filter,sortBy,findIndex,find,forEach,cloneDeep\" exports=\"npm\"`\n * Copyright JS Foundation and other contributors <https://js.foundation/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used as the maximum memoize cache size. */\nvar MAX_MEMOIZE_SIZE = 500;\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/** Used to detect hot functions by number of calls within a span of milliseconds. */\nvar HOT_COUNT = 800,\n    HOT_SPAN = 16;\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0,\n    MAX_SAFE_INTEGER = 9007199254740991;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    asyncTag = '[object AsyncFunction]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    nullTag = '[object Null]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    proxyTag = '[object Proxy]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]',\n    undefinedTag = '[object Undefined]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/,\n    rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Detect free variable `exports`. */\nvar freeExports =  true && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * A faster alternative to `Function#apply`, this function invokes `func`\n * with the `this` binding of `thisArg` and the arguments of `args`.\n *\n * @private\n * @param {Function} func The function to invoke.\n * @param {*} thisArg The `this` binding of `func`.\n * @param {Array} args The arguments to invoke `func` with.\n * @returns {*} Returns the result of `func`.\n */\nfunction apply(func, thisArg, args) {\n  switch (args.length) {\n    case 0: return func.call(thisArg);\n    case 1: return func.call(thisArg, args[0]);\n    case 2: return func.call(thisArg, args[0], args[1]);\n    case 3: return func.call(thisArg, args[0], args[1], args[2]);\n  }\n  return func.apply(thisArg, args);\n}\n\n/**\n * A specialized version of `_.filter` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction arrayFilter(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      resIndex = 0,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index];\n    if (predicate(value, index, array)) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\n\n/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction arrayMap(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\n\n/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\n/**\n * A specialized version of `_.some` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */\nfunction arraySome(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (predicate(array[index], index, array)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction baseProperty(key) {\n  return function(object) {\n    return object == null ? undefined : object[key];\n  };\n}\n\n/**\n * The base implementation of `_.sortBy` which uses `comparer` to define the\n * sort order of `array` and replaces criteria objects with their corresponding\n * values.\n *\n * @private\n * @param {Array} array The array to sort.\n * @param {Function} comparer The function to define sort order.\n * @returns {Array} Returns `array`.\n */\nfunction baseSortBy(array, comparer) {\n  var length = array.length;\n\n  array.sort(comparer);\n  while (length--) {\n    array[length] = array[length].value;\n  }\n  return array;\n}\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\n/**\n * Checks if a `cache` value for `key` exists.\n *\n * @private\n * @param {Object} cache The cache to query.\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction cacheHas(cache, key) {\n  return cache.has(key);\n}\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined,\n    Symbol = root.Symbol,\n    Uint8Array = root.Uint8Array,\n    propertyIsEnumerable = objectProto.propertyIsEnumerable,\n    splice = arrayProto.splice,\n    spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined,\n    symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\nvar defineProperty = (function() {\n  try {\n    var func = getNative(Object, 'defineProperty');\n    func({}, '', {});\n    return func;\n  } catch (e) {}\n}());\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols,\n    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\n    nativeKeys = overArg(Object.keys, Object),\n    nativeMax = Math.max,\n    nativeNow = Date.now;\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView'),\n    Map = getNative(root, 'Map'),\n    Promise = getNative(root, 'Promise'),\n    Set = getNative(root, 'Set'),\n    WeakMap = getNative(root, 'WeakMap'),\n    nativeCreate = getNative(Object, 'create');\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n *\n * Creates an array cache object to store unique values.\n *\n * @private\n * @constructor\n * @param {Array} [values] The values to cache.\n */\nfunction SetCache(values) {\n  var index = -1,\n      length = values == null ? 0 : values.length;\n\n  this.__data__ = new MapCache;\n  while (++index < length) {\n    this.add(values[index]);\n  }\n}\n\n/**\n * Adds `value` to the array cache.\n *\n * @private\n * @name add\n * @memberOf SetCache\n * @alias push\n * @param {*} value The value to cache.\n * @returns {Object} Returns the cache instance.\n */\nfunction setCacheAdd(value) {\n  this.__data__.set(value, HASH_UNDEFINED);\n  return this;\n}\n\n/**\n * Checks if `value` is in the array cache.\n *\n * @private\n * @name has\n * @memberOf SetCache\n * @param {*} value The value to search for.\n * @returns {number} Returns `true` if `value` is found, else `false`.\n */\nfunction setCacheHas(value) {\n  return this.__data__.has(value);\n}\n\n// Add methods to `SetCache`.\nSetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\nSetCache.prototype.has = setCacheHas;\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  var data = this.__data__ = new ListCache(entries);\n  this.size = data.size;\n}\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  var data = this.__data__,\n      result = data['delete'](key);\n\n  this.size = data.size;\n  return result;\n}\n\n/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\n/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var data = this.__data__;\n  if (data instanceof ListCache) {\n    var pairs = data.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      this.size = ++data.size;\n      return this;\n    }\n    data = this.__data__ = new MapCache(pairs);\n  }\n  data.set(key, value);\n  this.size = data.size;\n  return this;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.forEach` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array|Object} Returns `collection`.\n */\nvar baseEach = createBaseEach(baseForOwn);\n\n/**\n * The base implementation of `_.flatten` with support for restricting flattening.\n *\n * @private\n * @param {Array} array The array to flatten.\n * @param {number} depth The maximum recursion depth.\n * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.\n * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.\n * @param {Array} [result=[]] The initial result value.\n * @returns {Array} Returns the new flattened array.\n */\nfunction baseFlatten(array, depth, predicate, isStrict, result) {\n  var index = -1,\n      length = array.length;\n\n  predicate || (predicate = isFlattenable);\n  result || (result = []);\n\n  while (++index < length) {\n    var value = array[index];\n    if (depth > 0 && predicate(value)) {\n      if (depth > 1) {\n        // Recursively flatten arrays (susceptible to call stack limits).\n        baseFlatten(value, depth - 1, predicate, isStrict, result);\n      } else {\n        arrayPush(result, value);\n      }\n    } else if (!isStrict) {\n      result[result.length] = value;\n    }\n  }\n  return result;\n}\n\n/**\n * The base implementation of `baseForOwn` which iterates over `object`\n * properties returned by `keysFunc` and invokes `iteratee` for each property.\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @returns {Object} Returns `object`.\n */\nvar baseFor = createBaseFor();\n\n/**\n * The base implementation of `_.forOwn` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Object} Returns `object`.\n */\nfunction baseForOwn(object, iteratee) {\n  return object && baseFor(object, iteratee, keys);\n}\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = castPath(path, object);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n}\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\n/**\n * The base implementation of `_.hasIn` without support for deep paths.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {Array|string} key The key to check.\n * @returns {boolean} Returns `true` if `key` exists, else `false`.\n */\nfunction baseHasIn(object, key) {\n  return object != null && key in Object(object);\n}\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\n/**\n * The base implementation of `_.isEqual` which supports partial comparisons\n * and tracks traversed objects.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Unordered comparison\n *  2 - Partial comparison\n * @param {Function} [customizer] The function to customize comparisons.\n * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n */\nfunction baseIsEqual(value, other, bitmask, customizer, stack) {\n  if (value === other) {\n    return true;\n  }\n  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {\n    return value !== value && other !== other;\n  }\n  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n}\n\n/**\n * A specialized version of `baseIsEqual` for arrays and objects which performs\n * deep comparisons and tracks traversed objects enabling objects with circular\n * references to be compared.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n  var objIsArr = isArray(object),\n      othIsArr = isArray(other),\n      objTag = objIsArr ? arrayTag : getTag(object),\n      othTag = othIsArr ? arrayTag : getTag(other);\n\n  objTag = objTag == argsTag ? objectTag : objTag;\n  othTag = othTag == argsTag ? objectTag : othTag;\n\n  var objIsObj = objTag == objectTag,\n      othIsObj = othTag == objectTag,\n      isSameTag = objTag == othTag;\n\n  if (isSameTag && isBuffer(object)) {\n    if (!isBuffer(other)) {\n      return false;\n    }\n    objIsArr = true;\n    objIsObj = false;\n  }\n  if (isSameTag && !objIsObj) {\n    stack || (stack = new Stack);\n    return (objIsArr || isTypedArray(object))\n      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)\n      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n  }\n  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\n    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n    if (objIsWrapped || othIsWrapped) {\n      var objUnwrapped = objIsWrapped ? object.value() : object,\n          othUnwrapped = othIsWrapped ? other.value() : other;\n\n      stack || (stack = new Stack);\n      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n    }\n  }\n  if (!isSameTag) {\n    return false;\n  }\n  stack || (stack = new Stack);\n  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n}\n\n/**\n * The base implementation of `_.isMatch` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to inspect.\n * @param {Object} source The object of property values to match.\n * @param {Array} matchData The property names, values, and compare flags to match.\n * @param {Function} [customizer] The function to customize comparisons.\n * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n */\nfunction baseIsMatch(object, source, matchData, customizer) {\n  var index = matchData.length,\n      length = index,\n      noCustomizer = !customizer;\n\n  if (object == null) {\n    return !length;\n  }\n  object = Object(object);\n  while (index--) {\n    var data = matchData[index];\n    if ((noCustomizer && data[2])\n          ? data[1] !== object[data[0]]\n          : !(data[0] in object)\n        ) {\n      return false;\n    }\n  }\n  while (++index < length) {\n    data = matchData[index];\n    var key = data[0],\n        objValue = object[key],\n        srcValue = data[1];\n\n    if (noCustomizer && data[2]) {\n      if (objValue === undefined && !(key in object)) {\n        return false;\n      }\n    } else {\n      var stack = new Stack;\n      if (customizer) {\n        var result = customizer(objValue, srcValue, key, object, source, stack);\n      }\n      if (!(result === undefined\n            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)\n            : result\n          )) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\n/**\n * The base implementation of `_.iteratee`.\n *\n * @private\n * @param {*} [value=_.identity] The value to convert to an iteratee.\n * @returns {Function} Returns the iteratee.\n */\nfunction baseIteratee(value) {\n  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n  if (typeof value == 'function') {\n    return value;\n  }\n  if (value == null) {\n    return identity;\n  }\n  if (typeof value == 'object') {\n    return isArray(value)\n      ? baseMatchesProperty(value[0], value[1])\n      : baseMatches(value);\n  }\n  return property(value);\n}\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.map` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction baseMap(collection, iteratee) {\n  var index = -1,\n      result = isArrayLike(collection) ? Array(collection.length) : [];\n\n  baseEach(collection, function(value, key, collection) {\n    result[++index] = iteratee(value, key, collection);\n  });\n  return result;\n}\n\n/**\n * The base implementation of `_.matches` which doesn't clone `source`.\n *\n * @private\n * @param {Object} source The object of property values to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatches(source) {\n  var matchData = getMatchData(source);\n  if (matchData.length == 1 && matchData[0][2]) {\n    return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n  }\n  return function(object) {\n    return object === source || baseIsMatch(object, source, matchData);\n  };\n}\n\n/**\n * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n *\n * @private\n * @param {string} path The path of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatchesProperty(path, srcValue) {\n  if (isKey(path) && isStrictComparable(srcValue)) {\n    return matchesStrictComparable(toKey(path), srcValue);\n  }\n  return function(object) {\n    var objValue = get(object, path);\n    return (objValue === undefined && objValue === srcValue)\n      ? hasIn(object, path)\n      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);\n  };\n}\n\n/**\n * The base implementation of `_.orderBy` without param guards.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.\n * @param {string[]} orders The sort orders of `iteratees`.\n * @returns {Array} Returns the new sorted array.\n */\nfunction baseOrderBy(collection, iteratees, orders) {\n  var index = -1;\n  iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(baseIteratee));\n\n  var result = baseMap(collection, function(value, key, collection) {\n    var criteria = arrayMap(iteratees, function(iteratee) {\n      return iteratee(value);\n    });\n    return { 'criteria': criteria, 'index': ++index, 'value': value };\n  });\n\n  return baseSortBy(result, function(object, other) {\n    return compareMultiple(object, other, orders);\n  });\n}\n\n/**\n * A specialized version of `baseProperty` which supports deep paths.\n *\n * @private\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction basePropertyDeep(path) {\n  return function(object) {\n    return baseGet(object, path);\n  };\n}\n\n/**\n * The base implementation of `_.rest` which doesn't validate or coerce arguments.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @returns {Function} Returns the new function.\n */\nfunction baseRest(func, start) {\n  return setToString(overRest(func, start, identity), func + '');\n}\n\n/**\n * The base implementation of `setToString` without support for hot loop shorting.\n *\n * @private\n * @param {Function} func The function to modify.\n * @param {Function} string The `toString` result.\n * @returns {Function} Returns `func`.\n */\nvar baseSetToString = !defineProperty ? identity : function(func, string) {\n  return defineProperty(func, 'toString', {\n    'configurable': true,\n    'enumerable': false,\n    'value': constant(string),\n    'writable': true\n  });\n};\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isArray(value)) {\n    // Recursively convert values (susceptible to call stack limits).\n    return arrayMap(value, baseToString) + '';\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @param {Object} [object] The object to query keys on.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value, object) {\n  if (isArray(value)) {\n    return value;\n  }\n  return isKey(value, object) ? [value] : stringToPath(toString(value));\n}\n\n/**\n * Compares values to sort them in ascending order.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {number} Returns the sort order indicator for `value`.\n */\nfunction compareAscending(value, other) {\n  if (value !== other) {\n    var valIsDefined = value !== undefined,\n        valIsNull = value === null,\n        valIsReflexive = value === value,\n        valIsSymbol = isSymbol(value);\n\n    var othIsDefined = other !== undefined,\n        othIsNull = other === null,\n        othIsReflexive = other === other,\n        othIsSymbol = isSymbol(other);\n\n    if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||\n        (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||\n        (valIsNull && othIsDefined && othIsReflexive) ||\n        (!valIsDefined && othIsReflexive) ||\n        !valIsReflexive) {\n      return 1;\n    }\n    if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||\n        (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||\n        (othIsNull && valIsDefined && valIsReflexive) ||\n        (!othIsDefined && valIsReflexive) ||\n        !othIsReflexive) {\n      return -1;\n    }\n  }\n  return 0;\n}\n\n/**\n * Used by `_.orderBy` to compare multiple properties of a value to another\n * and stable sort them.\n *\n * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,\n * specify an order of \"desc\" for descending or \"asc\" for ascending sort order\n * of corresponding values.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {boolean[]|string[]} orders The order to sort by for each property.\n * @returns {number} Returns the sort order indicator for `object`.\n */\nfunction compareMultiple(object, other, orders) {\n  var index = -1,\n      objCriteria = object.criteria,\n      othCriteria = other.criteria,\n      length = objCriteria.length,\n      ordersLength = orders.length;\n\n  while (++index < length) {\n    var result = compareAscending(objCriteria[index], othCriteria[index]);\n    if (result) {\n      if (index >= ordersLength) {\n        return result;\n      }\n      var order = orders[index];\n      return result * (order == 'desc' ? -1 : 1);\n    }\n  }\n  // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications\n  // that causes it, under certain circumstances, to provide the same value for\n  // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247\n  // for more details.\n  //\n  // This also ensures a stable sort in V8 and other engines.\n  // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.\n  return object.index - other.index;\n}\n\n/**\n * Creates a `baseEach` or `baseEachRight` function.\n *\n * @private\n * @param {Function} eachFunc The function to iterate over a collection.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseEach(eachFunc, fromRight) {\n  return function(collection, iteratee) {\n    if (collection == null) {\n      return collection;\n    }\n    if (!isArrayLike(collection)) {\n      return eachFunc(collection, iteratee);\n    }\n    var length = collection.length,\n        index = fromRight ? length : -1,\n        iterable = Object(collection);\n\n    while ((fromRight ? index-- : ++index < length)) {\n      if (iteratee(iterable[index], index, iterable) === false) {\n        break;\n      }\n    }\n    return collection;\n  };\n}\n\n/**\n * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseFor(fromRight) {\n  return function(object, iteratee, keysFunc) {\n    var index = -1,\n        iterable = Object(object),\n        props = keysFunc(object),\n        length = props.length;\n\n    while (length--) {\n      var key = props[fromRight ? length : ++index];\n      if (iteratee(iterable[key], key, iterable) === false) {\n        break;\n      }\n    }\n    return object;\n  };\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for arrays with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Array} array The array to compare.\n * @param {Array} other The other array to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `array` and `other` objects.\n * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n */\nfunction equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      arrLength = array.length,\n      othLength = other.length;\n\n  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n    return false;\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(array);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var index = -1,\n      result = true,\n      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;\n\n  stack.set(array, other);\n  stack.set(other, array);\n\n  // Ignore non-index properties.\n  while (++index < arrLength) {\n    var arrValue = array[index],\n        othValue = other[index];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, arrValue, index, other, array, stack)\n        : customizer(arrValue, othValue, index, array, other, stack);\n    }\n    if (compared !== undefined) {\n      if (compared) {\n        continue;\n      }\n      result = false;\n      break;\n    }\n    // Recursively compare arrays (susceptible to call stack limits).\n    if (seen) {\n      if (!arraySome(other, function(othValue, othIndex) {\n            if (!cacheHas(seen, othIndex) &&\n                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n              return seen.push(othIndex);\n            }\n          })) {\n        result = false;\n        break;\n      }\n    } else if (!(\n          arrValue === othValue ||\n            equalFunc(arrValue, othValue, bitmask, customizer, stack)\n        )) {\n      result = false;\n      break;\n    }\n  }\n  stack['delete'](array);\n  stack['delete'](other);\n  return result;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for comparing objects of\n * the same `toStringTag`.\n *\n * **Note:** This function only supports comparing values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {string} tag The `toStringTag` of the objects to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n  switch (tag) {\n    case dataViewTag:\n      if ((object.byteLength != other.byteLength) ||\n          (object.byteOffset != other.byteOffset)) {\n        return false;\n      }\n      object = object.buffer;\n      other = other.buffer;\n\n    case arrayBufferTag:\n      if ((object.byteLength != other.byteLength) ||\n          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n        return false;\n      }\n      return true;\n\n    case boolTag:\n    case dateTag:\n    case numberTag:\n      // Coerce booleans to `1` or `0` and dates to milliseconds.\n      // Invalid dates are coerced to `NaN`.\n      return eq(+object, +other);\n\n    case errorTag:\n      return object.name == other.name && object.message == other.message;\n\n    case regexpTag:\n    case stringTag:\n      // Coerce regexes to strings and treat strings, primitives and objects,\n      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n      // for more details.\n      return object == (other + '');\n\n    case mapTag:\n      var convert = mapToArray;\n\n    case setTag:\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\n      convert || (convert = setToArray);\n\n      if (object.size != other.size && !isPartial) {\n        return false;\n      }\n      // Assume cyclic values are equal.\n      var stacked = stack.get(object);\n      if (stacked) {\n        return stacked == other;\n      }\n      bitmask |= COMPARE_UNORDERED_FLAG;\n\n      // Recursively compare objects (susceptible to call stack limits).\n      stack.set(object, other);\n      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n      stack['delete'](object);\n      return result;\n\n    case symbolTag:\n      if (symbolValueOf) {\n        return symbolValueOf.call(object) == symbolValueOf.call(other);\n      }\n  }\n  return false;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for objects with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      objProps = getAllKeys(object),\n      objLength = objProps.length,\n      othProps = getAllKeys(other),\n      othLength = othProps.length;\n\n  if (objLength != othLength && !isPartial) {\n    return false;\n  }\n  var index = objLength;\n  while (index--) {\n    var key = objProps[index];\n    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n      return false;\n    }\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(object);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var result = true;\n  stack.set(object, other);\n  stack.set(other, object);\n\n  var skipCtor = isPartial;\n  while (++index < objLength) {\n    key = objProps[index];\n    var objValue = object[key],\n        othValue = other[key];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, objValue, key, other, object, stack)\n        : customizer(objValue, othValue, key, object, other, stack);\n    }\n    // Recursively compare objects (susceptible to call stack limits).\n    if (!(compared === undefined\n          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))\n          : compared\n        )) {\n      result = false;\n      break;\n    }\n    skipCtor || (skipCtor = key == 'constructor');\n  }\n  if (result && !skipCtor) {\n    var objCtor = object.constructor,\n        othCtor = other.constructor;\n\n    // Non `Object` object instances with different constructors are not equal.\n    if (objCtor != othCtor &&\n        ('constructor' in object && 'constructor' in other) &&\n        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n          typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n      result = false;\n    }\n  }\n  stack['delete'](object);\n  stack['delete'](other);\n  return result;\n}\n\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n  return baseGetAllKeys(object, keys, getSymbols);\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the property names, values, and compare flags of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the match data of `object`.\n */\nfunction getMatchData(object) {\n  var result = keys(object),\n      length = result.length;\n\n  while (length--) {\n    var key = result[length],\n        value = object[key];\n\n    result[length] = [key, value, isStrictComparable(value)];\n  }\n  return result;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\n/**\n * Creates an array of the own enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = !nativeGetSymbols ? stubArray : function(object) {\n  if (object == null) {\n    return [];\n  }\n  object = Object(object);\n  return arrayFilter(nativeGetSymbols(object), function(symbol) {\n    return propertyIsEnumerable.call(object, symbol);\n  });\n};\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = baseGetTag(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : '';\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\n/**\n * Checks if `path` exists on `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @param {Function} hasFunc The function to check properties.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n */\nfunction hasPath(object, path, hasFunc) {\n  path = castPath(path, object);\n\n  var index = -1,\n      length = path.length,\n      result = false;\n\n  while (++index < length) {\n    var key = toKey(path[index]);\n    if (!(result = object != null && hasFunc(object, key))) {\n      break;\n    }\n    object = object[key];\n  }\n  if (result || ++index != length) {\n    return result;\n  }\n  length = object == null ? 0 : object.length;\n  return !!length && isLength(length) && isIndex(key, length) &&\n    (isArray(object) || isArguments(object));\n}\n\n/**\n * Checks if `value` is a flattenable `arguments` object or array.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.\n */\nfunction isFlattenable(value) {\n  return isArray(value) || isArguments(value) ||\n    !!(spreadableSymbol && value && value[spreadableSymbol]);\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  var type = typeof value;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n\n  return !!length &&\n    (type == 'number' ||\n      (type != 'symbol' && reIsUint.test(value))) &&\n        (value > -1 && value % 1 == 0 && value < length);\n}\n\n/**\n * Checks if the given arguments are from an iteratee call.\n *\n * @private\n * @param {*} value The potential iteratee value argument.\n * @param {*} index The potential iteratee index or key argument.\n * @param {*} object The potential iteratee object argument.\n * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\n *  else `false`.\n */\nfunction isIterateeCall(value, index, object) {\n  if (!isObject(object)) {\n    return false;\n  }\n  var type = typeof index;\n  if (type == 'number'\n        ? (isArrayLike(object) && isIndex(index, object.length))\n        : (type == 'string' && index in object)\n      ) {\n    return eq(object[index], value);\n  }\n  return false;\n}\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\n/**\n * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` if suitable for strict\n *  equality comparisons, else `false`.\n */\nfunction isStrictComparable(value) {\n  return value === value && !isObject(value);\n}\n\n/**\n * A specialized version of `matchesProperty` for source values suitable\n * for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction matchesStrictComparable(key, srcValue) {\n  return function(object) {\n    if (object == null) {\n      return false;\n    }\n    return object[key] === srcValue &&\n      (srcValue !== undefined || (key in Object(object)));\n  };\n}\n\n/**\n * A specialized version of `_.memoize` which clears the memoized function's\n * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n *\n * @private\n * @param {Function} func The function to have its output memoized.\n * @returns {Function} Returns the new memoized function.\n */\nfunction memoizeCapped(func) {\n  var result = memoize(func, function(key) {\n    if (cache.size === MAX_MEMOIZE_SIZE) {\n      cache.clear();\n    }\n    return key;\n  });\n\n  var cache = result.cache;\n  return result;\n}\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\n/**\n * A specialized version of `baseRest` which transforms the rest array.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @param {Function} transform The rest array transform.\n * @returns {Function} Returns the new function.\n */\nfunction overRest(func, start, transform) {\n  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);\n  return function() {\n    var args = arguments,\n        index = -1,\n        length = nativeMax(args.length - start, 0),\n        array = Array(length);\n\n    while (++index < length) {\n      array[index] = args[start + index];\n    }\n    index = -1;\n    var otherArgs = Array(start + 1);\n    while (++index < start) {\n      otherArgs[index] = args[index];\n    }\n    otherArgs[start] = transform(array);\n    return apply(func, this, otherArgs);\n  };\n}\n\n/**\n * Sets the `toString` method of `func` to return `string`.\n *\n * @private\n * @param {Function} func The function to modify.\n * @param {Function} string The `toString` result.\n * @returns {Function} Returns `func`.\n */\nvar setToString = shortOut(baseSetToString);\n\n/**\n * Creates a function that'll short out and invoke `identity` instead\n * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`\n * milliseconds.\n *\n * @private\n * @param {Function} func The function to restrict.\n * @returns {Function} Returns the new shortable function.\n */\nfunction shortOut(func) {\n  var count = 0,\n      lastCalled = 0;\n\n  return function() {\n    var stamp = nativeNow(),\n        remaining = HOT_SPAN - (stamp - lastCalled);\n\n    lastCalled = stamp;\n    if (remaining > 0) {\n      if (++count >= HOT_COUNT) {\n        return arguments[0];\n      }\n    } else {\n      count = 0;\n    }\n    return func.apply(undefined, arguments);\n  };\n}\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoizeCapped(function(string) {\n  var result = [];\n  if (string.charCodeAt(0) === 46 /* . */) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, subString) {\n    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * Creates an array of elements, sorted in ascending order by the results of\n * running each element in a collection thru each iteratee. This method\n * performs a stable sort, that is, it preserves the original sort order of\n * equal elements. The iteratees are invoked with one argument: (value).\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {...(Function|Function[])} [iteratees=[_.identity]]\n *  The iteratees to sort by.\n * @returns {Array} Returns the new sorted array.\n * @example\n *\n * var users = [\n *   { 'user': 'fred',   'age': 48 },\n *   { 'user': 'barney', 'age': 36 },\n *   { 'user': 'fred',   'age': 40 },\n *   { 'user': 'barney', 'age': 34 }\n * ];\n *\n * _.sortBy(users, [function(o) { return o.user; }]);\n * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]\n *\n * _.sortBy(users, ['user', 'age']);\n * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]\n */\nvar sortBy = baseRest(function(collection, iteratees) {\n  if (collection == null) {\n    return [];\n  }\n  var length = iteratees.length;\n  if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {\n    iteratees = [];\n  } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {\n    iteratees = [iteratees[0]];\n  }\n  return baseOrderBy(collection, baseFlatten(iteratees, 1), []);\n});\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result) || cache;\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Expose `MapCache`.\nmemoize.Cache = MapCache;\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get(object, path, defaultValue) {\n  var result = object == null ? undefined : baseGet(object, path);\n  return result === undefined ? defaultValue : result;\n}\n\n/**\n * Checks if `path` is a direct or inherited property of `object`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n * @example\n *\n * var object = _.create({ 'a': _.create({ 'b': 2 }) });\n *\n * _.hasIn(object, 'a');\n * // => true\n *\n * _.hasIn(object, 'a.b');\n * // => true\n *\n * _.hasIn(object, ['a', 'b']);\n * // => true\n *\n * _.hasIn(object, 'b');\n * // => false\n */\nfunction hasIn(object, path) {\n  return object != null && hasPath(object, path, baseHasIn);\n}\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\n/**\n * Creates a function that returns `value`.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {*} value The value to return from the new function.\n * @returns {Function} Returns the new constant function.\n * @example\n *\n * var objects = _.times(2, _.constant({ 'a': 1 }));\n *\n * console.log(objects);\n * // => [{ 'a': 1 }, { 'a': 1 }]\n *\n * console.log(objects[0] === objects[1]);\n * // => true\n */\nfunction constant(value) {\n  return function() {\n    return value;\n  };\n}\n\n/**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\n/**\n * Creates a function that returns the value at `path` of a given object.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n * @example\n *\n * var objects = [\n *   { 'a': { 'b': 2 } },\n *   { 'a': { 'b': 1 } }\n * ];\n *\n * _.map(objects, _.property('a.b'));\n * // => [2, 1]\n *\n * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n * // => [1, 2]\n */\nfunction property(path) {\n  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n}\n\n/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n  return [];\n}\n\n/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = sortBy;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../../../../../webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9sb2Rhc2gtY3VzdG9tLWJ1aWxkL21vZHVsYXJpemUvbG9kYXNoLnNvcnRieS9pbmRleC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Aa2lzc215YnV0dG9uL21vdG9yY29ydGV4L2xvZGFzaC1jdXN0b20tYnVpbGQvbW9kdWxhcml6ZS9sb2Rhc2guc29ydGJ5L2luZGV4LmpzP2FjM2YiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBMb2Rhc2ggKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGluY2x1ZGU9XCJmaWx0ZXIsc29ydEJ5LGZpbmRJbmRleCxmaW5kLGZvckVhY2gsY2xvbmVEZWVwXCIgZXhwb3J0cz1cIm5wbVwiYFxuICogQ29weXJpZ2h0IEpTIEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9qcy5mb3VuZGF0aW9uLz5cbiAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqL1xuXG4vKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbnZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4vKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKiBVc2VkIGFzIHRoZSBtYXhpbXVtIG1lbW9pemUgY2FjaGUgc2l6ZS4gKi9cbnZhciBNQVhfTUVNT0laRV9TSVpFID0gNTAwO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3QgZnVuY3Rpb25zIGJ5IG51bWJlciBvZiBjYWxscyB3aXRoaW4gYSBzcGFuIG9mIG1pbGxpc2Vjb25kcy4gKi9cbnZhciBIT1RfQ09VTlQgPSA4MDAsXG4gICAgSE9UX1NQQU4gPSAxNjtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMCxcbiAgICBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcHJvbWlzZVRhZyA9ICdbb2JqZWN0IFByb21pc2VdJyxcbiAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXScsXG4gICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUlzRGVlcFByb3AgPSAvXFwufFxcWyg/OlteW1xcXV0qfChbXCInXSkoPzooPyFcXDEpW15cXFxcXXxcXFxcLikqP1xcMSlcXF0vLFxuICAgIHJlSXNQbGFpblByb3AgPSAvXlxcdyokLyxcbiAgICByZVByb3BOYW1lID0gL1teLltcXF1dK3xcXFsoPzooLT9cXGQrKD86XFwuXFxkKyk/KXwoW1wiJ10pKCg/Oig/IVxcMilbXlxcXFxdfFxcXFwuKSo/KVxcMilcXF18KD89KD86XFwufFxcW1xcXSkoPzpcXC58XFxbXFxdfCQpKS9nO1xuXG4vKipcbiAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxuICovXG52YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nO1xuXG4vKiogVXNlZCB0byBtYXRjaCBiYWNrc2xhc2hlcyBpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUVzY2FwZUNoYXIgPSAvXFxcXChcXFxcKT8vZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkpLiAqL1xudmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbi8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cbnZhciByZUlzVWludCA9IC9eKD86MHxbMS05XVxcZCopJC87XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cbnZhciB0eXBlZEFycmF5VGFncyA9IHt9O1xudHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG50eXBlZEFycmF5VGFnc1thcmdzVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XG50eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9XG50eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9XG50eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9XG50eXBlZEFycmF5VGFnc1ttYXBUYWddID0gdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9XG50eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID0gdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9XG50eXBlZEFycmF5VGFnc1tzZXRUYWddID0gdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9XG50eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBwcm9jZXNzYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZVByb2Nlc3MgPSBtb2R1bGVFeHBvcnRzICYmIGZyZWVHbG9iYWwucHJvY2VzcztcblxuLyoqIFVzZWQgdG8gYWNjZXNzIGZhc3RlciBOb2RlLmpzIGhlbHBlcnMuICovXG52YXIgbm9kZVV0aWwgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGZyZWVQcm9jZXNzICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcgJiYgZnJlZVByb2Nlc3MuYmluZGluZygndXRpbCcpO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxuLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbnZhciBub2RlSXNUeXBlZEFycmF5ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNUeXBlZEFycmF5O1xuXG4vKipcbiAqIEEgZmFzdGVyIGFsdGVybmF0aXZlIHRvIGBGdW5jdGlvbiNhcHBseWAsIHRoaXMgZnVuY3Rpb24gaW52b2tlcyBgZnVuY2BcbiAqIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIGB0aGlzQXJnYCBhbmQgdGhlIGFyZ3VtZW50cyBvZiBgYXJnc2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGludm9rZS5cbiAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBgZnVuY2Agd2l0aC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYGZ1bmNgLlxuICovXG5mdW5jdGlvbiBhcHBseShmdW5jLCB0aGlzQXJnLCBhcmdzKSB7XG4gIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICBjYXNlIDA6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZyk7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0pO1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZpbHRlcmAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheUZpbHRlcihhcnJheSwgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXNJbmRleCA9IDAsXG4gICAgICByZXN1bHQgPSBbXTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWFwYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TWFwKGFycmF5LCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBBcHBlbmRzIHRoZSBlbGVtZW50cyBvZiBgdmFsdWVzYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYXBwZW5kLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5UHVzaChhcnJheSwgdmFsdWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIG9mZnNldCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W29mZnNldCArIGluZGV4XSA9IHZhbHVlc1tpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zb21lYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlTb21lKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eShrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICB9O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNvcnRCeWAgd2hpY2ggdXNlcyBgY29tcGFyZXJgIHRvIGRlZmluZSB0aGVcbiAqIHNvcnQgb3JkZXIgb2YgYGFycmF5YCBhbmQgcmVwbGFjZXMgY3JpdGVyaWEgb2JqZWN0cyB3aXRoIHRoZWlyIGNvcnJlc3BvbmRpbmdcbiAqIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNvcnQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJlciBUaGUgZnVuY3Rpb24gdG8gZGVmaW5lIHNvcnQgb3JkZXIuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYmFzZVNvcnRCeShhcnJheSwgY29tcGFyZXIpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBhcnJheS5zb3J0KGNvbXBhcmVyKTtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgYXJyYXlbbGVuZ3RoXSA9IGFycmF5W2xlbmd0aF0udmFsdWU7XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuYXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIHN0b3JpbmcgbWV0YWRhdGEuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlVW5hcnkoZnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG4gIH07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgYGNhY2hlYCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gY2FjaGUgVGhlIGNhY2hlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGNhY2hlSGFzKGNhY2hlLCBrZXkpIHtcbiAgcmV0dXJuIGNhY2hlLmhhcyhrZXkpO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZShvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgbWFwYCB0byBpdHMga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUga2V5LXZhbHVlIHBhaXJzLlxuICovXG5mdW5jdGlvbiBtYXBUb0FycmF5KG1hcCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG1hcC5zaXplKTtcblxuICBtYXAuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gW2tleSwgdmFsdWVdO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gIH07XG59XG5cbi8qKlxuICogQ29udmVydHMgYHNldGAgdG8gYW4gYXJyYXkgb2YgaXRzIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNldCBUaGUgc2V0IHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gc2V0VG9BcnJheShzZXQpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShzZXQuc2l6ZSk7XG5cbiAgc2V0LmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSB2YWx1ZTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlLFxuICAgIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvdmVycmVhY2hpbmcgY29yZS1qcyBzaGltcy4gKi9cbnZhciBjb3JlSnNEYXRhID0gcm9vdFsnX19jb3JlLWpzX3NoYXJlZF9fJ107XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtZXRob2RzIG1hc3F1ZXJhZGluZyBhcyBuYXRpdmUuICovXG52YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoY29yZUpzRGF0YSAmJiBjb3JlSnNEYXRhLmtleXMgJiYgY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8ICcnKTtcbiAgcmV0dXJuIHVpZCA/ICgnU3ltYm9sKHNyYylfMS4nICsgdWlkKSA6ICcnO1xufSgpKTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG52YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICBmdW5jVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbik7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZCxcbiAgICBTeW1ib2wgPSByb290LlN5bWJvbCxcbiAgICBVaW50OEFycmF5ID0gcm9vdC5VaW50OEFycmF5LFxuICAgIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGUsXG4gICAgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2UsXG4gICAgc3ByZWFkYWJsZVN5bWJvbCA9IFN5bWJvbCA/IFN5bWJvbC5pc0NvbmNhdFNwcmVhZGFibGUgOiB1bmRlZmluZWQsXG4gICAgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICB2YXIgZnVuYyA9IGdldE5hdGl2ZShPYmplY3QsICdkZWZpbmVQcm9wZXJ0eScpO1xuICAgIGZ1bmMoe30sICcnLCB7fSk7XG4gICAgcmV0dXJuIGZ1bmM7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlR2V0U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsXG4gICAgbmF0aXZlSXNCdWZmZXIgPSBCdWZmZXIgPyBCdWZmZXIuaXNCdWZmZXIgOiB1bmRlZmluZWQsXG4gICAgbmF0aXZlS2V5cyA9IG92ZXJBcmcoT2JqZWN0LmtleXMsIE9iamVjdCksXG4gICAgbmF0aXZlTWF4ID0gTWF0aC5tYXgsXG4gICAgbmF0aXZlTm93ID0gRGF0ZS5ub3c7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBEYXRhVmlldyA9IGdldE5hdGl2ZShyb290LCAnRGF0YVZpZXcnKSxcbiAgICBNYXAgPSBnZXROYXRpdmUocm9vdCwgJ01hcCcpLFxuICAgIFByb21pc2UgPSBnZXROYXRpdmUocm9vdCwgJ1Byb21pc2UnKSxcbiAgICBTZXQgPSBnZXROYXRpdmUocm9vdCwgJ1NldCcpLFxuICAgIFdlYWtNYXAgPSBnZXROYXRpdmUocm9vdCwgJ1dlYWtNYXAnKSxcbiAgICBuYXRpdmVDcmVhdGUgPSBnZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtYXBzLCBzZXRzLCBhbmQgd2Vha21hcHMuICovXG52YXIgZGF0YVZpZXdDdG9yU3RyaW5nID0gdG9Tb3VyY2UoRGF0YVZpZXcpLFxuICAgIG1hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShNYXApLFxuICAgIHByb21pc2VDdG9yU3RyaW5nID0gdG9Tb3VyY2UoUHJvbWlzZSksXG4gICAgc2V0Q3RvclN0cmluZyA9IHRvU291cmNlKFNldCksXG4gICAgd2Vha01hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShXZWFrTWFwKTtcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFZhbHVlT2YgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnZhbHVlT2YgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKi9cbmZ1bmN0aW9uIGhhc2hDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5hdGl2ZUNyZWF0ZSA/IG5hdGl2ZUNyZWF0ZShudWxsKSA6IHt9O1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaERlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGhhc2ggdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gaGFzaEdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAobmF0aXZlQ3JlYXRlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGRhdGFba2V5XTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSBIQVNIX1VOREVGSU5FRCA/IHVuZGVmaW5lZCA6IHJlc3VsdDtcbiAgfVxuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIGhhc2ggdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hIYXMoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgcmV0dXJuIG5hdGl2ZUNyZWF0ZSA/IChkYXRhW2tleV0gIT09IHVuZGVmaW5lZCkgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHRoaXMuc2l6ZSArPSB0aGlzLmhhcyhrZXkpID8gMCA6IDE7XG4gIGRhdGFba2V5XSA9IChuYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCA6IHZhbHVlO1xuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG5IYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBoYXNoRGVsZXRlO1xuSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbkhhc2gucHJvdG90eXBlLmhhcyA9IGhhc2hIYXM7XG5IYXNoLnByb3RvdHlwZS5zZXQgPSBoYXNoU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIExpc3RDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBbXTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGxhc3RJbmRleCA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgaWYgKGluZGV4ID09IGxhc3RJbmRleCkge1xuICAgIGRhdGEucG9wKCk7XG4gIH0gZWxzZSB7XG4gICAgc3BsaWNlLmNhbGwoZGF0YSwgaW5kZXgsIDEpO1xuICB9XG4gIC0tdGhpcy5zaXplO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGFzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgbGlzdCBjYWNoZSBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgKyt0aGlzLnNpemU7XG4gICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0gZWxzZSB7XG4gICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXG5MaXN0Q2FjaGUucHJvdG90eXBlLmNsZWFyID0gbGlzdENhY2hlQ2xlYXI7XG5MaXN0Q2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IGxpc3RDYWNoZURlbGV0ZTtcbkxpc3RDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbGlzdENhY2hlR2V0O1xuTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBsaXN0Q2FjaGVIYXM7XG5MaXN0Q2FjaGUucHJvdG90eXBlLnNldCA9IGxpc3RDYWNoZVNldDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVDbGVhcigpIHtcbiAgdGhpcy5zaXplID0gMDtcbiAgdGhpcy5fX2RhdGFfXyA9IHtcbiAgICAnaGFzaCc6IG5ldyBIYXNoLFxuICAgICdtYXAnOiBuZXcgKE1hcCB8fCBMaXN0Q2FjaGUpLFxuICAgICdzdHJpbmcnOiBuZXcgSGFzaFxuICB9O1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSlbJ2RlbGV0ZSddKGtleSk7XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBtYXAgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlR2V0KGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmdldChrZXkpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIG1hcCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmhhcyhrZXkpO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIG1hcCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBtYXAgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSksXG4gICAgICBzaXplID0gZGF0YS5zaXplO1xuXG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgKz0gZGF0YS5zaXplID09IHNpemUgPyAwIDogMTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBNYXBDYWNoZWAuXG5NYXBDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBtYXBDYWNoZUNsZWFyO1xuTWFwQ2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IG1hcENhY2hlRGVsZXRlO1xuTWFwQ2FjaGUucHJvdG90eXBlLmdldCA9IG1hcENhY2hlR2V0O1xuTWFwQ2FjaGUucHJvdG90eXBlLmhhcyA9IG1hcENhY2hlSGFzO1xuTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IG1hcENhY2hlU2V0O1xuXG4vKipcbiAqXG4gKiBDcmVhdGVzIGFuIGFycmF5IGNhY2hlIG9iamVjdCB0byBzdG9yZSB1bmlxdWUgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFNldENhY2hlKHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcyA9PSBudWxsID8gMCA6IHZhbHVlcy5sZW5ndGg7XG5cbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB0aGlzLmFkZCh2YWx1ZXNbaW5kZXhdKTtcbiAgfVxufVxuXG4vKipcbiAqIEFkZHMgYHZhbHVlYCB0byB0aGUgYXJyYXkgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGFkZFxuICogQG1lbWJlck9mIFNldENhY2hlXG4gKiBAYWxpYXMgcHVzaFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2FjaGUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVBZGQodmFsdWUpIHtcbiAgdGhpcy5fX2RhdGFfXy5zZXQodmFsdWUsIEhBU0hfVU5ERUZJTkVEKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgaW4gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVIYXModmFsdWUpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKHZhbHVlKTtcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFNldENhY2hlYC5cblNldENhY2hlLnByb3RvdHlwZS5hZGQgPSBTZXRDYWNoZS5wcm90b3R5cGUucHVzaCA9IHNldENhY2hlQWRkO1xuU2V0Q2FjaGUucHJvdG90eXBlLmhhcyA9IHNldENhY2hlSGFzO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzdGFjayBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTdGFjayhlbnRyaWVzKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGUoZW50cmllcyk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBTdGFja1xuICovXG5mdW5jdGlvbiBzdGFja0NsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIHJlc3VsdCA9IGRhdGFbJ2RlbGV0ZSddKGtleSk7XG5cbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIHN0YWNrIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBzdGFja0dldChrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uZ2V0KGtleSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgc3RhY2sgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0hhcyhrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKGtleSk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgc3RhY2sgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgc3RhY2sgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAoZGF0YSBpbnN0YW5jZW9mIExpc3RDYWNoZSkge1xuICAgIHZhciBwYWlycyA9IGRhdGEuX19kYXRhX187XG4gICAgaWYgKCFNYXAgfHwgKHBhaXJzLmxlbmd0aCA8IExBUkdFX0FSUkFZX1NJWkUgLSAxKSkge1xuICAgICAgcGFpcnMucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgdGhpcy5zaXplID0gKytkYXRhLnNpemU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGUocGFpcnMpO1xuICB9XG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU3RhY2tgLlxuU3RhY2sucHJvdG90eXBlLmNsZWFyID0gc3RhY2tDbGVhcjtcblN0YWNrLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBzdGFja0RlbGV0ZTtcblN0YWNrLnByb3RvdHlwZS5nZXQgPSBzdGFja0dldDtcblN0YWNrLnByb3RvdHlwZS5oYXMgPSBzdGFja0hhcztcblN0YWNrLnByb3RvdHlwZS5zZXQgPSBzdGFja1NldDtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XG4gIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpLFxuICAgICAgaXNBcmcgPSAhaXNBcnIgJiYgaXNBcmd1bWVudHModmFsdWUpLFxuICAgICAgaXNCdWZmID0gIWlzQXJyICYmICFpc0FyZyAmJiBpc0J1ZmZlcih2YWx1ZSksXG4gICAgICBpc1R5cGUgPSAhaXNBcnIgJiYgIWlzQXJnICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHZhbHVlKSxcbiAgICAgIHNraXBJbmRleGVzID0gaXNBcnIgfHwgaXNBcmcgfHwgaXNCdWZmIHx8IGlzVHlwZSxcbiAgICAgIHJlc3VsdCA9IHNraXBJbmRleGVzID8gYmFzZVRpbWVzKHZhbHVlLmxlbmd0aCwgU3RyaW5nKSA6IFtdLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSAmJlxuICAgICAgICAhKHNraXBJbmRleGVzICYmIChcbiAgICAgICAgICAgLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLlxuICAgICAgICAgICBrZXkgPT0gJ2xlbmd0aCcgfHxcbiAgICAgICAgICAgLy8gTm9kZS5qcyAwLjEwIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIGJ1ZmZlcnMuXG4gICAgICAgICAgIChpc0J1ZmYgJiYgKGtleSA9PSAnb2Zmc2V0JyB8fCBrZXkgPT0gJ3BhcmVudCcpKSB8fFxuICAgICAgICAgICAvLyBQaGFudG9tSlMgMiBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiB0eXBlZCBhcnJheXMuXG4gICAgICAgICAgIChpc1R5cGUgJiYgKGtleSA9PSAnYnVmZmVyJyB8fCBrZXkgPT0gJ2J5dGVMZW5ndGgnIHx8IGtleSA9PSAnYnl0ZU9mZnNldCcpKSB8fFxuICAgICAgICAgICAvLyBTa2lwIGluZGV4IHByb3BlcnRpZXMuXG4gICAgICAgICAgIGlzSW5kZXgoa2V5LCBsZW5ndGgpXG4gICAgICAgICkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBga2V5YCBpcyBmb3VuZCBpbiBgYXJyYXlgIG9mIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IGtleSBUaGUga2V5IHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBhc3NvY0luZGV4T2YoYXJyYXksIGtleSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBpZiAoZXEoYXJyYXlbbGVuZ3RoXVswXSwga2V5KSkge1xuICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvckVhY2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICovXG52YXIgYmFzZUVhY2ggPSBjcmVhdGVCYXNlRWFjaChiYXNlRm9yT3duKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mbGF0dGVuYCB3aXRoIHN1cHBvcnQgZm9yIHJlc3RyaWN0aW5nIGZsYXR0ZW5pbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICogQHBhcmFtIHtudW1iZXJ9IGRlcHRoIFRoZSBtYXhpbXVtIHJlY3Vyc2lvbiBkZXB0aC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3ByZWRpY2F0ZT1pc0ZsYXR0ZW5hYmxlXSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNTdHJpY3RdIFJlc3RyaWN0IHRvIHZhbHVlcyB0aGF0IHBhc3MgYHByZWRpY2F0ZWAgY2hlY2tzLlxuICogQHBhcmFtIHtBcnJheX0gW3Jlc3VsdD1bXV0gVGhlIGluaXRpYWwgcmVzdWx0IHZhbHVlLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlRmxhdHRlbihhcnJheSwgZGVwdGgsIHByZWRpY2F0ZSwgaXNTdHJpY3QsIHJlc3VsdCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBwcmVkaWNhdGUgfHwgKHByZWRpY2F0ZSA9IGlzRmxhdHRlbmFibGUpO1xuICByZXN1bHQgfHwgKHJlc3VsdCA9IFtdKTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICBpZiAoZGVwdGggPiAwICYmIHByZWRpY2F0ZSh2YWx1ZSkpIHtcbiAgICAgIGlmIChkZXB0aCA+IDEpIHtcbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgZmxhdHRlbiBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgYmFzZUZsYXR0ZW4odmFsdWUsIGRlcHRoIC0gMSwgcHJlZGljYXRlLCBpc1N0cmljdCwgcmVzdWx0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFycmF5UHVzaChyZXN1bHQsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFpc1N0cmljdCkge1xuICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGJhc2VGb3JPd25gIHdoaWNoIGl0ZXJhdGVzIG92ZXIgYG9iamVjdGBcbiAqIHByb3BlcnRpZXMgcmV0dXJuZWQgYnkgYGtleXNGdW5jYCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIHByb3BlcnR5LlxuICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG52YXIgYmFzZUZvciA9IGNyZWF0ZUJhc2VGb3IoKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JPd25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlRm9yT3duKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgcmV0dXJuIG9iamVjdCAmJiBiYXNlRm9yKG9iamVjdCwgaXRlcmF0ZWUsIGtleXMpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmdldGAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWZhdWx0IHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldChvYmplY3QsIHBhdGgpIHtcbiAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gMCxcbiAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXG4gIHdoaWxlIChvYmplY3QgIT0gbnVsbCAmJiBpbmRleCA8IGxlbmd0aCkge1xuICAgIG9iamVjdCA9IG9iamVjdFt0b0tleShwYXRoW2luZGV4KytdKV07XG4gIH1cbiAgcmV0dXJuIChpbmRleCAmJiBpbmRleCA9PSBsZW5ndGgpID8gb2JqZWN0IDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRBbGxLZXlzYCBhbmQgYGdldEFsbEtleXNJbmAgd2hpY2ggdXNlc1xuICogYGtleXNGdW5jYCBhbmQgYHN5bWJvbHNGdW5jYCB0byBnZXQgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gKiBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3ltYm9sc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0Z1bmMsIHN5bWJvbHNGdW5jKSB7XG4gIHZhciByZXN1bHQgPSBrZXlzRnVuYyhvYmplY3QpO1xuICByZXR1cm4gaXNBcnJheShvYmplY3QpID8gcmVzdWx0IDogYXJyYXlQdXNoKHJlc3VsdCwgc3ltYm9sc0Z1bmMob2JqZWN0KSk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2Agd2l0aG91dCBmYWxsYmFja3MgZm9yIGJ1Z2d5IGVudmlyb25tZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICB9XG4gIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICA/IGdldFJhd1RhZyh2YWx1ZSlcbiAgICA6IG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5oYXNJbmAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBrZXkgVGhlIGtleSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUhhc0luKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBrZXkgaW4gT2JqZWN0KG9iamVjdCk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcmd1bWVudHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqL1xuZnVuY3Rpb24gYmFzZUlzQXJndW1lbnRzKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFyZ3NUYWc7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNFcXVhbGAgd2hpY2ggc3VwcG9ydHMgcGFydGlhbCBjb21wYXJpc29uc1xuICogYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuXG4gKiAgMSAtIFVub3JkZXJlZCBjb21wYXJpc29uXG4gKiAgMiAtIFBhcnRpYWwgY29tcGFyaXNvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGB2YWx1ZWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spIHtcbiAgaWYgKHZhbHVlID09PSBvdGhlcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsIHx8IG90aGVyID09IG51bGwgfHwgKCFpc09iamVjdExpa2UodmFsdWUpICYmICFpc09iamVjdExpa2Uob3RoZXIpKSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyO1xuICB9XG4gIHJldHVybiBiYXNlSXNFcXVhbERlZXAodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBiYXNlSXNFcXVhbCwgc3RhY2spO1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcbiAqIGRlZXAgY29tcGFyaXNvbnMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAqIHJlZmVyZW5jZXMgdG8gYmUgY29tcGFyZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsRGVlcChvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBvYmpJc0FyciA9IGlzQXJyYXkob2JqZWN0KSxcbiAgICAgIG90aElzQXJyID0gaXNBcnJheShvdGhlciksXG4gICAgICBvYmpUYWcgPSBvYmpJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnKG9iamVjdCksXG4gICAgICBvdGhUYWcgPSBvdGhJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnKG90aGVyKTtcblxuICBvYmpUYWcgPSBvYmpUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG9ialRhZztcbiAgb3RoVGFnID0gb3RoVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvdGhUYWc7XG5cbiAgdmFyIG9iaklzT2JqID0gb2JqVGFnID09IG9iamVjdFRhZyxcbiAgICAgIG90aElzT2JqID0gb3RoVGFnID09IG9iamVjdFRhZyxcbiAgICAgIGlzU2FtZVRhZyA9IG9ialRhZyA9PSBvdGhUYWc7XG5cbiAgaWYgKGlzU2FtZVRhZyAmJiBpc0J1ZmZlcihvYmplY3QpKSB7XG4gICAgaWYgKCFpc0J1ZmZlcihvdGhlcikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgb2JqSXNBcnIgPSB0cnVlO1xuICAgIG9iaklzT2JqID0gZmFsc2U7XG4gIH1cbiAgaWYgKGlzU2FtZVRhZyAmJiAhb2JqSXNPYmopIHtcbiAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgIHJldHVybiAob2JqSXNBcnIgfHwgaXNUeXBlZEFycmF5KG9iamVjdCkpXG4gICAgICA/IGVxdWFsQXJyYXlzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spXG4gICAgICA6IGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgb2JqVGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgfVxuICBpZiAoIShiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcpKSB7XG4gICAgdmFyIG9iaklzV3JhcHBlZCA9IG9iaklzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCAnX193cmFwcGVkX18nKSxcbiAgICAgICAgb3RoSXNXcmFwcGVkID0gb3RoSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwgJ19fd3JhcHBlZF9fJyk7XG5cbiAgICBpZiAob2JqSXNXcmFwcGVkIHx8IG90aElzV3JhcHBlZCkge1xuICAgICAgdmFyIG9ialVud3JhcHBlZCA9IG9iaklzV3JhcHBlZCA/IG9iamVjdC52YWx1ZSgpIDogb2JqZWN0LFxuICAgICAgICAgIG90aFVud3JhcHBlZCA9IG90aElzV3JhcHBlZCA/IG90aGVyLnZhbHVlKCkgOiBvdGhlcjtcblxuICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgIHJldHVybiBlcXVhbEZ1bmMob2JqVW53cmFwcGVkLCBvdGhVbndyYXBwZWQsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFpc1NhbWVUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgcmV0dXJuIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc01hdGNoYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAqIEBwYXJhbSB7QXJyYXl9IG1hdGNoRGF0YSBUaGUgcHJvcGVydHkgbmFtZXMsIHZhbHVlcywgYW5kIGNvbXBhcmUgZmxhZ3MgdG8gbWF0Y2guXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgb2JqZWN0YCBpcyBhIG1hdGNoLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEsIGN1c3RvbWl6ZXIpIHtcbiAgdmFyIGluZGV4ID0gbWF0Y2hEYXRhLmxlbmd0aCxcbiAgICAgIGxlbmd0aCA9IGluZGV4LFxuICAgICAgbm9DdXN0b21pemVyID0gIWN1c3RvbWl6ZXI7XG5cbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuICFsZW5ndGg7XG4gIH1cbiAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgdmFyIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgIGlmICgobm9DdXN0b21pemVyICYmIGRhdGFbMl0pXG4gICAgICAgICAgPyBkYXRhWzFdICE9PSBvYmplY3RbZGF0YVswXV1cbiAgICAgICAgICA6ICEoZGF0YVswXSBpbiBvYmplY3QpXG4gICAgICAgICkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgIHZhciBrZXkgPSBkYXRhWzBdLFxuICAgICAgICBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICBzcmNWYWx1ZSA9IGRhdGFbMV07XG5cbiAgICBpZiAobm9DdXN0b21pemVyICYmIGRhdGFbMl0pIHtcbiAgICAgIGlmIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc3RhY2sgPSBuZXcgU3RhY2s7XG4gICAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKTtcbiAgICAgIH1cbiAgICAgIGlmICghKHJlc3VsdCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IGJhc2VJc0VxdWFsKHNyY1ZhbHVlLCBvYmpWYWx1ZSwgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgfCBDT01QQVJFX1VOT1JERVJFRF9GTEFHLCBjdXN0b21pemVyLCBzdGFjaylcbiAgICAgICAgICAgIDogcmVzdWx0XG4gICAgICAgICAgKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHBhdHRlcm4gPSBpc0Z1bmN0aW9uKHZhbHVlKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1R5cGVkQXJyYXlgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzVHlwZWRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJlxuICAgIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tiYXNlR2V0VGFnKHZhbHVlKV07XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXRlcmF0ZWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IFt2YWx1ZT1fLmlkZW50aXR5XSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhbiBpdGVyYXRlZS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgaXRlcmF0ZWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJdGVyYXRlZSh2YWx1ZSkge1xuICAvLyBEb24ndCBzdG9yZSB0aGUgYHR5cGVvZmAgcmVzdWx0IGluIGEgdmFyaWFibGUgdG8gYXZvaWQgYSBKSVQgYnVnIGluIFNhZmFyaSA5LlxuICAvLyBTZWUgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE1NjAzNCBmb3IgbW9yZSBkZXRhaWxzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gaWRlbnRpdHk7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBpc0FycmF5KHZhbHVlKVxuICAgICAgPyBiYXNlTWF0Y2hlc1Byb3BlcnR5KHZhbHVlWzBdLCB2YWx1ZVsxXSlcbiAgICAgIDogYmFzZU1hdGNoZXModmFsdWUpO1xuICB9XG4gIHJldHVybiBwcm9wZXJ0eSh2YWx1ZSk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c2Agd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5cyhvYmplY3QpIHtcbiAgaWYgKCFpc1Byb3RvdHlwZShvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBrZXkgIT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXBgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IGlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pID8gQXJyYXkoY29sbGVjdGlvbi5sZW5ndGgpIDogW107XG5cbiAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IGl0ZXJhdGVlKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzYCB3aGljaCBkb2Vzbid0IGNsb25lIGBzb3VyY2VgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hdGNoZXMoc291cmNlKSB7XG4gIHZhciBtYXRjaERhdGEgPSBnZXRNYXRjaERhdGEoc291cmNlKTtcbiAgaWYgKG1hdGNoRGF0YS5sZW5ndGggPT0gMSAmJiBtYXRjaERhdGFbMF1bMl0pIHtcbiAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUobWF0Y2hEYXRhWzBdWzBdLCBtYXRjaERhdGFbMF1bMV0pO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09PSBzb3VyY2UgfHwgYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSk7XG4gIH07XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc1Byb3BlcnR5YCB3aGljaCBkb2Vzbid0IGNsb25lIGBzcmNWYWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VNYXRjaGVzUHJvcGVydHkocGF0aCwgc3JjVmFsdWUpIHtcbiAgaWYgKGlzS2V5KHBhdGgpICYmIGlzU3RyaWN0Q29tcGFyYWJsZShzcmNWYWx1ZSkpIHtcbiAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUodG9LZXkocGF0aCksIHNyY1ZhbHVlKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIG9ialZhbHVlID0gZ2V0KG9iamVjdCwgcGF0aCk7XG4gICAgcmV0dXJuIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkICYmIG9ialZhbHVlID09PSBzcmNWYWx1ZSlcbiAgICAgID8gaGFzSW4ob2JqZWN0LCBwYXRoKVxuICAgICAgOiBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIENPTVBBUkVfUEFSVElBTF9GTEFHIHwgQ09NUEFSRV9VTk9SREVSRURfRkxBRyk7XG4gIH07XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ub3JkZXJCeWAgd2l0aG91dCBwYXJhbSBndWFyZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb25bXXxPYmplY3RbXXxzdHJpbmdbXX0gaXRlcmF0ZWVzIFRoZSBpdGVyYXRlZXMgdG8gc29ydCBieS5cbiAqIEBwYXJhbSB7c3RyaW5nW119IG9yZGVycyBUaGUgc29ydCBvcmRlcnMgb2YgYGl0ZXJhdGVlc2AuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzb3J0ZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGJhc2VPcmRlckJ5KGNvbGxlY3Rpb24sIGl0ZXJhdGVlcywgb3JkZXJzKSB7XG4gIHZhciBpbmRleCA9IC0xO1xuICBpdGVyYXRlZXMgPSBhcnJheU1hcChpdGVyYXRlZXMubGVuZ3RoID8gaXRlcmF0ZWVzIDogW2lkZW50aXR5XSwgYmFzZVVuYXJ5KGJhc2VJdGVyYXRlZSkpO1xuXG4gIHZhciByZXN1bHQgPSBiYXNlTWFwKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICB2YXIgY3JpdGVyaWEgPSBhcnJheU1hcChpdGVyYXRlZXMsIGZ1bmN0aW9uKGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gaXRlcmF0ZWUodmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiB7ICdjcml0ZXJpYSc6IGNyaXRlcmlhLCAnaW5kZXgnOiArK2luZGV4LCAndmFsdWUnOiB2YWx1ZSB9O1xuICB9KTtcblxuICByZXR1cm4gYmFzZVNvcnRCeShyZXN1bHQsIGZ1bmN0aW9uKG9iamVjdCwgb3RoZXIpIHtcbiAgICByZXR1cm4gY29tcGFyZU11bHRpcGxlKG9iamVjdCwgb3RoZXIsIG9yZGVycyk7XG4gIH0pO1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVByb3BlcnR5YCB3aGljaCBzdXBwb3J0cyBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eURlZXAocGF0aCkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZXN0YCB3aGljaCBkb2Vzbid0IHZhbGlkYXRlIG9yIGNvZXJjZSBhcmd1bWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVJlc3QoZnVuYywgc3RhcnQpIHtcbiAgcmV0dXJuIHNldFRvU3RyaW5nKG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCBpZGVudGl0eSksIGZ1bmMgKyAnJyk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYHNldFRvU3RyaW5nYCB3aXRob3V0IHN1cHBvcnQgZm9yIGhvdCBsb29wIHNob3J0aW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAqL1xudmFyIGJhc2VTZXRUb1N0cmluZyA9ICFkZWZpbmVQcm9wZXJ0eSA/IGlkZW50aXR5IDogZnVuY3Rpb24oZnVuYywgc3RyaW5nKSB7XG4gIHJldHVybiBkZWZpbmVQcm9wZXJ0eShmdW5jLCAndG9TdHJpbmcnLCB7XG4gICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgJ2VudW1lcmFibGUnOiBmYWxzZSxcbiAgICAndmFsdWUnOiBjb25zdGFudChzdHJpbmcpLFxuICAgICd3cml0YWJsZSc6IHRydWVcbiAgfSk7XG59O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvU3RyaW5nYCB3aGljaCBkb2Vzbid0IGNvbnZlcnQgbnVsbGlzaFxuICogdmFsdWVzIHRvIGVtcHR5IHN0cmluZ3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xuICAvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbnZlcnQgdmFsdWVzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgcmV0dXJuIGFycmF5TWFwKHZhbHVlLCBiYXNlVG9TdHJpbmcpICsgJyc7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBzeW1ib2xUb1N0cmluZyA/IHN5bWJvbFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG4vKipcbiAqIENhc3RzIGB2YWx1ZWAgdG8gYSBwYXRoIGFycmF5IGlmIGl0J3Mgbm90IG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3QgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gY2FzdFBhdGgodmFsdWUsIG9iamVjdCkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIGlzS2V5KHZhbHVlLCBvYmplY3QpID8gW3ZhbHVlXSA6IHN0cmluZ1RvUGF0aCh0b1N0cmluZyh2YWx1ZSkpO1xufVxuXG4vKipcbiAqIENvbXBhcmVzIHZhbHVlcyB0byBzb3J0IHRoZW0gaW4gYXNjZW5kaW5nIG9yZGVyLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHNvcnQgb3JkZXIgaW5kaWNhdG9yIGZvciBgdmFsdWVgLlxuICovXG5mdW5jdGlvbiBjb21wYXJlQXNjZW5kaW5nKHZhbHVlLCBvdGhlcikge1xuICBpZiAodmFsdWUgIT09IG90aGVyKSB7XG4gICAgdmFyIHZhbElzRGVmaW5lZCA9IHZhbHVlICE9PSB1bmRlZmluZWQsXG4gICAgICAgIHZhbElzTnVsbCA9IHZhbHVlID09PSBudWxsLFxuICAgICAgICB2YWxJc1JlZmxleGl2ZSA9IHZhbHVlID09PSB2YWx1ZSxcbiAgICAgICAgdmFsSXNTeW1ib2wgPSBpc1N5bWJvbCh2YWx1ZSk7XG5cbiAgICB2YXIgb3RoSXNEZWZpbmVkID0gb3RoZXIgIT09IHVuZGVmaW5lZCxcbiAgICAgICAgb3RoSXNOdWxsID0gb3RoZXIgPT09IG51bGwsXG4gICAgICAgIG90aElzUmVmbGV4aXZlID0gb3RoZXIgPT09IG90aGVyLFxuICAgICAgICBvdGhJc1N5bWJvbCA9IGlzU3ltYm9sKG90aGVyKTtcblxuICAgIGlmICgoIW90aElzTnVsbCAmJiAhb3RoSXNTeW1ib2wgJiYgIXZhbElzU3ltYm9sICYmIHZhbHVlID4gb3RoZXIpIHx8XG4gICAgICAgICh2YWxJc1N5bWJvbCAmJiBvdGhJc0RlZmluZWQgJiYgb3RoSXNSZWZsZXhpdmUgJiYgIW90aElzTnVsbCAmJiAhb3RoSXNTeW1ib2wpIHx8XG4gICAgICAgICh2YWxJc051bGwgJiYgb3RoSXNEZWZpbmVkICYmIG90aElzUmVmbGV4aXZlKSB8fFxuICAgICAgICAoIXZhbElzRGVmaW5lZCAmJiBvdGhJc1JlZmxleGl2ZSkgfHxcbiAgICAgICAgIXZhbElzUmVmbGV4aXZlKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgaWYgKCghdmFsSXNOdWxsICYmICF2YWxJc1N5bWJvbCAmJiAhb3RoSXNTeW1ib2wgJiYgdmFsdWUgPCBvdGhlcikgfHxcbiAgICAgICAgKG90aElzU3ltYm9sICYmIHZhbElzRGVmaW5lZCAmJiB2YWxJc1JlZmxleGl2ZSAmJiAhdmFsSXNOdWxsICYmICF2YWxJc1N5bWJvbCkgfHxcbiAgICAgICAgKG90aElzTnVsbCAmJiB2YWxJc0RlZmluZWQgJiYgdmFsSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICghb3RoSXNEZWZpbmVkICYmIHZhbElzUmVmbGV4aXZlKSB8fFxuICAgICAgICAhb3RoSXNSZWZsZXhpdmUpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8qKlxuICogVXNlZCBieSBgXy5vcmRlckJ5YCB0byBjb21wYXJlIG11bHRpcGxlIHByb3BlcnRpZXMgb2YgYSB2YWx1ZSB0byBhbm90aGVyXG4gKiBhbmQgc3RhYmxlIHNvcnQgdGhlbS5cbiAqXG4gKiBJZiBgb3JkZXJzYCBpcyB1bnNwZWNpZmllZCwgYWxsIHZhbHVlcyBhcmUgc29ydGVkIGluIGFzY2VuZGluZyBvcmRlci4gT3RoZXJ3aXNlLFxuICogc3BlY2lmeSBhbiBvcmRlciBvZiBcImRlc2NcIiBmb3IgZGVzY2VuZGluZyBvciBcImFzY1wiIGZvciBhc2NlbmRpbmcgc29ydCBvcmRlclxuICogb2YgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbltdfHN0cmluZ1tdfSBvcmRlcnMgVGhlIG9yZGVyIHRvIHNvcnQgYnkgZm9yIGVhY2ggcHJvcGVydHkuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzb3J0IG9yZGVyIGluZGljYXRvciBmb3IgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmVNdWx0aXBsZShvYmplY3QsIG90aGVyLCBvcmRlcnMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBvYmpDcml0ZXJpYSA9IG9iamVjdC5jcml0ZXJpYSxcbiAgICAgIG90aENyaXRlcmlhID0gb3RoZXIuY3JpdGVyaWEsXG4gICAgICBsZW5ndGggPSBvYmpDcml0ZXJpYS5sZW5ndGgsXG4gICAgICBvcmRlcnNMZW5ndGggPSBvcmRlcnMubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHJlc3VsdCA9IGNvbXBhcmVBc2NlbmRpbmcob2JqQ3JpdGVyaWFbaW5kZXhdLCBvdGhDcml0ZXJpYVtpbmRleF0pO1xuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIGlmIChpbmRleCA+PSBvcmRlcnNMZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHZhciBvcmRlciA9IG9yZGVyc1tpbmRleF07XG4gICAgICByZXR1cm4gcmVzdWx0ICogKG9yZGVyID09ICdkZXNjJyA/IC0xIDogMSk7XG4gICAgfVxuICB9XG4gIC8vIEZpeGVzIGFuIGBBcnJheSNzb3J0YCBidWcgaW4gdGhlIEpTIGVuZ2luZSBlbWJlZGRlZCBpbiBBZG9iZSBhcHBsaWNhdGlvbnNcbiAgLy8gdGhhdCBjYXVzZXMgaXQsIHVuZGVyIGNlcnRhaW4gY2lyY3Vtc3RhbmNlcywgdG8gcHJvdmlkZSB0aGUgc2FtZSB2YWx1ZSBmb3JcbiAgLy8gYG9iamVjdGAgYW5kIGBvdGhlcmAuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vamFzaGtlbmFzL3VuZGVyc2NvcmUvcHVsbC8xMjQ3XG4gIC8vIGZvciBtb3JlIGRldGFpbHMuXG4gIC8vXG4gIC8vIFRoaXMgYWxzbyBlbnN1cmVzIGEgc3RhYmxlIHNvcnQgaW4gVjggYW5kIG90aGVyIGVuZ2luZXMuXG4gIC8vIFNlZSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD05MCBmb3IgbW9yZSBkZXRhaWxzLlxuICByZXR1cm4gb2JqZWN0LmluZGV4IC0gb3RoZXIuaW5kZXg7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGBiYXNlRWFjaGAgb3IgYGJhc2VFYWNoUmlnaHRgIGZ1bmN0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGEgY29sbGVjdGlvbi5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmFzZUVhY2goZWFjaEZ1bmMsIGZyb21SaWdodCkge1xuICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICB9XG4gICAgaWYgKCFpc0FycmF5TGlrZShjb2xsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKTtcbiAgICB9XG4gICAgdmFyIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoLFxuICAgICAgICBpbmRleCA9IGZyb21SaWdodCA/IGxlbmd0aCA6IC0xLFxuICAgICAgICBpdGVyYWJsZSA9IE9iamVjdChjb2xsZWN0aW9uKTtcblxuICAgIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVbaW5kZXhdLCBpbmRleCwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gIH07XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGJhc2UgZnVuY3Rpb24gZm9yIG1ldGhvZHMgbGlrZSBgXy5mb3JJbmAgYW5kIGBfLmZvck93bmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmFzZUZvcihmcm9tUmlnaHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCwgaXRlcmF0ZWUsIGtleXNGdW5jKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGl0ZXJhYmxlID0gT2JqZWN0KG9iamVjdCksXG4gICAgICAgIHByb3BzID0ga2V5c0Z1bmMob2JqZWN0KSxcbiAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICB2YXIga2V5ID0gcHJvcHNbZnJvbVJpZ2h0ID8gbGVuZ3RoIDogKytpbmRleF07XG4gICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVba2V5XSwga2V5LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9O1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgYXJyYXlzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0FycmF5fSBvdGhlciBUaGUgb3RoZXIgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYGFycmF5YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcnJheXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxBcnJheXMoYXJyYXksIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICBhcnJMZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBvdGhMZW5ndGggPSBvdGhlci5sZW5ndGg7XG5cbiAgaWYgKGFyckxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIShpc1BhcnRpYWwgJiYgb3RoTGVuZ3RoID4gYXJyTGVuZ3RoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KGFycmF5KTtcbiAgaWYgKHN0YWNrZWQgJiYgc3RhY2suZ2V0KG90aGVyKSkge1xuICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICB9XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gdHJ1ZSxcbiAgICAgIHNlZW4gPSAoYml0bWFzayAmIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcpID8gbmV3IFNldENhY2hlIDogdW5kZWZpbmVkO1xuXG4gIHN0YWNrLnNldChhcnJheSwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIGFycmF5KTtcblxuICAvLyBJZ25vcmUgbm9uLWluZGV4IHByb3BlcnRpZXMuXG4gIHdoaWxlICgrK2luZGV4IDwgYXJyTGVuZ3RoKSB7XG4gICAgdmFyIGFyclZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2luZGV4XTtcblxuICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBhcnJWYWx1ZSwgaW5kZXgsIG90aGVyLCBhcnJheSwgc3RhY2spXG4gICAgICAgIDogY3VzdG9taXplcihhcnJWYWx1ZSwgb3RoVmFsdWUsIGluZGV4LCBhcnJheSwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgaWYgKGNvbXBhcmVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChjb21wYXJlZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKHNlZW4pIHtcbiAgICAgIGlmICghYXJyYXlTb21lKG90aGVyLCBmdW5jdGlvbihvdGhWYWx1ZSwgb3RoSW5kZXgpIHtcbiAgICAgICAgICAgIGlmICghY2FjaGVIYXMoc2Vlbiwgb3RoSW5kZXgpICYmXG4gICAgICAgICAgICAgICAgKGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzZWVuLnB1c2gob3RoSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKSB7XG4gICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEoXG4gICAgICAgICAgYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8XG4gICAgICAgICAgICBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaylcbiAgICAgICAgKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgc3RhY2tbJ2RlbGV0ZSddKGFycmF5KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGNvbXBhcmluZyBvYmplY3RzIG9mXG4gKiB0aGUgc2FtZSBgdG9TdHJpbmdUYWdgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY29tcGFyaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIG9yIGBTdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3RzIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCB0YWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlIGRhdGFWaWV3VGFnOlxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgIChvYmplY3QuYnl0ZU9mZnNldCAhPSBvdGhlci5ieXRlT2Zmc2V0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBvYmplY3QgPSBvYmplY3QuYnVmZmVyO1xuICAgICAgb3RoZXIgPSBvdGhlci5idWZmZXI7XG5cbiAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgICFlcXVhbEZ1bmMobmV3IFVpbnQ4QXJyYXkob2JqZWN0KSwgbmV3IFVpbnQ4QXJyYXkob3RoZXIpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGNhc2UgYm9vbFRhZzpcbiAgICBjYXNlIGRhdGVUYWc6XG4gICAgY2FzZSBudW1iZXJUYWc6XG4gICAgICAvLyBDb2VyY2UgYm9vbGVhbnMgdG8gYDFgIG9yIGAwYCBhbmQgZGF0ZXMgdG8gbWlsbGlzZWNvbmRzLlxuICAgICAgLy8gSW52YWxpZCBkYXRlcyBhcmUgY29lcmNlZCB0byBgTmFOYC5cbiAgICAgIHJldHVybiBlcSgrb2JqZWN0LCArb3RoZXIpO1xuXG4gICAgY2FzZSBlcnJvclRhZzpcbiAgICAgIHJldHVybiBvYmplY3QubmFtZSA9PSBvdGhlci5uYW1lICYmIG9iamVjdC5tZXNzYWdlID09IG90aGVyLm1lc3NhZ2U7XG5cbiAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgIC8vIENvZXJjZSByZWdleGVzIHRvIHN0cmluZ3MgYW5kIHRyZWF0IHN0cmluZ3MsIHByaW1pdGl2ZXMgYW5kIG9iamVjdHMsXG4gICAgICAvLyBhcyBlcXVhbC4gU2VlIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1yZWdleHAucHJvdG90eXBlLnRvc3RyaW5nXG4gICAgICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgcmV0dXJuIG9iamVjdCA9PSAob3RoZXIgKyAnJyk7XG5cbiAgICBjYXNlIG1hcFRhZzpcbiAgICAgIHZhciBjb252ZXJ0ID0gbWFwVG9BcnJheTtcblxuICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRztcbiAgICAgIGNvbnZlcnQgfHwgKGNvbnZlcnQgPSBzZXRUb0FycmF5KTtcblxuICAgICAgaWYgKG9iamVjdC5zaXplICE9IG90aGVyLnNpemUgJiYgIWlzUGFydGlhbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICAgICAgaWYgKHN0YWNrZWQpIHtcbiAgICAgICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gICAgICB9XG4gICAgICBiaXRtYXNrIHw9IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUc7XG5cbiAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICAgICAgdmFyIHJlc3VsdCA9IGVxdWFsQXJyYXlzKGNvbnZlcnQob2JqZWN0KSwgY29udmVydChvdGhlciksIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICAgICAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICBpZiAoc3ltYm9sVmFsdWVPZikge1xuICAgICAgICByZXR1cm4gc3ltYm9sVmFsdWVPZi5jYWxsKG9iamVjdCkgPT0gc3ltYm9sVmFsdWVPZi5jYWxsKG90aGVyKTtcbiAgICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBvYmplY3RzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICBvYmpQcm9wcyA9IGdldEFsbEtleXMob2JqZWN0KSxcbiAgICAgIG9iakxlbmd0aCA9IG9ialByb3BzLmxlbmd0aCxcbiAgICAgIG90aFByb3BzID0gZ2V0QWxsS2V5cyhvdGhlciksXG4gICAgICBvdGhMZW5ndGggPSBvdGhQcm9wcy5sZW5ndGg7XG5cbiAgaWYgKG9iakxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIWlzUGFydGlhbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgaW5kZXggPSBvYmpMZW5ndGg7XG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgdmFyIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICBpZiAoIShpc1BhcnRpYWwgPyBrZXkgaW4gb3RoZXIgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCBrZXkpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gIGlmIChzdGFja2VkICYmIHN0YWNrLmdldChvdGhlcikpIHtcbiAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgfVxuICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIG9iamVjdCk7XG5cbiAgdmFyIHNraXBDdG9yID0gaXNQYXJ0aWFsO1xuICB3aGlsZSAoKytpbmRleCA8IG9iakxlbmd0aCkge1xuICAgIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltrZXldO1xuXG4gICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIG9ialZhbHVlLCBrZXksIG90aGVyLCBvYmplY3QsIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIob2JqVmFsdWUsIG90aFZhbHVlLCBrZXksIG9iamVjdCwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKCEoY29tcGFyZWQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gKG9ialZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMob2JqVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpXG4gICAgICAgICAgOiBjb21wYXJlZFxuICAgICAgICApKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBza2lwQ3RvciB8fCAoc2tpcEN0b3IgPSBrZXkgPT0gJ2NvbnN0cnVjdG9yJyk7XG4gIH1cbiAgaWYgKHJlc3VsdCAmJiAhc2tpcEN0b3IpIHtcbiAgICB2YXIgb2JqQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcixcbiAgICAgICAgb3RoQ3RvciA9IG90aGVyLmNvbnN0cnVjdG9yO1xuXG4gICAgLy8gTm9uIGBPYmplY3RgIG9iamVjdCBpbnN0YW5jZXMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1YWwuXG4gICAgaWYgKG9iakN0b3IgIT0gb3RoQ3RvciAmJlxuICAgICAgICAoJ2NvbnN0cnVjdG9yJyBpbiBvYmplY3QgJiYgJ2NvbnN0cnVjdG9yJyBpbiBvdGhlcikgJiZcbiAgICAgICAgISh0eXBlb2Ygb2JqQ3RvciA9PSAnZnVuY3Rpb24nICYmIG9iakN0b3IgaW5zdGFuY2VvZiBvYmpDdG9yICYmXG4gICAgICAgICAgdHlwZW9mIG90aEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvdGhDdG9yIGluc3RhbmNlb2Ygb3RoQ3RvcikpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBnZXRBbGxLZXlzKG9iamVjdCkge1xuICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzLCBnZXRTeW1ib2xzKTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBkYXRhIGZvciBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcmVmZXJlbmNlIGtleS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cbiAqL1xuZnVuY3Rpb24gZ2V0TWFwRGF0YShtYXAsIGtleSkge1xuICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcbiAgcmV0dXJuIGlzS2V5YWJsZShrZXkpXG4gICAgPyBkYXRhW3R5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyAnc3RyaW5nJyA6ICdoYXNoJ11cbiAgICA6IGRhdGEubWFwO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIHByb3BlcnR5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG1hdGNoIGRhdGEgb2YgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGdldE1hdGNoRGF0YShvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IGtleXMob2JqZWN0KSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgdmFyIGtleSA9IHJlc3VsdFtsZW5ndGhdLFxuICAgICAgICB2YWx1ZSA9IG9iamVjdFtrZXldO1xuXG4gICAgcmVzdWx0W2xlbmd0aF0gPSBba2V5LCB2YWx1ZSwgaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKV07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gIHZhciB2YWx1ZSA9IGdldFZhbHVlKG9iamVjdCwga2V5KTtcbiAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gIHRyeSB7XG4gICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBpZiAodW5tYXNrZWQpIHtcbiAgICBpZiAoaXNPd24pIHtcbiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gKi9cbnZhciBnZXRTeW1ib2xzID0gIW5hdGl2ZUdldFN5bWJvbHMgPyBzdHViQXJyYXkgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICByZXR1cm4gYXJyYXlGaWx0ZXIobmF0aXZlR2V0U3ltYm9scyhvYmplY3QpLCBmdW5jdGlvbihzeW1ib2wpIHtcbiAgICByZXR1cm4gcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmplY3QsIHN5bWJvbCk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBgdG9TdHJpbmdUYWdgIG9mIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xudmFyIGdldFRhZyA9IGJhc2VHZXRUYWc7XG5cbi8vIEZhbGxiYWNrIGZvciBkYXRhIHZpZXdzLCBtYXBzLCBzZXRzLCBhbmQgd2VhayBtYXBzIGluIElFIDExIGFuZCBwcm9taXNlcyBpbiBOb2RlLmpzIDwgNi5cbmlmICgoRGF0YVZpZXcgJiYgZ2V0VGFnKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSkpKSAhPSBkYXRhVmlld1RhZykgfHxcbiAgICAoTWFwICYmIGdldFRhZyhuZXcgTWFwKSAhPSBtYXBUYWcpIHx8XG4gICAgKFByb21pc2UgJiYgZ2V0VGFnKFByb21pc2UucmVzb2x2ZSgpKSAhPSBwcm9taXNlVGFnKSB8fFxuICAgIChTZXQgJiYgZ2V0VGFnKG5ldyBTZXQpICE9IHNldFRhZykgfHxcbiAgICAoV2Vha01hcCAmJiBnZXRUYWcobmV3IFdlYWtNYXApICE9IHdlYWtNYXBUYWcpKSB7XG4gIGdldFRhZyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGJhc2VHZXRUYWcodmFsdWUpLFxuICAgICAgICBDdG9yID0gcmVzdWx0ID09IG9iamVjdFRhZyA/IHZhbHVlLmNvbnN0cnVjdG9yIDogdW5kZWZpbmVkLFxuICAgICAgICBjdG9yU3RyaW5nID0gQ3RvciA/IHRvU291cmNlKEN0b3IpIDogJyc7XG5cbiAgICBpZiAoY3RvclN0cmluZykge1xuICAgICAgc3dpdGNoIChjdG9yU3RyaW5nKSB7XG4gICAgICAgIGNhc2UgZGF0YVZpZXdDdG9yU3RyaW5nOiByZXR1cm4gZGF0YVZpZXdUYWc7XG4gICAgICAgIGNhc2UgbWFwQ3RvclN0cmluZzogcmV0dXJuIG1hcFRhZztcbiAgICAgICAgY2FzZSBwcm9taXNlQ3RvclN0cmluZzogcmV0dXJuIHByb21pc2VUYWc7XG4gICAgICAgIGNhc2Ugc2V0Q3RvclN0cmluZzogcmV0dXJuIHNldFRhZztcbiAgICAgICAgY2FzZSB3ZWFrTWFwQ3RvclN0cmluZzogcmV0dXJuIHdlYWtNYXBUYWc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwYXRoYCBleGlzdHMgb24gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFzRnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2sgcHJvcGVydGllcy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBoYXNGdW5jKSB7XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBmYWxzZTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSk7XG4gICAgaWYgKCEocmVzdWx0ID0gb2JqZWN0ICE9IG51bGwgJiYgaGFzRnVuYyhvYmplY3QsIGtleSkpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgb2JqZWN0ID0gb2JqZWN0W2tleV07XG4gIH1cbiAgaWYgKHJlc3VsdCB8fCArK2luZGV4ICE9IGxlbmd0aCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgbGVuZ3RoID0gb2JqZWN0ID09IG51bGwgPyAwIDogb2JqZWN0Lmxlbmd0aDtcbiAgcmV0dXJuICEhbGVuZ3RoICYmIGlzTGVuZ3RoKGxlbmd0aCkgJiYgaXNJbmRleChrZXksIGxlbmd0aCkgJiZcbiAgICAoaXNBcnJheShvYmplY3QpIHx8IGlzQXJndW1lbnRzKG9iamVjdCkpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgZmxhdHRlbmFibGUgYGFyZ3VtZW50c2Agb2JqZWN0IG9yIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZsYXR0ZW5hYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzRmxhdHRlbmFibGUodmFsdWUpIHtcbiAgcmV0dXJuIGlzQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSB8fFxuICAgICEhKHNwcmVhZGFibGVTeW1ib2wgJiYgdmFsdWUgJiYgdmFsdWVbc3ByZWFkYWJsZVN5bWJvbF0pO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuXG4gIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICh0eXBlID09ICdudW1iZXInIHx8XG4gICAgICAodHlwZSAhPSAnc3ltYm9sJyAmJiByZUlzVWludC50ZXN0KHZhbHVlKSkpICYmXG4gICAgICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgdmFsdWUgYXJndW1lbnQuXG4gKiBAcGFyYW0geyp9IGluZGV4IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgaW5kZXggb3Iga2V5IGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBvYmplY3QgYXJndW1lbnQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJdGVyYXRlZUNhbGwodmFsdWUsIGluZGV4LCBvYmplY3QpIHtcbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0eXBlID0gdHlwZW9mIGluZGV4O1xuICBpZiAodHlwZSA9PSAnbnVtYmVyJ1xuICAgICAgICA/IChpc0FycmF5TGlrZShvYmplY3QpICYmIGlzSW5kZXgoaW5kZXgsIG9iamVjdC5sZW5ndGgpKVxuICAgICAgICA6ICh0eXBlID09ICdzdHJpbmcnICYmIGluZGV4IGluIG9iamVjdClcbiAgICAgICkge1xuICAgIHJldHVybiBlcShvYmplY3RbaW5kZXhdLCB2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSBhbmQgbm90IGEgcHJvcGVydHkgcGF0aC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5KHZhbHVlLCBvYmplY3QpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBpZiAodHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nIHx8XG4gICAgICB2YWx1ZSA9PSBudWxsIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiByZUlzUGxhaW5Qcm9wLnRlc3QodmFsdWUpIHx8ICFyZUlzRGVlcFByb3AudGVzdCh2YWx1ZSkgfHxcbiAgICAob2JqZWN0ICE9IG51bGwgJiYgdmFsdWUgaW4gT2JqZWN0KG9iamVjdCkpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciB1c2UgYXMgdW5pcXVlIG9iamVjdCBrZXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXlhYmxlKHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gKHR5cGUgPT0gJ3N0cmluZycgfHwgdHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nKVxuICAgID8gKHZhbHVlICE9PSAnX19wcm90b19fJylcbiAgICA6ICh2YWx1ZSA9PT0gbnVsbCk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgaXRzIHNvdXJjZSBtYXNrZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNNYXNrZWQoZnVuYykge1xuICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhIHByb3RvdHlwZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm90b3R5cGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNQcm90b3R5cGUodmFsdWUpIHtcbiAgdmFyIEN0b3IgPSB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvcixcbiAgICAgIHByb3RvID0gKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUpIHx8IG9iamVjdFByb3RvO1xuXG4gIHJldHVybiB2YWx1ZSA9PT0gcHJvdG87XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpZiBzdWl0YWJsZSBmb3Igc3RyaWN0XG4gKiAgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgJiYgIWlzT2JqZWN0KHZhbHVlKTtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYG1hdGNoZXNQcm9wZXJ0eWAgZm9yIHNvdXJjZSB2YWx1ZXMgc3VpdGFibGVcbiAqIGZvciBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gbWF0Y2guXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZShrZXksIHNyY1ZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdFtrZXldID09PSBzcmNWYWx1ZSAmJlxuICAgICAgKHNyY1ZhbHVlICE9PSB1bmRlZmluZWQgfHwgKGtleSBpbiBPYmplY3Qob2JqZWN0KSkpO1xuICB9O1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tZW1vaXplYCB3aGljaCBjbGVhcnMgdGhlIG1lbW9pemVkIGZ1bmN0aW9uJ3NcbiAqIGNhY2hlIHdoZW4gaXQgZXhjZWVkcyBgTUFYX01FTU9JWkVfU0laRWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBtZW1vaXplQ2FwcGVkKGZ1bmMpIHtcbiAgdmFyIHJlc3VsdCA9IG1lbW9pemUoZnVuYywgZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKGNhY2hlLnNpemUgPT09IE1BWF9NRU1PSVpFX1NJWkUpIHtcbiAgICAgIGNhY2hlLmNsZWFyKCk7XG4gICAgfVxuICAgIHJldHVybiBrZXk7XG4gIH0pO1xuXG4gIHZhciBjYWNoZSA9IHJlc3VsdC5jYWNoZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VSZXN0YCB3aGljaCB0cmFuc2Zvcm1zIHRoZSByZXN0IGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSByZXN0IGFycmF5IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyUmVzdChmdW5jLCBzdGFydCwgdHJhbnNmb3JtKSB7XG4gIHN0YXJ0ID0gbmF0aXZlTWF4KHN0YXJ0ID09PSB1bmRlZmluZWQgPyAoZnVuYy5sZW5ndGggLSAxKSA6IHN0YXJ0LCAwKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoYXJncy5sZW5ndGggLSBzdGFydCwgMCksXG4gICAgICAgIGFycmF5ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBhcnJheVtpbmRleF0gPSBhcmdzW3N0YXJ0ICsgaW5kZXhdO1xuICAgIH1cbiAgICBpbmRleCA9IC0xO1xuICAgIHZhciBvdGhlckFyZ3MgPSBBcnJheShzdGFydCArIDEpO1xuICAgIHdoaWxlICgrK2luZGV4IDwgc3RhcnQpIHtcbiAgICAgIG90aGVyQXJnc1tpbmRleF0gPSBhcmdzW2luZGV4XTtcbiAgICB9XG4gICAgb3RoZXJBcmdzW3N0YXJ0XSA9IHRyYW5zZm9ybShhcnJheSk7XG4gICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHRoaXMsIG90aGVyQXJncyk7XG4gIH07XG59XG5cbi8qKlxuICogU2V0cyB0aGUgYHRvU3RyaW5nYCBtZXRob2Qgb2YgYGZ1bmNgIHRvIHJldHVybiBgc3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5nIFRoZSBgdG9TdHJpbmdgIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gKi9cbnZhciBzZXRUb1N0cmluZyA9IHNob3J0T3V0KGJhc2VTZXRUb1N0cmluZyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQnbGwgc2hvcnQgb3V0IGFuZCBpbnZva2UgYGlkZW50aXR5YCBpbnN0ZWFkXG4gKiBvZiBgZnVuY2Agd2hlbiBpdCdzIGNhbGxlZCBgSE9UX0NPVU5UYCBvciBtb3JlIHRpbWVzIGluIGBIT1RfU1BBTmBcbiAqIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzaG9ydGFibGUgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHNob3J0T3V0KGZ1bmMpIHtcbiAgdmFyIGNvdW50ID0gMCxcbiAgICAgIGxhc3RDYWxsZWQgPSAwO1xuXG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RhbXAgPSBuYXRpdmVOb3coKSxcbiAgICAgICAgcmVtYWluaW5nID0gSE9UX1NQQU4gLSAoc3RhbXAgLSBsYXN0Q2FsbGVkKTtcblxuICAgIGxhc3RDYWxsZWQgPSBzdGFtcDtcbiAgICBpZiAocmVtYWluaW5nID4gMCkge1xuICAgICAgaWYgKCsrY291bnQgPj0gSE9UX0NPVU5UKSB7XG4gICAgICAgIHJldHVybiBhcmd1bWVudHNbMF07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvdW50ID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmMuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIGEgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKi9cbnZhciBzdHJpbmdUb1BhdGggPSBtZW1vaXplQ2FwcGVkKGZ1bmN0aW9uKHN0cmluZykge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChzdHJpbmcuY2hhckNvZGVBdCgwKSA9PT0gNDYgLyogLiAqLykge1xuICAgIHJlc3VsdC5wdXNoKCcnKTtcbiAgfVxuICBzdHJpbmcucmVwbGFjZShyZVByb3BOYW1lLCBmdW5jdGlvbihtYXRjaCwgbnVtYmVyLCBxdW90ZSwgc3ViU3RyaW5nKSB7XG4gICAgcmVzdWx0LnB1c2gocXVvdGUgPyBzdWJTdHJpbmcucmVwbGFjZShyZUVzY2FwZUNoYXIsICckMScpIDogKG51bWJlciB8fCBtYXRjaCkpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcga2V5IGlmIGl0J3Mgbm90IGEgc3RyaW5nIG9yIHN5bWJvbC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtzdHJpbmd8c3ltYm9sfSBSZXR1cm5zIHRoZSBrZXkuXG4gKi9cbmZ1bmN0aW9uIHRvS2V5KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgZnVuY2AgdG8gaXRzIHNvdXJjZSBjb2RlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc291cmNlIGNvZGUuXG4gKi9cbmZ1bmN0aW9uIHRvU291cmNlKGZ1bmMpIHtcbiAgaWYgKGZ1bmMgIT0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZnVuY1RvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIChmdW5jICsgJycpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZWxlbWVudHMsIHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXIgYnkgdGhlIHJlc3VsdHMgb2ZcbiAqIHJ1bm5pbmcgZWFjaCBlbGVtZW50IGluIGEgY29sbGVjdGlvbiB0aHJ1IGVhY2ggaXRlcmF0ZWUuIFRoaXMgbWV0aG9kXG4gKiBwZXJmb3JtcyBhIHN0YWJsZSBzb3J0LCB0aGF0IGlzLCBpdCBwcmVzZXJ2ZXMgdGhlIG9yaWdpbmFsIHNvcnQgb3JkZXIgb2ZcbiAqIGVxdWFsIGVsZW1lbnRzLiBUaGUgaXRlcmF0ZWVzIGFyZSBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW2l0ZXJhdGVlcz1bXy5pZGVudGl0eV1dXG4gKiAgVGhlIGl0ZXJhdGVlcyB0byBzb3J0IGJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc29ydGVkIGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgdXNlcnMgPSBbXG4gKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQ4IH0sXG4gKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH0sXG4gKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM0IH1cbiAqIF07XG4gKlxuICogXy5zb3J0QnkodXNlcnMsIFtmdW5jdGlvbihvKSB7IHJldHVybiBvLnVzZXI7IH1dKTtcbiAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ2Jhcm5leScsIDM2XSwgWydiYXJuZXknLCAzNF0sIFsnZnJlZCcsIDQ4XSwgWydmcmVkJywgNDBdXVxuICpcbiAqIF8uc29ydEJ5KHVzZXJzLCBbJ3VzZXInLCAnYWdlJ10pO1xuICogLy8gPT4gb2JqZWN0cyBmb3IgW1snYmFybmV5JywgMzRdLCBbJ2Jhcm5leScsIDM2XSwgWydmcmVkJywgNDBdLCBbJ2ZyZWQnLCA0OF1dXG4gKi9cbnZhciBzb3J0QnkgPSBiYXNlUmVzdChmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZXMpIHtcbiAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICB2YXIgbGVuZ3RoID0gaXRlcmF0ZWVzLmxlbmd0aDtcbiAgaWYgKGxlbmd0aCA+IDEgJiYgaXNJdGVyYXRlZUNhbGwoY29sbGVjdGlvbiwgaXRlcmF0ZWVzWzBdLCBpdGVyYXRlZXNbMV0pKSB7XG4gICAgaXRlcmF0ZWVzID0gW107XG4gIH0gZWxzZSBpZiAobGVuZ3RoID4gMiAmJiBpc0l0ZXJhdGVlQ2FsbChpdGVyYXRlZXNbMF0sIGl0ZXJhdGVlc1sxXSwgaXRlcmF0ZWVzWzJdKSkge1xuICAgIGl0ZXJhdGVlcyA9IFtpdGVyYXRlZXNbMF1dO1xuICB9XG4gIHJldHVybiBiYXNlT3JkZXJCeShjb2xsZWN0aW9uLCBiYXNlRmxhdHRlbihpdGVyYXRlZXMsIDEpLCBbXSk7XG59KTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBtZW1vaXplcyB0aGUgcmVzdWx0IG9mIGBmdW5jYC4gSWYgYHJlc29sdmVyYCBpc1xuICogcHJvdmlkZWQsIGl0IGRldGVybWluZXMgdGhlIGNhY2hlIGtleSBmb3Igc3RvcmluZyB0aGUgcmVzdWx0IGJhc2VkIG9uIHRoZVxuICogYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbi4gQnkgZGVmYXVsdCwgdGhlIGZpcnN0IGFyZ3VtZW50XG4gKiBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24gaXMgdXNlZCBhcyB0aGUgbWFwIGNhY2hlIGtleS4gVGhlIGBmdW5jYFxuICogaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKlxuICogKipOb3RlOioqIFRoZSBjYWNoZSBpcyBleHBvc2VkIGFzIHRoZSBgY2FjaGVgIHByb3BlcnR5IG9uIHRoZSBtZW1vaXplZFxuICogZnVuY3Rpb24uIEl0cyBjcmVhdGlvbiBtYXkgYmUgY3VzdG9taXplZCBieSByZXBsYWNpbmcgdGhlIGBfLm1lbW9pemUuQ2FjaGVgXG4gKiBjb25zdHJ1Y3RvciB3aXRoIG9uZSB3aG9zZSBpbnN0YW5jZXMgaW1wbGVtZW50IHRoZVxuICogW2BNYXBgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wcm9wZXJ0aWVzLW9mLXRoZS1tYXAtcHJvdG90eXBlLW9iamVjdClcbiAqIG1ldGhvZCBpbnRlcmZhY2Ugb2YgYGNsZWFyYCwgYGRlbGV0ZWAsIGBnZXRgLCBgaGFzYCwgYW5kIGBzZXRgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jlc29sdmVyXSBUaGUgZnVuY3Rpb24gdG8gcmVzb2x2ZSB0aGUgY2FjaGUga2V5LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdjJzogMywgJ2QnOiA0IH07XG4gKlxuICogdmFyIHZhbHVlcyA9IF8ubWVtb2l6ZShfLnZhbHVlcyk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIHZhbHVlcyhvdGhlcik7XG4gKiAvLyA9PiBbMywgNF1cbiAqXG4gKiBvYmplY3QuYSA9IDI7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIC8vIE1vZGlmeSB0aGUgcmVzdWx0IGNhY2hlLlxuICogdmFsdWVzLmNhY2hlLnNldChvYmplY3QsIFsnYScsICdiJ10pO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddXG4gKlxuICogLy8gUmVwbGFjZSBgXy5tZW1vaXplLkNhY2hlYC5cbiAqIF8ubWVtb2l6ZS5DYWNoZSA9IFdlYWtNYXA7XG4gKi9cbmZ1bmN0aW9uIG1lbW9pemUoZnVuYywgcmVzb2x2ZXIpIHtcbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicgfHwgKHJlc29sdmVyICE9IG51bGwgJiYgdHlwZW9mIHJlc29sdmVyICE9ICdmdW5jdGlvbicpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBrZXkgPSByZXNvbHZlciA/IHJlc29sdmVyLmFwcGx5KHRoaXMsIGFyZ3MpIDogYXJnc1swXSxcbiAgICAgICAgY2FjaGUgPSBtZW1vaXplZC5jYWNoZTtcblxuICAgIGlmIChjYWNoZS5oYXMoa2V5KSkge1xuICAgICAgcmV0dXJuIGNhY2hlLmdldChrZXkpO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICBtZW1vaXplZC5jYWNoZSA9IGNhY2hlLnNldChrZXksIHJlc3VsdCkgfHwgY2FjaGU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgbWVtb2l6ZWQuY2FjaGUgPSBuZXcgKG1lbW9pemUuQ2FjaGUgfHwgTWFwQ2FjaGUpO1xuICByZXR1cm4gbWVtb2l6ZWQ7XG59XG5cbi8vIEV4cG9zZSBgTWFwQ2FjaGVgLlxubWVtb2l6ZS5DYWNoZSA9IE1hcENhY2hlO1xuXG4vKipcbiAqIFBlcmZvcm1zIGFcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcSgnYScsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcShOYU4sIE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJndW1lbnRzID0gYmFzZUlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID8gYmFzZUlzQXJndW1lbnRzIDogZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmXG4gICAgIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKTtcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheSgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcbiAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcbiAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBCdWZmZXIoMikpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IFVpbnQ4QXJyYXkoMikpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQnVmZmVyID0gbmF0aXZlSXNCdWZmZXIgfHwgc3R1YkZhbHNlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gU2FmYXJpIDkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXlzIGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gIHZhciB0YWcgPSBiYXNlR2V0VGFnKHZhbHVlKTtcbiAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWcgfHwgdGFnID09IGFzeW5jVGFnIHx8IHRhZyA9PSBwcm94eVRhZztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNMZW5ndGgoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgdHlwZWQgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkoW10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzVHlwZWRBcnJheSA9IG5vZGVJc1R5cGVkQXJyYXkgPyBiYXNlVW5hcnkobm9kZUlzVHlwZWRBcnJheSkgOiBiYXNlSXNUeXBlZEFycmF5O1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcuIEFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZCBmb3IgYG51bGxgXG4gKiBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzLiBUaGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9TdHJpbmcobnVsbCk7XG4gKiAvLyA9PiAnJ1xuICpcbiAqIF8udG9TdHJpbmcoLTApO1xuICogLy8gPT4gJy0wJ1xuICpcbiAqIF8udG9TdHJpbmcoWzEsIDIsIDNdKTtcbiAqIC8vID0+ICcxLDIsMydcbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IGJhc2VUb1N0cmluZyh2YWx1ZSk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgLiBJZiB0aGUgcmVzb2x2ZWQgdmFsdWUgaXNcbiAqIGB1bmRlZmluZWRgLCB0aGUgYGRlZmF1bHRWYWx1ZWAgaXMgcmV0dXJuZWQgaW4gaXRzIHBsYWNlLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy43LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IFtkZWZhdWx0VmFsdWVdIFRoZSB2YWx1ZSByZXR1cm5lZCBmb3IgYHVuZGVmaW5lZGAgcmVzb2x2ZWQgdmFsdWVzLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9XSB9O1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgJ2FbMF0uYi5jJyk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5nZXQob2JqZWN0LCBbJ2EnLCAnMCcsICdiJywgJ2MnXSk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5nZXQob2JqZWN0LCAnYS5iLmMnLCAnZGVmYXVsdCcpO1xuICogLy8gPT4gJ2RlZmF1bHQnXG4gKi9cbmZ1bmN0aW9uIGdldChvYmplY3QsIHBhdGgsIGRlZmF1bHRWYWx1ZSkge1xuICB2YXIgcmVzdWx0ID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHBhdGhgIGlzIGEgZGlyZWN0IG9yIGluaGVyaXRlZCBwcm9wZXJ0eSBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSBfLmNyZWF0ZSh7ICdhJzogXy5jcmVhdGUoeyAnYic6IDIgfSkgfSk7XG4gKlxuICogXy5oYXNJbihvYmplY3QsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsICdhLmInKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsICdiJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBoYXNJbihvYmplY3QsIHBhdGgpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBiYXNlSGFzSW4pO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXG4gKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5cyhuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiBfLmtleXMoJ2hpJyk7XG4gKiAvLyA9PiBbJzAnLCAnMSddXG4gKi9cbmZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QpIDogYmFzZUtleXMob2JqZWN0KTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGB2YWx1ZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJldHVybiBmcm9tIHRoZSBuZXcgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb25zdGFudCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBfLnRpbWVzKDIsIF8uY29uc3RhbnQoeyAnYSc6IDEgfSkpO1xuICpcbiAqIGNvbnNvbGUubG9nKG9iamVjdHMpO1xuICogLy8gPT4gW3sgJ2EnOiAxIH0sIHsgJ2EnOiAxIH1dXG4gKlxuICogY29uc29sZS5sb2cob2JqZWN0c1swXSA9PT0gb2JqZWN0c1sxXSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGNvbnN0YW50KHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgaXQgcmVjZWl2ZXMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKlxuICogY29uc29sZS5sb2coXy5pZGVudGl0eShvYmplY3QpID09PSBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpZGVudGl0eSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGEgZ2l2ZW4gb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi40LjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gW1xuICogICB7ICdhJzogeyAnYic6IDIgfSB9LFxuICogICB7ICdhJzogeyAnYic6IDEgfSB9XG4gKiBdO1xuICpcbiAqIF8ubWFwKG9iamVjdHMsIF8ucHJvcGVydHkoJ2EuYicpKTtcbiAqIC8vID0+IFsyLCAxXVxuICpcbiAqIF8ubWFwKF8uc29ydEJ5KG9iamVjdHMsIF8ucHJvcGVydHkoWydhJywgJ2InXSkpLCAnYS5iJyk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqL1xuZnVuY3Rpb24gcHJvcGVydHkocGF0aCkge1xuICByZXR1cm4gaXNLZXkocGF0aCkgPyBiYXNlUHJvcGVydHkodG9LZXkocGF0aCkpIDogYmFzZVByb3BlcnR5RGVlcChwYXRoKTtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGVtcHR5IGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZW1wdHkgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBhcnJheXMgPSBfLnRpbWVzKDIsIF8uc3R1YkFycmF5KTtcbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheXMpO1xuICogLy8gPT4gW1tdLCBbXV1cbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheXNbMF0gPT09IGFycmF5c1sxXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBzdHViQXJyYXkoKSB7XG4gIHJldHVybiBbXTtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGBmYWxzZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRpbWVzKDIsIF8uc3R1YkZhbHNlKTtcbiAqIC8vID0+IFtmYWxzZSwgZmFsc2VdXG4gKi9cbmZ1bmN0aW9uIHN0dWJGYWxzZSgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNvcnRCeTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.sortby/index.js\n");

/***/ }),

/***/ "./node_modules/fastest-validator/dist/index.min.js":
/*!**********************************************************!*\
  !*** ./node_modules/fastest-validator/dist/index.min.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {function r(){function e(e,t){if(\"string\"!=typeof e)return this.makeError(\"string\");if(e=e.toLowerCase(),!T.test(e))return this.makeError(\"uuid\");var r=0|e.charAt(14);if(t.version&&t.version!==r)return this.makeError(\"uuidVersion\",t.version,r);switch(r){case 1:case 2:return!0;case 3:case 4:case 5:return-1!==[\"8\",\"9\",\"a\",\"b\"].indexOf(e.charAt(19))||this.makeError(\"uuid\")}}function t(e){return\"string\"!=typeof e?this.makeError(\"string\"):!!A.test(e)||this.makeError(\"url\")}function r(e,t){if(\"string\"!=typeof e)return this.makeError(\"string\");var r=e.length;return!1===t.empty&&0===r?this.makeError(\"stringEmpty\"):null!=t.min&&r<t.min?this.makeError(\"stringMin\",t.min,r):null!=t.max&&r>t.max?this.makeError(\"stringMax\",t.max,r):null!=t.length&&r!==t.length?this.makeError(\"stringLength\",t.length,r):null==t.pattern||(r=\"string\"==typeof t.pattern?new RegExp(t.pattern,t.patternFlags):t.pattern).test(e)?null!=t.contains&&-1===e.indexOf(t.contains)?this.makeError(\"stringContains\",t.contains):null!=t.enum&&-1===t.enum.indexOf(e)?this.makeError(\"stringEnum\",t.enum):!0!==t.numeric||S.test(e)?!0!==t.alpha||x.test(e)?!0!==t.alphanum||O.test(e)?!(!0===t.alphadash&&!_.test(e))||this.makeError(\"stringAlphadash\",\"An alphadash string\",e):this.makeError(\"stringAlphanum\",\"An alphanumeric string\",e):this.makeError(\"stringAlpha\",\"An alphabetic string\",e):this.makeError(\"stringNumeric\",\"A numeric string\",e):this.makeError(\"stringPattern\",r)}function n(e,t){if(\"object\"!=typeof e||null===e||Array.isArray(e))return this.makeError(\"object\");if(!0===t.strict&&t.props){t=Object.keys(t.props);var r=[];e=Object.keys(e);for(var n=0;n<e.length;n++)-1===t.indexOf(e[n])&&r.push(e[n]);if(0!==r.length)return this.makeError(\"objectStrict\",void 0,r.join(\", \"))}return!0}function i(e,t){return!0===t.convert&&\"number\"!=typeof e&&(e=Number(e)),\"number\"!=typeof e||isNaN(e)||!isFinite(e)?this.makeError(\"number\"):null!=t.min&&e<t.min?this.makeError(\"numberMin\",t.min,e):null!=t.max&&e>t.max?this.makeError(\"numberMax\",t.max,e):null!=t.equal&&e!==t.equal?this.makeError(\"numberEqual\",t.equal,e):null!=t.notEqual&&e===t.notEqual?this.makeError(\"numberNotEqual\",t.notEqual):!0===t.integer&&0!=e%1?this.makeError(\"numberInteger\",e):!0===t.positive&&0>=e?this.makeError(\"numberPositive\",e):!(!0===t.negative&&0<=e)||this.makeError(\"numberNegative\",e)}function a(e){return\"function\"==typeof e||this.makeError(\"function\")}function o(e){return null===e||void 0===e||this.makeError(\"forbidden\")}function s(e,t){return null==t.values||-1!==t.values.indexOf(e)||this.makeError(\"enumValue\",t.values,e)}function u(e,t){return\"string\"!=typeof e?this.makeError(\"string\"):!!(\"precise\"==t.mode?E:k).test(e)||this.makeError(\"email\")}function l(e,t){return!0!==t.convert||e instanceof Date||(e=new Date(e)),e instanceof Date&&!isNaN(e.getTime())||this.makeError(\"date\")}function f(e,t){return t.check.call(this,e,t)}function c(e,t){return!0===t.convert&&\"boolean\"!=typeof e&&(1===e||0===e||\"true\"===e||\"false\"===e||\"1\"===e||\"0\"===e||\"on\"===e||\"off\"===e)||(\"boolean\"==typeof e||this.makeError(\"boolean\"))}function h(e,t){if(!Array.isArray(e))return this.makeError(\"array\");var r=e.length;if(!1===t.empty&&0===r)return this.makeError(\"arrayEmpty\");if(null!=t.min&&r<t.min)return this.makeError(\"arrayMin\",t.min,r);if(null!=t.max&&r>t.max)return this.makeError(\"arrayMax\",t.max,r);if(null!=t.length&&r!==t.length)return this.makeError(\"arrayLength\",t.length,r);if(null!=t.contains&&-1===e.indexOf(t.contains))return this.makeError(\"arrayContains\",t.contains);if(null!=t.enum)for(r=0;r<e.length;r++)if(-1===t.enum.indexOf(e[r]))return this.makeError(\"arrayEnum\",e[r],t.enum);return!0}function p(){return!0}function m(e,t){t=t||[];for(var r=0;r<e.length;++r)Array.isArray(e[r])?m(e[r],t):t.push(e[r]);return t}function d(e,t){for(var r in t)\"object\"==typeof t[r]&&null!==t[r]?(e[r]=e[r]||{},d(e[r],t[r])):e[r]=t[r];return e}function y(e){return e.replace(M,function(e){switch(e){case'\"':case\"'\":case\"\\\\\":return\"\\\\\"+e;case\"\\n\":return\"\\\\n\";case\"\\r\":return\"\\\\r\";case\"\\u2028\":return\"\\\\u2028\";case\"\\u2029\":return\"\\\\u2029\"}})}function b(m){this.opts={messages:g({},v)},m&&g(this.opts,m),this.messages=this.opts.messages,this.messageKeys=Object.keys(this.messages),this.rules={any:p,array:h,boolean:c,custom:f,date:l,email:u,enum:s,forbidden:o,function:a,number:i,object:n,string:r,url:t,uuid:e},this.cache=new Map}var g=d,v={required:\"The '{field}' field is required!\",string:\"The '{field}' field must be a string!\",stringEmpty:\"The '{field}' field must not be empty!\",stringMin:\"The '{field}' field length must be greater than or equal to {expected} characters long!\",stringMax:\"The '{field}' field length must be less than or equal to {expected} characters long!\",stringLength:\"The '{field}' field length must be {expected} characters long!\",stringPattern:\"The '{field}' field fails to match the required pattern!\",stringContains:\"The '{field}' field must contain the '{expected}' text!\",stringEnum:\"The '{field}' field does not match any of the allowed values!\",stringNumeric:\"The '{field}' field must be a numeric string\",stringAlpha:\"The '{field}' field must be an alphabetic string\",stringAlphanum:\"The '{field}' field must be an alphanumeric string\",stringAlphadash:\"The '{field}' field must be an alphadash string\",number:\"The '{field}' field must be a number!\",numberMin:\"The '{field}' field must be greater than or equal to {expected}!\",numberMax:\"The '{field}' field must be less than or equal to {expected}!\",numberEqual:\"The '{field}' field must be equal with {expected}!\",numberNotEqual:\"The '{field}' field can't be equal with {expected}!\",numberInteger:\"The '{field}' field must be an integer!\",numberPositive:\"The '{field}' field must be a positive number!\",numberNegative:\"The '{field}' field must be a negative number!\",array:\"The '{field}' field must be an array!\",arrayEmpty:\"The '{field}' field must not be an empty array!\",arrayMin:\"The '{field}' field must contain at least {expected} items!\",arrayMax:\"The '{field}' field must contain less than or equal to {expected} items!\",arrayLength:\"The '{field}' field must contain {expected} items!\",arrayContains:\"The '{field}' field must contain the '{expected}' item!\",arrayEnum:\"The '{field} field value '{expected}' does not match any of the allowed values!\",boolean:\"The '{field}' field must be a boolean!\",function:\"The '{field}' field must be a function!\",date:\"The '{field}' field must be a Date!\",dateMin:\"The '{field}' field must be greater than or equal to {expected}!\",dateMax:\"The '{field}' field must be less than or equal to {expected}!\",forbidden:\"The '{field}' field is forbidden!\",email:\"The '{field}' field must be a valid e-mail!\",url:\"The '{field}' field must be a valid URL!\",enumValue:\"The '{field} field value '{expected}' does not match any of the allowed values!\",object:\"The '{field}' must be an Object!\",objectStrict:\"The object '{field}' contains invalid keys: '{actual}'!\",uuid:\"The {field} field must be a valid UUID\",uuidVersion:\"The {field} field must be a valid version provided\"},E=/^(([^<>()[\\]\\\\.,;:\\s@\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/,k=/^\\S+@\\S+\\.\\S+$/,S=/^-?[0-9]\\d*(\\.\\d+)?$/,x=/^[a-zA-Z]+$/,O=/^[a-zA-Z0-9]+$/,_=/^[a-zA-Z0-9_-]+$/,A=/^https?:\\/\\/\\S+/,T=/^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[0-9a-f]{4}-[0-9a-f]{12}$/i,j=/^[_$a-zA-Z][_$a-zA-Z0-9]*$/,M=/[\"'\\\\\\n\\r\\u2028\\u2029]/g;return b.prototype.validate=function(e,t){return this.compile(t)(e)},b.prototype.compile=function(e){var t=this;if(Array.isArray(e)){if(0==e.length)throw Error(\"If the schema is an Array, must contain at least one element!\");var r=this.compileSchemaType(e);return this.cache.clear(),function(e,n,i){return t.checkSchemaType(e,r,n,i||null)}}var n=this.compileSchemaObject(e);return this.cache.clear(),function(e,r,i){return t.checkSchemaObject(e,n,r,i||null)}},b.prototype.compileSchemaObject=function(e){var t=this;if(null===e||\"object\"!=typeof e||Array.isArray(e))throw Error(\"Invalid schema!\");var r=this.cache.get(e);if(r)return r.cycle=!0,r;r={cycle:!1,properties:null,compiledObjectFunction:null,objectStack:[]},this.cache.set(e,r),r.properties=Object.keys(e).filter(function(e){return\"$$strict\"!==e}).map(function(r){return{name:r,compiledType:t.compileSchemaType(e[r])}});var n=[];n.push(\"let res;\"),n.push(\"let propertyPath;\"),n.push(\"const errors = [];\"),!0===e.$$strict&&n.push(\"const givenProps = new Map(Object.keys(value).map(key => [key, true]));\");for(var i=0;i<r.properties.length;i++){var a=r.properties[i],o=y(a.name),s=j.test(o)?\"value.\"+o:'value[\"'+o+'\"]';n.push('propertyPath = (path !== undefined ? path + \".'+o+'\" : \"'+o+'\");'),Array.isArray(a.compiledType)?n.push(\"res = this.checkSchemaType(\"+s+\", properties[\"+i+\"].compiledType, propertyPath, value);\"):n.push(\"res = this.checkSchemaRule(\"+s+\", properties[\"+i+\"].compiledType, propertyPath, value);\"),n.push(\"if (res !== true) {\"),n.push(\"\\tthis.handleResult(errors, propertyPath, res, properties[\"+i+\"].compiledType.messages);\"),n.push(\"}\"),!0===e.$$strict&&n.push('givenProps.delete(\"'+o+'\");')}return!0===e.$$strict&&(n.push(\"if (givenProps.size !== 0) {\"),n.push(\"\\tthis.handleResult(errors, path || 'rootObject', this.makeError('objectStrict', undefined, [...givenProps.keys()].join(', ')), this.messages);\"),n.push(\"}\")),n.push(\"return errors.length === 0 ? true : errors;\"),r.compiledObjectFunction=new Function(\"value\",\"properties\",\"path\",\"parent\",n.join(\"\\n\")),r},b.prototype.compileSchemaType=function(e){var t=this;return Array.isArray(e)?(e=m(e.map(function(e){return t.compileSchemaType(e)})),1==e.length?e[0]:e):this.compileSchemaRule(e)},b.prototype.compileMessages=function(e){var t=this;return e.messages?this.messageKeys.reduce(function(r,n){return r[n]=e.messages[n]||t.messages[n],r},{}):this.messages},b.prototype.compileSchemaRule=function(e){\"string\"==typeof e&&(e={type:e});var t=this.rules[e.type];if(!t)throw Error(\"Invalid '\"+e.type+\"' type in validator schema!\");var r=this.compileMessages(e),n=null,i=null;return\"object\"===e.type&&e.props?(n=this.compileSchemaObject(e.props),i=this.checkSchemaObject):\"array\"===e.type&&e.items&&(n=this.compileSchemaType(e.items),i=this.checkSchemaArray),{messages:r,schemaRule:e,ruleFunction:t,dataFunction:i,dataParameter:n}},b.prototype.checkSchemaObject=function(e,t,r,n){return t.cycle?-1!==t.objectStack.indexOf(e)||(t.objectStack.push(e),e=this.checkSchemaObjectInner(e,t,r,n),t.objectStack.pop(),e):this.checkSchemaObjectInner(e,t,r,n)},b.prototype.checkSchemaObjectInner=function(e,t,r,n){return t.compiledObjectFunction.call(this,e,t.properties,r,n)},b.prototype.checkSchemaType=function(e,t,r,n){if(Array.isArray(t)){for(var i=[],a=t.length,o=0;o<a;o++){var s=this.checkSchemaRule(e,t[o],r,n);if(!0===s)return!0;this.handleResult(i,r,s,t.messages)}return i}return this.checkSchemaRule(e,t,r,n)},b.prototype.checkSchemaArray=function(e,t,r,n){for(var i=[],a=e.length,o=0;o<a;o++){var s=(void 0!==r?r:\"\")+\"[\"+o+\"]\",u=this.checkSchemaType(e[o],t,s,e,n);!0!==u&&this.handleResult(i,s,u,t.messages)}return 0===i.length||i},b.prototype.checkSchemaRule=function(e,t,r,n){var i=t.schemaRule;return void 0===e||null===e?\"forbidden\"===i.type||!0===i.optional||(e=[],this.handleResult(e,r,this.makeError(\"required\"),t.messages),e):(i=t.ruleFunction.call(this,e,i,r,n),!0!==i?(e=[],this.handleResult(e,r,i,t.messages),e):null===t.dataFunction||t.dataFunction.call(this,e,t.dataParameter,r,n))},b.prototype.handleResult=function(e,t,r,n){var i=this;(Array.isArray(r)?r:[r]).forEach(function(r){r.field||(r.field=t),r.message||(r.message=i.resolveMessage(r,n[r.type])),e.push(r)})},b.prototype.makeError=function(e,t,r){return{type:e,expected:t,actual:r}},b.prototype.resolveMessage=function(e,t){if(void 0===t&&(t=null),null!=t){var r=null!=e.expected?e.expected:\"\",n=null!=e.actual?e.actual:\"\";return t.replace(/\\{field\\}/g,e.field).replace(/\\{expected\\}/g,r).replace(/\\{actual\\}/g,n)}},b.prototype.add=function(e,t){this.rules[e]=t},b}var f=f||{};f.scope={},f.ASSUME_ES5=!1,f.ASSUME_NO_NATIVE_MAP=!1,f.ASSUME_NO_NATIVE_SET=!1,f.defineProperty=f.ASSUME_ES5||\"function\"==typeof Object.defineProperties?Object.defineProperty:function(e,t,r){e!=Array.prototype&&e!=Object.prototype&&(e[t]=r.value)},f.getGlobal=function(e){return\"undefined\"!=typeof window&&window===e?e:\"undefined\"!=typeof global&&null!=global?global:e},f.global=f.getGlobal(this),f.SYMBOL_PREFIX=\"jscomp_symbol_\",f.initSymbol=function(){f.initSymbol=function(){},f.global.Symbol||(f.global.Symbol=f.Symbol)},f.Symbol=function(){var e=0;return function(t){return f.SYMBOL_PREFIX+(t||\"\")+e++}}(),f.initSymbolIterator=function(){f.initSymbol();var e=f.global.Symbol.iterator;e||(e=f.global.Symbol.iterator=f.global.Symbol(\"iterator\")),\"function\"!=typeof Array.prototype[e]&&f.defineProperty(Array.prototype,e,{configurable:!0,writable:!0,value:function(){return f.arrayIterator(this)}}),f.initSymbolIterator=function(){}},f.arrayIterator=function(e){var t=0;return f.iteratorPrototype(function(){return t<e.length?{done:!1,value:e[t++]}:{done:!0}})},f.iteratorPrototype=function(e){return f.initSymbolIterator(),e={next:e},e[f.global.Symbol.iterator]=function(){return this},e},f.iteratorFromArray=function(e,t){f.initSymbolIterator(),e instanceof String&&(e+=\"\");var r=0,n={next:function(){if(r<e.length){var i=r++;return{value:t(i,e[i]),done:!1}}return n.next=function(){return{done:!0,value:void 0}},n.next()}};return n[Symbol.iterator]=function(){return n},n},f.polyfill=function(e,t){if(t){var r=f.global;e=e.split(\".\");for(var n=0;n<e.length-1;n++){var i=e[n];i in r||(r[i]={}),r=r[i]}(t=t(n=r[e=e[e.length-1]]))!=n&&null!=t&&f.defineProperty(r,e,{configurable:!0,writable:!0,value:t})}},f.polyfill(\"Array.prototype.keys\",function(e){return e||function(){return f.iteratorFromArray(this,function(e){return e})}},\"es6\",\"es3\"),f.checkEs6ConformanceViaProxy=function(){try{var e={},t=Object.create(new f.global.Proxy(e,{get:function(r,n,i){return r==e&&\"q\"==n&&i==t}}));return!0===t.q}catch(e){return!1}},f.USE_PROXY_FOR_ES6_CONFORMANCE_CHECKS=!1,f.ES6_CONFORMANCE=f.USE_PROXY_FOR_ES6_CONFORMANCE_CHECKS&&f.checkEs6ConformanceViaProxy(),f.makeIterator=function(e){f.initSymbolIterator();var t=e[Symbol.iterator];return t?t.call(e):f.arrayIterator(e)},f.owns=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},f.polyfill(\"WeakMap\",function(e){function t(e){if(this.id_=(a+=Math.random()+1).toString(),e){f.initSymbol(),f.initSymbolIterator(),e=f.makeIterator(e);for(var t;!(t=e.next()).done;)t=t.value,this.set(t[0],t[1])}}function r(e){f.owns(e,i)||f.defineProperty(e,i,{value:{}})}function n(e){var t=Object[e];t&&(Object[e]=function(e){return r(e),t(e)})}if(f.USE_PROXY_FOR_ES6_CONFORMANCE_CHECKS){if(e&&f.ES6_CONFORMANCE)return e}else if(function(){if(!e||!Object.seal)return!1;try{var t=Object.seal({}),r=Object.seal({}),n=new e([[t,2],[r,3]]);return 2==n.get(t)&&3==n.get(r)&&(n.delete(t),n.set(r,4),!n.has(t)&&4==n.get(r))}catch(e){return!1}}())return e;var i=\"$jscomp_hidden_\"+Math.random();n(\"freeze\"),n(\"preventExtensions\"),n(\"seal\");var a=0;return t.prototype.set=function(e,t){if(r(e),!f.owns(e,i))throw Error(\"WeakMap key fail: \"+e);return e[i][this.id_]=t,this},t.prototype.get=function(e){return f.owns(e,i)?e[i][this.id_]:void 0},t.prototype.has=function(e){return f.owns(e,i)&&f.owns(e[i],this.id_)},t.prototype.delete=function(e){return!(!f.owns(e,i)||!f.owns(e[i],this.id_))&&delete e[i][this.id_]},t},\"es6\",\"es3\"),f.MapEntry=function(){},f.polyfill(\"Map\",function(e){function t(){var e={};return e.previous=e.next=e.head=e}function r(e,t){var r=e.head_;return f.iteratorPrototype(function(){if(r){for(;r.head!=e.head_;)r=r.previous;for(;r.next!=r.head;)return r=r.next,{done:!1,value:t(r)};r=null}return{done:!0,value:void 0}})}function n(e,t){var r=t&&typeof t;\"object\"==r||\"function\"==r?a.has(t)?r=a.get(t):(r=\"\"+ ++o,a.set(t,r)):r=\"p_\"+t;var n=e.data_[r];if(n&&f.owns(e.data_,r))for(e=0;e<n.length;e++){var i=n[e];if(t!==t&&i.key!==i.key||t===i.key)return{id:r,list:n,index:e,entry:i}}return{id:r,list:n,index:-1,entry:void 0}}function i(e){if(this.data_={},this.head_=t(),this.size=0,e){e=f.makeIterator(e);for(var r;!(r=e.next()).done;)r=r.value,this.set(r[0],r[1])}}if(f.USE_PROXY_FOR_ES6_CONFORMANCE_CHECKS){if(e&&f.ES6_CONFORMANCE)return e}else if(function(){if(f.ASSUME_NO_NATIVE_MAP||!e||\"function\"!=typeof e||!e.prototype.entries||\"function\"!=typeof Object.seal)return!1;try{var t=Object.seal({x:4}),r=new e(f.makeIterator([[t,\"s\"]]));if(\"s\"!=r.get(t)||1!=r.size||r.get({x:4})||r.set({x:4},\"t\")!=r||2!=r.size)return!1;var n=r.entries(),i=n.next();return!i.done&&i.value[0]==t&&\"s\"==i.value[1]&&!((i=n.next()).done||4!=i.value[0].x||\"t\"!=i.value[1]||!n.next().done)}catch(e){return!1}}())return e;f.initSymbol(),f.initSymbolIterator();var a=new WeakMap;i.prototype.set=function(e,t){var r=n(this,e);return r.list||(r.list=this.data_[r.id]=[]),r.entry?r.entry.value=t:(r.entry={next:this.head_,previous:this.head_.previous,head:this.head_,key:e,value:t},r.list.push(r.entry),this.head_.previous.next=r.entry,this.head_.previous=r.entry,this.size++),this},i.prototype.delete=function(e){return!(!(e=n(this,e)).entry||!e.list)&&(e.list.splice(e.index,1),e.list.length||delete this.data_[e.id],e.entry.previous.next=e.entry.next,e.entry.next.previous=e.entry.previous,e.entry.head=null,this.size--,!0)},i.prototype.clear=function(){this.data_={},this.head_=this.head_.previous=t(),this.size=0},i.prototype.has=function(e){return!!n(this,e).entry},i.prototype.get=function(e){return(e=n(this,e).entry)&&e.value},i.prototype.entries=function(){return r(this,function(e){return[e.key,e.value]})},i.prototype.keys=function(){return r(this,function(e){return e.key})},i.prototype.values=function(){return r(this,function(e){return e.value})},i.prototype.forEach=function(e,t){for(var r,n=this.entries();!(r=n.next()).done;)r=r.value,e.call(t,r[1],r[0],this)},i.prototype[Symbol.iterator]=i.prototype.entries;var o=0;return i},\"es6\",\"es3\"), true?module.exports=r():undefined;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmFzdGVzdC12YWxpZGF0b3IvZGlzdC9pbmRleC5taW4uanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmFzdGVzdC12YWxpZGF0b3IvZGlzdC9pbmRleC5taW4uanM/MDc5NSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKCl7ZnVuY3Rpb24gZShlLHQpe2lmKFwic3RyaW5nXCIhPXR5cGVvZiBlKXJldHVybiB0aGlzLm1ha2VFcnJvcihcInN0cmluZ1wiKTtpZihlPWUudG9Mb3dlckNhc2UoKSwhVC50ZXN0KGUpKXJldHVybiB0aGlzLm1ha2VFcnJvcihcInV1aWRcIik7dmFyIHI9MHxlLmNoYXJBdCgxNCk7aWYodC52ZXJzaW9uJiZ0LnZlcnNpb24hPT1yKXJldHVybiB0aGlzLm1ha2VFcnJvcihcInV1aWRWZXJzaW9uXCIsdC52ZXJzaW9uLHIpO3N3aXRjaChyKXtjYXNlIDE6Y2FzZSAyOnJldHVybiEwO2Nhc2UgMzpjYXNlIDQ6Y2FzZSA1OnJldHVybi0xIT09W1wiOFwiLFwiOVwiLFwiYVwiLFwiYlwiXS5pbmRleE9mKGUuY2hhckF0KDE5KSl8fHRoaXMubWFrZUVycm9yKFwidXVpZFwiKX19ZnVuY3Rpb24gdChlKXtyZXR1cm5cInN0cmluZ1wiIT10eXBlb2YgZT90aGlzLm1ha2VFcnJvcihcInN0cmluZ1wiKTohIUEudGVzdChlKXx8dGhpcy5tYWtlRXJyb3IoXCJ1cmxcIil9ZnVuY3Rpb24gcihlLHQpe2lmKFwic3RyaW5nXCIhPXR5cGVvZiBlKXJldHVybiB0aGlzLm1ha2VFcnJvcihcInN0cmluZ1wiKTt2YXIgcj1lLmxlbmd0aDtyZXR1cm4hMT09PXQuZW1wdHkmJjA9PT1yP3RoaXMubWFrZUVycm9yKFwic3RyaW5nRW1wdHlcIik6bnVsbCE9dC5taW4mJnI8dC5taW4/dGhpcy5tYWtlRXJyb3IoXCJzdHJpbmdNaW5cIix0Lm1pbixyKTpudWxsIT10Lm1heCYmcj50Lm1heD90aGlzLm1ha2VFcnJvcihcInN0cmluZ01heFwiLHQubWF4LHIpOm51bGwhPXQubGVuZ3RoJiZyIT09dC5sZW5ndGg/dGhpcy5tYWtlRXJyb3IoXCJzdHJpbmdMZW5ndGhcIix0Lmxlbmd0aCxyKTpudWxsPT10LnBhdHRlcm58fChyPVwic3RyaW5nXCI9PXR5cGVvZiB0LnBhdHRlcm4/bmV3IFJlZ0V4cCh0LnBhdHRlcm4sdC5wYXR0ZXJuRmxhZ3MpOnQucGF0dGVybikudGVzdChlKT9udWxsIT10LmNvbnRhaW5zJiYtMT09PWUuaW5kZXhPZih0LmNvbnRhaW5zKT90aGlzLm1ha2VFcnJvcihcInN0cmluZ0NvbnRhaW5zXCIsdC5jb250YWlucyk6bnVsbCE9dC5lbnVtJiYtMT09PXQuZW51bS5pbmRleE9mKGUpP3RoaXMubWFrZUVycm9yKFwic3RyaW5nRW51bVwiLHQuZW51bSk6ITAhPT10Lm51bWVyaWN8fFMudGVzdChlKT8hMCE9PXQuYWxwaGF8fHgudGVzdChlKT8hMCE9PXQuYWxwaGFudW18fE8udGVzdChlKT8hKCEwPT09dC5hbHBoYWRhc2gmJiFfLnRlc3QoZSkpfHx0aGlzLm1ha2VFcnJvcihcInN0cmluZ0FscGhhZGFzaFwiLFwiQW4gYWxwaGFkYXNoIHN0cmluZ1wiLGUpOnRoaXMubWFrZUVycm9yKFwic3RyaW5nQWxwaGFudW1cIixcIkFuIGFscGhhbnVtZXJpYyBzdHJpbmdcIixlKTp0aGlzLm1ha2VFcnJvcihcInN0cmluZ0FscGhhXCIsXCJBbiBhbHBoYWJldGljIHN0cmluZ1wiLGUpOnRoaXMubWFrZUVycm9yKFwic3RyaW5nTnVtZXJpY1wiLFwiQSBudW1lcmljIHN0cmluZ1wiLGUpOnRoaXMubWFrZUVycm9yKFwic3RyaW5nUGF0dGVyblwiLHIpfWZ1bmN0aW9uIG4oZSx0KXtpZihcIm9iamVjdFwiIT10eXBlb2YgZXx8bnVsbD09PWV8fEFycmF5LmlzQXJyYXkoZSkpcmV0dXJuIHRoaXMubWFrZUVycm9yKFwib2JqZWN0XCIpO2lmKCEwPT09dC5zdHJpY3QmJnQucHJvcHMpe3Q9T2JqZWN0LmtleXModC5wcm9wcyk7dmFyIHI9W107ZT1PYmplY3Qua2V5cyhlKTtmb3IodmFyIG49MDtuPGUubGVuZ3RoO24rKyktMT09PXQuaW5kZXhPZihlW25dKSYmci5wdXNoKGVbbl0pO2lmKDAhPT1yLmxlbmd0aClyZXR1cm4gdGhpcy5tYWtlRXJyb3IoXCJvYmplY3RTdHJpY3RcIix2b2lkIDAsci5qb2luKFwiLCBcIikpfXJldHVybiEwfWZ1bmN0aW9uIGkoZSx0KXtyZXR1cm4hMD09PXQuY29udmVydCYmXCJudW1iZXJcIiE9dHlwZW9mIGUmJihlPU51bWJlcihlKSksXCJudW1iZXJcIiE9dHlwZW9mIGV8fGlzTmFOKGUpfHwhaXNGaW5pdGUoZSk/dGhpcy5tYWtlRXJyb3IoXCJudW1iZXJcIik6bnVsbCE9dC5taW4mJmU8dC5taW4/dGhpcy5tYWtlRXJyb3IoXCJudW1iZXJNaW5cIix0Lm1pbixlKTpudWxsIT10Lm1heCYmZT50Lm1heD90aGlzLm1ha2VFcnJvcihcIm51bWJlck1heFwiLHQubWF4LGUpOm51bGwhPXQuZXF1YWwmJmUhPT10LmVxdWFsP3RoaXMubWFrZUVycm9yKFwibnVtYmVyRXF1YWxcIix0LmVxdWFsLGUpOm51bGwhPXQubm90RXF1YWwmJmU9PT10Lm5vdEVxdWFsP3RoaXMubWFrZUVycm9yKFwibnVtYmVyTm90RXF1YWxcIix0Lm5vdEVxdWFsKTohMD09PXQuaW50ZWdlciYmMCE9ZSUxP3RoaXMubWFrZUVycm9yKFwibnVtYmVySW50ZWdlclwiLGUpOiEwPT09dC5wb3NpdGl2ZSYmMD49ZT90aGlzLm1ha2VFcnJvcihcIm51bWJlclBvc2l0aXZlXCIsZSk6ISghMD09PXQubmVnYXRpdmUmJjA8PWUpfHx0aGlzLm1ha2VFcnJvcihcIm51bWJlck5lZ2F0aXZlXCIsZSl9ZnVuY3Rpb24gYShlKXtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiBlfHx0aGlzLm1ha2VFcnJvcihcImZ1bmN0aW9uXCIpfWZ1bmN0aW9uIG8oZSl7cmV0dXJuIG51bGw9PT1lfHx2b2lkIDA9PT1lfHx0aGlzLm1ha2VFcnJvcihcImZvcmJpZGRlblwiKX1mdW5jdGlvbiBzKGUsdCl7cmV0dXJuIG51bGw9PXQudmFsdWVzfHwtMSE9PXQudmFsdWVzLmluZGV4T2YoZSl8fHRoaXMubWFrZUVycm9yKFwiZW51bVZhbHVlXCIsdC52YWx1ZXMsZSl9ZnVuY3Rpb24gdShlLHQpe3JldHVyblwic3RyaW5nXCIhPXR5cGVvZiBlP3RoaXMubWFrZUVycm9yKFwic3RyaW5nXCIpOiEhKFwicHJlY2lzZVwiPT10Lm1vZGU/RTprKS50ZXN0KGUpfHx0aGlzLm1ha2VFcnJvcihcImVtYWlsXCIpfWZ1bmN0aW9uIGwoZSx0KXtyZXR1cm4hMCE9PXQuY29udmVydHx8ZSBpbnN0YW5jZW9mIERhdGV8fChlPW5ldyBEYXRlKGUpKSxlIGluc3RhbmNlb2YgRGF0ZSYmIWlzTmFOKGUuZ2V0VGltZSgpKXx8dGhpcy5tYWtlRXJyb3IoXCJkYXRlXCIpfWZ1bmN0aW9uIGYoZSx0KXtyZXR1cm4gdC5jaGVjay5jYWxsKHRoaXMsZSx0KX1mdW5jdGlvbiBjKGUsdCl7cmV0dXJuITA9PT10LmNvbnZlcnQmJlwiYm9vbGVhblwiIT10eXBlb2YgZSYmKDE9PT1lfHwwPT09ZXx8XCJ0cnVlXCI9PT1lfHxcImZhbHNlXCI9PT1lfHxcIjFcIj09PWV8fFwiMFwiPT09ZXx8XCJvblwiPT09ZXx8XCJvZmZcIj09PWUpfHwoXCJib29sZWFuXCI9PXR5cGVvZiBlfHx0aGlzLm1ha2VFcnJvcihcImJvb2xlYW5cIikpfWZ1bmN0aW9uIGgoZSx0KXtpZighQXJyYXkuaXNBcnJheShlKSlyZXR1cm4gdGhpcy5tYWtlRXJyb3IoXCJhcnJheVwiKTt2YXIgcj1lLmxlbmd0aDtpZighMT09PXQuZW1wdHkmJjA9PT1yKXJldHVybiB0aGlzLm1ha2VFcnJvcihcImFycmF5RW1wdHlcIik7aWYobnVsbCE9dC5taW4mJnI8dC5taW4pcmV0dXJuIHRoaXMubWFrZUVycm9yKFwiYXJyYXlNaW5cIix0Lm1pbixyKTtpZihudWxsIT10Lm1heCYmcj50Lm1heClyZXR1cm4gdGhpcy5tYWtlRXJyb3IoXCJhcnJheU1heFwiLHQubWF4LHIpO2lmKG51bGwhPXQubGVuZ3RoJiZyIT09dC5sZW5ndGgpcmV0dXJuIHRoaXMubWFrZUVycm9yKFwiYXJyYXlMZW5ndGhcIix0Lmxlbmd0aCxyKTtpZihudWxsIT10LmNvbnRhaW5zJiYtMT09PWUuaW5kZXhPZih0LmNvbnRhaW5zKSlyZXR1cm4gdGhpcy5tYWtlRXJyb3IoXCJhcnJheUNvbnRhaW5zXCIsdC5jb250YWlucyk7aWYobnVsbCE9dC5lbnVtKWZvcihyPTA7cjxlLmxlbmd0aDtyKyspaWYoLTE9PT10LmVudW0uaW5kZXhPZihlW3JdKSlyZXR1cm4gdGhpcy5tYWtlRXJyb3IoXCJhcnJheUVudW1cIixlW3JdLHQuZW51bSk7cmV0dXJuITB9ZnVuY3Rpb24gcCgpe3JldHVybiEwfWZ1bmN0aW9uIG0oZSx0KXt0PXR8fFtdO2Zvcih2YXIgcj0wO3I8ZS5sZW5ndGg7KytyKUFycmF5LmlzQXJyYXkoZVtyXSk/bShlW3JdLHQpOnQucHVzaChlW3JdKTtyZXR1cm4gdH1mdW5jdGlvbiBkKGUsdCl7Zm9yKHZhciByIGluIHQpXCJvYmplY3RcIj09dHlwZW9mIHRbcl0mJm51bGwhPT10W3JdPyhlW3JdPWVbcl18fHt9LGQoZVtyXSx0W3JdKSk6ZVtyXT10W3JdO3JldHVybiBlfWZ1bmN0aW9uIHkoZSl7cmV0dXJuIGUucmVwbGFjZShNLGZ1bmN0aW9uKGUpe3N3aXRjaChlKXtjYXNlJ1wiJzpjYXNlXCInXCI6Y2FzZVwiXFxcXFwiOnJldHVyblwiXFxcXFwiK2U7Y2FzZVwiXFxuXCI6cmV0dXJuXCJcXFxcblwiO2Nhc2VcIlxcclwiOnJldHVyblwiXFxcXHJcIjtjYXNlXCJcXHUyMDI4XCI6cmV0dXJuXCJcXFxcdTIwMjhcIjtjYXNlXCJcXHUyMDI5XCI6cmV0dXJuXCJcXFxcdTIwMjlcIn19KX1mdW5jdGlvbiBiKG0pe3RoaXMub3B0cz17bWVzc2FnZXM6Zyh7fSx2KX0sbSYmZyh0aGlzLm9wdHMsbSksdGhpcy5tZXNzYWdlcz10aGlzLm9wdHMubWVzc2FnZXMsdGhpcy5tZXNzYWdlS2V5cz1PYmplY3Qua2V5cyh0aGlzLm1lc3NhZ2VzKSx0aGlzLnJ1bGVzPXthbnk6cCxhcnJheTpoLGJvb2xlYW46YyxjdXN0b206ZixkYXRlOmwsZW1haWw6dSxlbnVtOnMsZm9yYmlkZGVuOm8sZnVuY3Rpb246YSxudW1iZXI6aSxvYmplY3Q6bixzdHJpbmc6cix1cmw6dCx1dWlkOmV9LHRoaXMuY2FjaGU9bmV3IE1hcH12YXIgZz1kLHY9e3JlcXVpcmVkOlwiVGhlICd7ZmllbGR9JyBmaWVsZCBpcyByZXF1aXJlZCFcIixzdHJpbmc6XCJUaGUgJ3tmaWVsZH0nIGZpZWxkIG11c3QgYmUgYSBzdHJpbmchXCIsc3RyaW5nRW1wdHk6XCJUaGUgJ3tmaWVsZH0nIGZpZWxkIG11c3Qgbm90IGJlIGVtcHR5IVwiLHN0cmluZ01pbjpcIlRoZSAne2ZpZWxkfScgZmllbGQgbGVuZ3RoIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHtleHBlY3RlZH0gY2hhcmFjdGVycyBsb25nIVwiLHN0cmluZ01heDpcIlRoZSAne2ZpZWxkfScgZmllbGQgbGVuZ3RoIG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHtleHBlY3RlZH0gY2hhcmFjdGVycyBsb25nIVwiLHN0cmluZ0xlbmd0aDpcIlRoZSAne2ZpZWxkfScgZmllbGQgbGVuZ3RoIG11c3QgYmUge2V4cGVjdGVkfSBjaGFyYWN0ZXJzIGxvbmchXCIsc3RyaW5nUGF0dGVybjpcIlRoZSAne2ZpZWxkfScgZmllbGQgZmFpbHMgdG8gbWF0Y2ggdGhlIHJlcXVpcmVkIHBhdHRlcm4hXCIsc3RyaW5nQ29udGFpbnM6XCJUaGUgJ3tmaWVsZH0nIGZpZWxkIG11c3QgY29udGFpbiB0aGUgJ3tleHBlY3RlZH0nIHRleHQhXCIsc3RyaW5nRW51bTpcIlRoZSAne2ZpZWxkfScgZmllbGQgZG9lcyBub3QgbWF0Y2ggYW55IG9mIHRoZSBhbGxvd2VkIHZhbHVlcyFcIixzdHJpbmdOdW1lcmljOlwiVGhlICd7ZmllbGR9JyBmaWVsZCBtdXN0IGJlIGEgbnVtZXJpYyBzdHJpbmdcIixzdHJpbmdBbHBoYTpcIlRoZSAne2ZpZWxkfScgZmllbGQgbXVzdCBiZSBhbiBhbHBoYWJldGljIHN0cmluZ1wiLHN0cmluZ0FscGhhbnVtOlwiVGhlICd7ZmllbGR9JyBmaWVsZCBtdXN0IGJlIGFuIGFscGhhbnVtZXJpYyBzdHJpbmdcIixzdHJpbmdBbHBoYWRhc2g6XCJUaGUgJ3tmaWVsZH0nIGZpZWxkIG11c3QgYmUgYW4gYWxwaGFkYXNoIHN0cmluZ1wiLG51bWJlcjpcIlRoZSAne2ZpZWxkfScgZmllbGQgbXVzdCBiZSBhIG51bWJlciFcIixudW1iZXJNaW46XCJUaGUgJ3tmaWVsZH0nIGZpZWxkIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHtleHBlY3RlZH0hXCIsbnVtYmVyTWF4OlwiVGhlICd7ZmllbGR9JyBmaWVsZCBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB7ZXhwZWN0ZWR9IVwiLG51bWJlckVxdWFsOlwiVGhlICd7ZmllbGR9JyBmaWVsZCBtdXN0IGJlIGVxdWFsIHdpdGgge2V4cGVjdGVkfSFcIixudW1iZXJOb3RFcXVhbDpcIlRoZSAne2ZpZWxkfScgZmllbGQgY2FuJ3QgYmUgZXF1YWwgd2l0aCB7ZXhwZWN0ZWR9IVwiLG51bWJlckludGVnZXI6XCJUaGUgJ3tmaWVsZH0nIGZpZWxkIG11c3QgYmUgYW4gaW50ZWdlciFcIixudW1iZXJQb3NpdGl2ZTpcIlRoZSAne2ZpZWxkfScgZmllbGQgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlciFcIixudW1iZXJOZWdhdGl2ZTpcIlRoZSAne2ZpZWxkfScgZmllbGQgbXVzdCBiZSBhIG5lZ2F0aXZlIG51bWJlciFcIixhcnJheTpcIlRoZSAne2ZpZWxkfScgZmllbGQgbXVzdCBiZSBhbiBhcnJheSFcIixhcnJheUVtcHR5OlwiVGhlICd7ZmllbGR9JyBmaWVsZCBtdXN0IG5vdCBiZSBhbiBlbXB0eSBhcnJheSFcIixhcnJheU1pbjpcIlRoZSAne2ZpZWxkfScgZmllbGQgbXVzdCBjb250YWluIGF0IGxlYXN0IHtleHBlY3RlZH0gaXRlbXMhXCIsYXJyYXlNYXg6XCJUaGUgJ3tmaWVsZH0nIGZpZWxkIG11c3QgY29udGFpbiBsZXNzIHRoYW4gb3IgZXF1YWwgdG8ge2V4cGVjdGVkfSBpdGVtcyFcIixhcnJheUxlbmd0aDpcIlRoZSAne2ZpZWxkfScgZmllbGQgbXVzdCBjb250YWluIHtleHBlY3RlZH0gaXRlbXMhXCIsYXJyYXlDb250YWluczpcIlRoZSAne2ZpZWxkfScgZmllbGQgbXVzdCBjb250YWluIHRoZSAne2V4cGVjdGVkfScgaXRlbSFcIixhcnJheUVudW06XCJUaGUgJ3tmaWVsZH0gZmllbGQgdmFsdWUgJ3tleHBlY3RlZH0nIGRvZXMgbm90IG1hdGNoIGFueSBvZiB0aGUgYWxsb3dlZCB2YWx1ZXMhXCIsYm9vbGVhbjpcIlRoZSAne2ZpZWxkfScgZmllbGQgbXVzdCBiZSBhIGJvb2xlYW4hXCIsZnVuY3Rpb246XCJUaGUgJ3tmaWVsZH0nIGZpZWxkIG11c3QgYmUgYSBmdW5jdGlvbiFcIixkYXRlOlwiVGhlICd7ZmllbGR9JyBmaWVsZCBtdXN0IGJlIGEgRGF0ZSFcIixkYXRlTWluOlwiVGhlICd7ZmllbGR9JyBmaWVsZCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB7ZXhwZWN0ZWR9IVwiLGRhdGVNYXg6XCJUaGUgJ3tmaWVsZH0nIGZpZWxkIG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHtleHBlY3RlZH0hXCIsZm9yYmlkZGVuOlwiVGhlICd7ZmllbGR9JyBmaWVsZCBpcyBmb3JiaWRkZW4hXCIsZW1haWw6XCJUaGUgJ3tmaWVsZH0nIGZpZWxkIG11c3QgYmUgYSB2YWxpZCBlLW1haWwhXCIsdXJsOlwiVGhlICd7ZmllbGR9JyBmaWVsZCBtdXN0IGJlIGEgdmFsaWQgVVJMIVwiLGVudW1WYWx1ZTpcIlRoZSAne2ZpZWxkfSBmaWVsZCB2YWx1ZSAne2V4cGVjdGVkfScgZG9lcyBub3QgbWF0Y2ggYW55IG9mIHRoZSBhbGxvd2VkIHZhbHVlcyFcIixvYmplY3Q6XCJUaGUgJ3tmaWVsZH0nIG11c3QgYmUgYW4gT2JqZWN0IVwiLG9iamVjdFN0cmljdDpcIlRoZSBvYmplY3QgJ3tmaWVsZH0nIGNvbnRhaW5zIGludmFsaWQga2V5czogJ3thY3R1YWx9JyFcIix1dWlkOlwiVGhlIHtmaWVsZH0gZmllbGQgbXVzdCBiZSBhIHZhbGlkIFVVSURcIix1dWlkVmVyc2lvbjpcIlRoZSB7ZmllbGR9IGZpZWxkIG11c3QgYmUgYSB2YWxpZCB2ZXJzaW9uIHByb3ZpZGVkXCJ9LEU9L14oKFtePD4oKVtcXF1cXFxcLiw7Olxcc0BcIl0rKFxcLltePD4oKVtcXF1cXFxcLiw7Olxcc0BcIl0rKSopfChcIi4rXCIpKUAoKFxcW1swLTldezEsM31cXC5bMC05XXsxLDN9XFwuWzAtOV17MSwzfVxcLlswLTldezEsM31cXF0pfCgoW2EtekEtWlxcLTAtOV0rXFwuKStbYS16QS1aXXsyLH0pKSQvLGs9L15cXFMrQFxcUytcXC5cXFMrJC8sUz0vXi0/WzAtOV1cXGQqKFxcLlxcZCspPyQvLHg9L15bYS16QS1aXSskLyxPPS9eW2EtekEtWjAtOV0rJC8sXz0vXlthLXpBLVowLTlfLV0rJC8sQT0vXmh0dHBzPzpcXC9cXC9cXFMrLyxUPS9eWzAtOWEtZl17OH0tWzAtOWEtZl17NH0tWzEtNV1bMC05YS1mXXszfS1bMC05YS1mXXs0fS1bMC05YS1mXXsxMn0kL2ksaj0vXltfJGEtekEtWl1bXyRhLXpBLVowLTldKiQvLE09L1tcIidcXFxcXFxuXFxyXFx1MjAyOFxcdTIwMjldL2c7cmV0dXJuIGIucHJvdG90eXBlLnZhbGlkYXRlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMuY29tcGlsZSh0KShlKX0sYi5wcm90b3R5cGUuY29tcGlsZT1mdW5jdGlvbihlKXt2YXIgdD10aGlzO2lmKEFycmF5LmlzQXJyYXkoZSkpe2lmKDA9PWUubGVuZ3RoKXRocm93IEVycm9yKFwiSWYgdGhlIHNjaGVtYSBpcyBhbiBBcnJheSwgbXVzdCBjb250YWluIGF0IGxlYXN0IG9uZSBlbGVtZW50IVwiKTt2YXIgcj10aGlzLmNvbXBpbGVTY2hlbWFUeXBlKGUpO3JldHVybiB0aGlzLmNhY2hlLmNsZWFyKCksZnVuY3Rpb24oZSxuLGkpe3JldHVybiB0LmNoZWNrU2NoZW1hVHlwZShlLHIsbixpfHxudWxsKX19dmFyIG49dGhpcy5jb21waWxlU2NoZW1hT2JqZWN0KGUpO3JldHVybiB0aGlzLmNhY2hlLmNsZWFyKCksZnVuY3Rpb24oZSxyLGkpe3JldHVybiB0LmNoZWNrU2NoZW1hT2JqZWN0KGUsbixyLGl8fG51bGwpfX0sYi5wcm90b3R5cGUuY29tcGlsZVNjaGVtYU9iamVjdD1mdW5jdGlvbihlKXt2YXIgdD10aGlzO2lmKG51bGw9PT1lfHxcIm9iamVjdFwiIT10eXBlb2YgZXx8QXJyYXkuaXNBcnJheShlKSl0aHJvdyBFcnJvcihcIkludmFsaWQgc2NoZW1hIVwiKTt2YXIgcj10aGlzLmNhY2hlLmdldChlKTtpZihyKXJldHVybiByLmN5Y2xlPSEwLHI7cj17Y3ljbGU6ITEscHJvcGVydGllczpudWxsLGNvbXBpbGVkT2JqZWN0RnVuY3Rpb246bnVsbCxvYmplY3RTdGFjazpbXX0sdGhpcy5jYWNoZS5zZXQoZSxyKSxyLnByb3BlcnRpZXM9T2JqZWN0LmtleXMoZSkuZmlsdGVyKGZ1bmN0aW9uKGUpe3JldHVyblwiJCRzdHJpY3RcIiE9PWV9KS5tYXAoZnVuY3Rpb24ocil7cmV0dXJue25hbWU6cixjb21waWxlZFR5cGU6dC5jb21waWxlU2NoZW1hVHlwZShlW3JdKX19KTt2YXIgbj1bXTtuLnB1c2goXCJsZXQgcmVzO1wiKSxuLnB1c2goXCJsZXQgcHJvcGVydHlQYXRoO1wiKSxuLnB1c2goXCJjb25zdCBlcnJvcnMgPSBbXTtcIiksITA9PT1lLiQkc3RyaWN0JiZuLnB1c2goXCJjb25zdCBnaXZlblByb3BzID0gbmV3IE1hcChPYmplY3Qua2V5cyh2YWx1ZSkubWFwKGtleSA9PiBba2V5LCB0cnVlXSkpO1wiKTtmb3IodmFyIGk9MDtpPHIucHJvcGVydGllcy5sZW5ndGg7aSsrKXt2YXIgYT1yLnByb3BlcnRpZXNbaV0sbz15KGEubmFtZSkscz1qLnRlc3Qobyk/XCJ2YWx1ZS5cIitvOid2YWx1ZVtcIicrbysnXCJdJztuLnB1c2goJ3Byb3BlcnR5UGF0aCA9IChwYXRoICE9PSB1bmRlZmluZWQgPyBwYXRoICsgXCIuJytvKydcIiA6IFwiJytvKydcIik7JyksQXJyYXkuaXNBcnJheShhLmNvbXBpbGVkVHlwZSk/bi5wdXNoKFwicmVzID0gdGhpcy5jaGVja1NjaGVtYVR5cGUoXCIrcytcIiwgcHJvcGVydGllc1tcIitpK1wiXS5jb21waWxlZFR5cGUsIHByb3BlcnR5UGF0aCwgdmFsdWUpO1wiKTpuLnB1c2goXCJyZXMgPSB0aGlzLmNoZWNrU2NoZW1hUnVsZShcIitzK1wiLCBwcm9wZXJ0aWVzW1wiK2krXCJdLmNvbXBpbGVkVHlwZSwgcHJvcGVydHlQYXRoLCB2YWx1ZSk7XCIpLG4ucHVzaChcImlmIChyZXMgIT09IHRydWUpIHtcIiksbi5wdXNoKFwiXFx0dGhpcy5oYW5kbGVSZXN1bHQoZXJyb3JzLCBwcm9wZXJ0eVBhdGgsIHJlcywgcHJvcGVydGllc1tcIitpK1wiXS5jb21waWxlZFR5cGUubWVzc2FnZXMpO1wiKSxuLnB1c2goXCJ9XCIpLCEwPT09ZS4kJHN0cmljdCYmbi5wdXNoKCdnaXZlblByb3BzLmRlbGV0ZShcIicrbysnXCIpOycpfXJldHVybiEwPT09ZS4kJHN0cmljdCYmKG4ucHVzaChcImlmIChnaXZlblByb3BzLnNpemUgIT09IDApIHtcIiksbi5wdXNoKFwiXFx0dGhpcy5oYW5kbGVSZXN1bHQoZXJyb3JzLCBwYXRoIHx8ICdyb290T2JqZWN0JywgdGhpcy5tYWtlRXJyb3IoJ29iamVjdFN0cmljdCcsIHVuZGVmaW5lZCwgWy4uLmdpdmVuUHJvcHMua2V5cygpXS5qb2luKCcsICcpKSwgdGhpcy5tZXNzYWdlcyk7XCIpLG4ucHVzaChcIn1cIikpLG4ucHVzaChcInJldHVybiBlcnJvcnMubGVuZ3RoID09PSAwID8gdHJ1ZSA6IGVycm9ycztcIiksci5jb21waWxlZE9iamVjdEZ1bmN0aW9uPW5ldyBGdW5jdGlvbihcInZhbHVlXCIsXCJwcm9wZXJ0aWVzXCIsXCJwYXRoXCIsXCJwYXJlbnRcIixuLmpvaW4oXCJcXG5cIikpLHJ9LGIucHJvdG90eXBlLmNvbXBpbGVTY2hlbWFUeXBlPWZ1bmN0aW9uKGUpe3ZhciB0PXRoaXM7cmV0dXJuIEFycmF5LmlzQXJyYXkoZSk/KGU9bShlLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gdC5jb21waWxlU2NoZW1hVHlwZShlKX0pKSwxPT1lLmxlbmd0aD9lWzBdOmUpOnRoaXMuY29tcGlsZVNjaGVtYVJ1bGUoZSl9LGIucHJvdG90eXBlLmNvbXBpbGVNZXNzYWdlcz1mdW5jdGlvbihlKXt2YXIgdD10aGlzO3JldHVybiBlLm1lc3NhZ2VzP3RoaXMubWVzc2FnZUtleXMucmVkdWNlKGZ1bmN0aW9uKHIsbil7cmV0dXJuIHJbbl09ZS5tZXNzYWdlc1tuXXx8dC5tZXNzYWdlc1tuXSxyfSx7fSk6dGhpcy5tZXNzYWdlc30sYi5wcm90b3R5cGUuY29tcGlsZVNjaGVtYVJ1bGU9ZnVuY3Rpb24oZSl7XCJzdHJpbmdcIj09dHlwZW9mIGUmJihlPXt0eXBlOmV9KTt2YXIgdD10aGlzLnJ1bGVzW2UudHlwZV07aWYoIXQpdGhyb3cgRXJyb3IoXCJJbnZhbGlkICdcIitlLnR5cGUrXCInIHR5cGUgaW4gdmFsaWRhdG9yIHNjaGVtYSFcIik7dmFyIHI9dGhpcy5jb21waWxlTWVzc2FnZXMoZSksbj1udWxsLGk9bnVsbDtyZXR1cm5cIm9iamVjdFwiPT09ZS50eXBlJiZlLnByb3BzPyhuPXRoaXMuY29tcGlsZVNjaGVtYU9iamVjdChlLnByb3BzKSxpPXRoaXMuY2hlY2tTY2hlbWFPYmplY3QpOlwiYXJyYXlcIj09PWUudHlwZSYmZS5pdGVtcyYmKG49dGhpcy5jb21waWxlU2NoZW1hVHlwZShlLml0ZW1zKSxpPXRoaXMuY2hlY2tTY2hlbWFBcnJheSkse21lc3NhZ2VzOnIsc2NoZW1hUnVsZTplLHJ1bGVGdW5jdGlvbjp0LGRhdGFGdW5jdGlvbjppLGRhdGFQYXJhbWV0ZXI6bn19LGIucHJvdG90eXBlLmNoZWNrU2NoZW1hT2JqZWN0PWZ1bmN0aW9uKGUsdCxyLG4pe3JldHVybiB0LmN5Y2xlPy0xIT09dC5vYmplY3RTdGFjay5pbmRleE9mKGUpfHwodC5vYmplY3RTdGFjay5wdXNoKGUpLGU9dGhpcy5jaGVja1NjaGVtYU9iamVjdElubmVyKGUsdCxyLG4pLHQub2JqZWN0U3RhY2sucG9wKCksZSk6dGhpcy5jaGVja1NjaGVtYU9iamVjdElubmVyKGUsdCxyLG4pfSxiLnByb3RvdHlwZS5jaGVja1NjaGVtYU9iamVjdElubmVyPWZ1bmN0aW9uKGUsdCxyLG4pe3JldHVybiB0LmNvbXBpbGVkT2JqZWN0RnVuY3Rpb24uY2FsbCh0aGlzLGUsdC5wcm9wZXJ0aWVzLHIsbil9LGIucHJvdG90eXBlLmNoZWNrU2NoZW1hVHlwZT1mdW5jdGlvbihlLHQscixuKXtpZihBcnJheS5pc0FycmF5KHQpKXtmb3IodmFyIGk9W10sYT10Lmxlbmd0aCxvPTA7bzxhO28rKyl7dmFyIHM9dGhpcy5jaGVja1NjaGVtYVJ1bGUoZSx0W29dLHIsbik7aWYoITA9PT1zKXJldHVybiEwO3RoaXMuaGFuZGxlUmVzdWx0KGkscixzLHQubWVzc2FnZXMpfXJldHVybiBpfXJldHVybiB0aGlzLmNoZWNrU2NoZW1hUnVsZShlLHQscixuKX0sYi5wcm90b3R5cGUuY2hlY2tTY2hlbWFBcnJheT1mdW5jdGlvbihlLHQscixuKXtmb3IodmFyIGk9W10sYT1lLmxlbmd0aCxvPTA7bzxhO28rKyl7dmFyIHM9KHZvaWQgMCE9PXI/cjpcIlwiKStcIltcIitvK1wiXVwiLHU9dGhpcy5jaGVja1NjaGVtYVR5cGUoZVtvXSx0LHMsZSxuKTshMCE9PXUmJnRoaXMuaGFuZGxlUmVzdWx0KGkscyx1LHQubWVzc2FnZXMpfXJldHVybiAwPT09aS5sZW5ndGh8fGl9LGIucHJvdG90eXBlLmNoZWNrU2NoZW1hUnVsZT1mdW5jdGlvbihlLHQscixuKXt2YXIgaT10LnNjaGVtYVJ1bGU7cmV0dXJuIHZvaWQgMD09PWV8fG51bGw9PT1lP1wiZm9yYmlkZGVuXCI9PT1pLnR5cGV8fCEwPT09aS5vcHRpb25hbHx8KGU9W10sdGhpcy5oYW5kbGVSZXN1bHQoZSxyLHRoaXMubWFrZUVycm9yKFwicmVxdWlyZWRcIiksdC5tZXNzYWdlcyksZSk6KGk9dC5ydWxlRnVuY3Rpb24uY2FsbCh0aGlzLGUsaSxyLG4pLCEwIT09aT8oZT1bXSx0aGlzLmhhbmRsZVJlc3VsdChlLHIsaSx0Lm1lc3NhZ2VzKSxlKTpudWxsPT09dC5kYXRhRnVuY3Rpb258fHQuZGF0YUZ1bmN0aW9uLmNhbGwodGhpcyxlLHQuZGF0YVBhcmFtZXRlcixyLG4pKX0sYi5wcm90b3R5cGUuaGFuZGxlUmVzdWx0PWZ1bmN0aW9uKGUsdCxyLG4pe3ZhciBpPXRoaXM7KEFycmF5LmlzQXJyYXkocik/cjpbcl0pLmZvckVhY2goZnVuY3Rpb24ocil7ci5maWVsZHx8KHIuZmllbGQ9dCksci5tZXNzYWdlfHwoci5tZXNzYWdlPWkucmVzb2x2ZU1lc3NhZ2UocixuW3IudHlwZV0pKSxlLnB1c2gocil9KX0sYi5wcm90b3R5cGUubWFrZUVycm9yPWZ1bmN0aW9uKGUsdCxyKXtyZXR1cm57dHlwZTplLGV4cGVjdGVkOnQsYWN0dWFsOnJ9fSxiLnByb3RvdHlwZS5yZXNvbHZlTWVzc2FnZT1mdW5jdGlvbihlLHQpe2lmKHZvaWQgMD09PXQmJih0PW51bGwpLG51bGwhPXQpe3ZhciByPW51bGwhPWUuZXhwZWN0ZWQ/ZS5leHBlY3RlZDpcIlwiLG49bnVsbCE9ZS5hY3R1YWw/ZS5hY3R1YWw6XCJcIjtyZXR1cm4gdC5yZXBsYWNlKC9cXHtmaWVsZFxcfS9nLGUuZmllbGQpLnJlcGxhY2UoL1xce2V4cGVjdGVkXFx9L2cscikucmVwbGFjZSgvXFx7YWN0dWFsXFx9L2csbil9fSxiLnByb3RvdHlwZS5hZGQ9ZnVuY3Rpb24oZSx0KXt0aGlzLnJ1bGVzW2VdPXR9LGJ9dmFyIGY9Znx8e307Zi5zY29wZT17fSxmLkFTU1VNRV9FUzU9ITEsZi5BU1NVTUVfTk9fTkFUSVZFX01BUD0hMSxmLkFTU1VNRV9OT19OQVRJVkVfU0VUPSExLGYuZGVmaW5lUHJvcGVydHk9Zi5BU1NVTUVfRVM1fHxcImZ1bmN0aW9uXCI9PXR5cGVvZiBPYmplY3QuZGVmaW5lUHJvcGVydGllcz9PYmplY3QuZGVmaW5lUHJvcGVydHk6ZnVuY3Rpb24oZSx0LHIpe2UhPUFycmF5LnByb3RvdHlwZSYmZSE9T2JqZWN0LnByb3RvdHlwZSYmKGVbdF09ci52YWx1ZSl9LGYuZ2V0R2xvYmFsPWZ1bmN0aW9uKGUpe3JldHVyblwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3cmJndpbmRvdz09PWU/ZTpcInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsJiZudWxsIT1nbG9iYWw/Z2xvYmFsOmV9LGYuZ2xvYmFsPWYuZ2V0R2xvYmFsKHRoaXMpLGYuU1lNQk9MX1BSRUZJWD1cImpzY29tcF9zeW1ib2xfXCIsZi5pbml0U3ltYm9sPWZ1bmN0aW9uKCl7Zi5pbml0U3ltYm9sPWZ1bmN0aW9uKCl7fSxmLmdsb2JhbC5TeW1ib2x8fChmLmdsb2JhbC5TeW1ib2w9Zi5TeW1ib2wpfSxmLlN5bWJvbD1mdW5jdGlvbigpe3ZhciBlPTA7cmV0dXJuIGZ1bmN0aW9uKHQpe3JldHVybiBmLlNZTUJPTF9QUkVGSVgrKHR8fFwiXCIpK2UrK319KCksZi5pbml0U3ltYm9sSXRlcmF0b3I9ZnVuY3Rpb24oKXtmLmluaXRTeW1ib2woKTt2YXIgZT1mLmdsb2JhbC5TeW1ib2wuaXRlcmF0b3I7ZXx8KGU9Zi5nbG9iYWwuU3ltYm9sLml0ZXJhdG9yPWYuZ2xvYmFsLlN5bWJvbChcIml0ZXJhdG9yXCIpKSxcImZ1bmN0aW9uXCIhPXR5cGVvZiBBcnJheS5wcm90b3R5cGVbZV0mJmYuZGVmaW5lUHJvcGVydHkoQXJyYXkucHJvdG90eXBlLGUse2NvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpmdW5jdGlvbigpe3JldHVybiBmLmFycmF5SXRlcmF0b3IodGhpcyl9fSksZi5pbml0U3ltYm9sSXRlcmF0b3I9ZnVuY3Rpb24oKXt9fSxmLmFycmF5SXRlcmF0b3I9ZnVuY3Rpb24oZSl7dmFyIHQ9MDtyZXR1cm4gZi5pdGVyYXRvclByb3RvdHlwZShmdW5jdGlvbigpe3JldHVybiB0PGUubGVuZ3RoP3tkb25lOiExLHZhbHVlOmVbdCsrXX06e2RvbmU6ITB9fSl9LGYuaXRlcmF0b3JQcm90b3R5cGU9ZnVuY3Rpb24oZSl7cmV0dXJuIGYuaW5pdFN5bWJvbEl0ZXJhdG9yKCksZT17bmV4dDplfSxlW2YuZ2xvYmFsLlN5bWJvbC5pdGVyYXRvcl09ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30sZX0sZi5pdGVyYXRvckZyb21BcnJheT1mdW5jdGlvbihlLHQpe2YuaW5pdFN5bWJvbEl0ZXJhdG9yKCksZSBpbnN0YW5jZW9mIFN0cmluZyYmKGUrPVwiXCIpO3ZhciByPTAsbj17bmV4dDpmdW5jdGlvbigpe2lmKHI8ZS5sZW5ndGgpe3ZhciBpPXIrKztyZXR1cm57dmFsdWU6dChpLGVbaV0pLGRvbmU6ITF9fXJldHVybiBuLm5leHQ9ZnVuY3Rpb24oKXtyZXR1cm57ZG9uZTohMCx2YWx1ZTp2b2lkIDB9fSxuLm5leHQoKX19O3JldHVybiBuW1N5bWJvbC5pdGVyYXRvcl09ZnVuY3Rpb24oKXtyZXR1cm4gbn0sbn0sZi5wb2x5ZmlsbD1mdW5jdGlvbihlLHQpe2lmKHQpe3ZhciByPWYuZ2xvYmFsO2U9ZS5zcGxpdChcIi5cIik7Zm9yKHZhciBuPTA7bjxlLmxlbmd0aC0xO24rKyl7dmFyIGk9ZVtuXTtpIGluIHJ8fChyW2ldPXt9KSxyPXJbaV19KHQ9dChuPXJbZT1lW2UubGVuZ3RoLTFdXSkpIT1uJiZudWxsIT10JiZmLmRlZmluZVByb3BlcnR5KHIsZSx7Y29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnR9KX19LGYucG9seWZpbGwoXCJBcnJheS5wcm90b3R5cGUua2V5c1wiLGZ1bmN0aW9uKGUpe3JldHVybiBlfHxmdW5jdGlvbigpe3JldHVybiBmLml0ZXJhdG9yRnJvbUFycmF5KHRoaXMsZnVuY3Rpb24oZSl7cmV0dXJuIGV9KX19LFwiZXM2XCIsXCJlczNcIiksZi5jaGVja0VzNkNvbmZvcm1hbmNlVmlhUHJveHk9ZnVuY3Rpb24oKXt0cnl7dmFyIGU9e30sdD1PYmplY3QuY3JlYXRlKG5ldyBmLmdsb2JhbC5Qcm94eShlLHtnZXQ6ZnVuY3Rpb24ocixuLGkpe3JldHVybiByPT1lJiZcInFcIj09biYmaT09dH19KSk7cmV0dXJuITA9PT10LnF9Y2F0Y2goZSl7cmV0dXJuITF9fSxmLlVTRV9QUk9YWV9GT1JfRVM2X0NPTkZPUk1BTkNFX0NIRUNLUz0hMSxmLkVTNl9DT05GT1JNQU5DRT1mLlVTRV9QUk9YWV9GT1JfRVM2X0NPTkZPUk1BTkNFX0NIRUNLUyYmZi5jaGVja0VzNkNvbmZvcm1hbmNlVmlhUHJveHkoKSxmLm1ha2VJdGVyYXRvcj1mdW5jdGlvbihlKXtmLmluaXRTeW1ib2xJdGVyYXRvcigpO3ZhciB0PWVbU3ltYm9sLml0ZXJhdG9yXTtyZXR1cm4gdD90LmNhbGwoZSk6Zi5hcnJheUl0ZXJhdG9yKGUpfSxmLm93bnM9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsdCl9LGYucG9seWZpbGwoXCJXZWFrTWFwXCIsZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdChlKXtpZih0aGlzLmlkXz0oYSs9TWF0aC5yYW5kb20oKSsxKS50b1N0cmluZygpLGUpe2YuaW5pdFN5bWJvbCgpLGYuaW5pdFN5bWJvbEl0ZXJhdG9yKCksZT1mLm1ha2VJdGVyYXRvcihlKTtmb3IodmFyIHQ7ISh0PWUubmV4dCgpKS5kb25lOyl0PXQudmFsdWUsdGhpcy5zZXQodFswXSx0WzFdKX19ZnVuY3Rpb24gcihlKXtmLm93bnMoZSxpKXx8Zi5kZWZpbmVQcm9wZXJ0eShlLGkse3ZhbHVlOnt9fSl9ZnVuY3Rpb24gbihlKXt2YXIgdD1PYmplY3RbZV07dCYmKE9iamVjdFtlXT1mdW5jdGlvbihlKXtyZXR1cm4gcihlKSx0KGUpfSl9aWYoZi5VU0VfUFJPWFlfRk9SX0VTNl9DT05GT1JNQU5DRV9DSEVDS1Mpe2lmKGUmJmYuRVM2X0NPTkZPUk1BTkNFKXJldHVybiBlfWVsc2UgaWYoZnVuY3Rpb24oKXtpZighZXx8IU9iamVjdC5zZWFsKXJldHVybiExO3RyeXt2YXIgdD1PYmplY3Quc2VhbCh7fSkscj1PYmplY3Quc2VhbCh7fSksbj1uZXcgZShbW3QsMl0sW3IsM11dKTtyZXR1cm4gMj09bi5nZXQodCkmJjM9PW4uZ2V0KHIpJiYobi5kZWxldGUodCksbi5zZXQociw0KSwhbi5oYXModCkmJjQ9PW4uZ2V0KHIpKX1jYXRjaChlKXtyZXR1cm4hMX19KCkpcmV0dXJuIGU7dmFyIGk9XCIkanNjb21wX2hpZGRlbl9cIitNYXRoLnJhbmRvbSgpO24oXCJmcmVlemVcIiksbihcInByZXZlbnRFeHRlbnNpb25zXCIpLG4oXCJzZWFsXCIpO3ZhciBhPTA7cmV0dXJuIHQucHJvdG90eXBlLnNldD1mdW5jdGlvbihlLHQpe2lmKHIoZSksIWYub3ducyhlLGkpKXRocm93IEVycm9yKFwiV2Vha01hcCBrZXkgZmFpbDogXCIrZSk7cmV0dXJuIGVbaV1bdGhpcy5pZF9dPXQsdGhpc30sdC5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKGUpe3JldHVybiBmLm93bnMoZSxpKT9lW2ldW3RoaXMuaWRfXTp2b2lkIDB9LHQucHJvdG90eXBlLmhhcz1mdW5jdGlvbihlKXtyZXR1cm4gZi5vd25zKGUsaSkmJmYub3ducyhlW2ldLHRoaXMuaWRfKX0sdC5wcm90b3R5cGUuZGVsZXRlPWZ1bmN0aW9uKGUpe3JldHVybiEoIWYub3ducyhlLGkpfHwhZi5vd25zKGVbaV0sdGhpcy5pZF8pKSYmZGVsZXRlIGVbaV1bdGhpcy5pZF9dfSx0fSxcImVzNlwiLFwiZXMzXCIpLGYuTWFwRW50cnk9ZnVuY3Rpb24oKXt9LGYucG9seWZpbGwoXCJNYXBcIixmdW5jdGlvbihlKXtmdW5jdGlvbiB0KCl7dmFyIGU9e307cmV0dXJuIGUucHJldmlvdXM9ZS5uZXh0PWUuaGVhZD1lfWZ1bmN0aW9uIHIoZSx0KXt2YXIgcj1lLmhlYWRfO3JldHVybiBmLml0ZXJhdG9yUHJvdG90eXBlKGZ1bmN0aW9uKCl7aWYocil7Zm9yKDtyLmhlYWQhPWUuaGVhZF87KXI9ci5wcmV2aW91cztmb3IoO3IubmV4dCE9ci5oZWFkOylyZXR1cm4gcj1yLm5leHQse2RvbmU6ITEsdmFsdWU6dChyKX07cj1udWxsfXJldHVybntkb25lOiEwLHZhbHVlOnZvaWQgMH19KX1mdW5jdGlvbiBuKGUsdCl7dmFyIHI9dCYmdHlwZW9mIHQ7XCJvYmplY3RcIj09cnx8XCJmdW5jdGlvblwiPT1yP2EuaGFzKHQpP3I9YS5nZXQodCk6KHI9XCJcIisgKytvLGEuc2V0KHQscikpOnI9XCJwX1wiK3Q7dmFyIG49ZS5kYXRhX1tyXTtpZihuJiZmLm93bnMoZS5kYXRhXyxyKSlmb3IoZT0wO2U8bi5sZW5ndGg7ZSsrKXt2YXIgaT1uW2VdO2lmKHQhPT10JiZpLmtleSE9PWkua2V5fHx0PT09aS5rZXkpcmV0dXJue2lkOnIsbGlzdDpuLGluZGV4OmUsZW50cnk6aX19cmV0dXJue2lkOnIsbGlzdDpuLGluZGV4Oi0xLGVudHJ5OnZvaWQgMH19ZnVuY3Rpb24gaShlKXtpZih0aGlzLmRhdGFfPXt9LHRoaXMuaGVhZF89dCgpLHRoaXMuc2l6ZT0wLGUpe2U9Zi5tYWtlSXRlcmF0b3IoZSk7Zm9yKHZhciByOyEocj1lLm5leHQoKSkuZG9uZTspcj1yLnZhbHVlLHRoaXMuc2V0KHJbMF0sclsxXSl9fWlmKGYuVVNFX1BST1hZX0ZPUl9FUzZfQ09ORk9STUFOQ0VfQ0hFQ0tTKXtpZihlJiZmLkVTNl9DT05GT1JNQU5DRSlyZXR1cm4gZX1lbHNlIGlmKGZ1bmN0aW9uKCl7aWYoZi5BU1NVTUVfTk9fTkFUSVZFX01BUHx8IWV8fFwiZnVuY3Rpb25cIiE9dHlwZW9mIGV8fCFlLnByb3RvdHlwZS5lbnRyaWVzfHxcImZ1bmN0aW9uXCIhPXR5cGVvZiBPYmplY3Quc2VhbClyZXR1cm4hMTt0cnl7dmFyIHQ9T2JqZWN0LnNlYWwoe3g6NH0pLHI9bmV3IGUoZi5tYWtlSXRlcmF0b3IoW1t0LFwic1wiXV0pKTtpZihcInNcIiE9ci5nZXQodCl8fDEhPXIuc2l6ZXx8ci5nZXQoe3g6NH0pfHxyLnNldCh7eDo0fSxcInRcIikhPXJ8fDIhPXIuc2l6ZSlyZXR1cm4hMTt2YXIgbj1yLmVudHJpZXMoKSxpPW4ubmV4dCgpO3JldHVybiFpLmRvbmUmJmkudmFsdWVbMF09PXQmJlwic1wiPT1pLnZhbHVlWzFdJiYhKChpPW4ubmV4dCgpKS5kb25lfHw0IT1pLnZhbHVlWzBdLnh8fFwidFwiIT1pLnZhbHVlWzFdfHwhbi5uZXh0KCkuZG9uZSl9Y2F0Y2goZSl7cmV0dXJuITF9fSgpKXJldHVybiBlO2YuaW5pdFN5bWJvbCgpLGYuaW5pdFN5bWJvbEl0ZXJhdG9yKCk7dmFyIGE9bmV3IFdlYWtNYXA7aS5wcm90b3R5cGUuc2V0PWZ1bmN0aW9uKGUsdCl7dmFyIHI9bih0aGlzLGUpO3JldHVybiByLmxpc3R8fChyLmxpc3Q9dGhpcy5kYXRhX1tyLmlkXT1bXSksci5lbnRyeT9yLmVudHJ5LnZhbHVlPXQ6KHIuZW50cnk9e25leHQ6dGhpcy5oZWFkXyxwcmV2aW91czp0aGlzLmhlYWRfLnByZXZpb3VzLGhlYWQ6dGhpcy5oZWFkXyxrZXk6ZSx2YWx1ZTp0fSxyLmxpc3QucHVzaChyLmVudHJ5KSx0aGlzLmhlYWRfLnByZXZpb3VzLm5leHQ9ci5lbnRyeSx0aGlzLmhlYWRfLnByZXZpb3VzPXIuZW50cnksdGhpcy5zaXplKyspLHRoaXN9LGkucHJvdG90eXBlLmRlbGV0ZT1mdW5jdGlvbihlKXtyZXR1cm4hKCEoZT1uKHRoaXMsZSkpLmVudHJ5fHwhZS5saXN0KSYmKGUubGlzdC5zcGxpY2UoZS5pbmRleCwxKSxlLmxpc3QubGVuZ3RofHxkZWxldGUgdGhpcy5kYXRhX1tlLmlkXSxlLmVudHJ5LnByZXZpb3VzLm5leHQ9ZS5lbnRyeS5uZXh0LGUuZW50cnkubmV4dC5wcmV2aW91cz1lLmVudHJ5LnByZXZpb3VzLGUuZW50cnkuaGVhZD1udWxsLHRoaXMuc2l6ZS0tLCEwKX0saS5wcm90b3R5cGUuY2xlYXI9ZnVuY3Rpb24oKXt0aGlzLmRhdGFfPXt9LHRoaXMuaGVhZF89dGhpcy5oZWFkXy5wcmV2aW91cz10KCksdGhpcy5zaXplPTB9LGkucHJvdG90eXBlLmhhcz1mdW5jdGlvbihlKXtyZXR1cm4hIW4odGhpcyxlKS5lbnRyeX0saS5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKGUpe3JldHVybihlPW4odGhpcyxlKS5lbnRyeSkmJmUudmFsdWV9LGkucHJvdG90eXBlLmVudHJpZXM9ZnVuY3Rpb24oKXtyZXR1cm4gcih0aGlzLGZ1bmN0aW9uKGUpe3JldHVybltlLmtleSxlLnZhbHVlXX0pfSxpLnByb3RvdHlwZS5rZXlzPWZ1bmN0aW9uKCl7cmV0dXJuIHIodGhpcyxmdW5jdGlvbihlKXtyZXR1cm4gZS5rZXl9KX0saS5wcm90b3R5cGUudmFsdWVzPWZ1bmN0aW9uKCl7cmV0dXJuIHIodGhpcyxmdW5jdGlvbihlKXtyZXR1cm4gZS52YWx1ZX0pfSxpLnByb3RvdHlwZS5mb3JFYWNoPWZ1bmN0aW9uKGUsdCl7Zm9yKHZhciByLG49dGhpcy5lbnRyaWVzKCk7IShyPW4ubmV4dCgpKS5kb25lOylyPXIudmFsdWUsZS5jYWxsKHQsclsxXSxyWzBdLHRoaXMpfSxpLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdPWkucHJvdG90eXBlLmVudHJpZXM7dmFyIG89MDtyZXR1cm4gaX0sXCJlczZcIixcImVzM1wiKSxcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz1yKCk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShyKTp0aGlzLkZhc3Rlc3RWYWxpZGF0b3I9cigpO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTs7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/fastest-validator/dist/index.min.js\n");

/***/ }),

/***/ "./node_modules/flubber/build/flubber.min.js":
/*!***************************************************!*\
  !*** ./node_modules/flubber/build/flubber.min.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("!function(t,n){ true?n(exports):undefined}(this,function(t){\"use strict\";function n(t){return 10===t||13===t||8232===t||8233===t||32===t||9===t||11===t||12===t||160===t||t>=5760&&an.indexOf(t)>=0}function e(t){switch(32|t){case 109:case 122:case 108:case 104:case 118:case 99:case 115:case 113:case 116:case 97:case 114:return!0}return!1}function r(t){return t>=48&&t<=57}function i(t){return t>=48&&t<=57||43===t||45===t||46===t}function a(t){this.index=0,this.path=t,this.max=t.length,this.result=[],this.param=0,this.err=\"\",this.segmentStart=0,this.data=[]}function o(t){for(;t.index<t.max&&n(t.path.charCodeAt(t.index));)t.index++}function s(t){var n,e=t.index,i=e,a=t.max,o=!1,s=!1,h=!1,u=!1;if(i>=a)return void(t.err=\"SvgPath: missed param (at pos \"+i+\")\");if(n=t.path.charCodeAt(i),43!==n&&45!==n||(i++,n=i<a?t.path.charCodeAt(i):0),!r(n)&&46!==n)return void(t.err=\"SvgPath: param should start with 0..9 or `.` (at pos \"+i+\")\");if(46!==n){if(o=48===n,i++,n=i<a?t.path.charCodeAt(i):0,o&&i<a&&n&&r(n))return void(t.err=\"SvgPath: numbers started with `0` such as `09` are ilegal (at pos \"+e+\")\");for(;i<a&&r(t.path.charCodeAt(i));)i++,s=!0;n=i<a?t.path.charCodeAt(i):0}if(46===n){for(u=!0,i++;r(t.path.charCodeAt(i));)i++,h=!0;n=i<a?t.path.charCodeAt(i):0}if(101===n||69===n){if(u&&!s&&!h)return void(t.err=\"SvgPath: invalid float exponent (at pos \"+i+\")\");if(i++,n=i<a?t.path.charCodeAt(i):0,43!==n&&45!==n||i++,!(i<a&&r(t.path.charCodeAt(i))))return void(t.err=\"SvgPath: invalid float exponent (at pos \"+i+\")\");for(;i<a&&r(t.path.charCodeAt(i));)i++}t.index=i,t.param=parseFloat(t.path.slice(e,i))+0}function h(t){var n,e;n=t.path[t.segmentStart],e=n.toLowerCase();var r=t.data;if(\"m\"===e&&r.length>2&&(t.result.push([n,r[0],r[1]]),r=r.slice(2),e=\"l\",n=\"m\"===n?\"l\":\"L\"),\"r\"===e)t.result.push([n].concat(r));else for(;r.length>=rn[e]&&(t.result.push([n].concat(r.splice(0,rn[e]))),rn[e]););}function u(t){var n,r,a,u,c=t.max;if(t.segmentStart=t.index,n=t.path.charCodeAt(t.index),!e(n))return void(t.err=\"SvgPath: bad command \"+t.path[t.index]+\" (at pos \"+t.index+\")\");if(a=rn[t.path[t.index].toLowerCase()],t.index++,o(t),t.data=[],!a)return void h(t);for(r=!1;;){for(u=a;u>0;u--){if(s(t),t.err.length)return;t.data.push(t.param),o(t),r=!1,t.index<c&&44===t.path.charCodeAt(t.index)&&(t.index++,o(t),r=!0)}if(!r){if(t.index>=t.max)break;if(!i(t.path.charCodeAt(t.index)))break}}h(t)}function c(t,n){return[t[0]*n[0]+t[2]*n[1],t[1]*n[0]+t[3]*n[1],t[0]*n[2]+t[2]*n[3],t[1]*n[2]+t[3]*n[3],t[0]*n[4]+t[2]*n[5]+t[4],t[1]*n[4]+t[3]*n[5]+t[5]]}function f(){if(!(this instanceof f))return new f;this.queue=[],this.cache=null}function l(t,n,e,r){var i=t*r-n*e<0?-1:1,a=Math.sqrt(t*t+n*n),o=Math.sqrt(t*t+n*n),s=t*e+n*r,h=s/(a*o);return h>1&&(h=1),h<-1&&(h=-1),i*Math.acos(h)}function p(t,n,e,r,i,a,o,s,h,u){var c=u*(t-e)/2+h*(n-r)/2,f=-h*(t-e)/2+u*(n-r)/2,p=o*o,g=s*s,v=c*c,x=f*f,y=p*g-p*x-g*v;y<0&&(y=0),y/=p*x+g*v,y=Math.sqrt(y)*(i===a?-1:1);var d=y*o/s*f,m=y*-s/o*c,M=u*d-h*m+(t+e)/2,w=h*d+u*m+(n+r)/2,b=(c-d)/o,L=(f-m)/s,A=(-c-d)/o,q=(-f-m)/s,k=l(1,0,b,L),P=l(b,L,A,q);return 0===a&&P>0&&(P-=ln),1===a&&P<0&&(P+=ln),[M,w,k,P]}function g(t,n){var e=4/3*Math.tan(n/4),r=Math.cos(t),i=Math.sin(t),a=Math.cos(t+n),o=Math.sin(t+n);return[r,i,r-i*e,i+r*e,a+o*e,o-a*e,a,o]}function v(t,n,e){if(!(this instanceof v))return new v(t,n,e);this.rx=t,this.ry=n,this.ax=e}function x(t){if(!(this instanceof x))return new x(t);var n=on(t);this.segments=n.segments,this.err=n.err,this.__stack=[]}function y(t){var n=t.match(wn);return n?n.map(Number):[]}function d(t,n,e,r,i,a,o,s){this.a={x:t,y:n},this.b={x:e,y:r},this.c={x:i,y:a},this.d={x:o,y:s},null!==o&&void 0!==o&&null!==s&&void 0!==s?(this.getArcLength=_,this.getPoint=L,this.getDerivative=M):(this.getArcLength=A,this.getPoint=b,this.getDerivative=m),this.init()}function m(t,n,e){return{x:2*(1-e)*(t[1]-t[0])+2*e*(t[2]-t[1]),y:2*(1-e)*(n[1]-n[0])+2*e*(n[2]-n[1])}}function M(t,n,e){return b([3*(t[1]-t[0]),3*(t[2]-t[1]),3*(t[3]-t[2])],[3*(n[1]-n[0]),3*(n[2]-n[1]),3*(n[3]-n[2])],e)}function w(t,n,e,r,i){for(var a=1,o=t/n,s=(t-e(r,i,o))/n;a>.001;){var h=e(r,i,o+s),u=e(r,i,o-s),c=Math.abs(t-h)/n,f=Math.abs(t-u)/n;c<a?(a=c,o+=s):f<a?(a=f,o-=s):s/=2}return o}function b(t,n,e){return{x:(1-e)*(1-e)*t[0]+2*(1-e)*e*t[1]+e*e*t[2],y:(1-e)*(1-e)*n[0]+2*(1-e)*e*n[1]+e*e*n[2]}}function L(t,n,e){return{x:(1-e)*(1-e)*(1-e)*t[0]+3*(1-e)*(1-e)*e*t[1]+3*(1-e)*e*e*t[2]+e*e*e*t[3],y:(1-e)*(1-e)*(1-e)*n[0]+3*(1-e)*(1-e)*e*n[1]+3*(1-e)*e*e*n[2]+e*e*e*n[3]}}function A(t,n,e){void 0===e&&(e=1);var r=t[0]-2*t[1]+t[2],i=n[0]-2*n[1]+n[2],a=2*t[1]-2*t[0],o=2*n[1]-2*n[0],s=4*(r*r+i*i),h=4*(r*a+i*o),u=a*a+o*o;if(0===s)return e*Math.sqrt(Math.pow(t[2]-t[0],2)+Math.pow(n[2]-n[0],2));var c=h/(2*s),f=u/s,l=e+c,p=f-c*c;return Math.sqrt(s)/2*(l*Math.sqrt(l*l+p)-c*Math.sqrt(c*c+p)+p*Math.log(Math.abs((l+Math.sqrt(l*l+p))/(c+Math.sqrt(c*c+p)))))}function q(t,n){return qn[t][n]}function k(t,n,e){var r,i,a,o=e.length-1;if(0===o)return 0;if(0===t){for(i=0,a=0;a<=o;a++)i+=q(o,a)*Math.pow(1-n,o-a)*Math.pow(n,a)*e[a];return i}for(r=new Array(o),a=0;a<o;a++)r[a]=o*(e[a+1]-e[a]);return k(t-1,n,r)}function P(t,n,e){var r=k(1,e,t),i=k(1,e,n),a=r*r+i*i;return Math.sqrt(a)}function _(t,n,e){var r,i,a,o;void 0===e&&(e=1);for(r=e/2,i=0,a=0;a<20;a++)o=r*Ln[20][a]+r,i+=An[20][a]*P(t,n,o);return r*i}function E(t,n,e,r){var i=t*r-n*e<0?-1:1,a=t*e+n*r;return a>1&&(a=1),a<-1&&(a=-1),i*Math.acos(a)}function S(t,n,e,r,i,a,o,s,h,u){var c=u*(t-e)/2+h*(n-r)/2,f=-h*(t-e)/2+u*(n-r)/2,l=o*o,p=s*s,g=c*c,v=f*f,x=l*p-l*v-p*g;x<0&&(x=0),x/=l*v+p*g,x=Math.sqrt(x)*(i===a?-1:1);var y=x*o/s*f,d=x*-s/o*c,m=u*y-h*d+(t+e)/2,M=h*y+u*d+(n+r)/2,w=(c-y)/o,b=(f-d)/s,L=(-c-y)/o,A=(-f-d)/s,q=E(1,0,w,b),k=E(w,b,L,A);return 0===a&&k>0&&(k-=kn),1===a&&k<0&&(k+=kn),[m,M,q,k]}function C(t,n){var e=4/3*Math.tan(n/4),r=Math.cos(t),i=Math.sin(t),a=Math.cos(t+n),o=Math.sin(t+n);return[r,i,r-i*e,i+r*e,a+o*e,o-a*e,a,o]}function Z(t,n,e,r,i,a,o,s,h){var u=0,c=[],f=[];Pn(t,n,e,r,i,a,o,s,h).forEach(function(t){var n=new bn(t[0],t[1],t[2],t[3],t[4],t[5],t[6],t[7]),e=n.getTotalLength();u+=e,c.push(e),f.push(n)}),this.length=u,this.partialLengths=c,this.curves=f}function T(t,n,e,r){this.x0=t,this.x1=n,this.y0=e,this.y1=r}function F(t,n){return Math.sqrt((t[0]-n[0])*(t[0]-n[0])+(t[1]-n[1])*(t[1]-n[1]))}function z(t,n,e){return[t[0]+(n[0]-t[0])*e,t[1]+(n[1]-t[1])*e]}function j(t,n){return F(t,n)<1e-9}function I(t,n,e){var r=t.map(function(t,e){return V(t,n[e])});return function(t){var n=r.map(function(n){return n(t)});return e?H(n):n}}function V(t,n){return function(e){return t.map(function(t,r){return t+e*(n[r]-t)})}}function X(t){return\"number\"==typeof t&&isFinite(t)}function Y(t){return G(t)?nn(t):[(t[0][0]+t[t.length-1][0])/2,(t[0][1]+t[t.length-1][1])/2]}function G(t){for(var n=0;n<t.length-2;n++){var e=t[n],r=t[n+1],i=t[n+2];if(e[0]*(r[1]-i[1])+r[0]*(i[1]-e[1])+i[0]*(e[1]-r[1]))return!0}return!1}function O(t){return new yn(t).abs()}function D(t){return t.toString().split(\"M\").map(function(t,n){return t=t.trim(),n&&t?\"M\"+t:t}).filter(function(t){return t})}function H(t){return\"M\"+t.join(\"L\")+\"Z\"}function N(t){return D(O(t))}function Q(t,n){var e=O(t);return U(e)||R(e,n)}function U(t){var n=t.segments||[],e=[];if(!n.length||\"M\"!==n[0][0])return!1;for(var r=0;r<n.length;r++){var i=n[r],a=i[0],o=i[1],s=i[2];if(\"M\"===a&&r||\"Z\"===a)break;if(\"M\"===a||\"L\"===a)e.push([o,s]);else if(\"H\"===a)e.push([o,e[e.length-1][1]]);else{if(\"V\"!==a)return!1;e.push([e[e.length-1][0],o])}}return!!e.length&&{ring:e}}function R(t,n){var e,r,i=D(t)[0],a=[],o=3;if(!i)throw new TypeError(Cn);r=B(i),e=r.getTotalLength(),n&&X(n)&&n>0&&(o=Math.max(o,Math.ceil(e/n)));for(var s=0;s<o;s++){var h=r.getPointAtLength(e*s/o);a.push([h.x,h.y])}return{ring:a,skipBisect:!0}}function B(t){if(\"undefined\"!=typeof window&&window&&window.document)try{var n=window.document.createElementNS(\"http://www.w3.org/2000/svg\",\"path\");return n.setAttributeNS(null,\"d\",t),n}catch(t){}return Sn(t)}function W(t,n){for(var e=t.length+n,r=en(t)/n,i=0,a=0,o=r/2;t.length<e;){var s=t[i],h=t[(i+1)%t.length],u=F(s,h);o<=a+u?(t.splice(i+1,0,u?z(s,h,(o-a)/u):s.slice(0)),o+=r):(a+=u,i++)}}function $(t,n){void 0===n&&(n=1/0);for(var e=0;e<t.length;e++)for(var r=t[e],i=e===t.length-1?t[0]:t[e+1];F(r,i)>n;)i=z(r,i,.5),t.splice(e+1,0,i)}function J(t,n){var e,r,i;if(\"string\"==typeof t){var a=Q(t,n);t=a.ring,i=a.skipBisect}else if(!Array.isArray(t))throw new TypeError(Cn);if(e=t.slice(0),!K(e))throw new TypeError(Cn);return e.length>1&&j(e[0],e[e.length-1])&&e.pop(),r=tn(e),r>0&&e.reverse(),!i&&n&&X(n)&&n>0&&$(e,n),e}function K(t){return t.every(function(t){return Array.isArray(t)&&t.length>=2&&X(t[0])&&X(t[1])})}function tt(t,n,e){var r;return r=t.length-n.length,W(t,r<0?-1*r:0),W(n,r>0?r:0),Tn(t,n),I(t,n,e)}function nt(t,n,e){e=e||2;var r=n&&n.length,i=r?n[0]*e:t.length,a=et(t,0,i,e,!0),o=[];if(!a)return o;var s,h,u,c,f,l,p;if(r&&(a=ut(t,n,a,e)),t.length>80*e){s=u=t[0],h=c=t[1];for(var g=e;g<i;g+=e)f=t[g],l=t[g+1],f<s&&(s=f),l<h&&(h=l),f>u&&(u=f),l>c&&(c=l);p=Math.max(u-s,c-h)}return it(a,o,e,s,h,p),o}function et(t,n,e,r,i){var a,o;if(i===Et(t,n,e,r)>0)for(a=n;a<e;a+=r)o=kt(a,t[a],t[a+1],o);else for(a=e-r;a>=n;a-=r)o=kt(a,t[a],t[a+1],o);return o&&Mt(o,o.next)&&(Pt(o),o=o.next),o}function rt(t,n){if(!t)return t;n||(n=t);var e,r=t;do{if(e=!1,r.steiner||!Mt(r,r.next)&&0!==mt(r.prev,r,r.next))r=r.next;else{if(Pt(r),(r=n=r.prev)===r.next)return null;e=!0}}while(e||r!==n);return n}function it(t,n,e,r,i,a,o){if(t){!o&&a&&pt(t,r,i,a);for(var s,h,u=t;t.prev!==t.next;)if(s=t.prev,h=t.next,a?ot(t,r,i,a):at(t))n.push(s.i/e),n.push(t.i/e),n.push(h.i/e),Pt(t),t=h.next,u=h.next;else if((t=h)===u){o?1===o?(t=st(t,n,e),it(t,n,e,r,i,a,2)):2===o&&ht(t,n,e,r,i,a):it(rt(t),n,e,r,i,a,1);break}}}function at(t){var n=t.prev,e=t,r=t.next;if(mt(n,e,r)>=0)return!1;for(var i=t.next.next;i!==t.prev;){if(yt(n.x,n.y,e.x,e.y,r.x,r.y,i.x,i.y)&&mt(i.prev,i,i.next)>=0)return!1;i=i.next}return!0}function ot(t,n,e,r){var i=t.prev,a=t,o=t.next;if(mt(i,a,o)>=0)return!1;for(var s=i.x<a.x?i.x<o.x?i.x:o.x:a.x<o.x?a.x:o.x,h=i.y<a.y?i.y<o.y?i.y:o.y:a.y<o.y?a.y:o.y,u=i.x>a.x?i.x>o.x?i.x:o.x:a.x>o.x?a.x:o.x,c=i.y>a.y?i.y>o.y?i.y:o.y:a.y>o.y?a.y:o.y,f=vt(s,h,n,e,r),l=vt(u,c,n,e,r),p=t.nextZ;p&&p.z<=l;){if(p!==t.prev&&p!==t.next&&yt(i.x,i.y,a.x,a.y,o.x,o.y,p.x,p.y)&&mt(p.prev,p,p.next)>=0)return!1;p=p.nextZ}for(p=t.prevZ;p&&p.z>=f;){if(p!==t.prev&&p!==t.next&&yt(i.x,i.y,a.x,a.y,o.x,o.y,p.x,p.y)&&mt(p.prev,p,p.next)>=0)return!1;p=p.prevZ}return!0}function st(t,n,e){var r=t;do{var i=r.prev,a=r.next.next;!Mt(i,a)&&wt(i,r,r.next,a)&&Lt(i,a)&&Lt(a,i)&&(n.push(i.i/e),n.push(r.i/e),n.push(a.i/e),Pt(r),Pt(r.next),r=t=a),r=r.next}while(r!==t);return r}function ht(t,n,e,r,i,a){var o=t;do{for(var s=o.next.next;s!==o.prev;){if(o.i!==s.i&&dt(o,s)){var h=qt(o,s);return o=rt(o,o.next),h=rt(h,h.next),it(o,n,e,r,i,a),void it(h,n,e,r,i,a)}s=s.next}o=o.next}while(o!==t)}function ut(t,n,e,r){var i,a,o,s,h,u=[];for(i=0,a=n.length;i<a;i++)o=n[i]*r,s=i<a-1?n[i+1]*r:t.length,h=et(t,o,s,r,!1),h===h.next&&(h.steiner=!0),u.push(xt(h));for(u.sort(ct),i=0;i<u.length;i++)ft(u[i],e),e=rt(e,e.next);return e}function ct(t,n){return t.x-n.x}function ft(t,n){if(n=lt(t,n)){var e=qt(n,t);rt(e,e.next)}}function lt(t,n){var e,r=n,i=t.x,a=t.y,o=-1/0;do{if(a<=r.y&&a>=r.next.y){var s=r.x+(a-r.y)*(r.next.x-r.x)/(r.next.y-r.y);if(s<=i&&s>o){if(o=s,s===i){if(a===r.y)return r;if(a===r.next.y)return r.next}e=r.x<r.next.x?r:r.next}}r=r.next}while(r!==n);if(!e)return null;if(i===o)return e.prev;var h,u=e,c=e.x,f=e.y,l=1/0;for(r=e.next;r!==u;)i>=r.x&&r.x>=c&&yt(a<f?i:o,a,c,f,a<f?o:i,a,r.x,r.y)&&((h=Math.abs(a-r.y)/(i-r.x))<l||h===l&&r.x>e.x)&&Lt(r,t)&&(e=r,l=h),r=r.next;return e}function pt(t,n,e,r){var i=t;do{null===i.z&&(i.z=vt(i.x,i.y,n,e,r)),i.prevZ=i.prev,i.nextZ=i.next,i=i.next}while(i!==t);i.prevZ.nextZ=null,i.prevZ=null,gt(i)}function gt(t){var n,e,r,i,a,o,s,h,u=1;do{for(e=t,t=null,a=null,o=0;e;){for(o++,r=e,s=0,n=0;n<u&&(s++,r=r.nextZ);n++);for(h=u;s>0||h>0&&r;)0===s?(i=r,r=r.nextZ,h--):0!==h&&r?e.z<=r.z?(i=e,e=e.nextZ,s--):(i=r,r=r.nextZ,h--):(i=e,e=e.nextZ,s--),a?a.nextZ=i:t=i,i.prevZ=a,a=i;e=r}a.nextZ=null,u*=2}while(o>1);return t}function vt(t,n,e,r,i){return t=32767*(t-e)/i,n=32767*(n-r)/i,t=16711935&(t|t<<8),t=252645135&(t|t<<4),t=858993459&(t|t<<2),t=1431655765&(t|t<<1),n=16711935&(n|n<<8),n=252645135&(n|n<<4),n=858993459&(n|n<<2),n=1431655765&(n|n<<1),t|n<<1}function xt(t){var n=t,e=t;do{n.x<e.x&&(e=n),n=n.next}while(n!==t);return e}function yt(t,n,e,r,i,a,o,s){return(i-o)*(n-s)-(t-o)*(a-s)>=0&&(t-o)*(r-s)-(e-o)*(n-s)>=0&&(e-o)*(a-s)-(i-o)*(r-s)>=0}function dt(t,n){return t.next.i!==n.i&&t.prev.i!==n.i&&!bt(t,n)&&Lt(t,n)&&Lt(n,t)&&At(t,n)}function mt(t,n,e){return(n.y-t.y)*(e.x-n.x)-(n.x-t.x)*(e.y-n.y)}function Mt(t,n){return t.x===n.x&&t.y===n.y}function wt(t,n,e,r){return!!(Mt(t,n)&&Mt(e,r)||Mt(t,r)&&Mt(e,n))||mt(t,n,e)>0!=mt(t,n,r)>0&&mt(e,r,t)>0!=mt(e,r,n)>0}function bt(t,n){var e=t;do{if(e.i!==t.i&&e.next.i!==t.i&&e.i!==n.i&&e.next.i!==n.i&&wt(e,e.next,t,n))return!0;e=e.next}while(e!==t);return!1}function Lt(t,n){return mt(t.prev,t,t.next)<0?mt(t,n,t.next)>=0&&mt(t,t.prev,n)>=0:mt(t,n,t.prev)<0||mt(t,t.next,n)<0}function At(t,n){var e=t,r=!1,i=(t.x+n.x)/2,a=(t.y+n.y)/2;do{e.y>a!=e.next.y>a&&i<(e.next.x-e.x)*(a-e.y)/(e.next.y-e.y)+e.x&&(r=!r),e=e.next}while(e!==t);return r}function qt(t,n){var e=new _t(t.i,t.x,t.y),r=new _t(n.i,n.x,n.y),i=t.next,a=n.prev;return t.next=n,n.prev=t,e.next=i,i.prev=e,r.next=e,e.prev=r,a.next=r,r.prev=a,r}function kt(t,n,e,r){var i=new _t(t,n,e);return r?(i.next=r.next,i.prev=r,r.next.prev=i,r.next=i):(i.prev=i,i.next=i),i}function Pt(t){t.next.prev=t.prev,t.prev.next=t.next,t.prevZ&&(t.prevZ.nextZ=t.nextZ),t.nextZ&&(t.nextZ.prevZ=t.prevZ)}function _t(t,n,e){this.i=t,this.x=n,this.y=e,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}function Et(t,n,e,r){for(var i=0,a=n,o=e-r;a<e;a+=r)i+=(t[o]-t[a])*(t[a+1]+t[o+1]),o=a;return i}function St(t,n){var e=n.id,r=n.bbox,i=null==n.properties?{}:n.properties,a=Ct(t,n);return null==e&&null==r?{type:\"Feature\",properties:i,geometry:a}:null==r?{type:\"Feature\",id:e,properties:i,geometry:a}:{type:\"Feature\",id:e,bbox:r,properties:i,geometry:a}}function Ct(t,n){function e(t,n){n.length&&n.pop();for(var e=u[t<0?~t:t],r=0,i=e.length;r<i;++r)n.push(h(e[r],r));t<0&&Vn(n,i)}function r(t){return h(t)}function i(t){for(var n=[],r=0,i=t.length;r<i;++r)e(t[r],n);return n.length<2&&n.push(n[0]),n}function a(t){for(var n=i(t);n.length<4;)n.push(n[0]);return n}function o(t){return t.map(a)}function s(t){var n,e=t.type;switch(e){case\"GeometryCollection\":return{type:e,geometries:t.geometries.map(s)};case\"Point\":n=r(t.coordinates);break;case\"MultiPoint\":n=t.coordinates.map(r);break;case\"LineString\":n=i(t.arcs);break;case\"MultiLineString\":n=t.arcs.map(i);break;case\"Polygon\":n=o(t.arcs);break;case\"MultiPolygon\":n=t.arcs.map(o);break;default:return null}return{type:e,coordinates:n}}var h=In(t.transform),u=t.arcs;return s(n)}function Zt(t){for(var n,e=-1,r=t.length,i=t[r-1],a=0;++e<r;)n=i,i=t[e],a+=n[0]*i[1]-n[1]*i[0];return Math.abs(a)}function Tt(t,n){function e(t){switch(t.type){case\"GeometryCollection\":t.geometries.forEach(e);break;case\"Polygon\":r(t.arcs);break;case\"MultiPolygon\":t.arcs.forEach(r)}}function r(t){t.forEach(function(n){n.forEach(function(n){(a[n=n<0?~n:n]||(a[n]=[])).push(t)})}),o.push(t)}function i(n){return Zt(Ct(t,{type:\"Polygon\",arcs:[n]}).coordinates[0])}var a={},o=[],s=[];return n.forEach(e),o.forEach(function(t){if(!t._){var n=[],e=[t];for(t._=1,s.push(n);t=e.pop();)n.push(t),t.forEach(function(t){t.forEach(function(t){a[t<0?~t:t].forEach(function(t){t._||(t._=1,e.push(t))})})})}}),o.forEach(function(t){delete t._}),{type:\"MultiPolygon\",arcs:s.map(function(n){var e,r=[];if(n.forEach(function(t){t.forEach(function(t){t.forEach(function(t){a[t<0?~t:t].length<2&&r.push(t)})})}),r=Yn(t,r),(e=r.length)>1)for(var o,s,h=1,u=i(r[0]);h<e;++h)(o=i(r[h]))>u&&(s=r[0],r[0]=r[h],r[h]=s,u=o);return r})}}function Ft(t){return function(n,e){return Dn(t(n),e)}}function zt(t,n){var e={},r={type:\"Topology\",objects:{triangles:{type:\"GeometryCollection\",geometries:[]}},arcs:[]};return t.forEach(function(t){var i=[];t.forEach(function(t,a){var o=t[0]<t[1]?t.join(\",\"):t[1]+\",\"+t[0],s=t.map(function(t){return n[t]});o in e?i.push(~e[o]):(i.push(e[o]=r.arcs.length),r.arcs.push(s))}),r.objects.triangles.geometries.push({type:\"Polygon\",area:Math.abs(tn(t.map(function(t){return n[t[0]]}))),arcs:[i]})}),r.objects.triangles.geometries.sort(function(t,n){return t.area-n.area}),r}function jt(t,n){for(var e=t.objects.triangles.geometries,r=Hn(function(t){return t.area}).left;e.length>n;)!function(){var n=e[0],i=On(e)[0][0],a=e[i],o=Tt(t,[n,a]);o.area=n.area+a.area,o.type=\"Polygon\",o.arcs=o.arcs[0],e.splice(i,1),e.shift(),e.splice(r(e,o.area),0,o)}();if(n>e.length)throw new RangeError(\"Can't collapse topology into \"+n+\" pieces.\");return Xn(t,t.objects.triangles).features.map(function(t){return t.geometry.coordinates[0].pop(),t.geometry.coordinates[0]})}function It(t){for(var n=zn(t.reduce(function(t,n){return t.concat([n[0]],[n[1]])},[])),e=[],r=0,i=n.length;r<i;r+=3)e.push([[n[r],n[r+1]],[n[r+1],n[r+2]],[n[r+2],n[r]]]);return e}function Vt(t,n,e){function r(t,n,o){void 0===n&&(n=[]),void 0===o&&(o=0);for(var s=0;s<t.length;s++){var h=t.splice(s,1),u=e[h[0]][n.length];o+u<i&&(t.length?r(t.slice(),n.concat(h),o+u):(i=o+u,a=n.concat(h))),t.length&&t.splice(s,0,h[0])}}var i=1/0,a=t.map(function(t,n){return n});return r(a),a}function Xt(t,n){var e=F(Y(t),Y(n));return e*e}function Yt(t,n,e){void 0===e&&(e={});var r=e.maxSegmentLength;void 0===r&&(r=10);var i=e.string;void 0===i&&(i=!0);var a=e.single;void 0===a&&(a=!1);var o=J(t,r);o.length<n.length+2&&W(o,n.length+2-o.length);var s,h=Qn(o,n.length),u=n.map(function(t){return J(t,r)}),c=\"string\"==typeof t&&t;return a&&!n.every(function(t){return\"string\"==typeof t})||(s=n.slice(0)),Dt(h,u,{match:!0,string:i,single:a,t0:c,t1:s})}function Gt(t,n,e){void 0===e&&(e={});var r=e.maxSegmentLength;void 0===r&&(r=10);var i=e.string;void 0===i&&(i=!0);var a=e.single;void 0===a&&(a=!1);var o=Yt(n,t,{maxSegmentLength:r,string:i,single:a});return a?function(t){return o(1-t)}:o.map(function(t){return function(n){return t(1-n)}})}function Ot(t,n,e){void 0===e&&(e={});var r=e.maxSegmentLength;void 0===r&&(r=10);var i=e.string;void 0===i&&(i=!0);var a=e.single;if(void 0===a&&(a=!1),!Array.isArray(t)||!Array.isArray(n)||t.length!==n.length||!t.length)throw new TypeError(Zn);var o,s,h=function(t){return J(t,r)},u=t.map(h),c=n.map(h);return a?(t.every(function(t){return\"string\"==typeof t})&&(o=t.slice(0)),n.every(function(t){return\"string\"==typeof t})&&(s=n.slice(0))):(o=t.slice(0),s=n.slice(0)),Dt(u,c,{string:i,single:a,t0:o,t1:s,match:!1})}function Dt(t,n,e){void 0===e&&(e={});var r=e.string,i=e.single,a=e.t0,o=e.t1,s=e.match,h=s?Un(t,n):t.map(function(t,n){return n}),u=h.map(function(e,i){return tt(t[e],n[i],r)});if(s&&Array.isArray(a)&&(a=h.map(function(t){return a[t]})),i&&r&&(Array.isArray(a)&&(a=a.join(\" \")),Array.isArray(o)&&(o=o.join(\" \"))),i){var c=r?function(t){return u.map(function(n){return n(t)}).join(\" \")}:function(t){return u.map(function(n){return n(t)})};return r&&(a||o)?function(t){return t<1e-4&&a||1-t<1e-4&&o||c(t)}:c}return r?(a=Array.isArray(a)?a.map(function(t){return\"string\"==typeof t&&t}):[],o=Array.isArray(o)?o.map(function(t){return\"string\"==typeof t&&t}):[],u.map(function(t,n){return a[n]||o[n]?function(e){return e<1e-4&&a[n]||1-e<1e-4&&o[n]||t(e)}:t})):u}function Ht(t,n,e,r,i){return Rt(Bt(t,n,e),r,Jt(t,n,e),2*Math.PI*e,i)}function Nt(t,n,e,r,i){var a=Ht(n,e,r,t,i);return function(t){return a(1-t)}}function Qt(t,n,e,r,i,a){return Rt(Wt(t,n,e,r),i,Kt(t,n,e,r),2*e+2*r,a)}function Ut(t,n,e,r,i,a){var o=Qt(n,e,r,i,t,a);return function(t){return o(1-t)}}function Rt(t,n,e,r,i){void 0===i&&(i={});var a=i.maxSegmentLength;void 0===a&&(a=10);var o=i.string;void 0===o&&(o=!0);var s,h,u=J(n,a);return X(r)&&u.length<r/a&&W(u,Math.ceil(r/a-u.length)),s=t(u),h=I(s,u,o),o?function(t){return t<1e-4?e:h(t)}:h}function Bt(t,n,e){return function(r){var i=Y(r),a=en(r.concat([r[0]])),o=Math.atan2(r[0][1]-i[1],r[0][0]-i[0]),s=0;return r.map(function(i,h){var u;return h&&(s+=F(i,r[h-1])),u=o+2*Math.PI*(a?s/a:h/r.length),[Math.cos(u)*e+t,Math.sin(u)*e+n]})}}function Wt(t,n,e,r){return function(i){var a=Y(i),o=en(i.concat([i[0]])),s=Math.atan2(i[0][1]-a[1],i[0][0]-a[0]),h=0;s<0&&(s=2*Math.PI+s);var u=s/(2*Math.PI);return i.map(function(a,s){s&&(h+=F(a,i[s-1]));var c=$t((u+(o?h/o:s/i.length))%1);return[t+c[0]*e,n+c[1]*r]})}}function $t(t){return t<=1/8?[1,.5+4*t]:t<=3/8?[1.5-4*t,1]:t<=5/8?[0,2.5-4*t]:t<=7/8?[4*t-2.5,0]:[1,4*t-3.5]}function Jt(t,n,e){var r=t-e+\",\"+n,i=t+e+\",\"+n,a=\"A\"+e+\",\"+e+\",0,1,1,\";return\"M\"+r+a+i+a+r+\"Z\"}function Kt(t,n,e,r){var i=t+e,a=n+r;return\"M\"+t+\",\"+n+\"L\"+i+\",\"+n+\"L\"+i+\",\"+a+\"L\"+t+\",\"+a+\"Z\"}var tn=function(t){for(var n,e=-1,r=t.length,i=t[r-1],a=0;++e<r;)n=i,i=t[e],a+=n[1]*i[0]-n[0]*i[1];return a/2},nn=function(t){for(var n,e,r=-1,i=t.length,a=0,o=0,s=t[i-1],h=0;++r<i;)n=s,s=t[r],h+=e=n[0]*s[1]-s[0]*n[1],a+=(n[0]+s[0])*e,o+=(n[1]+s[1])*e;return h*=3,[a/h,o/h]},en=function(t){for(var n,e,r=-1,i=t.length,a=t[i-1],o=a[0],s=a[1],h=0;++r<i;)n=o,e=s,a=t[r],o=a[0],s=a[1],n-=o,e-=s,h+=Math.sqrt(n*n+e*e);return h},rn={a:7,c:6,h:1,l:2,m:2,r:4,q:4,s:4,t:2,v:1,z:0},an=[5760,6158,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8239,8287,12288,65279],on=function(t){var n=new a(t),e=n.max;for(o(n);n.index<e&&!n.err.length;)u(n);return n.err.length?n.result=[]:n.result.length&&(\"mM\".indexOf(n.result[0][0])<0?(n.err=\"SvgPath: string should start with `M` or `m`\",n.result=[]):n.result[0][0]=\"M\"),{err:n.err,segments:n.result}};f.prototype.matrix=function(t){return 1===t[0]&&0===t[1]&&0===t[2]&&1===t[3]&&0===t[4]&&0===t[5]?this:(this.cache=null,this.queue.push(t),this)},f.prototype.translate=function(t,n){return 0===t&&0===n||(this.cache=null,this.queue.push([1,0,0,1,t,n])),this},f.prototype.scale=function(t,n){return 1===t&&1===n||(this.cache=null,this.queue.push([t,0,0,n,0,0])),this},f.prototype.rotate=function(t,n,e){var r,i,a;return 0!==t&&(this.translate(n,e),r=t*Math.PI/180,i=Math.cos(r),a=Math.sin(r),this.queue.push([i,a,-a,i,0,0]),this.cache=null,this.translate(-n,-e)),this},f.prototype.skewX=function(t){return 0!==t&&(this.cache=null,this.queue.push([1,0,Math.tan(t*Math.PI/180),1,0,0])),this},f.prototype.skewY=function(t){return 0!==t&&(this.cache=null,this.queue.push([1,Math.tan(t*Math.PI/180),0,1,0,0])),this},f.prototype.toArray=function(){var t=this;if(this.cache)return this.cache;if(!this.queue.length)return this.cache=[1,0,0,1,0,0],this.cache;if(this.cache=this.queue[0],1===this.queue.length)return this.cache;for(var n=1;n<this.queue.length;n++)t.cache=c(t.cache,t.queue[n]);return this.cache},f.prototype.calc=function(t,n,e){var r;return this.queue.length?(this.cache||(this.cache=this.toArray()),r=this.cache,[t*r[0]+n*r[2]+(e?0:r[4]),t*r[1]+n*r[3]+(e?0:r[5])]):[t,n]};var sn=f,hn={matrix:!0,scale:!0,rotate:!0,translate:!0,skewX:!0,skewY:!0},un=/\\s*(matrix|translate|scale|rotate|skewX|skewY)\\s*\\(\\s*(.+?)\\s*\\)[\\s,]*/,cn=/[\\s,]+/,fn=function(t){var n,e,r=new sn;return t.split(un).forEach(function(t){if(t.length){if(void 0!==hn[t])return void(n=t);switch(e=t.split(cn).map(function(t){return+t||0}),n){case\"matrix\":return void(6===e.length&&r.matrix(e));case\"scale\":return void(1===e.length?r.scale(e[0],e[0]):2===e.length&&r.scale(e[0],e[1]));case\"rotate\":return void(1===e.length?r.rotate(e[0],0,0):3===e.length&&r.rotate(e[0],e[1],e[2]));case\"translate\":return void(1===e.length?r.translate(e[0],0):2===e.length&&r.translate(e[0],e[1]));case\"skewX\":return void(1===e.length&&r.skewX(e[0]));case\"skewY\":return void(1===e.length&&r.skewY(e[0]))}}}),r},ln=2*Math.PI,pn=function(t,n,e,r,i,a,o,s,h){var u=Math.sin(h*ln/360),c=Math.cos(h*ln/360),f=c*(t-e)/2+u*(n-r)/2,l=-u*(t-e)/2+c*(n-r)/2;if(0===f&&0===l)return[];if(0===o||0===s)return[];o=Math.abs(o),s=Math.abs(s);var v=f*f/(o*o)+l*l/(s*s);v>1&&(o*=Math.sqrt(v),s*=Math.sqrt(v));var x=p(t,n,e,r,i,a,o,s,u,c),y=[],d=x[2],m=x[3],M=Math.max(Math.ceil(Math.abs(m)/(ln/4)),1);m/=M;for(var w=0;w<M;w++)y.push(g(d,m)),d+=m;return y.map(function(t){for(var n=0;n<t.length;n+=2){var e=t[n+0],r=t[n+1];e*=o,r*=s;var i=c*e-u*r,a=u*e+c*r;t[n+0]=i+x[0],t[n+1]=a+x[1]}return t})},gn=Math.PI/180;v.prototype.transform=function(t){var n=Math.cos(this.ax*gn),e=Math.sin(this.ax*gn),r=[this.rx*(t[0]*n+t[2]*e),this.rx*(t[1]*n+t[3]*e),this.ry*(-t[0]*e+t[2]*n),this.ry*(-t[1]*e+t[3]*n)],i=r[0]*r[0]+r[2]*r[2],a=r[1]*r[1]+r[3]*r[3],o=((r[0]-r[3])*(r[0]-r[3])+(r[2]+r[1])*(r[2]+r[1]))*((r[0]+r[3])*(r[0]+r[3])+(r[2]-r[1])*(r[2]-r[1])),s=(i+a)/2;if(o<1e-10*s)return this.rx=this.ry=Math.sqrt(s),this.ax=0,this;var h=r[0]*r[1]+r[2]*r[3];o=Math.sqrt(o);var u=s+o/2,c=s-o/2;return this.ax=Math.abs(h)<1e-10&&Math.abs(u-a)<1e-10?90:180*Math.atan(Math.abs(h)>Math.abs(u-a)?(u-i)/h:h/(u-a))/Math.PI,this.ax>=0?(this.rx=Math.sqrt(u),this.ry=Math.sqrt(c)):(this.ax+=90,this.rx=Math.sqrt(c),this.ry=Math.sqrt(u)),this},v.prototype.isDegenerate=function(){return this.rx<1e-10*this.ry||this.ry<1e-10*this.rx};var vn=v;x.prototype.__matrix=function(t){var n,e=this;t.queue.length&&this.iterate(function(r,i,a,o){var s,h,u,c;switch(r[0]){case\"v\":s=t.calc(0,r[1],!0),h=0===s[0]?[\"v\",s[1]]:[\"l\",s[0],s[1]];break;case\"V\":s=t.calc(a,r[1],!1),h=s[0]===t.calc(a,o,!1)[0]?[\"V\",s[1]]:[\"L\",s[0],s[1]];break;case\"h\":s=t.calc(r[1],0,!0),h=0===s[1]?[\"h\",s[0]]:[\"l\",s[0],s[1]];break;case\"H\":s=t.calc(r[1],o,!1),h=s[1]===t.calc(a,o,!1)[1]?[\"H\",s[0]]:[\"L\",s[0],s[1]];break;case\"a\":case\"A\":var f=t.toArray(),l=vn(r[1],r[2],r[3]).transform(f);if(f[0]*f[3]-f[1]*f[2]<0&&(r[5]=r[5]?\"0\":\"1\"),s=t.calc(r[6],r[7],\"a\"===r[0]),\"A\"===r[0]&&r[6]===a&&r[7]===o||\"a\"===r[0]&&0===r[6]&&0===r[7]){h=[\"a\"===r[0]?\"l\":\"L\",s[0],s[1]];break}h=l.isDegenerate()?[\"a\"===r[0]?\"l\":\"L\",s[0],s[1]]:[r[0],l.rx,l.ry,l.ax,r[4],r[5],s[0],s[1]];break;case\"m\":c=i>0,s=t.calc(r[1],r[2],c),h=[\"m\",s[0],s[1]];break;default:for(u=r[0],h=[u],c=u.toLowerCase()===u,n=1;n<r.length;n+=2)s=t.calc(r[n],r[n+1],c),h.push(s[0],s[1])}e.segments[i]=h},!0)},x.prototype.__evaluateStack=function(){var t,n,e=this;if(this.__stack.length){if(1===this.__stack.length)return this.__matrix(this.__stack[0]),void(this.__stack=[]);for(t=sn(),n=this.__stack.length;--n>=0;)t.matrix(e.__stack[n].toArray());this.__matrix(t),this.__stack=[]}},x.prototype.toString=function(){var t,n,e=this,r=[];this.__evaluateStack();for(var i=0;i<this.segments.length;i++)n=e.segments[i][0],t=i>0&&\"m\"!==n&&\"M\"!==n&&n===e.segments[i-1][0],r=r.concat(t?e.segments[i].slice(1):e.segments[i]);return r.join(\" \").replace(/ ?([achlmqrstvz]) ?/gi,\"$1\").replace(/ \\-/g,\"-\").replace(/zm/g,\"z m\")},x.prototype.translate=function(t,n){return this.__stack.push(sn().translate(t,n||0)),this},x.prototype.scale=function(t,n){return this.__stack.push(sn().scale(t,n||0===n?n:t)),this},x.prototype.rotate=function(t,n,e){return this.__stack.push(sn().rotate(t,n||0,e||0)),this},x.prototype.skewX=function(t){return this.__stack.push(sn().skewX(t)),this},x.prototype.skewY=function(t){return this.__stack.push(sn().skewY(t)),this},x.prototype.matrix=function(t){return this.__stack.push(sn().matrix(t)),this},x.prototype.transform=function(t){return t.trim()?(this.__stack.push(fn(t)),this):this},x.prototype.round=function(t){var n,e=0,r=0,i=0,a=0;return t=t||0,this.__evaluateStack(),this.segments.forEach(function(o){var s=o[0].toLowerCase()===o[0];switch(o[0]){case\"H\":case\"h\":return s&&(o[1]+=i),i=o[1]-o[1].toFixed(t),void(o[1]=+o[1].toFixed(t));case\"V\":case\"v\":return s&&(o[1]+=a),a=o[1]-o[1].toFixed(t),void(o[1]=+o[1].toFixed(t));case\"Z\":case\"z\":return i=e,void(a=r);case\"M\":case\"m\":return s&&(o[1]+=i,o[2]+=a),i=o[1]-o[1].toFixed(t),a=o[2]-o[2].toFixed(t),e=i,r=a,o[1]=+o[1].toFixed(t),void(o[2]=+o[2].toFixed(t));case\"A\":case\"a\":return s&&(o[6]+=i,o[7]+=a),i=o[6]-o[6].toFixed(t),a=o[7]-o[7].toFixed(t),o[1]=+o[1].toFixed(t),o[2]=+o[2].toFixed(t),o[3]=+o[3].toFixed(t+2),o[6]=+o[6].toFixed(t),void(o[7]=+o[7].toFixed(t));default:return n=o.length,s&&(o[n-2]+=i,o[n-1]+=a),i=o[n-2]-o[n-2].toFixed(t),a=o[n-1]-o[n-1].toFixed(t),void o.forEach(function(n,e){e&&(o[e]=+o[e].toFixed(t))})}}),this},x.prototype.iterate=function(t,n){var e,r,i,a=this.segments,o={},s=!1,h=0,u=0,c=0,f=0;if(n||this.__evaluateStack(),a.forEach(function(n,e){var r=t(n,e,h,u);Array.isArray(r)&&(o[e]=r,s=!0);var i=n[0]===n[0].toLowerCase();switch(n[0]){case\"m\":case\"M\":return h=n[1]+(i?h:0),u=n[2]+(i?u:0),c=h,void(f=u);case\"h\":case\"H\":return void(h=n[1]+(i?h:0));case\"v\":case\"V\":return void(u=n[1]+(i?u:0));case\"z\":case\"Z\":return h=c,void(u=f);default:h=n[n.length-2]+(i?h:0),u=n[n.length-1]+(i?u:0)}}),!s)return this;for(i=[],e=0;e<a.length;e++)if(void 0!==o[e])for(r=0;r<o[e].length;r++)i.push(o[e][r]);else i.push(a[e]);return this.segments=i,this},x.prototype.abs=function(){return this.iterate(function(t,n,e,r){var i,a=t[0],o=a.toUpperCase();if(a!==o)switch(t[0]=o,a){case\"v\":return void(t[1]+=r);case\"a\":return t[6]+=e,void(t[7]+=r);default:for(i=1;i<t.length;i++)t[i]+=i%2?e:r}},!0),this},x.prototype.rel=function(){return this.iterate(function(t,n,e,r){var i,a=t[0],o=a.toLowerCase();if(a!==o&&(0!==n||\"M\"!==a))switch(t[0]=o,a){case\"V\":return void(t[1]-=r);case\"A\":return t[6]-=e,void(t[7]-=r);default:for(i=1;i<t.length;i++)t[i]-=i%2?e:r}},!0),this},x.prototype.unarc=function(){return this.iterate(function(t,n,e,r){var i,a,o,s=[],h=t[0];return\"A\"!==h&&\"a\"!==h?null:(\"a\"===h?(a=e+t[6],o=r+t[7]):(a=t[6],o=t[7]),i=pn(e,r,a,o,t[4],t[5],t[1],t[2],t[3]),0===i.length?[[\"a\"===t[0]?\"l\":\"L\",t[6],t[7]]]:(i.forEach(function(t){s.push([\"C\",t[2],t[3],t[4],t[5],t[6],t[7]])}),s))}),this},x.prototype.unshort=function(){var t,n,e,r,i,a=this.segments;return this.iterate(function(o,s,h,u){var c,f=o[0],l=f.toUpperCase();s&&(\"T\"===l?(c=\"t\"===f,e=a[s-1],\"Q\"===e[0]?(t=e[1]-h,n=e[2]-u):\"q\"===e[0]?(t=e[1]-e[3],n=e[2]-e[4]):(t=0,n=0),r=-t,i=-n,c||(r+=h,i+=u),a[s]=[c?\"q\":\"Q\",r,i,o[1],o[2]]):\"S\"===l&&(c=\"s\"===f,e=a[s-1],\"C\"===e[0]?(t=e[3]-h,n=e[4]-u):\"c\"===e[0]?(t=e[3]-e[5],n=e[4]-e[6]):(t=0,n=0),r=-t,i=-n,c||(r+=h,i+=u),a[s]=[c?\"c\":\"C\",r,i,o[1],o[2],o[3],o[4]]))}),this};var xn=x,yn=xn,dn={a:7,c:6,h:1,l:2,m:2,q:4,s:4,t:2,v:1,z:0},mn=/([astvzqmhlc])([^astvzqmhlc]*)/gi,Mn=function(t){var n=[];return t.replace(mn,function(t,e,r){var i=e.toLowerCase();for(r=y(r),\"m\"===i&&r.length>2&&(n.push([e].concat(r.splice(0,2))),i=\"l\",e=\"m\"===e?\"l\":\"L\");r.length>=0;){if(r.length===dn[i])return r.unshift(e),n.push(r);if(r.length<dn[i])throw new Error(\"malformed path data\");n.push([e].concat(r.splice(0,dn[i])))}}),n},wn=/-?[0-9]*\\.?[0-9]+(?:e[-+]?\\d+)?/gi,bn=function(t,n,e,r,i,a,o,s){return new d(t,n,e,r,i,a,o,s)};d.prototype={constructor:d,init:function(){this.length=this.getArcLength([this.a.x,this.b.x,this.c.x,this.d.x],[this.a.y,this.b.y,this.c.y,this.d.y])},getTotalLength:function(){return this.length},getPointAtLength:function(t){var n=w(t,this.length,this.getArcLength,[this.a.x,this.b.x,this.c.x,this.d.x],[this.a.y,this.b.y,this.c.y,this.d.y]);return this.getPoint([this.a.x,this.b.x,this.c.x,this.d.x],[this.a.y,this.b.y,this.c.y,this.d.y],n)},getTangentAtLength:function(t){var n=w(t,this.length,this.getArcLength,[this.a.x,this.b.x,this.c.x,this.d.x],[this.a.y,this.b.y,this.c.y,this.d.y]),e=this.getDerivative([this.a.x,this.b.x,this.c.x,this.d.x],[this.a.y,this.b.y,this.c.y,this.d.y],n),r=Math.sqrt(e.x*e.x+e.y*e.y);return r>0?{x:e.x/r,y:e.y/r}:{x:0,y:0}},getPropertiesAtLength:function(t){var n,e=w(t,this.length,this.getArcLength,[this.a.x,this.b.x,this.c.x,this.d.x],[this.a.y,this.b.y,this.c.y,this.d.y]),r=this.getDerivative([this.a.x,this.b.x,this.c.x,this.d.x],[this.a.y,this.b.y,this.c.y,this.d.y],e),i=Math.sqrt(r.x*r.x+r.y*r.y);n=i>0?{x:r.x/i,y:r.y/i}:{\nx:0,y:0};var a=this.getPoint([this.a.x,this.b.x,this.c.x,this.d.x],[this.a.y,this.b.y,this.c.y,this.d.y],e);return{x:a.x,y:a.y,tangentX:n.x,tangentY:n.y}}};var Ln=[[],[],[-.5773502691896257,.5773502691896257],[0,-.7745966692414834,.7745966692414834],[-.33998104358485626,.33998104358485626,-.8611363115940526,.8611363115940526],[0,-.5384693101056831,.5384693101056831,-.906179845938664,.906179845938664],[.6612093864662645,-.6612093864662645,-.2386191860831969,.2386191860831969,-.932469514203152,.932469514203152],[0,.4058451513773972,-.4058451513773972,-.7415311855993945,.7415311855993945,-.9491079123427585,.9491079123427585],[-.1834346424956498,.1834346424956498,-.525532409916329,.525532409916329,-.7966664774136267,.7966664774136267,-.9602898564975363,.9602898564975363],[0,-.8360311073266358,.8360311073266358,-.9681602395076261,.9681602395076261,-.3242534234038089,.3242534234038089,-.6133714327005904,.6133714327005904],[-.14887433898163122,.14887433898163122,-.4333953941292472,.4333953941292472,-.6794095682990244,.6794095682990244,-.8650633666889845,.8650633666889845,-.9739065285171717,.9739065285171717],[0,-.26954315595234496,.26954315595234496,-.5190961292068118,.5190961292068118,-.7301520055740494,.7301520055740494,-.8870625997680953,.8870625997680953,-.978228658146057,.978228658146057],[-.1252334085114689,.1252334085114689,-.3678314989981802,.3678314989981802,-.5873179542866175,.5873179542866175,-.7699026741943047,.7699026741943047,-.9041172563704749,.9041172563704749,-.9815606342467192,.9815606342467192],[0,-.2304583159551348,.2304583159551348,-.44849275103644687,.44849275103644687,-.6423493394403402,.6423493394403402,-.8015780907333099,.8015780907333099,-.9175983992229779,.9175983992229779,-.9841830547185881,.9841830547185881],[-.10805494870734367,.10805494870734367,-.31911236892788974,.31911236892788974,-.5152486363581541,.5152486363581541,-.6872929048116855,.6872929048116855,-.827201315069765,.827201315069765,-.9284348836635735,.9284348836635735,-.9862838086968123,.9862838086968123],[0,-.20119409399743451,.20119409399743451,-.3941513470775634,.3941513470775634,-.5709721726085388,.5709721726085388,-.7244177313601701,.7244177313601701,-.8482065834104272,.8482065834104272,-.937273392400706,.937273392400706,-.9879925180204854,.9879925180204854],[-.09501250983763744,.09501250983763744,-.2816035507792589,.2816035507792589,-.45801677765722737,.45801677765722737,-.6178762444026438,.6178762444026438,-.755404408355003,.755404408355003,-.8656312023878318,.8656312023878318,-.9445750230732326,.9445750230732326,-.9894009349916499,.9894009349916499],[0,-.17848418149584785,.17848418149584785,-.3512317634538763,.3512317634538763,-.5126905370864769,.5126905370864769,-.6576711592166907,.6576711592166907,-.7815140038968014,.7815140038968014,-.8802391537269859,.8802391537269859,-.9506755217687678,.9506755217687678,-.9905754753144174,.9905754753144174],[-.0847750130417353,.0847750130417353,-.2518862256915055,.2518862256915055,-.41175116146284263,.41175116146284263,-.5597708310739475,.5597708310739475,-.6916870430603532,.6916870430603532,-.8037049589725231,.8037049589725231,-.8926024664975557,.8926024664975557,-.9558239495713977,.9558239495713977,-.9915651684209309,.9915651684209309],[0,-.16035864564022537,.16035864564022537,-.31656409996362983,.31656409996362983,-.46457074137596094,.46457074137596094,-.600545304661681,.600545304661681,-.7209661773352294,.7209661773352294,-.8227146565371428,.8227146565371428,-.9031559036148179,.9031559036148179,-.96020815213483,.96020815213483,-.9924068438435844,.9924068438435844],[-.07652652113349734,.07652652113349734,-.22778585114164507,.22778585114164507,-.37370608871541955,.37370608871541955,-.5108670019508271,.5108670019508271,-.636053680726515,.636053680726515,-.7463319064601508,.7463319064601508,-.8391169718222188,.8391169718222188,-.912234428251326,.912234428251326,-.9639719272779138,.9639719272779138,-.9931285991850949,.9931285991850949],[0,-.1455618541608951,.1455618541608951,-.2880213168024011,.2880213168024011,-.4243421202074388,.4243421202074388,-.5516188358872198,.5516188358872198,-.6671388041974123,.6671388041974123,-.7684399634756779,.7684399634756779,-.8533633645833173,.8533633645833173,-.9200993341504008,.9200993341504008,-.9672268385663063,.9672268385663063,-.9937521706203895,.9937521706203895],[-.06973927331972223,.06973927331972223,-.20786042668822127,.20786042668822127,-.34193582089208424,.34193582089208424,-.469355837986757,.469355837986757,-.5876404035069116,.5876404035069116,-.6944872631866827,.6944872631866827,-.7878168059792081,.7878168059792081,-.8658125777203002,.8658125777203002,-.926956772187174,.926956772187174,-.9700604978354287,.9700604978354287,-.9942945854823992,.9942945854823992],[0,-.1332568242984661,.1332568242984661,-.26413568097034495,.26413568097034495,-.3903010380302908,.3903010380302908,-.5095014778460075,.5095014778460075,-.6196098757636461,.6196098757636461,-.7186613631319502,.7186613631319502,-.8048884016188399,.8048884016188399,-.8767523582704416,.8767523582704416,-.9329710868260161,.9329710868260161,-.9725424712181152,.9725424712181152,-.9947693349975522,.9947693349975522],[-.06405689286260563,.06405689286260563,-.1911188674736163,.1911188674736163,-.3150426796961634,.3150426796961634,-.4337935076260451,.4337935076260451,-.5454214713888396,.5454214713888396,-.6480936519369755,.6480936519369755,-.7401241915785544,.7401241915785544,-.820001985973903,.820001985973903,-.8864155270044011,.8864155270044011,-.9382745520027328,.9382745520027328,-.9747285559713095,.9747285559713095,-.9951872199970213,.9951872199970213]],An=[[],[],[1,1],[.8888888888888888,.5555555555555556,.5555555555555556],[.6521451548625461,.6521451548625461,.34785484513745385,.34785484513745385],[.5688888888888889,.47862867049936647,.47862867049936647,.23692688505618908,.23692688505618908],[.3607615730481386,.3607615730481386,.46791393457269104,.46791393457269104,.17132449237917036,.17132449237917036],[.4179591836734694,.3818300505051189,.3818300505051189,.27970539148927664,.27970539148927664,.1294849661688697,.1294849661688697],[.362683783378362,.362683783378362,.31370664587788727,.31370664587788727,.22238103445337448,.22238103445337448,.10122853629037626,.10122853629037626],[.3302393550012598,.1806481606948574,.1806481606948574,.08127438836157441,.08127438836157441,.31234707704000286,.31234707704000286,.26061069640293544,.26061069640293544],[.29552422471475287,.29552422471475287,.26926671930999635,.26926671930999635,.21908636251598204,.21908636251598204,.1494513491505806,.1494513491505806,.06667134430868814,.06667134430868814],[.2729250867779006,.26280454451024665,.26280454451024665,.23319376459199048,.23319376459199048,.18629021092773426,.18629021092773426,.1255803694649046,.1255803694649046,.05566856711617366,.05566856711617366],[.24914704581340277,.24914704581340277,.2334925365383548,.2334925365383548,.20316742672306592,.20316742672306592,.16007832854334622,.16007832854334622,.10693932599531843,.10693932599531843,.04717533638651183,.04717533638651183],[.2325515532308739,.22628318026289723,.22628318026289723,.2078160475368885,.2078160475368885,.17814598076194574,.17814598076194574,.13887351021978725,.13887351021978725,.09212149983772845,.09212149983772845,.04048400476531588,.04048400476531588],[.2152638534631578,.2152638534631578,.2051984637212956,.2051984637212956,.18553839747793782,.18553839747793782,.15720316715819355,.15720316715819355,.12151857068790319,.12151857068790319,.08015808715976021,.08015808715976021,.03511946033175186,.03511946033175186],[.2025782419255613,.19843148532711158,.19843148532711158,.1861610000155622,.1861610000155622,.16626920581699392,.16626920581699392,.13957067792615432,.13957067792615432,.10715922046717194,.10715922046717194,.07036604748810812,.07036604748810812,.03075324199611727,.03075324199611727],[.1894506104550685,.1894506104550685,.18260341504492358,.18260341504492358,.16915651939500254,.16915651939500254,.14959598881657674,.14959598881657674,.12462897125553388,.12462897125553388,.09515851168249279,.09515851168249279,.062253523938647894,.062253523938647894,.027152459411754096,.027152459411754096],[.17944647035620653,.17656270536699264,.17656270536699264,.16800410215645004,.16800410215645004,.15404576107681028,.15404576107681028,.13513636846852548,.13513636846852548,.11188384719340397,.11188384719340397,.08503614831717918,.08503614831717918,.0554595293739872,.0554595293739872,.02414830286854793,.02414830286854793],[.1691423829631436,.1691423829631436,.16427648374583273,.16427648374583273,.15468467512626524,.15468467512626524,.14064291467065065,.14064291467065065,.12255520671147846,.12255520671147846,.10094204410628717,.10094204410628717,.07642573025488905,.07642573025488905,.0497145488949698,.0497145488949698,.02161601352648331,.02161601352648331],[.1610544498487837,.15896884339395434,.15896884339395434,.15276604206585967,.15276604206585967,.1426067021736066,.1426067021736066,.12875396253933621,.12875396253933621,.11156664554733399,.11156664554733399,.09149002162245,.09149002162245,.06904454273764123,.06904454273764123,.0448142267656996,.0448142267656996,.019461788229726478,.019461788229726478],[.15275338713072584,.15275338713072584,.14917298647260374,.14917298647260374,.14209610931838204,.14209610931838204,.13168863844917664,.13168863844917664,.11819453196151841,.11819453196151841,.10193011981724044,.10193011981724044,.08327674157670475,.08327674157670475,.06267204833410907,.06267204833410907,.04060142980038694,.04060142980038694,.017614007139152118,.017614007139152118],[.14608113364969041,.14452440398997005,.14452440398997005,.13988739479107315,.13988739479107315,.13226893863333747,.13226893863333747,.12183141605372853,.12183141605372853,.10879729916714838,.10879729916714838,.09344442345603386,.09344442345603386,.0761001136283793,.0761001136283793,.057134425426857205,.057134425426857205,.036953789770852494,.036953789770852494,.016017228257774335,.016017228257774335],[.13925187285563198,.13925187285563198,.13654149834601517,.13654149834601517,.13117350478706238,.13117350478706238,.12325237681051242,.12325237681051242,.11293229608053922,.11293229608053922,.10041414444288096,.10041414444288096,.08594160621706773,.08594160621706773,.06979646842452049,.06979646842452049,.052293335152683286,.052293335152683286,.03377490158481415,.03377490158481415,.0146279952982722,.0146279952982722],[.13365457218610619,.1324620394046966,.1324620394046966,.12890572218808216,.12890572218808216,.12304908430672953,.12304908430672953,.11499664022241136,.11499664022241136,.10489209146454141,.10489209146454141,.09291576606003515,.09291576606003515,.07928141177671895,.07928141177671895,.06423242140852585,.06423242140852585,.04803767173108467,.04803767173108467,.030988005856979445,.030988005856979445,.013411859487141771,.013411859487141771],[.12793819534675216,.12793819534675216,.1258374563468283,.1258374563468283,.12167047292780339,.12167047292780339,.1155056680537256,.1155056680537256,.10744427011596563,.10744427011596563,.09761865210411388,.09761865210411388,.08619016153195327,.08619016153195327,.0733464814110803,.0733464814110803,.05929858491543678,.05929858491543678,.04427743881741981,.04427743881741981,.028531388628933663,.028531388628933663,.0123412297999872,.0123412297999872]],qn=[[1],[1,1],[1,2,1],[1,3,3,1]],kn=2*Math.PI,Pn=function(t,n,e,r,i,a,o,s,h){var u=Math.sin(i*kn/360),c=Math.cos(i*kn/360),f=c*(t-s)/2+u*(n-h)/2,l=-u*(t-s)/2+c*(n-h)/2;if(0===f&&0===l)return[];if(0===e||0===r)return[];e=Math.abs(e),r=Math.abs(r);var p=f*f/(e*e)+l*l/(r*r);p>1&&(e*=Math.sqrt(p),r*=Math.sqrt(p));var g=S(t,n,s,h,a,o,e,r,u,c),v=[],x=g[2],y=g[3],d=Math.max(Math.ceil(Math.abs(y)/(kn/4)),1);y/=d;for(var m=0;m<d;m++)v.push(C(x,y)),x+=y;return v.map(function(t){for(var n=0;n<t.length;n+=2){var i=t[n+0],a=t[n+1];i*=e,a*=r;var o=c*i-u*a,s=u*i+c*a;t[n+0]=o+g[0],t[n+1]=s+g[1]}return t})},_n=function(t,n,e,r,i,a,o,s,h){return new Z(t,n,e,r,i,a,o,s,h)};Z.prototype={constructor:Z,init:function(){},getTotalLength:function(){return this.length},getPointAtLength:function(t){var n=this;t<0?t=0:t>this.length&&(t=this.length);for(var e=this.partialLengths.length-1;this.partialLengths[e]>=t&&this.partialLengths[e]>0;)e--;e<this.partialLengths.length-1&&e++;for(var r=0,i=0;i<e;i++)r+=n.partialLengths[i];return this.curves[e].getPointAtLength(t-r)},getTangentAtLength:function(t){var n=this;t<0?t=0:t>this.length&&(t=this.length);for(var e=this.partialLengths.length-1;this.partialLengths[e]>=t&&this.partialLengths[e]>0;)e--;e<this.partialLengths.length-1&&e++;for(var r=0,i=0;i<e;i++)r+=n.partialLengths[i];return this.curves[e].getTangentAtLength(t-r)},getPropertiesAtLength:function(t){var n=this.getTangentAtLength(t),e=this.getPointAtLength(t);return{x:e.x,y:e.y,tangentX:n.x,tangentY:n.y}}};var En=function(t,n,e,r){return new T(t,n,e,r)};T.prototype.getTotalLength=function(){return Math.sqrt(Math.pow(this.x0-this.x1,2)+Math.pow(this.y0-this.y1,2))},T.prototype.getPointAtLength=function(t){var n=t/Math.sqrt(Math.pow(this.x0-this.x1,2)+Math.pow(this.y0-this.y1,2)),e=(this.x1-this.x0)*n,r=(this.y1-this.y0)*n;return{x:this.x0+e,y:this.y0+r}},T.prototype.getTangentAtLength=function(){var t=Math.sqrt((this.x1-this.x0)*(this.x1-this.x0)+(this.y1-this.y0)*(this.y1-this.y0));return{x:(this.x1-this.x0)/t,y:(this.y1-this.y0)/t}},T.prototype.getPropertiesAtLength=function(t){var n=this.getPointAtLength(t),e=this.getTangentAtLength();return{x:n.x,y:n.y,tangentX:e.x,tangentY:e.y}};var Sn=function(t){function n(t){if(!t)return null;for(var a,o=Mn(t),s=[0,0],h=[0,0],u=0;u<o.length;u++)\"M\"===o[u][0]?(s=[o[u][1],o[u][2]],i.push(null)):\"m\"===o[u][0]?(s=[o[u][1]+s[0],o[u][2]+s[1]],i.push(null)):\"L\"===o[u][0]?(e+=Math.sqrt(Math.pow(s[0]-o[u][1],2)+Math.pow(s[1]-o[u][2],2)),i.push(new En(s[0],o[u][1],s[1],o[u][2])),s=[o[u][1],o[u][2]]):\"l\"===o[u][0]?(e+=Math.sqrt(Math.pow(o[u][1],2)+Math.pow(o[u][2],2)),i.push(new En(s[0],o[u][1]+s[0],s[1],o[u][2]+s[1])),s=[o[u][1]+s[0],o[u][2]+s[1]]):\"H\"===o[u][0]?(e+=Math.abs(s[0]-o[u][1]),i.push(new En(s[0],o[u][1],s[1],s[1])),s[0]=o[u][1]):\"h\"===o[u][0]?(e+=Math.abs(o[u][1]),i.push(new En(s[0],s[0]+o[u][1],s[1],s[1])),s[0]=o[u][1]+s[0]):\"V\"===o[u][0]?(e+=Math.abs(s[1]-o[u][1]),i.push(new En(s[0],s[0],s[1],o[u][1])),s[1]=o[u][1]):\"v\"===o[u][0]?(e+=Math.abs(o[u][1]),i.push(new En(s[0],s[0],s[1],s[1]+o[u][1])),s[1]=o[u][1]+s[1]):\"z\"===o[u][0]||\"Z\"===o[u][0]?(e+=Math.sqrt(Math.pow(o[0][1]-s[0],2)+Math.pow(o[0][2]-s[1],2)),i.push(new En(s[0],o[0][1],s[1],o[0][2])),s=[o[0][1],o[0][2]]):\"C\"===o[u][0]?(a=new bn(s[0],s[1],o[u][1],o[u][2],o[u][3],o[u][4],o[u][5],o[u][6]),e+=a.getTotalLength(),s=[o[u][5],o[u][6]],i.push(a)):\"c\"===o[u][0]?(a=new bn(s[0],s[1],s[0]+o[u][1],s[1]+o[u][2],s[0]+o[u][3],s[1]+o[u][4],s[0]+o[u][5],s[1]+o[u][6]),e+=a.getTotalLength(),s=[o[u][5]+s[0],o[u][6]+s[1]],i.push(a)):\"S\"===o[u][0]?(a=u>0&&[\"C\",\"c\",\"S\",\"s\"].indexOf(o[u-1][0])>-1?new bn(s[0],s[1],2*s[0]-o[u-1][o[u-1].length-4],2*s[1]-o[u-1][o[u-1].length-3],o[u][1],o[u][2],o[u][3],o[u][4]):new bn(s[0],s[1],s[0],s[1],o[u][1],o[u][2],o[u][3],o[u][4]),e+=a.getTotalLength(),s=[o[u][3],o[u][4]],i.push(a)):\"s\"===o[u][0]?(a=u>0&&[\"C\",\"c\",\"S\",\"s\"].indexOf(o[u-1][0])>-1?new bn(s[0],s[1],s[0]+a.d.x-a.c.x,s[1]+a.d.y-a.c.y,s[0]+o[u][1],s[1]+o[u][2],s[0]+o[u][3],s[1]+o[u][4]):new bn(s[0],s[1],s[0],s[1],s[0]+o[u][1],s[1]+o[u][2],s[0]+o[u][3],s[1]+o[u][4]),e+=a.getTotalLength(),s=[o[u][3]+s[0],o[u][4]+s[1]],i.push(a)):\"Q\"===o[u][0]?(a=new bn(s[0],s[1],o[u][1],o[u][2],o[u][3],o[u][4]),e+=a.getTotalLength(),i.push(a),s=[o[u][3],o[u][4]],h=[o[u][1],o[u][2]]):\"q\"===o[u][0]?(a=new bn(s[0],s[1],s[0]+o[u][1],s[1]+o[u][2],s[0]+o[u][3],s[1]+o[u][4]),e+=a.getTotalLength(),h=[s[0]+o[u][1],s[1]+o[u][2]],s=[o[u][3]+s[0],o[u][4]+s[1]],i.push(a)):\"T\"===o[u][0]?(a=u>0&&[\"Q\",\"q\",\"T\",\"t\"].indexOf(o[u-1][0])>-1?new bn(s[0],s[1],2*s[0]-h[0],2*s[1]-h[1],o[u][1],o[u][2]):new En(s[0],o[u][1],s[1],o[u][2]),i.push(a),e+=a.getTotalLength(),h=[2*s[0]-h[0],2*s[1]-h[1]],s=[o[u][1],o[u][2]]):\"t\"===o[u][0]?(a=u>0&&[\"Q\",\"q\",\"T\",\"t\"].indexOf(o[u-1][0])>-1?new bn(s[0],s[1],2*s[0]-h[0],2*s[1]-h[1],s[0]+o[u][1],s[1]+o[u][2]):new En(s[0],s[0]+o[u][1],s[1],s[1]+o[u][2]),e+=a.getTotalLength(),h=[2*s[0]-h[0],2*s[1]-h[1]],s=[o[u][1]+s[0],o[u][2]+s[0]],i.push(a)):\"A\"===o[u][0]?(a=new _n(s[0],s[1],o[u][1],o[u][2],o[u][3],o[u][4],o[u][5],o[u][6],o[u][7]),e+=a.getTotalLength(),s=[o[u][6],o[u][7]],i.push(a)):\"a\"===o[u][0]&&(a=new _n(s[0],s[1],o[u][1],o[u][2],o[u][3],o[u][4],o[u][5],s[0]+o[u][6],s[1]+o[u][7]),e+=a.getTotalLength(),s=[s[0]+o[u][6],s[1]+o[u][7]],i.push(a)),r.push(e);return n}var e=0,r=[],i=[];n.getTotalLength=function(){return e},n.getPointAtLength=function(t){var n=a(t);return i[n.i].getPointAtLength(n.fraction)},n.getTangentAtLength=function(t){var n=a(t);return i[n.i].getTangentAtLength(n.fraction)},n.getPropertiesAtLength=function(t){var n=a(t);return i[n.i].getPropertiesAtLength(n.fraction)};var a=function(t){t<0?t=0:t>e&&(t=e);for(var n=r.length-1;r[n]>=t&&r[n]>0;)n--;return n++,{fraction:t-r[n-1],i:n}};return n(t)},Cn='All shapes must be supplied as arrays of [x, y] points or an SVG path string (https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/d).\\nExample valid ways of supplying a shape would be:\\n[[0, 0], [10, 0], [10, 10]]\\n\"M0,0 L10,0 L10,10Z\"\\n',Zn=\"flubber.all() expects two arrays of equal length as arguments. Each element in both arrays should be an array of [x, y] points or an SVG path string (https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/d).\",Tn=function(t,n){for(var e,r,i,a=t.length,o=1/0,s=0;s<a;s++)!function(i){r=0,n.forEach(function(n,e){var o=F(t[(i+e)%a],n);r+=o*o}),r<o&&(o=r,e=i)}(s);e&&(i=t.splice(0,e),t.splice.apply(t,[t.length,0].concat(i)))},Fn=function(t,n,e){void 0===e&&(e={});var r=e.maxSegmentLength;void 0===r&&(r=10);var i=e.string;void 0===i&&(i=!0);var a=J(t,r),o=J(n,r),s=tt(a,o,i);return!i||\"string\"!=typeof t&&\"string\"!=typeof n?s:function(e){return e<1e-4&&\"string\"==typeof t?t:1-e<1e-4&&\"string\"==typeof n?n:s(e)}},zn=nt;nt.deviation=function(t,n,e,r){var i=n&&n.length,a=i?n[0]*e:t.length,o=Math.abs(Et(t,0,a,e));if(i)for(var s=0,h=n.length;s<h;s++){var u=n[s]*e,c=s<h-1?n[s+1]*e:t.length;o-=Math.abs(Et(t,u,c,e))}var f=0;for(s=0;s<r.length;s+=3){var l=r[s]*e,p=r[s+1]*e,g=r[s+2]*e;f+=Math.abs((t[l]-t[g])*(t[p+1]-t[l+1])-(t[l]-t[p])*(t[g+1]-t[l+1]))}return 0===o&&0===f?0:Math.abs((f-o)/o)},nt.flatten=function(t){for(var n=t[0][0].length,e={vertices:[],holes:[],dimensions:n},r=0,i=0;i<t.length;i++){for(var a=0;a<t[i].length;a++)for(var o=0;o<n;o++)e.vertices.push(t[i][a][o]);i>0&&(r+=t[i-1].length,e.holes.push(r))}return e};var jn=function(t){return t},In=function(t){if(null==t)return jn;var n,e,r=t.scale[0],i=t.scale[1],a=t.translate[0],o=t.translate[1];return function(t,s){s||(n=e=0);var h=2,u=t.length,c=new Array(u);for(c[0]=(n+=t[0])*r+a,c[1]=(e+=t[1])*i+o;h<u;)c[h]=t[h],++h;return c}},Vn=function(t,n){for(var e,r=t.length,i=r-n;i<--r;)e=t[i],t[i++]=t[r],t[r]=e},Xn=function(t,n){return\"GeometryCollection\"===n.type?{type:\"FeatureCollection\",features:n.geometries.map(function(n){return St(t,n)})}:St(t,n)},Yn=function(t,n){function e(n){var e,r=t.arcs[n<0?~n:n],i=r[0];return t.transform?(e=[0,0],r.forEach(function(t){e[0]+=t[0],e[1]+=t[1]})):e=r[r.length-1],n<0?[e,i]:[i,e]}function r(t,n){for(var e in t){var r=t[e];delete n[r.start],delete r.start,delete r.end,r.forEach(function(t){i[t<0?~t:t]=1}),s.push(r)}}var i={},a={},o={},s=[],h=-1;return n.forEach(function(e,r){var i,a=t.arcs[e<0?~e:e];a.length<3&&!a[1][0]&&!a[1][1]&&(i=n[++h],n[h]=e,n[r]=i)}),n.forEach(function(t){var n,r,i=e(t),s=i[0],h=i[1];if(n=o[s])if(delete o[n.end],n.push(t),n.end=h,r=a[h]){delete a[r.start];var u=r===n?n:n.concat(r);a[u.start=n.start]=o[u.end=r.end]=u}else a[n.start]=o[n.end]=n;else if(n=a[h])if(delete a[n.start],n.unshift(t),n.start=s,r=o[s]){delete o[r.end];var c=r===n?n:r.concat(n);a[c.start=r.start]=o[c.end=n.end]=c}else a[n.start]=o[n.end]=n;else n=[t],a[n.start=s]=o[n.end=h]=n}),r(o,a),r(a,o),n.forEach(function(t){i[t<0?~t:t]||s.push([t])}),s},Gn=function(t,n){for(var e=0,r=t.length;e<r;){var i=e+r>>>1;t[i]<n?e=i+1:r=i}return e},On=function(t){function n(t,n){t.forEach(function(t){t<0&&(t=~t);var e=i[t];e?e.push(n):i[t]=[n]})}function e(t,e){t.forEach(function(t){n(t,e)})}function r(t,n){\"GeometryCollection\"===t.type?t.geometries.forEach(function(t){r(t,n)}):t.type in o&&o[t.type](t.arcs,n)}var i={},a=t.map(function(){return[]}),o={LineString:n,MultiLineString:e,Polygon:e,MultiPolygon:function(t,n){t.forEach(function(t){e(t,n)})}};t.forEach(r);for(var s in i)for(var h=i[s],u=h.length,c=0;c<u;++c)for(var f=c+1;f<u;++f){var l,p=h[c],g=h[f];(l=a[p])[s=Gn(l,g)]!==g&&l.splice(s,0,g),(l=a[g])[s=Gn(l,p)]!==p&&l.splice(s,0,p)}return a},Dn=function(t,n){return t<n?-1:t>n?1:t>=n?0:NaN},Hn=function(t){return 1===t.length&&(t=Ft(t)),{left:function(n,e,r,i){for(null==r&&(r=0),null==i&&(i=n.length);r<i;){var a=r+i>>>1;t(n[a],e)<0?r=a+1:i=a}return r},right:function(n,e,r,i){for(null==r&&(r=0),null==i&&(i=n.length);r<i;){var a=r+i>>>1;t(n[a],e)>0?i=a:r=a+1}return r}}},Nn=Hn(Dn),Qn=(Nn.right,Math.sqrt(50),Math.sqrt(10),Math.sqrt(2),function(t,n){return jt(zt(It(t),t),n)}),Un=function(t,n){if(t.length>8)return t.map(function(t,n){return n});var e=t.map(function(t){return n.map(function(n){return Xt(t,n)})});return Vt(t,n,e)};t.interpolate=Fn,t.separate=Yt,t.combine=Gt,t.interpolateAll=Ot,t.splitPathString=N,t.toPathString=H,t.fromCircle=Ht,t.toCircle=Nt,t.fromRect=Qt,t.toRect=Ut,Object.defineProperty(t,\"__esModule\",{value:!0})});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmx1YmJlci9idWlsZC9mbHViYmVyLm1pbi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mbHViYmVyL2J1aWxkL2ZsdWJiZXIubWluLmpzP2Y5MTMiXSwic291cmNlc0NvbnRlbnQiOlsiIWZ1bmN0aW9uKHQsbil7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGU/bihleHBvcnRzKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtcImV4cG9ydHNcIl0sbik6bih0LmZsdWJiZXI9dC5mbHViYmVyfHx7fSl9KHRoaXMsZnVuY3Rpb24odCl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbih0KXtyZXR1cm4gMTA9PT10fHwxMz09PXR8fDgyMzI9PT10fHw4MjMzPT09dHx8MzI9PT10fHw5PT09dHx8MTE9PT10fHwxMj09PXR8fDE2MD09PXR8fHQ+PTU3NjAmJmFuLmluZGV4T2YodCk+PTB9ZnVuY3Rpb24gZSh0KXtzd2l0Y2goMzJ8dCl7Y2FzZSAxMDk6Y2FzZSAxMjI6Y2FzZSAxMDg6Y2FzZSAxMDQ6Y2FzZSAxMTg6Y2FzZSA5OTpjYXNlIDExNTpjYXNlIDExMzpjYXNlIDExNjpjYXNlIDk3OmNhc2UgMTE0OnJldHVybiEwfXJldHVybiExfWZ1bmN0aW9uIHIodCl7cmV0dXJuIHQ+PTQ4JiZ0PD01N31mdW5jdGlvbiBpKHQpe3JldHVybiB0Pj00OCYmdDw9NTd8fDQzPT09dHx8NDU9PT10fHw0Nj09PXR9ZnVuY3Rpb24gYSh0KXt0aGlzLmluZGV4PTAsdGhpcy5wYXRoPXQsdGhpcy5tYXg9dC5sZW5ndGgsdGhpcy5yZXN1bHQ9W10sdGhpcy5wYXJhbT0wLHRoaXMuZXJyPVwiXCIsdGhpcy5zZWdtZW50U3RhcnQ9MCx0aGlzLmRhdGE9W119ZnVuY3Rpb24gbyh0KXtmb3IoO3QuaW5kZXg8dC5tYXgmJm4odC5wYXRoLmNoYXJDb2RlQXQodC5pbmRleCkpOyl0LmluZGV4Kyt9ZnVuY3Rpb24gcyh0KXt2YXIgbixlPXQuaW5kZXgsaT1lLGE9dC5tYXgsbz0hMSxzPSExLGg9ITEsdT0hMTtpZihpPj1hKXJldHVybiB2b2lkKHQuZXJyPVwiU3ZnUGF0aDogbWlzc2VkIHBhcmFtIChhdCBwb3MgXCIraStcIilcIik7aWYobj10LnBhdGguY2hhckNvZGVBdChpKSw0MyE9PW4mJjQ1IT09bnx8KGkrKyxuPWk8YT90LnBhdGguY2hhckNvZGVBdChpKTowKSwhcihuKSYmNDYhPT1uKXJldHVybiB2b2lkKHQuZXJyPVwiU3ZnUGF0aDogcGFyYW0gc2hvdWxkIHN0YXJ0IHdpdGggMC4uOSBvciBgLmAgKGF0IHBvcyBcIitpK1wiKVwiKTtpZig0NiE9PW4pe2lmKG89NDg9PT1uLGkrKyxuPWk8YT90LnBhdGguY2hhckNvZGVBdChpKTowLG8mJmk8YSYmbiYmcihuKSlyZXR1cm4gdm9pZCh0LmVycj1cIlN2Z1BhdGg6IG51bWJlcnMgc3RhcnRlZCB3aXRoIGAwYCBzdWNoIGFzIGAwOWAgYXJlIGlsZWdhbCAoYXQgcG9zIFwiK2UrXCIpXCIpO2Zvcig7aTxhJiZyKHQucGF0aC5jaGFyQ29kZUF0KGkpKTspaSsrLHM9ITA7bj1pPGE/dC5wYXRoLmNoYXJDb2RlQXQoaSk6MH1pZig0Nj09PW4pe2Zvcih1PSEwLGkrKztyKHQucGF0aC5jaGFyQ29kZUF0KGkpKTspaSsrLGg9ITA7bj1pPGE/dC5wYXRoLmNoYXJDb2RlQXQoaSk6MH1pZigxMDE9PT1ufHw2OT09PW4pe2lmKHUmJiFzJiYhaClyZXR1cm4gdm9pZCh0LmVycj1cIlN2Z1BhdGg6IGludmFsaWQgZmxvYXQgZXhwb25lbnQgKGF0IHBvcyBcIitpK1wiKVwiKTtpZihpKyssbj1pPGE/dC5wYXRoLmNoYXJDb2RlQXQoaSk6MCw0MyE9PW4mJjQ1IT09bnx8aSsrLCEoaTxhJiZyKHQucGF0aC5jaGFyQ29kZUF0KGkpKSkpcmV0dXJuIHZvaWQodC5lcnI9XCJTdmdQYXRoOiBpbnZhbGlkIGZsb2F0IGV4cG9uZW50IChhdCBwb3MgXCIraStcIilcIik7Zm9yKDtpPGEmJnIodC5wYXRoLmNoYXJDb2RlQXQoaSkpOylpKyt9dC5pbmRleD1pLHQucGFyYW09cGFyc2VGbG9hdCh0LnBhdGguc2xpY2UoZSxpKSkrMH1mdW5jdGlvbiBoKHQpe3ZhciBuLGU7bj10LnBhdGhbdC5zZWdtZW50U3RhcnRdLGU9bi50b0xvd2VyQ2FzZSgpO3ZhciByPXQuZGF0YTtpZihcIm1cIj09PWUmJnIubGVuZ3RoPjImJih0LnJlc3VsdC5wdXNoKFtuLHJbMF0sclsxXV0pLHI9ci5zbGljZSgyKSxlPVwibFwiLG49XCJtXCI9PT1uP1wibFwiOlwiTFwiKSxcInJcIj09PWUpdC5yZXN1bHQucHVzaChbbl0uY29uY2F0KHIpKTtlbHNlIGZvcig7ci5sZW5ndGg+PXJuW2VdJiYodC5yZXN1bHQucHVzaChbbl0uY29uY2F0KHIuc3BsaWNlKDAscm5bZV0pKSkscm5bZV0pOyk7fWZ1bmN0aW9uIHUodCl7dmFyIG4scixhLHUsYz10Lm1heDtpZih0LnNlZ21lbnRTdGFydD10LmluZGV4LG49dC5wYXRoLmNoYXJDb2RlQXQodC5pbmRleCksIWUobikpcmV0dXJuIHZvaWQodC5lcnI9XCJTdmdQYXRoOiBiYWQgY29tbWFuZCBcIit0LnBhdGhbdC5pbmRleF0rXCIgKGF0IHBvcyBcIit0LmluZGV4K1wiKVwiKTtpZihhPXJuW3QucGF0aFt0LmluZGV4XS50b0xvd2VyQ2FzZSgpXSx0LmluZGV4Kyssbyh0KSx0LmRhdGE9W10sIWEpcmV0dXJuIHZvaWQgaCh0KTtmb3Iocj0hMTs7KXtmb3IodT1hO3U+MDt1LS0pe2lmKHModCksdC5lcnIubGVuZ3RoKXJldHVybjt0LmRhdGEucHVzaCh0LnBhcmFtKSxvKHQpLHI9ITEsdC5pbmRleDxjJiY0ND09PXQucGF0aC5jaGFyQ29kZUF0KHQuaW5kZXgpJiYodC5pbmRleCsrLG8odCkscj0hMCl9aWYoIXIpe2lmKHQuaW5kZXg+PXQubWF4KWJyZWFrO2lmKCFpKHQucGF0aC5jaGFyQ29kZUF0KHQuaW5kZXgpKSlicmVha319aCh0KX1mdW5jdGlvbiBjKHQsbil7cmV0dXJuW3RbMF0qblswXSt0WzJdKm5bMV0sdFsxXSpuWzBdK3RbM10qblsxXSx0WzBdKm5bMl0rdFsyXSpuWzNdLHRbMV0qblsyXSt0WzNdKm5bM10sdFswXSpuWzRdK3RbMl0qbls1XSt0WzRdLHRbMV0qbls0XSt0WzNdKm5bNV0rdFs1XV19ZnVuY3Rpb24gZigpe2lmKCEodGhpcyBpbnN0YW5jZW9mIGYpKXJldHVybiBuZXcgZjt0aGlzLnF1ZXVlPVtdLHRoaXMuY2FjaGU9bnVsbH1mdW5jdGlvbiBsKHQsbixlLHIpe3ZhciBpPXQqci1uKmU8MD8tMToxLGE9TWF0aC5zcXJ0KHQqdCtuKm4pLG89TWF0aC5zcXJ0KHQqdCtuKm4pLHM9dCplK24qcixoPXMvKGEqbyk7cmV0dXJuIGg+MSYmKGg9MSksaDwtMSYmKGg9LTEpLGkqTWF0aC5hY29zKGgpfWZ1bmN0aW9uIHAodCxuLGUscixpLGEsbyxzLGgsdSl7dmFyIGM9dSoodC1lKS8yK2gqKG4tcikvMixmPS1oKih0LWUpLzIrdSoobi1yKS8yLHA9bypvLGc9cypzLHY9YypjLHg9ZipmLHk9cCpnLXAqeC1nKnY7eTwwJiYoeT0wKSx5Lz1wKngrZyp2LHk9TWF0aC5zcXJ0KHkpKihpPT09YT8tMToxKTt2YXIgZD15Km8vcypmLG09eSotcy9vKmMsTT11KmQtaCptKyh0K2UpLzIsdz1oKmQrdSptKyhuK3IpLzIsYj0oYy1kKS9vLEw9KGYtbSkvcyxBPSgtYy1kKS9vLHE9KC1mLW0pL3Msaz1sKDEsMCxiLEwpLFA9bChiLEwsQSxxKTtyZXR1cm4gMD09PWEmJlA+MCYmKFAtPWxuKSwxPT09YSYmUDwwJiYoUCs9bG4pLFtNLHcsayxQXX1mdW5jdGlvbiBnKHQsbil7dmFyIGU9NC8zKk1hdGgudGFuKG4vNCkscj1NYXRoLmNvcyh0KSxpPU1hdGguc2luKHQpLGE9TWF0aC5jb3ModCtuKSxvPU1hdGguc2luKHQrbik7cmV0dXJuW3IsaSxyLWkqZSxpK3IqZSxhK28qZSxvLWEqZSxhLG9dfWZ1bmN0aW9uIHYodCxuLGUpe2lmKCEodGhpcyBpbnN0YW5jZW9mIHYpKXJldHVybiBuZXcgdih0LG4sZSk7dGhpcy5yeD10LHRoaXMucnk9bix0aGlzLmF4PWV9ZnVuY3Rpb24geCh0KXtpZighKHRoaXMgaW5zdGFuY2VvZiB4KSlyZXR1cm4gbmV3IHgodCk7dmFyIG49b24odCk7dGhpcy5zZWdtZW50cz1uLnNlZ21lbnRzLHRoaXMuZXJyPW4uZXJyLHRoaXMuX19zdGFjaz1bXX1mdW5jdGlvbiB5KHQpe3ZhciBuPXQubWF0Y2god24pO3JldHVybiBuP24ubWFwKE51bWJlcik6W119ZnVuY3Rpb24gZCh0LG4sZSxyLGksYSxvLHMpe3RoaXMuYT17eDp0LHk6bn0sdGhpcy5iPXt4OmUseTpyfSx0aGlzLmM9e3g6aSx5OmF9LHRoaXMuZD17eDpvLHk6c30sbnVsbCE9PW8mJnZvaWQgMCE9PW8mJm51bGwhPT1zJiZ2b2lkIDAhPT1zPyh0aGlzLmdldEFyY0xlbmd0aD1fLHRoaXMuZ2V0UG9pbnQ9TCx0aGlzLmdldERlcml2YXRpdmU9TSk6KHRoaXMuZ2V0QXJjTGVuZ3RoPUEsdGhpcy5nZXRQb2ludD1iLHRoaXMuZ2V0RGVyaXZhdGl2ZT1tKSx0aGlzLmluaXQoKX1mdW5jdGlvbiBtKHQsbixlKXtyZXR1cm57eDoyKigxLWUpKih0WzFdLXRbMF0pKzIqZSoodFsyXS10WzFdKSx5OjIqKDEtZSkqKG5bMV0tblswXSkrMiplKihuWzJdLW5bMV0pfX1mdW5jdGlvbiBNKHQsbixlKXtyZXR1cm4gYihbMyoodFsxXS10WzBdKSwzKih0WzJdLXRbMV0pLDMqKHRbM10tdFsyXSldLFszKihuWzFdLW5bMF0pLDMqKG5bMl0tblsxXSksMyooblszXS1uWzJdKV0sZSl9ZnVuY3Rpb24gdyh0LG4sZSxyLGkpe2Zvcih2YXIgYT0xLG89dC9uLHM9KHQtZShyLGksbykpL247YT4uMDAxOyl7dmFyIGg9ZShyLGksbytzKSx1PWUocixpLG8tcyksYz1NYXRoLmFicyh0LWgpL24sZj1NYXRoLmFicyh0LXUpL247YzxhPyhhPWMsbys9cyk6ZjxhPyhhPWYsby09cyk6cy89Mn1yZXR1cm4gb31mdW5jdGlvbiBiKHQsbixlKXtyZXR1cm57eDooMS1lKSooMS1lKSp0WzBdKzIqKDEtZSkqZSp0WzFdK2UqZSp0WzJdLHk6KDEtZSkqKDEtZSkqblswXSsyKigxLWUpKmUqblsxXStlKmUqblsyXX19ZnVuY3Rpb24gTCh0LG4sZSl7cmV0dXJue3g6KDEtZSkqKDEtZSkqKDEtZSkqdFswXSszKigxLWUpKigxLWUpKmUqdFsxXSszKigxLWUpKmUqZSp0WzJdK2UqZSplKnRbM10seTooMS1lKSooMS1lKSooMS1lKSpuWzBdKzMqKDEtZSkqKDEtZSkqZSpuWzFdKzMqKDEtZSkqZSplKm5bMl0rZSplKmUqblszXX19ZnVuY3Rpb24gQSh0LG4sZSl7dm9pZCAwPT09ZSYmKGU9MSk7dmFyIHI9dFswXS0yKnRbMV0rdFsyXSxpPW5bMF0tMipuWzFdK25bMl0sYT0yKnRbMV0tMip0WzBdLG89MipuWzFdLTIqblswXSxzPTQqKHIqcitpKmkpLGg9NCoociphK2kqbyksdT1hKmErbypvO2lmKDA9PT1zKXJldHVybiBlKk1hdGguc3FydChNYXRoLnBvdyh0WzJdLXRbMF0sMikrTWF0aC5wb3coblsyXS1uWzBdLDIpKTt2YXIgYz1oLygyKnMpLGY9dS9zLGw9ZStjLHA9Zi1jKmM7cmV0dXJuIE1hdGguc3FydChzKS8yKihsKk1hdGguc3FydChsKmwrcCktYypNYXRoLnNxcnQoYypjK3ApK3AqTWF0aC5sb2coTWF0aC5hYnMoKGwrTWF0aC5zcXJ0KGwqbCtwKSkvKGMrTWF0aC5zcXJ0KGMqYytwKSkpKSl9ZnVuY3Rpb24gcSh0LG4pe3JldHVybiBxblt0XVtuXX1mdW5jdGlvbiBrKHQsbixlKXt2YXIgcixpLGEsbz1lLmxlbmd0aC0xO2lmKDA9PT1vKXJldHVybiAwO2lmKDA9PT10KXtmb3IoaT0wLGE9MDthPD1vO2ErKylpKz1xKG8sYSkqTWF0aC5wb3coMS1uLG8tYSkqTWF0aC5wb3cobixhKSplW2FdO3JldHVybiBpfWZvcihyPW5ldyBBcnJheShvKSxhPTA7YTxvO2ErKylyW2FdPW8qKGVbYSsxXS1lW2FdKTtyZXR1cm4gayh0LTEsbixyKX1mdW5jdGlvbiBQKHQsbixlKXt2YXIgcj1rKDEsZSx0KSxpPWsoMSxlLG4pLGE9cipyK2kqaTtyZXR1cm4gTWF0aC5zcXJ0KGEpfWZ1bmN0aW9uIF8odCxuLGUpe3ZhciByLGksYSxvO3ZvaWQgMD09PWUmJihlPTEpO2ZvcihyPWUvMixpPTAsYT0wO2E8MjA7YSsrKW89cipMblsyMF1bYV0rcixpKz1BblsyMF1bYV0qUCh0LG4sbyk7cmV0dXJuIHIqaX1mdW5jdGlvbiBFKHQsbixlLHIpe3ZhciBpPXQqci1uKmU8MD8tMToxLGE9dCplK24qcjtyZXR1cm4gYT4xJiYoYT0xKSxhPC0xJiYoYT0tMSksaSpNYXRoLmFjb3MoYSl9ZnVuY3Rpb24gUyh0LG4sZSxyLGksYSxvLHMsaCx1KXt2YXIgYz11Kih0LWUpLzIraCoobi1yKS8yLGY9LWgqKHQtZSkvMit1KihuLXIpLzIsbD1vKm8scD1zKnMsZz1jKmMsdj1mKmYseD1sKnAtbCp2LXAqZzt4PDAmJih4PTApLHgvPWwqditwKmcseD1NYXRoLnNxcnQoeCkqKGk9PT1hPy0xOjEpO3ZhciB5PXgqby9zKmYsZD14Ki1zL28qYyxtPXUqeS1oKmQrKHQrZSkvMixNPWgqeSt1KmQrKG4rcikvMix3PShjLXkpL28sYj0oZi1kKS9zLEw9KC1jLXkpL28sQT0oLWYtZCkvcyxxPUUoMSwwLHcsYiksaz1FKHcsYixMLEEpO3JldHVybiAwPT09YSYmaz4wJiYoay09a24pLDE9PT1hJiZrPDAmJihrKz1rbiksW20sTSxxLGtdfWZ1bmN0aW9uIEModCxuKXt2YXIgZT00LzMqTWF0aC50YW4obi80KSxyPU1hdGguY29zKHQpLGk9TWF0aC5zaW4odCksYT1NYXRoLmNvcyh0K24pLG89TWF0aC5zaW4odCtuKTtyZXR1cm5bcixpLHItaSplLGkrciplLGErbyplLG8tYSplLGEsb119ZnVuY3Rpb24gWih0LG4sZSxyLGksYSxvLHMsaCl7dmFyIHU9MCxjPVtdLGY9W107UG4odCxuLGUscixpLGEsbyxzLGgpLmZvckVhY2goZnVuY3Rpb24odCl7dmFyIG49bmV3IGJuKHRbMF0sdFsxXSx0WzJdLHRbM10sdFs0XSx0WzVdLHRbNl0sdFs3XSksZT1uLmdldFRvdGFsTGVuZ3RoKCk7dSs9ZSxjLnB1c2goZSksZi5wdXNoKG4pfSksdGhpcy5sZW5ndGg9dSx0aGlzLnBhcnRpYWxMZW5ndGhzPWMsdGhpcy5jdXJ2ZXM9Zn1mdW5jdGlvbiBUKHQsbixlLHIpe3RoaXMueDA9dCx0aGlzLngxPW4sdGhpcy55MD1lLHRoaXMueTE9cn1mdW5jdGlvbiBGKHQsbil7cmV0dXJuIE1hdGguc3FydCgodFswXS1uWzBdKSoodFswXS1uWzBdKSsodFsxXS1uWzFdKSoodFsxXS1uWzFdKSl9ZnVuY3Rpb24geih0LG4sZSl7cmV0dXJuW3RbMF0rKG5bMF0tdFswXSkqZSx0WzFdKyhuWzFdLXRbMV0pKmVdfWZ1bmN0aW9uIGoodCxuKXtyZXR1cm4gRih0LG4pPDFlLTl9ZnVuY3Rpb24gSSh0LG4sZSl7dmFyIHI9dC5tYXAoZnVuY3Rpb24odCxlKXtyZXR1cm4gVih0LG5bZV0pfSk7cmV0dXJuIGZ1bmN0aW9uKHQpe3ZhciBuPXIubWFwKGZ1bmN0aW9uKG4pe3JldHVybiBuKHQpfSk7cmV0dXJuIGU/SChuKTpufX1mdW5jdGlvbiBWKHQsbil7cmV0dXJuIGZ1bmN0aW9uKGUpe3JldHVybiB0Lm1hcChmdW5jdGlvbih0LHIpe3JldHVybiB0K2UqKG5bcl0tdCl9KX19ZnVuY3Rpb24gWCh0KXtyZXR1cm5cIm51bWJlclwiPT10eXBlb2YgdCYmaXNGaW5pdGUodCl9ZnVuY3Rpb24gWSh0KXtyZXR1cm4gRyh0KT9ubih0KTpbKHRbMF1bMF0rdFt0Lmxlbmd0aC0xXVswXSkvMiwodFswXVsxXSt0W3QubGVuZ3RoLTFdWzFdKS8yXX1mdW5jdGlvbiBHKHQpe2Zvcih2YXIgbj0wO248dC5sZW5ndGgtMjtuKyspe3ZhciBlPXRbbl0scj10W24rMV0saT10W24rMl07aWYoZVswXSooclsxXS1pWzFdKStyWzBdKihpWzFdLWVbMV0pK2lbMF0qKGVbMV0tclsxXSkpcmV0dXJuITB9cmV0dXJuITF9ZnVuY3Rpb24gTyh0KXtyZXR1cm4gbmV3IHluKHQpLmFicygpfWZ1bmN0aW9uIEQodCl7cmV0dXJuIHQudG9TdHJpbmcoKS5zcGxpdChcIk1cIikubWFwKGZ1bmN0aW9uKHQsbil7cmV0dXJuIHQ9dC50cmltKCksbiYmdD9cIk1cIit0OnR9KS5maWx0ZXIoZnVuY3Rpb24odCl7cmV0dXJuIHR9KX1mdW5jdGlvbiBIKHQpe3JldHVyblwiTVwiK3Quam9pbihcIkxcIikrXCJaXCJ9ZnVuY3Rpb24gTih0KXtyZXR1cm4gRChPKHQpKX1mdW5jdGlvbiBRKHQsbil7dmFyIGU9Tyh0KTtyZXR1cm4gVShlKXx8UihlLG4pfWZ1bmN0aW9uIFUodCl7dmFyIG49dC5zZWdtZW50c3x8W10sZT1bXTtpZighbi5sZW5ndGh8fFwiTVwiIT09blswXVswXSlyZXR1cm4hMTtmb3IodmFyIHI9MDtyPG4ubGVuZ3RoO3IrKyl7dmFyIGk9bltyXSxhPWlbMF0sbz1pWzFdLHM9aVsyXTtpZihcIk1cIj09PWEmJnJ8fFwiWlwiPT09YSlicmVhaztpZihcIk1cIj09PWF8fFwiTFwiPT09YSllLnB1c2goW28sc10pO2Vsc2UgaWYoXCJIXCI9PT1hKWUucHVzaChbbyxlW2UubGVuZ3RoLTFdWzFdXSk7ZWxzZXtpZihcIlZcIiE9PWEpcmV0dXJuITE7ZS5wdXNoKFtlW2UubGVuZ3RoLTFdWzBdLG9dKX19cmV0dXJuISFlLmxlbmd0aCYme3Jpbmc6ZX19ZnVuY3Rpb24gUih0LG4pe3ZhciBlLHIsaT1EKHQpWzBdLGE9W10sbz0zO2lmKCFpKXRocm93IG5ldyBUeXBlRXJyb3IoQ24pO3I9QihpKSxlPXIuZ2V0VG90YWxMZW5ndGgoKSxuJiZYKG4pJiZuPjAmJihvPU1hdGgubWF4KG8sTWF0aC5jZWlsKGUvbikpKTtmb3IodmFyIHM9MDtzPG87cysrKXt2YXIgaD1yLmdldFBvaW50QXRMZW5ndGgoZSpzL28pO2EucHVzaChbaC54LGgueV0pfXJldHVybntyaW5nOmEsc2tpcEJpc2VjdDohMH19ZnVuY3Rpb24gQih0KXtpZihcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93JiZ3aW5kb3cmJndpbmRvdy5kb2N1bWVudCl0cnl7dmFyIG49d2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXCJwYXRoXCIpO3JldHVybiBuLnNldEF0dHJpYnV0ZU5TKG51bGwsXCJkXCIsdCksbn1jYXRjaCh0KXt9cmV0dXJuIFNuKHQpfWZ1bmN0aW9uIFcodCxuKXtmb3IodmFyIGU9dC5sZW5ndGgrbixyPWVuKHQpL24saT0wLGE9MCxvPXIvMjt0Lmxlbmd0aDxlOyl7dmFyIHM9dFtpXSxoPXRbKGkrMSkldC5sZW5ndGhdLHU9RihzLGgpO288PWErdT8odC5zcGxpY2UoaSsxLDAsdT96KHMsaCwoby1hKS91KTpzLnNsaWNlKDApKSxvKz1yKTooYSs9dSxpKyspfX1mdW5jdGlvbiAkKHQsbil7dm9pZCAwPT09biYmKG49MS8wKTtmb3IodmFyIGU9MDtlPHQubGVuZ3RoO2UrKylmb3IodmFyIHI9dFtlXSxpPWU9PT10Lmxlbmd0aC0xP3RbMF06dFtlKzFdO0YocixpKT5uOylpPXoocixpLC41KSx0LnNwbGljZShlKzEsMCxpKX1mdW5jdGlvbiBKKHQsbil7dmFyIGUscixpO2lmKFwic3RyaW5nXCI9PXR5cGVvZiB0KXt2YXIgYT1RKHQsbik7dD1hLnJpbmcsaT1hLnNraXBCaXNlY3R9ZWxzZSBpZighQXJyYXkuaXNBcnJheSh0KSl0aHJvdyBuZXcgVHlwZUVycm9yKENuKTtpZihlPXQuc2xpY2UoMCksIUsoZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihDbik7cmV0dXJuIGUubGVuZ3RoPjEmJmooZVswXSxlW2UubGVuZ3RoLTFdKSYmZS5wb3AoKSxyPXRuKGUpLHI+MCYmZS5yZXZlcnNlKCksIWkmJm4mJlgobikmJm4+MCYmJChlLG4pLGV9ZnVuY3Rpb24gSyh0KXtyZXR1cm4gdC5ldmVyeShmdW5jdGlvbih0KXtyZXR1cm4gQXJyYXkuaXNBcnJheSh0KSYmdC5sZW5ndGg+PTImJlgodFswXSkmJlgodFsxXSl9KX1mdW5jdGlvbiB0dCh0LG4sZSl7dmFyIHI7cmV0dXJuIHI9dC5sZW5ndGgtbi5sZW5ndGgsVyh0LHI8MD8tMSpyOjApLFcobixyPjA/cjowKSxUbih0LG4pLEkodCxuLGUpfWZ1bmN0aW9uIG50KHQsbixlKXtlPWV8fDI7dmFyIHI9biYmbi5sZW5ndGgsaT1yP25bMF0qZTp0Lmxlbmd0aCxhPWV0KHQsMCxpLGUsITApLG89W107aWYoIWEpcmV0dXJuIG87dmFyIHMsaCx1LGMsZixsLHA7aWYociYmKGE9dXQodCxuLGEsZSkpLHQubGVuZ3RoPjgwKmUpe3M9dT10WzBdLGg9Yz10WzFdO2Zvcih2YXIgZz1lO2c8aTtnKz1lKWY9dFtnXSxsPXRbZysxXSxmPHMmJihzPWYpLGw8aCYmKGg9bCksZj51JiYodT1mKSxsPmMmJihjPWwpO3A9TWF0aC5tYXgodS1zLGMtaCl9cmV0dXJuIGl0KGEsbyxlLHMsaCxwKSxvfWZ1bmN0aW9uIGV0KHQsbixlLHIsaSl7dmFyIGEsbztpZihpPT09RXQodCxuLGUscik+MClmb3IoYT1uO2E8ZTthKz1yKW89a3QoYSx0W2FdLHRbYSsxXSxvKTtlbHNlIGZvcihhPWUtcjthPj1uO2EtPXIpbz1rdChhLHRbYV0sdFthKzFdLG8pO3JldHVybiBvJiZNdChvLG8ubmV4dCkmJihQdChvKSxvPW8ubmV4dCksb31mdW5jdGlvbiBydCh0LG4pe2lmKCF0KXJldHVybiB0O258fChuPXQpO3ZhciBlLHI9dDtkb3tpZihlPSExLHIuc3RlaW5lcnx8IU10KHIsci5uZXh0KSYmMCE9PW10KHIucHJldixyLHIubmV4dCkpcj1yLm5leHQ7ZWxzZXtpZihQdChyKSwocj1uPXIucHJldik9PT1yLm5leHQpcmV0dXJuIG51bGw7ZT0hMH19d2hpbGUoZXx8ciE9PW4pO3JldHVybiBufWZ1bmN0aW9uIGl0KHQsbixlLHIsaSxhLG8pe2lmKHQpeyFvJiZhJiZwdCh0LHIsaSxhKTtmb3IodmFyIHMsaCx1PXQ7dC5wcmV2IT09dC5uZXh0OylpZihzPXQucHJldixoPXQubmV4dCxhP290KHQscixpLGEpOmF0KHQpKW4ucHVzaChzLmkvZSksbi5wdXNoKHQuaS9lKSxuLnB1c2goaC5pL2UpLFB0KHQpLHQ9aC5uZXh0LHU9aC5uZXh0O2Vsc2UgaWYoKHQ9aCk9PT11KXtvPzE9PT1vPyh0PXN0KHQsbixlKSxpdCh0LG4sZSxyLGksYSwyKSk6Mj09PW8mJmh0KHQsbixlLHIsaSxhKTppdChydCh0KSxuLGUscixpLGEsMSk7YnJlYWt9fX1mdW5jdGlvbiBhdCh0KXt2YXIgbj10LnByZXYsZT10LHI9dC5uZXh0O2lmKG10KG4sZSxyKT49MClyZXR1cm4hMTtmb3IodmFyIGk9dC5uZXh0Lm5leHQ7aSE9PXQucHJldjspe2lmKHl0KG4ueCxuLnksZS54LGUueSxyLngsci55LGkueCxpLnkpJiZtdChpLnByZXYsaSxpLm5leHQpPj0wKXJldHVybiExO2k9aS5uZXh0fXJldHVybiEwfWZ1bmN0aW9uIG90KHQsbixlLHIpe3ZhciBpPXQucHJldixhPXQsbz10Lm5leHQ7aWYobXQoaSxhLG8pPj0wKXJldHVybiExO2Zvcih2YXIgcz1pLng8YS54P2kueDxvLng/aS54Om8ueDphLng8by54P2EueDpvLngsaD1pLnk8YS55P2kueTxvLnk/aS55Om8ueTphLnk8by55P2EueTpvLnksdT1pLng+YS54P2kueD5vLng/aS54Om8ueDphLng+by54P2EueDpvLngsYz1pLnk+YS55P2kueT5vLnk/aS55Om8ueTphLnk+by55P2EueTpvLnksZj12dChzLGgsbixlLHIpLGw9dnQodSxjLG4sZSxyKSxwPXQubmV4dFo7cCYmcC56PD1sOyl7aWYocCE9PXQucHJldiYmcCE9PXQubmV4dCYmeXQoaS54LGkueSxhLngsYS55LG8ueCxvLnkscC54LHAueSkmJm10KHAucHJldixwLHAubmV4dCk+PTApcmV0dXJuITE7cD1wLm5leHRafWZvcihwPXQucHJldlo7cCYmcC56Pj1mOyl7aWYocCE9PXQucHJldiYmcCE9PXQubmV4dCYmeXQoaS54LGkueSxhLngsYS55LG8ueCxvLnkscC54LHAueSkmJm10KHAucHJldixwLHAubmV4dCk+PTApcmV0dXJuITE7cD1wLnByZXZafXJldHVybiEwfWZ1bmN0aW9uIHN0KHQsbixlKXt2YXIgcj10O2Rve3ZhciBpPXIucHJldixhPXIubmV4dC5uZXh0OyFNdChpLGEpJiZ3dChpLHIsci5uZXh0LGEpJiZMdChpLGEpJiZMdChhLGkpJiYobi5wdXNoKGkuaS9lKSxuLnB1c2goci5pL2UpLG4ucHVzaChhLmkvZSksUHQociksUHQoci5uZXh0KSxyPXQ9YSkscj1yLm5leHR9d2hpbGUociE9PXQpO3JldHVybiByfWZ1bmN0aW9uIGh0KHQsbixlLHIsaSxhKXt2YXIgbz10O2Rve2Zvcih2YXIgcz1vLm5leHQubmV4dDtzIT09by5wcmV2Oyl7aWYoby5pIT09cy5pJiZkdChvLHMpKXt2YXIgaD1xdChvLHMpO3JldHVybiBvPXJ0KG8sby5uZXh0KSxoPXJ0KGgsaC5uZXh0KSxpdChvLG4sZSxyLGksYSksdm9pZCBpdChoLG4sZSxyLGksYSl9cz1zLm5leHR9bz1vLm5leHR9d2hpbGUobyE9PXQpfWZ1bmN0aW9uIHV0KHQsbixlLHIpe3ZhciBpLGEsbyxzLGgsdT1bXTtmb3IoaT0wLGE9bi5sZW5ndGg7aTxhO2krKylvPW5baV0qcixzPWk8YS0xP25baSsxXSpyOnQubGVuZ3RoLGg9ZXQodCxvLHMsciwhMSksaD09PWgubmV4dCYmKGguc3RlaW5lcj0hMCksdS5wdXNoKHh0KGgpKTtmb3IodS5zb3J0KGN0KSxpPTA7aTx1Lmxlbmd0aDtpKyspZnQodVtpXSxlKSxlPXJ0KGUsZS5uZXh0KTtyZXR1cm4gZX1mdW5jdGlvbiBjdCh0LG4pe3JldHVybiB0Lngtbi54fWZ1bmN0aW9uIGZ0KHQsbil7aWYobj1sdCh0LG4pKXt2YXIgZT1xdChuLHQpO3J0KGUsZS5uZXh0KX19ZnVuY3Rpb24gbHQodCxuKXt2YXIgZSxyPW4saT10LngsYT10Lnksbz0tMS8wO2Rve2lmKGE8PXIueSYmYT49ci5uZXh0Lnkpe3ZhciBzPXIueCsoYS1yLnkpKihyLm5leHQueC1yLngpLyhyLm5leHQueS1yLnkpO2lmKHM8PWkmJnM+byl7aWYobz1zLHM9PT1pKXtpZihhPT09ci55KXJldHVybiByO2lmKGE9PT1yLm5leHQueSlyZXR1cm4gci5uZXh0fWU9ci54PHIubmV4dC54P3I6ci5uZXh0fX1yPXIubmV4dH13aGlsZShyIT09bik7aWYoIWUpcmV0dXJuIG51bGw7aWYoaT09PW8pcmV0dXJuIGUucHJldjt2YXIgaCx1PWUsYz1lLngsZj1lLnksbD0xLzA7Zm9yKHI9ZS5uZXh0O3IhPT11OylpPj1yLngmJnIueD49YyYmeXQoYTxmP2k6byxhLGMsZixhPGY/bzppLGEsci54LHIueSkmJigoaD1NYXRoLmFicyhhLXIueSkvKGktci54KSk8bHx8aD09PWwmJnIueD5lLngpJiZMdChyLHQpJiYoZT1yLGw9aCkscj1yLm5leHQ7cmV0dXJuIGV9ZnVuY3Rpb24gcHQodCxuLGUscil7dmFyIGk9dDtkb3tudWxsPT09aS56JiYoaS56PXZ0KGkueCxpLnksbixlLHIpKSxpLnByZXZaPWkucHJldixpLm5leHRaPWkubmV4dCxpPWkubmV4dH13aGlsZShpIT09dCk7aS5wcmV2Wi5uZXh0Wj1udWxsLGkucHJldlo9bnVsbCxndChpKX1mdW5jdGlvbiBndCh0KXt2YXIgbixlLHIsaSxhLG8scyxoLHU9MTtkb3tmb3IoZT10LHQ9bnVsbCxhPW51bGwsbz0wO2U7KXtmb3IobysrLHI9ZSxzPTAsbj0wO248dSYmKHMrKyxyPXIubmV4dFopO24rKyk7Zm9yKGg9dTtzPjB8fGg+MCYmcjspMD09PXM/KGk9cixyPXIubmV4dFosaC0tKTowIT09aCYmcj9lLno8PXIuej8oaT1lLGU9ZS5uZXh0WixzLS0pOihpPXIscj1yLm5leHRaLGgtLSk6KGk9ZSxlPWUubmV4dFoscy0tKSxhP2EubmV4dFo9aTp0PWksaS5wcmV2Wj1hLGE9aTtlPXJ9YS5uZXh0Wj1udWxsLHUqPTJ9d2hpbGUobz4xKTtyZXR1cm4gdH1mdW5jdGlvbiB2dCh0LG4sZSxyLGkpe3JldHVybiB0PTMyNzY3Kih0LWUpL2ksbj0zMjc2Nyoobi1yKS9pLHQ9MTY3MTE5MzUmKHR8dDw8OCksdD0yNTI2NDUxMzUmKHR8dDw8NCksdD04NTg5OTM0NTkmKHR8dDw8MiksdD0xNDMxNjU1NzY1Jih0fHQ8PDEpLG49MTY3MTE5MzUmKG58bjw8OCksbj0yNTI2NDUxMzUmKG58bjw8NCksbj04NTg5OTM0NTkmKG58bjw8Miksbj0xNDMxNjU1NzY1JihufG48PDEpLHR8bjw8MX1mdW5jdGlvbiB4dCh0KXt2YXIgbj10LGU9dDtkb3tuLng8ZS54JiYoZT1uKSxuPW4ubmV4dH13aGlsZShuIT09dCk7cmV0dXJuIGV9ZnVuY3Rpb24geXQodCxuLGUscixpLGEsbyxzKXtyZXR1cm4oaS1vKSoobi1zKS0odC1vKSooYS1zKT49MCYmKHQtbykqKHItcyktKGUtbykqKG4tcyk+PTAmJihlLW8pKihhLXMpLShpLW8pKihyLXMpPj0wfWZ1bmN0aW9uIGR0KHQsbil7cmV0dXJuIHQubmV4dC5pIT09bi5pJiZ0LnByZXYuaSE9PW4uaSYmIWJ0KHQsbikmJkx0KHQsbikmJkx0KG4sdCkmJkF0KHQsbil9ZnVuY3Rpb24gbXQodCxuLGUpe3JldHVybihuLnktdC55KSooZS54LW4ueCktKG4ueC10LngpKihlLnktbi55KX1mdW5jdGlvbiBNdCh0LG4pe3JldHVybiB0Lng9PT1uLngmJnQueT09PW4ueX1mdW5jdGlvbiB3dCh0LG4sZSxyKXtyZXR1cm4hIShNdCh0LG4pJiZNdChlLHIpfHxNdCh0LHIpJiZNdChlLG4pKXx8bXQodCxuLGUpPjAhPW10KHQsbixyKT4wJiZtdChlLHIsdCk+MCE9bXQoZSxyLG4pPjB9ZnVuY3Rpb24gYnQodCxuKXt2YXIgZT10O2Rve2lmKGUuaSE9PXQuaSYmZS5uZXh0LmkhPT10LmkmJmUuaSE9PW4uaSYmZS5uZXh0LmkhPT1uLmkmJnd0KGUsZS5uZXh0LHQsbikpcmV0dXJuITA7ZT1lLm5leHR9d2hpbGUoZSE9PXQpO3JldHVybiExfWZ1bmN0aW9uIEx0KHQsbil7cmV0dXJuIG10KHQucHJldix0LHQubmV4dCk8MD9tdCh0LG4sdC5uZXh0KT49MCYmbXQodCx0LnByZXYsbik+PTA6bXQodCxuLHQucHJldik8MHx8bXQodCx0Lm5leHQsbik8MH1mdW5jdGlvbiBBdCh0LG4pe3ZhciBlPXQscj0hMSxpPSh0Lngrbi54KS8yLGE9KHQueStuLnkpLzI7ZG97ZS55PmEhPWUubmV4dC55PmEmJmk8KGUubmV4dC54LWUueCkqKGEtZS55KS8oZS5uZXh0LnktZS55KStlLngmJihyPSFyKSxlPWUubmV4dH13aGlsZShlIT09dCk7cmV0dXJuIHJ9ZnVuY3Rpb24gcXQodCxuKXt2YXIgZT1uZXcgX3QodC5pLHQueCx0LnkpLHI9bmV3IF90KG4uaSxuLngsbi55KSxpPXQubmV4dCxhPW4ucHJldjtyZXR1cm4gdC5uZXh0PW4sbi5wcmV2PXQsZS5uZXh0PWksaS5wcmV2PWUsci5uZXh0PWUsZS5wcmV2PXIsYS5uZXh0PXIsci5wcmV2PWEscn1mdW5jdGlvbiBrdCh0LG4sZSxyKXt2YXIgaT1uZXcgX3QodCxuLGUpO3JldHVybiByPyhpLm5leHQ9ci5uZXh0LGkucHJldj1yLHIubmV4dC5wcmV2PWksci5uZXh0PWkpOihpLnByZXY9aSxpLm5leHQ9aSksaX1mdW5jdGlvbiBQdCh0KXt0Lm5leHQucHJldj10LnByZXYsdC5wcmV2Lm5leHQ9dC5uZXh0LHQucHJldlomJih0LnByZXZaLm5leHRaPXQubmV4dFopLHQubmV4dFomJih0Lm5leHRaLnByZXZaPXQucHJldlopfWZ1bmN0aW9uIF90KHQsbixlKXt0aGlzLmk9dCx0aGlzLng9bix0aGlzLnk9ZSx0aGlzLnByZXY9bnVsbCx0aGlzLm5leHQ9bnVsbCx0aGlzLno9bnVsbCx0aGlzLnByZXZaPW51bGwsdGhpcy5uZXh0Wj1udWxsLHRoaXMuc3RlaW5lcj0hMX1mdW5jdGlvbiBFdCh0LG4sZSxyKXtmb3IodmFyIGk9MCxhPW4sbz1lLXI7YTxlO2ErPXIpaSs9KHRbb10tdFthXSkqKHRbYSsxXSt0W28rMV0pLG89YTtyZXR1cm4gaX1mdW5jdGlvbiBTdCh0LG4pe3ZhciBlPW4uaWQscj1uLmJib3gsaT1udWxsPT1uLnByb3BlcnRpZXM/e306bi5wcm9wZXJ0aWVzLGE9Q3QodCxuKTtyZXR1cm4gbnVsbD09ZSYmbnVsbD09cj97dHlwZTpcIkZlYXR1cmVcIixwcm9wZXJ0aWVzOmksZ2VvbWV0cnk6YX06bnVsbD09cj97dHlwZTpcIkZlYXR1cmVcIixpZDplLHByb3BlcnRpZXM6aSxnZW9tZXRyeTphfTp7dHlwZTpcIkZlYXR1cmVcIixpZDplLGJib3g6cixwcm9wZXJ0aWVzOmksZ2VvbWV0cnk6YX19ZnVuY3Rpb24gQ3QodCxuKXtmdW5jdGlvbiBlKHQsbil7bi5sZW5ndGgmJm4ucG9wKCk7Zm9yKHZhciBlPXVbdDwwP350OnRdLHI9MCxpPWUubGVuZ3RoO3I8aTsrK3Ipbi5wdXNoKGgoZVtyXSxyKSk7dDwwJiZWbihuLGkpfWZ1bmN0aW9uIHIodCl7cmV0dXJuIGgodCl9ZnVuY3Rpb24gaSh0KXtmb3IodmFyIG49W10scj0wLGk9dC5sZW5ndGg7cjxpOysrcillKHRbcl0sbik7cmV0dXJuIG4ubGVuZ3RoPDImJm4ucHVzaChuWzBdKSxufWZ1bmN0aW9uIGEodCl7Zm9yKHZhciBuPWkodCk7bi5sZW5ndGg8NDspbi5wdXNoKG5bMF0pO3JldHVybiBufWZ1bmN0aW9uIG8odCl7cmV0dXJuIHQubWFwKGEpfWZ1bmN0aW9uIHModCl7dmFyIG4sZT10LnR5cGU7c3dpdGNoKGUpe2Nhc2VcIkdlb21ldHJ5Q29sbGVjdGlvblwiOnJldHVybnt0eXBlOmUsZ2VvbWV0cmllczp0Lmdlb21ldHJpZXMubWFwKHMpfTtjYXNlXCJQb2ludFwiOm49cih0LmNvb3JkaW5hdGVzKTticmVhaztjYXNlXCJNdWx0aVBvaW50XCI6bj10LmNvb3JkaW5hdGVzLm1hcChyKTticmVhaztjYXNlXCJMaW5lU3RyaW5nXCI6bj1pKHQuYXJjcyk7YnJlYWs7Y2FzZVwiTXVsdGlMaW5lU3RyaW5nXCI6bj10LmFyY3MubWFwKGkpO2JyZWFrO2Nhc2VcIlBvbHlnb25cIjpuPW8odC5hcmNzKTticmVhaztjYXNlXCJNdWx0aVBvbHlnb25cIjpuPXQuYXJjcy5tYXAobyk7YnJlYWs7ZGVmYXVsdDpyZXR1cm4gbnVsbH1yZXR1cm57dHlwZTplLGNvb3JkaW5hdGVzOm59fXZhciBoPUluKHQudHJhbnNmb3JtKSx1PXQuYXJjcztyZXR1cm4gcyhuKX1mdW5jdGlvbiBadCh0KXtmb3IodmFyIG4sZT0tMSxyPXQubGVuZ3RoLGk9dFtyLTFdLGE9MDsrK2U8cjspbj1pLGk9dFtlXSxhKz1uWzBdKmlbMV0tblsxXSppWzBdO3JldHVybiBNYXRoLmFicyhhKX1mdW5jdGlvbiBUdCh0LG4pe2Z1bmN0aW9uIGUodCl7c3dpdGNoKHQudHlwZSl7Y2FzZVwiR2VvbWV0cnlDb2xsZWN0aW9uXCI6dC5nZW9tZXRyaWVzLmZvckVhY2goZSk7YnJlYWs7Y2FzZVwiUG9seWdvblwiOnIodC5hcmNzKTticmVhaztjYXNlXCJNdWx0aVBvbHlnb25cIjp0LmFyY3MuZm9yRWFjaChyKX19ZnVuY3Rpb24gcih0KXt0LmZvckVhY2goZnVuY3Rpb24obil7bi5mb3JFYWNoKGZ1bmN0aW9uKG4peyhhW249bjwwP35uOm5dfHwoYVtuXT1bXSkpLnB1c2godCl9KX0pLG8ucHVzaCh0KX1mdW5jdGlvbiBpKG4pe3JldHVybiBadChDdCh0LHt0eXBlOlwiUG9seWdvblwiLGFyY3M6W25dfSkuY29vcmRpbmF0ZXNbMF0pfXZhciBhPXt9LG89W10scz1bXTtyZXR1cm4gbi5mb3JFYWNoKGUpLG8uZm9yRWFjaChmdW5jdGlvbih0KXtpZighdC5fKXt2YXIgbj1bXSxlPVt0XTtmb3IodC5fPTEscy5wdXNoKG4pO3Q9ZS5wb3AoKTspbi5wdXNoKHQpLHQuZm9yRWFjaChmdW5jdGlvbih0KXt0LmZvckVhY2goZnVuY3Rpb24odCl7YVt0PDA/fnQ6dF0uZm9yRWFjaChmdW5jdGlvbih0KXt0Ll98fCh0Ll89MSxlLnB1c2godCkpfSl9KX0pfX0pLG8uZm9yRWFjaChmdW5jdGlvbih0KXtkZWxldGUgdC5ffSkse3R5cGU6XCJNdWx0aVBvbHlnb25cIixhcmNzOnMubWFwKGZ1bmN0aW9uKG4pe3ZhciBlLHI9W107aWYobi5mb3JFYWNoKGZ1bmN0aW9uKHQpe3QuZm9yRWFjaChmdW5jdGlvbih0KXt0LmZvckVhY2goZnVuY3Rpb24odCl7YVt0PDA/fnQ6dF0ubGVuZ3RoPDImJnIucHVzaCh0KX0pfSl9KSxyPVluKHQsciksKGU9ci5sZW5ndGgpPjEpZm9yKHZhciBvLHMsaD0xLHU9aShyWzBdKTtoPGU7KytoKShvPWkocltoXSkpPnUmJihzPXJbMF0sclswXT1yW2hdLHJbaF09cyx1PW8pO3JldHVybiByfSl9fWZ1bmN0aW9uIEZ0KHQpe3JldHVybiBmdW5jdGlvbihuLGUpe3JldHVybiBEbih0KG4pLGUpfX1mdW5jdGlvbiB6dCh0LG4pe3ZhciBlPXt9LHI9e3R5cGU6XCJUb3BvbG9neVwiLG9iamVjdHM6e3RyaWFuZ2xlczp7dHlwZTpcIkdlb21ldHJ5Q29sbGVjdGlvblwiLGdlb21ldHJpZXM6W119fSxhcmNzOltdfTtyZXR1cm4gdC5mb3JFYWNoKGZ1bmN0aW9uKHQpe3ZhciBpPVtdO3QuZm9yRWFjaChmdW5jdGlvbih0LGEpe3ZhciBvPXRbMF08dFsxXT90LmpvaW4oXCIsXCIpOnRbMV0rXCIsXCIrdFswXSxzPXQubWFwKGZ1bmN0aW9uKHQpe3JldHVybiBuW3RdfSk7byBpbiBlP2kucHVzaCh+ZVtvXSk6KGkucHVzaChlW29dPXIuYXJjcy5sZW5ndGgpLHIuYXJjcy5wdXNoKHMpKX0pLHIub2JqZWN0cy50cmlhbmdsZXMuZ2VvbWV0cmllcy5wdXNoKHt0eXBlOlwiUG9seWdvblwiLGFyZWE6TWF0aC5hYnModG4odC5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIG5bdFswXV19KSkpLGFyY3M6W2ldfSl9KSxyLm9iamVjdHMudHJpYW5nbGVzLmdlb21ldHJpZXMuc29ydChmdW5jdGlvbih0LG4pe3JldHVybiB0LmFyZWEtbi5hcmVhfSkscn1mdW5jdGlvbiBqdCh0LG4pe2Zvcih2YXIgZT10Lm9iamVjdHMudHJpYW5nbGVzLmdlb21ldHJpZXMscj1IbihmdW5jdGlvbih0KXtyZXR1cm4gdC5hcmVhfSkubGVmdDtlLmxlbmd0aD5uOykhZnVuY3Rpb24oKXt2YXIgbj1lWzBdLGk9T24oZSlbMF1bMF0sYT1lW2ldLG89VHQodCxbbixhXSk7by5hcmVhPW4uYXJlYSthLmFyZWEsby50eXBlPVwiUG9seWdvblwiLG8uYXJjcz1vLmFyY3NbMF0sZS5zcGxpY2UoaSwxKSxlLnNoaWZ0KCksZS5zcGxpY2UocihlLG8uYXJlYSksMCxvKX0oKTtpZihuPmUubGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiQ2FuJ3QgY29sbGFwc2UgdG9wb2xvZ3kgaW50byBcIituK1wiIHBpZWNlcy5cIik7cmV0dXJuIFhuKHQsdC5vYmplY3RzLnRyaWFuZ2xlcykuZmVhdHVyZXMubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0Lmdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdLnBvcCgpLHQuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF19KX1mdW5jdGlvbiBJdCh0KXtmb3IodmFyIG49em4odC5yZWR1Y2UoZnVuY3Rpb24odCxuKXtyZXR1cm4gdC5jb25jYXQoW25bMF1dLFtuWzFdXSl9LFtdKSksZT1bXSxyPTAsaT1uLmxlbmd0aDtyPGk7cis9MyllLnB1c2goW1tuW3JdLG5bcisxXV0sW25bcisxXSxuW3IrMl1dLFtuW3IrMl0sbltyXV1dKTtyZXR1cm4gZX1mdW5jdGlvbiBWdCh0LG4sZSl7ZnVuY3Rpb24gcih0LG4sbyl7dm9pZCAwPT09biYmKG49W10pLHZvaWQgMD09PW8mJihvPTApO2Zvcih2YXIgcz0wO3M8dC5sZW5ndGg7cysrKXt2YXIgaD10LnNwbGljZShzLDEpLHU9ZVtoWzBdXVtuLmxlbmd0aF07byt1PGkmJih0Lmxlbmd0aD9yKHQuc2xpY2UoKSxuLmNvbmNhdChoKSxvK3UpOihpPW8rdSxhPW4uY29uY2F0KGgpKSksdC5sZW5ndGgmJnQuc3BsaWNlKHMsMCxoWzBdKX19dmFyIGk9MS8wLGE9dC5tYXAoZnVuY3Rpb24odCxuKXtyZXR1cm4gbn0pO3JldHVybiByKGEpLGF9ZnVuY3Rpb24gWHQodCxuKXt2YXIgZT1GKFkodCksWShuKSk7cmV0dXJuIGUqZX1mdW5jdGlvbiBZdCh0LG4sZSl7dm9pZCAwPT09ZSYmKGU9e30pO3ZhciByPWUubWF4U2VnbWVudExlbmd0aDt2b2lkIDA9PT1yJiYocj0xMCk7dmFyIGk9ZS5zdHJpbmc7dm9pZCAwPT09aSYmKGk9ITApO3ZhciBhPWUuc2luZ2xlO3ZvaWQgMD09PWEmJihhPSExKTt2YXIgbz1KKHQscik7by5sZW5ndGg8bi5sZW5ndGgrMiYmVyhvLG4ubGVuZ3RoKzItby5sZW5ndGgpO3ZhciBzLGg9UW4obyxuLmxlbmd0aCksdT1uLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gSih0LHIpfSksYz1cInN0cmluZ1wiPT10eXBlb2YgdCYmdDtyZXR1cm4gYSYmIW4uZXZlcnkoZnVuY3Rpb24odCl7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIHR9KXx8KHM9bi5zbGljZSgwKSksRHQoaCx1LHttYXRjaDohMCxzdHJpbmc6aSxzaW5nbGU6YSx0MDpjLHQxOnN9KX1mdW5jdGlvbiBHdCh0LG4sZSl7dm9pZCAwPT09ZSYmKGU9e30pO3ZhciByPWUubWF4U2VnbWVudExlbmd0aDt2b2lkIDA9PT1yJiYocj0xMCk7dmFyIGk9ZS5zdHJpbmc7dm9pZCAwPT09aSYmKGk9ITApO3ZhciBhPWUuc2luZ2xlO3ZvaWQgMD09PWEmJihhPSExKTt2YXIgbz1ZdChuLHQse21heFNlZ21lbnRMZW5ndGg6cixzdHJpbmc6aSxzaW5nbGU6YX0pO3JldHVybiBhP2Z1bmN0aW9uKHQpe3JldHVybiBvKDEtdCl9Om8ubWFwKGZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbihuKXtyZXR1cm4gdCgxLW4pfX0pfWZ1bmN0aW9uIE90KHQsbixlKXt2b2lkIDA9PT1lJiYoZT17fSk7dmFyIHI9ZS5tYXhTZWdtZW50TGVuZ3RoO3ZvaWQgMD09PXImJihyPTEwKTt2YXIgaT1lLnN0cmluZzt2b2lkIDA9PT1pJiYoaT0hMCk7dmFyIGE9ZS5zaW5nbGU7aWYodm9pZCAwPT09YSYmKGE9ITEpLCFBcnJheS5pc0FycmF5KHQpfHwhQXJyYXkuaXNBcnJheShuKXx8dC5sZW5ndGghPT1uLmxlbmd0aHx8IXQubGVuZ3RoKXRocm93IG5ldyBUeXBlRXJyb3IoWm4pO3ZhciBvLHMsaD1mdW5jdGlvbih0KXtyZXR1cm4gSih0LHIpfSx1PXQubWFwKGgpLGM9bi5tYXAoaCk7cmV0dXJuIGE/KHQuZXZlcnkoZnVuY3Rpb24odCl7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIHR9KSYmKG89dC5zbGljZSgwKSksbi5ldmVyeShmdW5jdGlvbih0KXtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgdH0pJiYocz1uLnNsaWNlKDApKSk6KG89dC5zbGljZSgwKSxzPW4uc2xpY2UoMCkpLER0KHUsYyx7c3RyaW5nOmksc2luZ2xlOmEsdDA6byx0MTpzLG1hdGNoOiExfSl9ZnVuY3Rpb24gRHQodCxuLGUpe3ZvaWQgMD09PWUmJihlPXt9KTt2YXIgcj1lLnN0cmluZyxpPWUuc2luZ2xlLGE9ZS50MCxvPWUudDEscz1lLm1hdGNoLGg9cz9Vbih0LG4pOnQubWFwKGZ1bmN0aW9uKHQsbil7cmV0dXJuIG59KSx1PWgubWFwKGZ1bmN0aW9uKGUsaSl7cmV0dXJuIHR0KHRbZV0sbltpXSxyKX0pO2lmKHMmJkFycmF5LmlzQXJyYXkoYSkmJihhPWgubWFwKGZ1bmN0aW9uKHQpe3JldHVybiBhW3RdfSkpLGkmJnImJihBcnJheS5pc0FycmF5KGEpJiYoYT1hLmpvaW4oXCIgXCIpKSxBcnJheS5pc0FycmF5KG8pJiYobz1vLmpvaW4oXCIgXCIpKSksaSl7dmFyIGM9cj9mdW5jdGlvbih0KXtyZXR1cm4gdS5tYXAoZnVuY3Rpb24obil7cmV0dXJuIG4odCl9KS5qb2luKFwiIFwiKX06ZnVuY3Rpb24odCl7cmV0dXJuIHUubWFwKGZ1bmN0aW9uKG4pe3JldHVybiBuKHQpfSl9O3JldHVybiByJiYoYXx8byk/ZnVuY3Rpb24odCl7cmV0dXJuIHQ8MWUtNCYmYXx8MS10PDFlLTQmJm98fGModCl9OmN9cmV0dXJuIHI/KGE9QXJyYXkuaXNBcnJheShhKT9hLm1hcChmdW5jdGlvbih0KXtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgdCYmdH0pOltdLG89QXJyYXkuaXNBcnJheShvKT9vLm1hcChmdW5jdGlvbih0KXtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgdCYmdH0pOltdLHUubWFwKGZ1bmN0aW9uKHQsbil7cmV0dXJuIGFbbl18fG9bbl0/ZnVuY3Rpb24oZSl7cmV0dXJuIGU8MWUtNCYmYVtuXXx8MS1lPDFlLTQmJm9bbl18fHQoZSl9OnR9KSk6dX1mdW5jdGlvbiBIdCh0LG4sZSxyLGkpe3JldHVybiBSdChCdCh0LG4sZSkscixKdCh0LG4sZSksMipNYXRoLlBJKmUsaSl9ZnVuY3Rpb24gTnQodCxuLGUscixpKXt2YXIgYT1IdChuLGUscix0LGkpO3JldHVybiBmdW5jdGlvbih0KXtyZXR1cm4gYSgxLXQpfX1mdW5jdGlvbiBRdCh0LG4sZSxyLGksYSl7cmV0dXJuIFJ0KFd0KHQsbixlLHIpLGksS3QodCxuLGUsciksMiplKzIqcixhKX1mdW5jdGlvbiBVdCh0LG4sZSxyLGksYSl7dmFyIG89UXQobixlLHIsaSx0LGEpO3JldHVybiBmdW5jdGlvbih0KXtyZXR1cm4gbygxLXQpfX1mdW5jdGlvbiBSdCh0LG4sZSxyLGkpe3ZvaWQgMD09PWkmJihpPXt9KTt2YXIgYT1pLm1heFNlZ21lbnRMZW5ndGg7dm9pZCAwPT09YSYmKGE9MTApO3ZhciBvPWkuc3RyaW5nO3ZvaWQgMD09PW8mJihvPSEwKTt2YXIgcyxoLHU9SihuLGEpO3JldHVybiBYKHIpJiZ1Lmxlbmd0aDxyL2EmJlcodSxNYXRoLmNlaWwoci9hLXUubGVuZ3RoKSkscz10KHUpLGg9SShzLHUsbyksbz9mdW5jdGlvbih0KXtyZXR1cm4gdDwxZS00P2U6aCh0KX06aH1mdW5jdGlvbiBCdCh0LG4sZSl7cmV0dXJuIGZ1bmN0aW9uKHIpe3ZhciBpPVkociksYT1lbihyLmNvbmNhdChbclswXV0pKSxvPU1hdGguYXRhbjIoclswXVsxXS1pWzFdLHJbMF1bMF0taVswXSkscz0wO3JldHVybiByLm1hcChmdW5jdGlvbihpLGgpe3ZhciB1O3JldHVybiBoJiYocys9RihpLHJbaC0xXSkpLHU9bysyKk1hdGguUEkqKGE/cy9hOmgvci5sZW5ndGgpLFtNYXRoLmNvcyh1KSplK3QsTWF0aC5zaW4odSkqZStuXX0pfX1mdW5jdGlvbiBXdCh0LG4sZSxyKXtyZXR1cm4gZnVuY3Rpb24oaSl7dmFyIGE9WShpKSxvPWVuKGkuY29uY2F0KFtpWzBdXSkpLHM9TWF0aC5hdGFuMihpWzBdWzFdLWFbMV0saVswXVswXS1hWzBdKSxoPTA7czwwJiYocz0yKk1hdGguUEkrcyk7dmFyIHU9cy8oMipNYXRoLlBJKTtyZXR1cm4gaS5tYXAoZnVuY3Rpb24oYSxzKXtzJiYoaCs9RihhLGlbcy0xXSkpO3ZhciBjPSR0KCh1KyhvP2gvbzpzL2kubGVuZ3RoKSklMSk7cmV0dXJuW3QrY1swXSplLG4rY1sxXSpyXX0pfX1mdW5jdGlvbiAkdCh0KXtyZXR1cm4gdDw9MS84P1sxLC41KzQqdF06dDw9My84P1sxLjUtNCp0LDFdOnQ8PTUvOD9bMCwyLjUtNCp0XTp0PD03Lzg/WzQqdC0yLjUsMF06WzEsNCp0LTMuNV19ZnVuY3Rpb24gSnQodCxuLGUpe3ZhciByPXQtZStcIixcIituLGk9dCtlK1wiLFwiK24sYT1cIkFcIitlK1wiLFwiK2UrXCIsMCwxLDEsXCI7cmV0dXJuXCJNXCIrcithK2krYStyK1wiWlwifWZ1bmN0aW9uIEt0KHQsbixlLHIpe3ZhciBpPXQrZSxhPW4rcjtyZXR1cm5cIk1cIit0K1wiLFwiK24rXCJMXCIraStcIixcIituK1wiTFwiK2krXCIsXCIrYStcIkxcIit0K1wiLFwiK2ErXCJaXCJ9dmFyIHRuPWZ1bmN0aW9uKHQpe2Zvcih2YXIgbixlPS0xLHI9dC5sZW5ndGgsaT10W3ItMV0sYT0wOysrZTxyOyluPWksaT10W2VdLGErPW5bMV0qaVswXS1uWzBdKmlbMV07cmV0dXJuIGEvMn0sbm49ZnVuY3Rpb24odCl7Zm9yKHZhciBuLGUscj0tMSxpPXQubGVuZ3RoLGE9MCxvPTAscz10W2ktMV0saD0wOysrcjxpOyluPXMscz10W3JdLGgrPWU9blswXSpzWzFdLXNbMF0qblsxXSxhKz0oblswXStzWzBdKSplLG8rPShuWzFdK3NbMV0pKmU7cmV0dXJuIGgqPTMsW2EvaCxvL2hdfSxlbj1mdW5jdGlvbih0KXtmb3IodmFyIG4sZSxyPS0xLGk9dC5sZW5ndGgsYT10W2ktMV0sbz1hWzBdLHM9YVsxXSxoPTA7KytyPGk7KW49byxlPXMsYT10W3JdLG89YVswXSxzPWFbMV0sbi09byxlLT1zLGgrPU1hdGguc3FydChuKm4rZSplKTtyZXR1cm4gaH0scm49e2E6NyxjOjYsaDoxLGw6MixtOjIscjo0LHE6NCxzOjQsdDoyLHY6MSx6OjB9LGFuPVs1NzYwLDYxNTgsODE5Miw4MTkzLDgxOTQsODE5NSw4MTk2LDgxOTcsODE5OCw4MTk5LDgyMDAsODIwMSw4MjAyLDgyMzksODI4NywxMjI4OCw2NTI3OV0sb249ZnVuY3Rpb24odCl7dmFyIG49bmV3IGEodCksZT1uLm1heDtmb3IobyhuKTtuLmluZGV4PGUmJiFuLmVyci5sZW5ndGg7KXUobik7cmV0dXJuIG4uZXJyLmxlbmd0aD9uLnJlc3VsdD1bXTpuLnJlc3VsdC5sZW5ndGgmJihcIm1NXCIuaW5kZXhPZihuLnJlc3VsdFswXVswXSk8MD8obi5lcnI9XCJTdmdQYXRoOiBzdHJpbmcgc2hvdWxkIHN0YXJ0IHdpdGggYE1gIG9yIGBtYFwiLG4ucmVzdWx0PVtdKTpuLnJlc3VsdFswXVswXT1cIk1cIikse2VycjpuLmVycixzZWdtZW50czpuLnJlc3VsdH19O2YucHJvdG90eXBlLm1hdHJpeD1mdW5jdGlvbih0KXtyZXR1cm4gMT09PXRbMF0mJjA9PT10WzFdJiYwPT09dFsyXSYmMT09PXRbM10mJjA9PT10WzRdJiYwPT09dFs1XT90aGlzOih0aGlzLmNhY2hlPW51bGwsdGhpcy5xdWV1ZS5wdXNoKHQpLHRoaXMpfSxmLnByb3RvdHlwZS50cmFuc2xhdGU9ZnVuY3Rpb24odCxuKXtyZXR1cm4gMD09PXQmJjA9PT1ufHwodGhpcy5jYWNoZT1udWxsLHRoaXMucXVldWUucHVzaChbMSwwLDAsMSx0LG5dKSksdGhpc30sZi5wcm90b3R5cGUuc2NhbGU9ZnVuY3Rpb24odCxuKXtyZXR1cm4gMT09PXQmJjE9PT1ufHwodGhpcy5jYWNoZT1udWxsLHRoaXMucXVldWUucHVzaChbdCwwLDAsbiwwLDBdKSksdGhpc30sZi5wcm90b3R5cGUucm90YXRlPWZ1bmN0aW9uKHQsbixlKXt2YXIgcixpLGE7cmV0dXJuIDAhPT10JiYodGhpcy50cmFuc2xhdGUobixlKSxyPXQqTWF0aC5QSS8xODAsaT1NYXRoLmNvcyhyKSxhPU1hdGguc2luKHIpLHRoaXMucXVldWUucHVzaChbaSxhLC1hLGksMCwwXSksdGhpcy5jYWNoZT1udWxsLHRoaXMudHJhbnNsYXRlKC1uLC1lKSksdGhpc30sZi5wcm90b3R5cGUuc2tld1g9ZnVuY3Rpb24odCl7cmV0dXJuIDAhPT10JiYodGhpcy5jYWNoZT1udWxsLHRoaXMucXVldWUucHVzaChbMSwwLE1hdGgudGFuKHQqTWF0aC5QSS8xODApLDEsMCwwXSkpLHRoaXN9LGYucHJvdG90eXBlLnNrZXdZPWZ1bmN0aW9uKHQpe3JldHVybiAwIT09dCYmKHRoaXMuY2FjaGU9bnVsbCx0aGlzLnF1ZXVlLnB1c2goWzEsTWF0aC50YW4odCpNYXRoLlBJLzE4MCksMCwxLDAsMF0pKSx0aGlzfSxmLnByb3RvdHlwZS50b0FycmF5PWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcztpZih0aGlzLmNhY2hlKXJldHVybiB0aGlzLmNhY2hlO2lmKCF0aGlzLnF1ZXVlLmxlbmd0aClyZXR1cm4gdGhpcy5jYWNoZT1bMSwwLDAsMSwwLDBdLHRoaXMuY2FjaGU7aWYodGhpcy5jYWNoZT10aGlzLnF1ZXVlWzBdLDE9PT10aGlzLnF1ZXVlLmxlbmd0aClyZXR1cm4gdGhpcy5jYWNoZTtmb3IodmFyIG49MTtuPHRoaXMucXVldWUubGVuZ3RoO24rKyl0LmNhY2hlPWModC5jYWNoZSx0LnF1ZXVlW25dKTtyZXR1cm4gdGhpcy5jYWNoZX0sZi5wcm90b3R5cGUuY2FsYz1mdW5jdGlvbih0LG4sZSl7dmFyIHI7cmV0dXJuIHRoaXMucXVldWUubGVuZ3RoPyh0aGlzLmNhY2hlfHwodGhpcy5jYWNoZT10aGlzLnRvQXJyYXkoKSkscj10aGlzLmNhY2hlLFt0KnJbMF0rbipyWzJdKyhlPzA6cls0XSksdCpyWzFdK24qclszXSsoZT8wOnJbNV0pXSk6W3Qsbl19O3ZhciBzbj1mLGhuPXttYXRyaXg6ITAsc2NhbGU6ITAscm90YXRlOiEwLHRyYW5zbGF0ZTohMCxza2V3WDohMCxza2V3WTohMH0sdW49L1xccyoobWF0cml4fHRyYW5zbGF0ZXxzY2FsZXxyb3RhdGV8c2tld1h8c2tld1kpXFxzKlxcKFxccyooLis/KVxccypcXClbXFxzLF0qLyxjbj0vW1xccyxdKy8sZm49ZnVuY3Rpb24odCl7dmFyIG4sZSxyPW5ldyBzbjtyZXR1cm4gdC5zcGxpdCh1bikuZm9yRWFjaChmdW5jdGlvbih0KXtpZih0Lmxlbmd0aCl7aWYodm9pZCAwIT09aG5bdF0pcmV0dXJuIHZvaWQobj10KTtzd2l0Y2goZT10LnNwbGl0KGNuKS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuK3R8fDB9KSxuKXtjYXNlXCJtYXRyaXhcIjpyZXR1cm4gdm9pZCg2PT09ZS5sZW5ndGgmJnIubWF0cml4KGUpKTtjYXNlXCJzY2FsZVwiOnJldHVybiB2b2lkKDE9PT1lLmxlbmd0aD9yLnNjYWxlKGVbMF0sZVswXSk6Mj09PWUubGVuZ3RoJiZyLnNjYWxlKGVbMF0sZVsxXSkpO2Nhc2VcInJvdGF0ZVwiOnJldHVybiB2b2lkKDE9PT1lLmxlbmd0aD9yLnJvdGF0ZShlWzBdLDAsMCk6Mz09PWUubGVuZ3RoJiZyLnJvdGF0ZShlWzBdLGVbMV0sZVsyXSkpO2Nhc2VcInRyYW5zbGF0ZVwiOnJldHVybiB2b2lkKDE9PT1lLmxlbmd0aD9yLnRyYW5zbGF0ZShlWzBdLDApOjI9PT1lLmxlbmd0aCYmci50cmFuc2xhdGUoZVswXSxlWzFdKSk7Y2FzZVwic2tld1hcIjpyZXR1cm4gdm9pZCgxPT09ZS5sZW5ndGgmJnIuc2tld1goZVswXSkpO2Nhc2VcInNrZXdZXCI6cmV0dXJuIHZvaWQoMT09PWUubGVuZ3RoJiZyLnNrZXdZKGVbMF0pKX19fSkscn0sbG49MipNYXRoLlBJLHBuPWZ1bmN0aW9uKHQsbixlLHIsaSxhLG8scyxoKXt2YXIgdT1NYXRoLnNpbihoKmxuLzM2MCksYz1NYXRoLmNvcyhoKmxuLzM2MCksZj1jKih0LWUpLzIrdSoobi1yKS8yLGw9LXUqKHQtZSkvMitjKihuLXIpLzI7aWYoMD09PWYmJjA9PT1sKXJldHVybltdO2lmKDA9PT1vfHwwPT09cylyZXR1cm5bXTtvPU1hdGguYWJzKG8pLHM9TWF0aC5hYnMocyk7dmFyIHY9ZipmLyhvKm8pK2wqbC8ocypzKTt2PjEmJihvKj1NYXRoLnNxcnQodikscyo9TWF0aC5zcXJ0KHYpKTt2YXIgeD1wKHQsbixlLHIsaSxhLG8scyx1LGMpLHk9W10sZD14WzJdLG09eFszXSxNPU1hdGgubWF4KE1hdGguY2VpbChNYXRoLmFicyhtKS8obG4vNCkpLDEpO20vPU07Zm9yKHZhciB3PTA7dzxNO3crKyl5LnB1c2goZyhkLG0pKSxkKz1tO3JldHVybiB5Lm1hcChmdW5jdGlvbih0KXtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rPTIpe3ZhciBlPXRbbiswXSxyPXRbbisxXTtlKj1vLHIqPXM7dmFyIGk9YyplLXUqcixhPXUqZStjKnI7dFtuKzBdPWkreFswXSx0W24rMV09YSt4WzFdfXJldHVybiB0fSl9LGduPU1hdGguUEkvMTgwO3YucHJvdG90eXBlLnRyYW5zZm9ybT1mdW5jdGlvbih0KXt2YXIgbj1NYXRoLmNvcyh0aGlzLmF4KmduKSxlPU1hdGguc2luKHRoaXMuYXgqZ24pLHI9W3RoaXMucngqKHRbMF0qbit0WzJdKmUpLHRoaXMucngqKHRbMV0qbit0WzNdKmUpLHRoaXMucnkqKC10WzBdKmUrdFsyXSpuKSx0aGlzLnJ5KigtdFsxXSplK3RbM10qbildLGk9clswXSpyWzBdK3JbMl0qclsyXSxhPXJbMV0qclsxXStyWzNdKnJbM10sbz0oKHJbMF0tclszXSkqKHJbMF0tclszXSkrKHJbMl0rclsxXSkqKHJbMl0rclsxXSkpKigoclswXStyWzNdKSooclswXStyWzNdKSsoclsyXS1yWzFdKSooclsyXS1yWzFdKSkscz0oaSthKS8yO2lmKG88MWUtMTAqcylyZXR1cm4gdGhpcy5yeD10aGlzLnJ5PU1hdGguc3FydChzKSx0aGlzLmF4PTAsdGhpczt2YXIgaD1yWzBdKnJbMV0rclsyXSpyWzNdO289TWF0aC5zcXJ0KG8pO3ZhciB1PXMrby8yLGM9cy1vLzI7cmV0dXJuIHRoaXMuYXg9TWF0aC5hYnMoaCk8MWUtMTAmJk1hdGguYWJzKHUtYSk8MWUtMTA/OTA6MTgwKk1hdGguYXRhbihNYXRoLmFicyhoKT5NYXRoLmFicyh1LWEpPyh1LWkpL2g6aC8odS1hKSkvTWF0aC5QSSx0aGlzLmF4Pj0wPyh0aGlzLnJ4PU1hdGguc3FydCh1KSx0aGlzLnJ5PU1hdGguc3FydChjKSk6KHRoaXMuYXgrPTkwLHRoaXMucng9TWF0aC5zcXJ0KGMpLHRoaXMucnk9TWF0aC5zcXJ0KHUpKSx0aGlzfSx2LnByb3RvdHlwZS5pc0RlZ2VuZXJhdGU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5yeDwxZS0xMCp0aGlzLnJ5fHx0aGlzLnJ5PDFlLTEwKnRoaXMucnh9O3ZhciB2bj12O3gucHJvdG90eXBlLl9fbWF0cml4PWZ1bmN0aW9uKHQpe3ZhciBuLGU9dGhpczt0LnF1ZXVlLmxlbmd0aCYmdGhpcy5pdGVyYXRlKGZ1bmN0aW9uKHIsaSxhLG8pe3ZhciBzLGgsdSxjO3N3aXRjaChyWzBdKXtjYXNlXCJ2XCI6cz10LmNhbGMoMCxyWzFdLCEwKSxoPTA9PT1zWzBdP1tcInZcIixzWzFdXTpbXCJsXCIsc1swXSxzWzFdXTticmVhaztjYXNlXCJWXCI6cz10LmNhbGMoYSxyWzFdLCExKSxoPXNbMF09PT10LmNhbGMoYSxvLCExKVswXT9bXCJWXCIsc1sxXV06W1wiTFwiLHNbMF0sc1sxXV07YnJlYWs7Y2FzZVwiaFwiOnM9dC5jYWxjKHJbMV0sMCwhMCksaD0wPT09c1sxXT9bXCJoXCIsc1swXV06W1wibFwiLHNbMF0sc1sxXV07YnJlYWs7Y2FzZVwiSFwiOnM9dC5jYWxjKHJbMV0sbywhMSksaD1zWzFdPT09dC5jYWxjKGEsbywhMSlbMV0/W1wiSFwiLHNbMF1dOltcIkxcIixzWzBdLHNbMV1dO2JyZWFrO2Nhc2VcImFcIjpjYXNlXCJBXCI6dmFyIGY9dC50b0FycmF5KCksbD12bihyWzFdLHJbMl0sclszXSkudHJhbnNmb3JtKGYpO2lmKGZbMF0qZlszXS1mWzFdKmZbMl08MCYmKHJbNV09cls1XT9cIjBcIjpcIjFcIikscz10LmNhbGMocls2XSxyWzddLFwiYVwiPT09clswXSksXCJBXCI9PT1yWzBdJiZyWzZdPT09YSYmcls3XT09PW98fFwiYVwiPT09clswXSYmMD09PXJbNl0mJjA9PT1yWzddKXtoPVtcImFcIj09PXJbMF0/XCJsXCI6XCJMXCIsc1swXSxzWzFdXTticmVha31oPWwuaXNEZWdlbmVyYXRlKCk/W1wiYVwiPT09clswXT9cImxcIjpcIkxcIixzWzBdLHNbMV1dOltyWzBdLGwucngsbC5yeSxsLmF4LHJbNF0scls1XSxzWzBdLHNbMV1dO2JyZWFrO2Nhc2VcIm1cIjpjPWk+MCxzPXQuY2FsYyhyWzFdLHJbMl0sYyksaD1bXCJtXCIsc1swXSxzWzFdXTticmVhaztkZWZhdWx0OmZvcih1PXJbMF0saD1bdV0sYz11LnRvTG93ZXJDYXNlKCk9PT11LG49MTtuPHIubGVuZ3RoO24rPTIpcz10LmNhbGMocltuXSxyW24rMV0sYyksaC5wdXNoKHNbMF0sc1sxXSl9ZS5zZWdtZW50c1tpXT1ofSwhMCl9LHgucHJvdG90eXBlLl9fZXZhbHVhdGVTdGFjaz1mdW5jdGlvbigpe3ZhciB0LG4sZT10aGlzO2lmKHRoaXMuX19zdGFjay5sZW5ndGgpe2lmKDE9PT10aGlzLl9fc3RhY2subGVuZ3RoKXJldHVybiB0aGlzLl9fbWF0cml4KHRoaXMuX19zdGFja1swXSksdm9pZCh0aGlzLl9fc3RhY2s9W10pO2Zvcih0PXNuKCksbj10aGlzLl9fc3RhY2subGVuZ3RoOy0tbj49MDspdC5tYXRyaXgoZS5fX3N0YWNrW25dLnRvQXJyYXkoKSk7dGhpcy5fX21hdHJpeCh0KSx0aGlzLl9fc3RhY2s9W119fSx4LnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3ZhciB0LG4sZT10aGlzLHI9W107dGhpcy5fX2V2YWx1YXRlU3RhY2soKTtmb3IodmFyIGk9MDtpPHRoaXMuc2VnbWVudHMubGVuZ3RoO2krKyluPWUuc2VnbWVudHNbaV1bMF0sdD1pPjAmJlwibVwiIT09biYmXCJNXCIhPT1uJiZuPT09ZS5zZWdtZW50c1tpLTFdWzBdLHI9ci5jb25jYXQodD9lLnNlZ21lbnRzW2ldLnNsaWNlKDEpOmUuc2VnbWVudHNbaV0pO3JldHVybiByLmpvaW4oXCIgXCIpLnJlcGxhY2UoLyA/KFthY2hsbXFyc3R2el0pID8vZ2ksXCIkMVwiKS5yZXBsYWNlKC8gXFwtL2csXCItXCIpLnJlcGxhY2UoL3ptL2csXCJ6IG1cIil9LHgucHJvdG90eXBlLnRyYW5zbGF0ZT1mdW5jdGlvbih0LG4pe3JldHVybiB0aGlzLl9fc3RhY2sucHVzaChzbigpLnRyYW5zbGF0ZSh0LG58fDApKSx0aGlzfSx4LnByb3RvdHlwZS5zY2FsZT1mdW5jdGlvbih0LG4pe3JldHVybiB0aGlzLl9fc3RhY2sucHVzaChzbigpLnNjYWxlKHQsbnx8MD09PW4/bjp0KSksdGhpc30seC5wcm90b3R5cGUucm90YXRlPWZ1bmN0aW9uKHQsbixlKXtyZXR1cm4gdGhpcy5fX3N0YWNrLnB1c2goc24oKS5yb3RhdGUodCxufHwwLGV8fDApKSx0aGlzfSx4LnByb3RvdHlwZS5za2V3WD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5fX3N0YWNrLnB1c2goc24oKS5za2V3WCh0KSksdGhpc30seC5wcm90b3R5cGUuc2tld1k9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX19zdGFjay5wdXNoKHNuKCkuc2tld1kodCkpLHRoaXN9LHgucHJvdG90eXBlLm1hdHJpeD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5fX3N0YWNrLnB1c2goc24oKS5tYXRyaXgodCkpLHRoaXN9LHgucHJvdG90eXBlLnRyYW5zZm9ybT1mdW5jdGlvbih0KXtyZXR1cm4gdC50cmltKCk/KHRoaXMuX19zdGFjay5wdXNoKGZuKHQpKSx0aGlzKTp0aGlzfSx4LnByb3RvdHlwZS5yb3VuZD1mdW5jdGlvbih0KXt2YXIgbixlPTAscj0wLGk9MCxhPTA7cmV0dXJuIHQ9dHx8MCx0aGlzLl9fZXZhbHVhdGVTdGFjaygpLHRoaXMuc2VnbWVudHMuZm9yRWFjaChmdW5jdGlvbihvKXt2YXIgcz1vWzBdLnRvTG93ZXJDYXNlKCk9PT1vWzBdO3N3aXRjaChvWzBdKXtjYXNlXCJIXCI6Y2FzZVwiaFwiOnJldHVybiBzJiYob1sxXSs9aSksaT1vWzFdLW9bMV0udG9GaXhlZCh0KSx2b2lkKG9bMV09K29bMV0udG9GaXhlZCh0KSk7Y2FzZVwiVlwiOmNhc2VcInZcIjpyZXR1cm4gcyYmKG9bMV0rPWEpLGE9b1sxXS1vWzFdLnRvRml4ZWQodCksdm9pZChvWzFdPStvWzFdLnRvRml4ZWQodCkpO2Nhc2VcIlpcIjpjYXNlXCJ6XCI6cmV0dXJuIGk9ZSx2b2lkKGE9cik7Y2FzZVwiTVwiOmNhc2VcIm1cIjpyZXR1cm4gcyYmKG9bMV0rPWksb1syXSs9YSksaT1vWzFdLW9bMV0udG9GaXhlZCh0KSxhPW9bMl0tb1syXS50b0ZpeGVkKHQpLGU9aSxyPWEsb1sxXT0rb1sxXS50b0ZpeGVkKHQpLHZvaWQob1syXT0rb1syXS50b0ZpeGVkKHQpKTtjYXNlXCJBXCI6Y2FzZVwiYVwiOnJldHVybiBzJiYob1s2XSs9aSxvWzddKz1hKSxpPW9bNl0tb1s2XS50b0ZpeGVkKHQpLGE9b1s3XS1vWzddLnRvRml4ZWQodCksb1sxXT0rb1sxXS50b0ZpeGVkKHQpLG9bMl09K29bMl0udG9GaXhlZCh0KSxvWzNdPStvWzNdLnRvRml4ZWQodCsyKSxvWzZdPStvWzZdLnRvRml4ZWQodCksdm9pZChvWzddPStvWzddLnRvRml4ZWQodCkpO2RlZmF1bHQ6cmV0dXJuIG49by5sZW5ndGgscyYmKG9bbi0yXSs9aSxvW24tMV0rPWEpLGk9b1tuLTJdLW9bbi0yXS50b0ZpeGVkKHQpLGE9b1tuLTFdLW9bbi0xXS50b0ZpeGVkKHQpLHZvaWQgby5mb3JFYWNoKGZ1bmN0aW9uKG4sZSl7ZSYmKG9bZV09K29bZV0udG9GaXhlZCh0KSl9KX19KSx0aGlzfSx4LnByb3RvdHlwZS5pdGVyYXRlPWZ1bmN0aW9uKHQsbil7dmFyIGUscixpLGE9dGhpcy5zZWdtZW50cyxvPXt9LHM9ITEsaD0wLHU9MCxjPTAsZj0wO2lmKG58fHRoaXMuX19ldmFsdWF0ZVN0YWNrKCksYS5mb3JFYWNoKGZ1bmN0aW9uKG4sZSl7dmFyIHI9dChuLGUsaCx1KTtBcnJheS5pc0FycmF5KHIpJiYob1tlXT1yLHM9ITApO3ZhciBpPW5bMF09PT1uWzBdLnRvTG93ZXJDYXNlKCk7c3dpdGNoKG5bMF0pe2Nhc2VcIm1cIjpjYXNlXCJNXCI6cmV0dXJuIGg9blsxXSsoaT9oOjApLHU9blsyXSsoaT91OjApLGM9aCx2b2lkKGY9dSk7Y2FzZVwiaFwiOmNhc2VcIkhcIjpyZXR1cm4gdm9pZChoPW5bMV0rKGk/aDowKSk7Y2FzZVwidlwiOmNhc2VcIlZcIjpyZXR1cm4gdm9pZCh1PW5bMV0rKGk/dTowKSk7Y2FzZVwielwiOmNhc2VcIlpcIjpyZXR1cm4gaD1jLHZvaWQodT1mKTtkZWZhdWx0Omg9bltuLmxlbmd0aC0yXSsoaT9oOjApLHU9bltuLmxlbmd0aC0xXSsoaT91OjApfX0pLCFzKXJldHVybiB0aGlzO2ZvcihpPVtdLGU9MDtlPGEubGVuZ3RoO2UrKylpZih2b2lkIDAhPT1vW2VdKWZvcihyPTA7cjxvW2VdLmxlbmd0aDtyKyspaS5wdXNoKG9bZV1bcl0pO2Vsc2UgaS5wdXNoKGFbZV0pO3JldHVybiB0aGlzLnNlZ21lbnRzPWksdGhpc30seC5wcm90b3R5cGUuYWJzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXRlcmF0ZShmdW5jdGlvbih0LG4sZSxyKXt2YXIgaSxhPXRbMF0sbz1hLnRvVXBwZXJDYXNlKCk7aWYoYSE9PW8pc3dpdGNoKHRbMF09byxhKXtjYXNlXCJ2XCI6cmV0dXJuIHZvaWQodFsxXSs9cik7Y2FzZVwiYVwiOnJldHVybiB0WzZdKz1lLHZvaWQodFs3XSs9cik7ZGVmYXVsdDpmb3IoaT0xO2k8dC5sZW5ndGg7aSsrKXRbaV0rPWklMj9lOnJ9fSwhMCksdGhpc30seC5wcm90b3R5cGUucmVsPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXRlcmF0ZShmdW5jdGlvbih0LG4sZSxyKXt2YXIgaSxhPXRbMF0sbz1hLnRvTG93ZXJDYXNlKCk7aWYoYSE9PW8mJigwIT09bnx8XCJNXCIhPT1hKSlzd2l0Y2godFswXT1vLGEpe2Nhc2VcIlZcIjpyZXR1cm4gdm9pZCh0WzFdLT1yKTtjYXNlXCJBXCI6cmV0dXJuIHRbNl0tPWUsdm9pZCh0WzddLT1yKTtkZWZhdWx0OmZvcihpPTE7aTx0Lmxlbmd0aDtpKyspdFtpXS09aSUyP2U6cn19LCEwKSx0aGlzfSx4LnByb3RvdHlwZS51bmFyYz1mdW5jdGlvbigpe3JldHVybiB0aGlzLml0ZXJhdGUoZnVuY3Rpb24odCxuLGUscil7dmFyIGksYSxvLHM9W10saD10WzBdO3JldHVyblwiQVwiIT09aCYmXCJhXCIhPT1oP251bGw6KFwiYVwiPT09aD8oYT1lK3RbNl0sbz1yK3RbN10pOihhPXRbNl0sbz10WzddKSxpPXBuKGUscixhLG8sdFs0XSx0WzVdLHRbMV0sdFsyXSx0WzNdKSwwPT09aS5sZW5ndGg/W1tcImFcIj09PXRbMF0/XCJsXCI6XCJMXCIsdFs2XSx0WzddXV06KGkuZm9yRWFjaChmdW5jdGlvbih0KXtzLnB1c2goW1wiQ1wiLHRbMl0sdFszXSx0WzRdLHRbNV0sdFs2XSx0WzddXSl9KSxzKSl9KSx0aGlzfSx4LnByb3RvdHlwZS51bnNob3J0PWZ1bmN0aW9uKCl7dmFyIHQsbixlLHIsaSxhPXRoaXMuc2VnbWVudHM7cmV0dXJuIHRoaXMuaXRlcmF0ZShmdW5jdGlvbihvLHMsaCx1KXt2YXIgYyxmPW9bMF0sbD1mLnRvVXBwZXJDYXNlKCk7cyYmKFwiVFwiPT09bD8oYz1cInRcIj09PWYsZT1hW3MtMV0sXCJRXCI9PT1lWzBdPyh0PWVbMV0taCxuPWVbMl0tdSk6XCJxXCI9PT1lWzBdPyh0PWVbMV0tZVszXSxuPWVbMl0tZVs0XSk6KHQ9MCxuPTApLHI9LXQsaT0tbixjfHwocis9aCxpKz11KSxhW3NdPVtjP1wicVwiOlwiUVwiLHIsaSxvWzFdLG9bMl1dKTpcIlNcIj09PWwmJihjPVwic1wiPT09ZixlPWFbcy0xXSxcIkNcIj09PWVbMF0/KHQ9ZVszXS1oLG49ZVs0XS11KTpcImNcIj09PWVbMF0/KHQ9ZVszXS1lWzVdLG49ZVs0XS1lWzZdKToodD0wLG49MCkscj0tdCxpPS1uLGN8fChyKz1oLGkrPXUpLGFbc109W2M/XCJjXCI6XCJDXCIscixpLG9bMV0sb1syXSxvWzNdLG9bNF1dKSl9KSx0aGlzfTt2YXIgeG49eCx5bj14bixkbj17YTo3LGM6NixoOjEsbDoyLG06MixxOjQsczo0LHQ6Mix2OjEsejowfSxtbj0vKFthc3R2enFtaGxjXSkoW15hc3R2enFtaGxjXSopL2dpLE1uPWZ1bmN0aW9uKHQpe3ZhciBuPVtdO3JldHVybiB0LnJlcGxhY2UobW4sZnVuY3Rpb24odCxlLHIpe3ZhciBpPWUudG9Mb3dlckNhc2UoKTtmb3Iocj15KHIpLFwibVwiPT09aSYmci5sZW5ndGg+MiYmKG4ucHVzaChbZV0uY29uY2F0KHIuc3BsaWNlKDAsMikpKSxpPVwibFwiLGU9XCJtXCI9PT1lP1wibFwiOlwiTFwiKTtyLmxlbmd0aD49MDspe2lmKHIubGVuZ3RoPT09ZG5baV0pcmV0dXJuIHIudW5zaGlmdChlKSxuLnB1c2gocik7aWYoci5sZW5ndGg8ZG5baV0pdGhyb3cgbmV3IEVycm9yKFwibWFsZm9ybWVkIHBhdGggZGF0YVwiKTtuLnB1c2goW2VdLmNvbmNhdChyLnNwbGljZSgwLGRuW2ldKSkpfX0pLG59LHduPS8tP1swLTldKlxcLj9bMC05XSsoPzplWy0rXT9cXGQrKT8vZ2ksYm49ZnVuY3Rpb24odCxuLGUscixpLGEsbyxzKXtyZXR1cm4gbmV3IGQodCxuLGUscixpLGEsbyxzKX07ZC5wcm90b3R5cGU9e2NvbnN0cnVjdG9yOmQsaW5pdDpmdW5jdGlvbigpe3RoaXMubGVuZ3RoPXRoaXMuZ2V0QXJjTGVuZ3RoKFt0aGlzLmEueCx0aGlzLmIueCx0aGlzLmMueCx0aGlzLmQueF0sW3RoaXMuYS55LHRoaXMuYi55LHRoaXMuYy55LHRoaXMuZC55XSl9LGdldFRvdGFsTGVuZ3RoOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGVuZ3RofSxnZXRQb2ludEF0TGVuZ3RoOmZ1bmN0aW9uKHQpe3ZhciBuPXcodCx0aGlzLmxlbmd0aCx0aGlzLmdldEFyY0xlbmd0aCxbdGhpcy5hLngsdGhpcy5iLngsdGhpcy5jLngsdGhpcy5kLnhdLFt0aGlzLmEueSx0aGlzLmIueSx0aGlzLmMueSx0aGlzLmQueV0pO3JldHVybiB0aGlzLmdldFBvaW50KFt0aGlzLmEueCx0aGlzLmIueCx0aGlzLmMueCx0aGlzLmQueF0sW3RoaXMuYS55LHRoaXMuYi55LHRoaXMuYy55LHRoaXMuZC55XSxuKX0sZ2V0VGFuZ2VudEF0TGVuZ3RoOmZ1bmN0aW9uKHQpe3ZhciBuPXcodCx0aGlzLmxlbmd0aCx0aGlzLmdldEFyY0xlbmd0aCxbdGhpcy5hLngsdGhpcy5iLngsdGhpcy5jLngsdGhpcy5kLnhdLFt0aGlzLmEueSx0aGlzLmIueSx0aGlzLmMueSx0aGlzLmQueV0pLGU9dGhpcy5nZXREZXJpdmF0aXZlKFt0aGlzLmEueCx0aGlzLmIueCx0aGlzLmMueCx0aGlzLmQueF0sW3RoaXMuYS55LHRoaXMuYi55LHRoaXMuYy55LHRoaXMuZC55XSxuKSxyPU1hdGguc3FydChlLngqZS54K2UueSplLnkpO3JldHVybiByPjA/e3g6ZS54L3IseTplLnkvcn06e3g6MCx5OjB9fSxnZXRQcm9wZXJ0aWVzQXRMZW5ndGg6ZnVuY3Rpb24odCl7dmFyIG4sZT13KHQsdGhpcy5sZW5ndGgsdGhpcy5nZXRBcmNMZW5ndGgsW3RoaXMuYS54LHRoaXMuYi54LHRoaXMuYy54LHRoaXMuZC54XSxbdGhpcy5hLnksdGhpcy5iLnksdGhpcy5jLnksdGhpcy5kLnldKSxyPXRoaXMuZ2V0RGVyaXZhdGl2ZShbdGhpcy5hLngsdGhpcy5iLngsdGhpcy5jLngsdGhpcy5kLnhdLFt0aGlzLmEueSx0aGlzLmIueSx0aGlzLmMueSx0aGlzLmQueV0sZSksaT1NYXRoLnNxcnQoci54KnIueCtyLnkqci55KTtuPWk+MD97eDpyLngvaSx5OnIueS9pfTp7XG54OjAseTowfTt2YXIgYT10aGlzLmdldFBvaW50KFt0aGlzLmEueCx0aGlzLmIueCx0aGlzLmMueCx0aGlzLmQueF0sW3RoaXMuYS55LHRoaXMuYi55LHRoaXMuYy55LHRoaXMuZC55XSxlKTtyZXR1cm57eDphLngseTphLnksdGFuZ2VudFg6bi54LHRhbmdlbnRZOm4ueX19fTt2YXIgTG49W1tdLFtdLFstLjU3NzM1MDI2OTE4OTYyNTcsLjU3NzM1MDI2OTE4OTYyNTddLFswLC0uNzc0NTk2NjY5MjQxNDgzNCwuNzc0NTk2NjY5MjQxNDgzNF0sWy0uMzM5OTgxMDQzNTg0ODU2MjYsLjMzOTk4MTA0MzU4NDg1NjI2LC0uODYxMTM2MzExNTk0MDUyNiwuODYxMTM2MzExNTk0MDUyNl0sWzAsLS41Mzg0NjkzMTAxMDU2ODMxLC41Mzg0NjkzMTAxMDU2ODMxLC0uOTA2MTc5ODQ1OTM4NjY0LC45MDYxNzk4NDU5Mzg2NjRdLFsuNjYxMjA5Mzg2NDY2MjY0NSwtLjY2MTIwOTM4NjQ2NjI2NDUsLS4yMzg2MTkxODYwODMxOTY5LC4yMzg2MTkxODYwODMxOTY5LC0uOTMyNDY5NTE0MjAzMTUyLC45MzI0Njk1MTQyMDMxNTJdLFswLC40MDU4NDUxNTEzNzczOTcyLC0uNDA1ODQ1MTUxMzc3Mzk3MiwtLjc0MTUzMTE4NTU5OTM5NDUsLjc0MTUzMTE4NTU5OTM5NDUsLS45NDkxMDc5MTIzNDI3NTg1LC45NDkxMDc5MTIzNDI3NTg1XSxbLS4xODM0MzQ2NDI0OTU2NDk4LC4xODM0MzQ2NDI0OTU2NDk4LC0uNTI1NTMyNDA5OTE2MzI5LC41MjU1MzI0MDk5MTYzMjksLS43OTY2NjY0Nzc0MTM2MjY3LC43OTY2NjY0Nzc0MTM2MjY3LC0uOTYwMjg5ODU2NDk3NTM2MywuOTYwMjg5ODU2NDk3NTM2M10sWzAsLS44MzYwMzExMDczMjY2MzU4LC44MzYwMzExMDczMjY2MzU4LC0uOTY4MTYwMjM5NTA3NjI2MSwuOTY4MTYwMjM5NTA3NjI2MSwtLjMyNDI1MzQyMzQwMzgwODksLjMyNDI1MzQyMzQwMzgwODksLS42MTMzNzE0MzI3MDA1OTA0LC42MTMzNzE0MzI3MDA1OTA0XSxbLS4xNDg4NzQzMzg5ODE2MzEyMiwuMTQ4ODc0MzM4OTgxNjMxMjIsLS40MzMzOTUzOTQxMjkyNDcyLC40MzMzOTUzOTQxMjkyNDcyLC0uNjc5NDA5NTY4Mjk5MDI0NCwuNjc5NDA5NTY4Mjk5MDI0NCwtLjg2NTA2MzM2NjY4ODk4NDUsLjg2NTA2MzM2NjY4ODk4NDUsLS45NzM5MDY1Mjg1MTcxNzE3LC45NzM5MDY1Mjg1MTcxNzE3XSxbMCwtLjI2OTU0MzE1NTk1MjM0NDk2LC4yNjk1NDMxNTU5NTIzNDQ5NiwtLjUxOTA5NjEyOTIwNjgxMTgsLjUxOTA5NjEyOTIwNjgxMTgsLS43MzAxNTIwMDU1NzQwNDk0LC43MzAxNTIwMDU1NzQwNDk0LC0uODg3MDYyNTk5NzY4MDk1MywuODg3MDYyNTk5NzY4MDk1MywtLjk3ODIyODY1ODE0NjA1NywuOTc4MjI4NjU4MTQ2MDU3XSxbLS4xMjUyMzM0MDg1MTE0Njg5LC4xMjUyMzM0MDg1MTE0Njg5LC0uMzY3ODMxNDk4OTk4MTgwMiwuMzY3ODMxNDk4OTk4MTgwMiwtLjU4NzMxNzk1NDI4NjYxNzUsLjU4NzMxNzk1NDI4NjYxNzUsLS43Njk5MDI2NzQxOTQzMDQ3LC43Njk5MDI2NzQxOTQzMDQ3LC0uOTA0MTE3MjU2MzcwNDc0OSwuOTA0MTE3MjU2MzcwNDc0OSwtLjk4MTU2MDYzNDI0NjcxOTIsLjk4MTU2MDYzNDI0NjcxOTJdLFswLC0uMjMwNDU4MzE1OTU1MTM0OCwuMjMwNDU4MzE1OTU1MTM0OCwtLjQ0ODQ5Mjc1MTAzNjQ0Njg3LC40NDg0OTI3NTEwMzY0NDY4NywtLjY0MjM0OTMzOTQ0MDM0MDIsLjY0MjM0OTMzOTQ0MDM0MDIsLS44MDE1NzgwOTA3MzMzMDk5LC44MDE1NzgwOTA3MzMzMDk5LC0uOTE3NTk4Mzk5MjIyOTc3OSwuOTE3NTk4Mzk5MjIyOTc3OSwtLjk4NDE4MzA1NDcxODU4ODEsLjk4NDE4MzA1NDcxODU4ODFdLFstLjEwODA1NDk0ODcwNzM0MzY3LC4xMDgwNTQ5NDg3MDczNDM2NywtLjMxOTExMjM2ODkyNzg4OTc0LC4zMTkxMTIzNjg5Mjc4ODk3NCwtLjUxNTI0ODYzNjM1ODE1NDEsLjUxNTI0ODYzNjM1ODE1NDEsLS42ODcyOTI5MDQ4MTE2ODU1LC42ODcyOTI5MDQ4MTE2ODU1LC0uODI3MjAxMzE1MDY5NzY1LC44MjcyMDEzMTUwNjk3NjUsLS45Mjg0MzQ4ODM2NjM1NzM1LC45Mjg0MzQ4ODM2NjM1NzM1LC0uOTg2MjgzODA4Njk2ODEyMywuOTg2MjgzODA4Njk2ODEyM10sWzAsLS4yMDExOTQwOTM5OTc0MzQ1MSwuMjAxMTk0MDkzOTk3NDM0NTEsLS4zOTQxNTEzNDcwNzc1NjM0LC4zOTQxNTEzNDcwNzc1NjM0LC0uNTcwOTcyMTcyNjA4NTM4OCwuNTcwOTcyMTcyNjA4NTM4OCwtLjcyNDQxNzczMTM2MDE3MDEsLjcyNDQxNzczMTM2MDE3MDEsLS44NDgyMDY1ODM0MTA0MjcyLC44NDgyMDY1ODM0MTA0MjcyLC0uOTM3MjczMzkyNDAwNzA2LC45MzcyNzMzOTI0MDA3MDYsLS45ODc5OTI1MTgwMjA0ODU0LC45ODc5OTI1MTgwMjA0ODU0XSxbLS4wOTUwMTI1MDk4Mzc2Mzc0NCwuMDk1MDEyNTA5ODM3NjM3NDQsLS4yODE2MDM1NTA3NzkyNTg5LC4yODE2MDM1NTA3NzkyNTg5LC0uNDU4MDE2Nzc3NjU3MjI3MzcsLjQ1ODAxNjc3NzY1NzIyNzM3LC0uNjE3ODc2MjQ0NDAyNjQzOCwuNjE3ODc2MjQ0NDAyNjQzOCwtLjc1NTQwNDQwODM1NTAwMywuNzU1NDA0NDA4MzU1MDAzLC0uODY1NjMxMjAyMzg3ODMxOCwuODY1NjMxMjAyMzg3ODMxOCwtLjk0NDU3NTAyMzA3MzIzMjYsLjk0NDU3NTAyMzA3MzIzMjYsLS45ODk0MDA5MzQ5OTE2NDk5LC45ODk0MDA5MzQ5OTE2NDk5XSxbMCwtLjE3ODQ4NDE4MTQ5NTg0Nzg1LC4xNzg0ODQxODE0OTU4NDc4NSwtLjM1MTIzMTc2MzQ1Mzg3NjMsLjM1MTIzMTc2MzQ1Mzg3NjMsLS41MTI2OTA1MzcwODY0NzY5LC41MTI2OTA1MzcwODY0NzY5LC0uNjU3NjcxMTU5MjE2NjkwNywuNjU3NjcxMTU5MjE2NjkwNywtLjc4MTUxNDAwMzg5NjgwMTQsLjc4MTUxNDAwMzg5NjgwMTQsLS44ODAyMzkxNTM3MjY5ODU5LC44ODAyMzkxNTM3MjY5ODU5LC0uOTUwNjc1NTIxNzY4NzY3OCwuOTUwNjc1NTIxNzY4NzY3OCwtLjk5MDU3NTQ3NTMxNDQxNzQsLjk5MDU3NTQ3NTMxNDQxNzRdLFstLjA4NDc3NTAxMzA0MTczNTMsLjA4NDc3NTAxMzA0MTczNTMsLS4yNTE4ODYyMjU2OTE1MDU1LC4yNTE4ODYyMjU2OTE1MDU1LC0uNDExNzUxMTYxNDYyODQyNjMsLjQxMTc1MTE2MTQ2Mjg0MjYzLC0uNTU5NzcwODMxMDczOTQ3NSwuNTU5NzcwODMxMDczOTQ3NSwtLjY5MTY4NzA0MzA2MDM1MzIsLjY5MTY4NzA0MzA2MDM1MzIsLS44MDM3MDQ5NTg5NzI1MjMxLC44MDM3MDQ5NTg5NzI1MjMxLC0uODkyNjAyNDY2NDk3NTU1NywuODkyNjAyNDY2NDk3NTU1NywtLjk1NTgyMzk0OTU3MTM5NzcsLjk1NTgyMzk0OTU3MTM5NzcsLS45OTE1NjUxNjg0MjA5MzA5LC45OTE1NjUxNjg0MjA5MzA5XSxbMCwtLjE2MDM1ODY0NTY0MDIyNTM3LC4xNjAzNTg2NDU2NDAyMjUzNywtLjMxNjU2NDA5OTk2MzYyOTgzLC4zMTY1NjQwOTk5NjM2Mjk4MywtLjQ2NDU3MDc0MTM3NTk2MDk0LC40NjQ1NzA3NDEzNzU5NjA5NCwtLjYwMDU0NTMwNDY2MTY4MSwuNjAwNTQ1MzA0NjYxNjgxLC0uNzIwOTY2MTc3MzM1MjI5NCwuNzIwOTY2MTc3MzM1MjI5NCwtLjgyMjcxNDY1NjUzNzE0MjgsLjgyMjcxNDY1NjUzNzE0MjgsLS45MDMxNTU5MDM2MTQ4MTc5LC45MDMxNTU5MDM2MTQ4MTc5LC0uOTYwMjA4MTUyMTM0ODMsLjk2MDIwODE1MjEzNDgzLC0uOTkyNDA2ODQzODQzNTg0NCwuOTkyNDA2ODQzODQzNTg0NF0sWy0uMDc2NTI2NTIxMTMzNDk3MzQsLjA3NjUyNjUyMTEzMzQ5NzM0LC0uMjI3Nzg1ODUxMTQxNjQ1MDcsLjIyNzc4NTg1MTE0MTY0NTA3LC0uMzczNzA2MDg4NzE1NDE5NTUsLjM3MzcwNjA4ODcxNTQxOTU1LC0uNTEwODY3MDAxOTUwODI3MSwuNTEwODY3MDAxOTUwODI3MSwtLjYzNjA1MzY4MDcyNjUxNSwuNjM2MDUzNjgwNzI2NTE1LC0uNzQ2MzMxOTA2NDYwMTUwOCwuNzQ2MzMxOTA2NDYwMTUwOCwtLjgzOTExNjk3MTgyMjIxODgsLjgzOTExNjk3MTgyMjIxODgsLS45MTIyMzQ0MjgyNTEzMjYsLjkxMjIzNDQyODI1MTMyNiwtLjk2Mzk3MTkyNzI3NzkxMzgsLjk2Mzk3MTkyNzI3NzkxMzgsLS45OTMxMjg1OTkxODUwOTQ5LC45OTMxMjg1OTkxODUwOTQ5XSxbMCwtLjE0NTU2MTg1NDE2MDg5NTEsLjE0NTU2MTg1NDE2MDg5NTEsLS4yODgwMjEzMTY4MDI0MDExLC4yODgwMjEzMTY4MDI0MDExLC0uNDI0MzQyMTIwMjA3NDM4OCwuNDI0MzQyMTIwMjA3NDM4OCwtLjU1MTYxODgzNTg4NzIxOTgsLjU1MTYxODgzNTg4NzIxOTgsLS42NjcxMzg4MDQxOTc0MTIzLC42NjcxMzg4MDQxOTc0MTIzLC0uNzY4NDM5OTYzNDc1Njc3OSwuNzY4NDM5OTYzNDc1Njc3OSwtLjg1MzM2MzM2NDU4MzMxNzMsLjg1MzM2MzM2NDU4MzMxNzMsLS45MjAwOTkzMzQxNTA0MDA4LC45MjAwOTkzMzQxNTA0MDA4LC0uOTY3MjI2ODM4NTY2MzA2MywuOTY3MjI2ODM4NTY2MzA2MywtLjk5Mzc1MjE3MDYyMDM4OTUsLjk5Mzc1MjE3MDYyMDM4OTVdLFstLjA2OTczOTI3MzMxOTcyMjIzLC4wNjk3MzkyNzMzMTk3MjIyMywtLjIwNzg2MDQyNjY4ODIyMTI3LC4yMDc4NjA0MjY2ODgyMjEyNywtLjM0MTkzNTgyMDg5MjA4NDI0LC4zNDE5MzU4MjA4OTIwODQyNCwtLjQ2OTM1NTgzNzk4Njc1NywuNDY5MzU1ODM3OTg2NzU3LC0uNTg3NjQwNDAzNTA2OTExNiwuNTg3NjQwNDAzNTA2OTExNiwtLjY5NDQ4NzI2MzE4NjY4MjcsLjY5NDQ4NzI2MzE4NjY4MjcsLS43ODc4MTY4MDU5NzkyMDgxLC43ODc4MTY4MDU5NzkyMDgxLC0uODY1ODEyNTc3NzIwMzAwMiwuODY1ODEyNTc3NzIwMzAwMiwtLjkyNjk1Njc3MjE4NzE3NCwuOTI2OTU2NzcyMTg3MTc0LC0uOTcwMDYwNDk3ODM1NDI4NywuOTcwMDYwNDk3ODM1NDI4NywtLjk5NDI5NDU4NTQ4MjM5OTIsLjk5NDI5NDU4NTQ4MjM5OTJdLFswLC0uMTMzMjU2ODI0Mjk4NDY2MSwuMTMzMjU2ODI0Mjk4NDY2MSwtLjI2NDEzNTY4MDk3MDM0NDk1LC4yNjQxMzU2ODA5NzAzNDQ5NSwtLjM5MDMwMTAzODAzMDI5MDgsLjM5MDMwMTAzODAzMDI5MDgsLS41MDk1MDE0Nzc4NDYwMDc1LC41MDk1MDE0Nzc4NDYwMDc1LC0uNjE5NjA5ODc1NzYzNjQ2MSwuNjE5NjA5ODc1NzYzNjQ2MSwtLjcxODY2MTM2MzEzMTk1MDIsLjcxODY2MTM2MzEzMTk1MDIsLS44MDQ4ODg0MDE2MTg4Mzk5LC44MDQ4ODg0MDE2MTg4Mzk5LC0uODc2NzUyMzU4MjcwNDQxNiwuODc2NzUyMzU4MjcwNDQxNiwtLjkzMjk3MTA4NjgyNjAxNjEsLjkzMjk3MTA4NjgyNjAxNjEsLS45NzI1NDI0NzEyMTgxMTUyLC45NzI1NDI0NzEyMTgxMTUyLC0uOTk0NzY5MzM0OTk3NTUyMiwuOTk0NzY5MzM0OTk3NTUyMl0sWy0uMDY0MDU2ODkyODYyNjA1NjMsLjA2NDA1Njg5Mjg2MjYwNTYzLC0uMTkxMTE4ODY3NDczNjE2MywuMTkxMTE4ODY3NDczNjE2MywtLjMxNTA0MjY3OTY5NjE2MzQsLjMxNTA0MjY3OTY5NjE2MzQsLS40MzM3OTM1MDc2MjYwNDUxLC40MzM3OTM1MDc2MjYwNDUxLC0uNTQ1NDIxNDcxMzg4ODM5NiwuNTQ1NDIxNDcxMzg4ODM5NiwtLjY0ODA5MzY1MTkzNjk3NTUsLjY0ODA5MzY1MTkzNjk3NTUsLS43NDAxMjQxOTE1Nzg1NTQ0LC43NDAxMjQxOTE1Nzg1NTQ0LC0uODIwMDAxOTg1OTczOTAzLC44MjAwMDE5ODU5NzM5MDMsLS44ODY0MTU1MjcwMDQ0MDExLC44ODY0MTU1MjcwMDQ0MDExLC0uOTM4Mjc0NTUyMDAyNzMyOCwuOTM4Mjc0NTUyMDAyNzMyOCwtLjk3NDcyODU1NTk3MTMwOTUsLjk3NDcyODU1NTk3MTMwOTUsLS45OTUxODcyMTk5OTcwMjEzLC45OTUxODcyMTk5OTcwMjEzXV0sQW49W1tdLFtdLFsxLDFdLFsuODg4ODg4ODg4ODg4ODg4OCwuNTU1NTU1NTU1NTU1NTU1NiwuNTU1NTU1NTU1NTU1NTU1Nl0sWy42NTIxNDUxNTQ4NjI1NDYxLC42NTIxNDUxNTQ4NjI1NDYxLC4zNDc4NTQ4NDUxMzc0NTM4NSwuMzQ3ODU0ODQ1MTM3NDUzODVdLFsuNTY4ODg4ODg4ODg4ODg4OSwuNDc4NjI4NjcwNDk5MzY2NDcsLjQ3ODYyODY3MDQ5OTM2NjQ3LC4yMzY5MjY4ODUwNTYxODkwOCwuMjM2OTI2ODg1MDU2MTg5MDhdLFsuMzYwNzYxNTczMDQ4MTM4NiwuMzYwNzYxNTczMDQ4MTM4NiwuNDY3OTEzOTM0NTcyNjkxMDQsLjQ2NzkxMzkzNDU3MjY5MTA0LC4xNzEzMjQ0OTIzNzkxNzAzNiwuMTcxMzI0NDkyMzc5MTcwMzZdLFsuNDE3OTU5MTgzNjczNDY5NCwuMzgxODMwMDUwNTA1MTE4OSwuMzgxODMwMDUwNTA1MTE4OSwuMjc5NzA1MzkxNDg5Mjc2NjQsLjI3OTcwNTM5MTQ4OTI3NjY0LC4xMjk0ODQ5NjYxNjg4Njk3LC4xMjk0ODQ5NjYxNjg4Njk3XSxbLjM2MjY4Mzc4MzM3ODM2MiwuMzYyNjgzNzgzMzc4MzYyLC4zMTM3MDY2NDU4Nzc4ODcyNywuMzEzNzA2NjQ1ODc3ODg3MjcsLjIyMjM4MTAzNDQ1MzM3NDQ4LC4yMjIzODEwMzQ0NTMzNzQ0OCwuMTAxMjI4NTM2MjkwMzc2MjYsLjEwMTIyODUzNjI5MDM3NjI2XSxbLjMzMDIzOTM1NTAwMTI1OTgsLjE4MDY0ODE2MDY5NDg1NzQsLjE4MDY0ODE2MDY5NDg1NzQsLjA4MTI3NDM4ODM2MTU3NDQxLC4wODEyNzQzODgzNjE1NzQ0MSwuMzEyMzQ3MDc3MDQwMDAyODYsLjMxMjM0NzA3NzA0MDAwMjg2LC4yNjA2MTA2OTY0MDI5MzU0NCwuMjYwNjEwNjk2NDAyOTM1NDRdLFsuMjk1NTI0MjI0NzE0NzUyODcsLjI5NTUyNDIyNDcxNDc1Mjg3LC4yNjkyNjY3MTkzMDk5OTYzNSwuMjY5MjY2NzE5MzA5OTk2MzUsLjIxOTA4NjM2MjUxNTk4MjA0LC4yMTkwODYzNjI1MTU5ODIwNCwuMTQ5NDUxMzQ5MTUwNTgwNiwuMTQ5NDUxMzQ5MTUwNTgwNiwuMDY2NjcxMzQ0MzA4Njg4MTQsLjA2NjY3MTM0NDMwODY4ODE0XSxbLjI3MjkyNTA4Njc3NzkwMDYsLjI2MjgwNDU0NDUxMDI0NjY1LC4yNjI4MDQ1NDQ1MTAyNDY2NSwuMjMzMTkzNzY0NTkxOTkwNDgsLjIzMzE5Mzc2NDU5MTk5MDQ4LC4xODYyOTAyMTA5Mjc3MzQyNiwuMTg2MjkwMjEwOTI3NzM0MjYsLjEyNTU4MDM2OTQ2NDkwNDYsLjEyNTU4MDM2OTQ2NDkwNDYsLjA1NTY2ODU2NzExNjE3MzY2LC4wNTU2Njg1NjcxMTYxNzM2Nl0sWy4yNDkxNDcwNDU4MTM0MDI3NywuMjQ5MTQ3MDQ1ODEzNDAyNzcsLjIzMzQ5MjUzNjUzODM1NDgsLjIzMzQ5MjUzNjUzODM1NDgsLjIwMzE2NzQyNjcyMzA2NTkyLC4yMDMxNjc0MjY3MjMwNjU5MiwuMTYwMDc4MzI4NTQzMzQ2MjIsLjE2MDA3ODMyODU0MzM0NjIyLC4xMDY5MzkzMjU5OTUzMTg0MywuMTA2OTM5MzI1OTk1MzE4NDMsLjA0NzE3NTMzNjM4NjUxMTgzLC4wNDcxNzUzMzYzODY1MTE4M10sWy4yMzI1NTE1NTMyMzA4NzM5LC4yMjYyODMxODAyNjI4OTcyMywuMjI2MjgzMTgwMjYyODk3MjMsLjIwNzgxNjA0NzUzNjg4ODUsLjIwNzgxNjA0NzUzNjg4ODUsLjE3ODE0NTk4MDc2MTk0NTc0LC4xNzgxNDU5ODA3NjE5NDU3NCwuMTM4ODczNTEwMjE5Nzg3MjUsLjEzODg3MzUxMDIxOTc4NzI1LC4wOTIxMjE0OTk4Mzc3Mjg0NSwuMDkyMTIxNDk5ODM3NzI4NDUsLjA0MDQ4NDAwNDc2NTMxNTg4LC4wNDA0ODQwMDQ3NjUzMTU4OF0sWy4yMTUyNjM4NTM0NjMxNTc4LC4yMTUyNjM4NTM0NjMxNTc4LC4yMDUxOTg0NjM3MjEyOTU2LC4yMDUxOTg0NjM3MjEyOTU2LC4xODU1MzgzOTc0Nzc5Mzc4MiwuMTg1NTM4Mzk3NDc3OTM3ODIsLjE1NzIwMzE2NzE1ODE5MzU1LC4xNTcyMDMxNjcxNTgxOTM1NSwuMTIxNTE4NTcwNjg3OTAzMTksLjEyMTUxODU3MDY4NzkwMzE5LC4wODAxNTgwODcxNTk3NjAyMSwuMDgwMTU4MDg3MTU5NzYwMjEsLjAzNTExOTQ2MDMzMTc1MTg2LC4wMzUxMTk0NjAzMzE3NTE4Nl0sWy4yMDI1NzgyNDE5MjU1NjEzLC4xOTg0MzE0ODUzMjcxMTE1OCwuMTk4NDMxNDg1MzI3MTExNTgsLjE4NjE2MTAwMDAxNTU2MjIsLjE4NjE2MTAwMDAxNTU2MjIsLjE2NjI2OTIwNTgxNjk5MzkyLC4xNjYyNjkyMDU4MTY5OTM5MiwuMTM5NTcwNjc3OTI2MTU0MzIsLjEzOTU3MDY3NzkyNjE1NDMyLC4xMDcxNTkyMjA0NjcxNzE5NCwuMTA3MTU5MjIwNDY3MTcxOTQsLjA3MDM2NjA0NzQ4ODEwODEyLC4wNzAzNjYwNDc0ODgxMDgxMiwuMDMwNzUzMjQxOTk2MTE3MjcsLjAzMDc1MzI0MTk5NjExNzI3XSxbLjE4OTQ1MDYxMDQ1NTA2ODUsLjE4OTQ1MDYxMDQ1NTA2ODUsLjE4MjYwMzQxNTA0NDkyMzU4LC4xODI2MDM0MTUwNDQ5MjM1OCwuMTY5MTU2NTE5Mzk1MDAyNTQsLjE2OTE1NjUxOTM5NTAwMjU0LC4xNDk1OTU5ODg4MTY1NzY3NCwuMTQ5NTk1OTg4ODE2NTc2NzQsLjEyNDYyODk3MTI1NTUzMzg4LC4xMjQ2Mjg5NzEyNTU1MzM4OCwuMDk1MTU4NTExNjgyNDkyNzksLjA5NTE1ODUxMTY4MjQ5Mjc5LC4wNjIyNTM1MjM5Mzg2NDc4OTQsLjA2MjI1MzUyMzkzODY0Nzg5NCwuMDI3MTUyNDU5NDExNzU0MDk2LC4wMjcxNTI0NTk0MTE3NTQwOTZdLFsuMTc5NDQ2NDcwMzU2MjA2NTMsLjE3NjU2MjcwNTM2Njk5MjY0LC4xNzY1NjI3MDUzNjY5OTI2NCwuMTY4MDA0MTAyMTU2NDUwMDQsLjE2ODAwNDEwMjE1NjQ1MDA0LC4xNTQwNDU3NjEwNzY4MTAyOCwuMTU0MDQ1NzYxMDc2ODEwMjgsLjEzNTEzNjM2ODQ2ODUyNTQ4LC4xMzUxMzYzNjg0Njg1MjU0OCwuMTExODgzODQ3MTkzNDAzOTcsLjExMTg4Mzg0NzE5MzQwMzk3LC4wODUwMzYxNDgzMTcxNzkxOCwuMDg1MDM2MTQ4MzE3MTc5MTgsLjA1NTQ1OTUyOTM3Mzk4NzIsLjA1NTQ1OTUyOTM3Mzk4NzIsLjAyNDE0ODMwMjg2ODU0NzkzLC4wMjQxNDgzMDI4Njg1NDc5M10sWy4xNjkxNDIzODI5NjMxNDM2LC4xNjkxNDIzODI5NjMxNDM2LC4xNjQyNzY0ODM3NDU4MzI3MywuMTY0Mjc2NDgzNzQ1ODMyNzMsLjE1NDY4NDY3NTEyNjI2NTI0LC4xNTQ2ODQ2NzUxMjYyNjUyNCwuMTQwNjQyOTE0NjcwNjUwNjUsLjE0MDY0MjkxNDY3MDY1MDY1LC4xMjI1NTUyMDY3MTE0Nzg0NiwuMTIyNTU1MjA2NzExNDc4NDYsLjEwMDk0MjA0NDEwNjI4NzE3LC4xMDA5NDIwNDQxMDYyODcxNywuMDc2NDI1NzMwMjU0ODg5MDUsLjA3NjQyNTczMDI1NDg4OTA1LC4wNDk3MTQ1NDg4OTQ5Njk4LC4wNDk3MTQ1NDg4OTQ5Njk4LC4wMjE2MTYwMTM1MjY0ODMzMSwuMDIxNjE2MDEzNTI2NDgzMzFdLFsuMTYxMDU0NDQ5ODQ4NzgzNywuMTU4OTY4ODQzMzkzOTU0MzQsLjE1ODk2ODg0MzM5Mzk1NDM0LC4xNTI3NjYwNDIwNjU4NTk2NywuMTUyNzY2MDQyMDY1ODU5NjcsLjE0MjYwNjcwMjE3MzYwNjYsLjE0MjYwNjcwMjE3MzYwNjYsLjEyODc1Mzk2MjUzOTMzNjIxLC4xMjg3NTM5NjI1MzkzMzYyMSwuMTExNTY2NjQ1NTQ3MzMzOTksLjExMTU2NjY0NTU0NzMzMzk5LC4wOTE0OTAwMjE2MjI0NSwuMDkxNDkwMDIxNjIyNDUsLjA2OTA0NDU0MjczNzY0MTIzLC4wNjkwNDQ1NDI3Mzc2NDEyMywuMDQ0ODE0MjI2NzY1Njk5NiwuMDQ0ODE0MjI2NzY1Njk5NiwuMDE5NDYxNzg4MjI5NzI2NDc4LC4wMTk0NjE3ODgyMjk3MjY0NzhdLFsuMTUyNzUzMzg3MTMwNzI1ODQsLjE1Mjc1MzM4NzEzMDcyNTg0LC4xNDkxNzI5ODY0NzI2MDM3NCwuMTQ5MTcyOTg2NDcyNjAzNzQsLjE0MjA5NjEwOTMxODM4MjA0LC4xNDIwOTYxMDkzMTgzODIwNCwuMTMxNjg4NjM4NDQ5MTc2NjQsLjEzMTY4ODYzODQ0OTE3NjY0LC4xMTgxOTQ1MzE5NjE1MTg0MSwuMTE4MTk0NTMxOTYxNTE4NDEsLjEwMTkzMDExOTgxNzI0MDQ0LC4xMDE5MzAxMTk4MTcyNDA0NCwuMDgzMjc2NzQxNTc2NzA0NzUsLjA4MzI3Njc0MTU3NjcwNDc1LC4wNjI2NzIwNDgzMzQxMDkwNywuMDYyNjcyMDQ4MzM0MTA5MDcsLjA0MDYwMTQyOTgwMDM4Njk0LC4wNDA2MDE0Mjk4MDAzODY5NCwuMDE3NjE0MDA3MTM5MTUyMTE4LC4wMTc2MTQwMDcxMzkxNTIxMThdLFsuMTQ2MDgxMTMzNjQ5NjkwNDEsLjE0NDUyNDQwMzk4OTk3MDA1LC4xNDQ1MjQ0MDM5ODk5NzAwNSwuMTM5ODg3Mzk0NzkxMDczMTUsLjEzOTg4NzM5NDc5MTA3MzE1LC4xMzIyNjg5Mzg2MzMzMzc0NywuMTMyMjY4OTM4NjMzMzM3NDcsLjEyMTgzMTQxNjA1MzcyODUzLC4xMjE4MzE0MTYwNTM3Mjg1MywuMTA4Nzk3Mjk5MTY3MTQ4MzgsLjEwODc5NzI5OTE2NzE0ODM4LC4wOTM0NDQ0MjM0NTYwMzM4NiwuMDkzNDQ0NDIzNDU2MDMzODYsLjA3NjEwMDExMzYyODM3OTMsLjA3NjEwMDExMzYyODM3OTMsLjA1NzEzNDQyNTQyNjg1NzIwNSwuMDU3MTM0NDI1NDI2ODU3MjA1LC4wMzY5NTM3ODk3NzA4NTI0OTQsLjAzNjk1Mzc4OTc3MDg1MjQ5NCwuMDE2MDE3MjI4MjU3Nzc0MzM1LC4wMTYwMTcyMjgyNTc3NzQzMzVdLFsuMTM5MjUxODcyODU1NjMxOTgsLjEzOTI1MTg3Mjg1NTYzMTk4LC4xMzY1NDE0OTgzNDYwMTUxNywuMTM2NTQxNDk4MzQ2MDE1MTcsLjEzMTE3MzUwNDc4NzA2MjM4LC4xMzExNzM1MDQ3ODcwNjIzOCwuMTIzMjUyMzc2ODEwNTEyNDIsLjEyMzI1MjM3NjgxMDUxMjQyLC4xMTI5MzIyOTYwODA1MzkyMiwuMTEyOTMyMjk2MDgwNTM5MjIsLjEwMDQxNDE0NDQ0Mjg4MDk2LC4xMDA0MTQxNDQ0NDI4ODA5NiwuMDg1OTQxNjA2MjE3MDY3NzMsLjA4NTk0MTYwNjIxNzA2NzczLC4wNjk3OTY0Njg0MjQ1MjA0OSwuMDY5Nzk2NDY4NDI0NTIwNDksLjA1MjI5MzMzNTE1MjY4MzI4NiwuMDUyMjkzMzM1MTUyNjgzMjg2LC4wMzM3NzQ5MDE1ODQ4MTQxNSwuMDMzNzc0OTAxNTg0ODE0MTUsLjAxNDYyNzk5NTI5ODI3MjIsLjAxNDYyNzk5NTI5ODI3MjJdLFsuMTMzNjU0NTcyMTg2MTA2MTksLjEzMjQ2MjAzOTQwNDY5NjYsLjEzMjQ2MjAzOTQwNDY5NjYsLjEyODkwNTcyMjE4ODA4MjE2LC4xMjg5MDU3MjIxODgwODIxNiwuMTIzMDQ5MDg0MzA2NzI5NTMsLjEyMzA0OTA4NDMwNjcyOTUzLC4xMTQ5OTY2NDAyMjI0MTEzNiwuMTE0OTk2NjQwMjIyNDExMzYsLjEwNDg5MjA5MTQ2NDU0MTQxLC4xMDQ4OTIwOTE0NjQ1NDE0MSwuMDkyOTE1NzY2MDYwMDM1MTUsLjA5MjkxNTc2NjA2MDAzNTE1LC4wNzkyODE0MTE3NzY3MTg5NSwuMDc5MjgxNDExNzc2NzE4OTUsLjA2NDIzMjQyMTQwODUyNTg1LC4wNjQyMzI0MjE0MDg1MjU4NSwuMDQ4MDM3NjcxNzMxMDg0NjcsLjA0ODAzNzY3MTczMTA4NDY3LC4wMzA5ODgwMDU4NTY5Nzk0NDUsLjAzMDk4ODAwNTg1Njk3OTQ0NSwuMDEzNDExODU5NDg3MTQxNzcxLC4wMTM0MTE4NTk0ODcxNDE3NzFdLFsuMTI3OTM4MTk1MzQ2NzUyMTYsLjEyNzkzODE5NTM0Njc1MjE2LC4xMjU4Mzc0NTYzNDY4MjgzLC4xMjU4Mzc0NTYzNDY4MjgzLC4xMjE2NzA0NzI5Mjc4MDMzOSwuMTIxNjcwNDcyOTI3ODAzMzksLjExNTUwNTY2ODA1MzcyNTYsLjExNTUwNTY2ODA1MzcyNTYsLjEwNzQ0NDI3MDExNTk2NTYzLC4xMDc0NDQyNzAxMTU5NjU2MywuMDk3NjE4NjUyMTA0MTEzODgsLjA5NzYxODY1MjEwNDExMzg4LC4wODYxOTAxNjE1MzE5NTMyNywuMDg2MTkwMTYxNTMxOTUzMjcsLjA3MzM0NjQ4MTQxMTA4MDMsLjA3MzM0NjQ4MTQxMTA4MDMsLjA1OTI5ODU4NDkxNTQzNjc4LC4wNTkyOTg1ODQ5MTU0MzY3OCwuMDQ0Mjc3NDM4ODE3NDE5ODEsLjA0NDI3NzQzODgxNzQxOTgxLC4wMjg1MzEzODg2Mjg5MzM2NjMsLjAyODUzMTM4ODYyODkzMzY2MywuMDEyMzQxMjI5Nzk5OTg3MiwuMDEyMzQxMjI5Nzk5OTg3Ml1dLHFuPVtbMV0sWzEsMV0sWzEsMiwxXSxbMSwzLDMsMV1dLGtuPTIqTWF0aC5QSSxQbj1mdW5jdGlvbih0LG4sZSxyLGksYSxvLHMsaCl7dmFyIHU9TWF0aC5zaW4oaSprbi8zNjApLGM9TWF0aC5jb3MoaSprbi8zNjApLGY9YyoodC1zKS8yK3UqKG4taCkvMixsPS11Kih0LXMpLzIrYyoobi1oKS8yO2lmKDA9PT1mJiYwPT09bClyZXR1cm5bXTtpZigwPT09ZXx8MD09PXIpcmV0dXJuW107ZT1NYXRoLmFicyhlKSxyPU1hdGguYWJzKHIpO3ZhciBwPWYqZi8oZSplKStsKmwvKHIqcik7cD4xJiYoZSo9TWF0aC5zcXJ0KHApLHIqPU1hdGguc3FydChwKSk7dmFyIGc9Uyh0LG4scyxoLGEsbyxlLHIsdSxjKSx2PVtdLHg9Z1syXSx5PWdbM10sZD1NYXRoLm1heChNYXRoLmNlaWwoTWF0aC5hYnMoeSkvKGtuLzQpKSwxKTt5Lz1kO2Zvcih2YXIgbT0wO208ZDttKyspdi5wdXNoKEMoeCx5KSkseCs9eTtyZXR1cm4gdi5tYXAoZnVuY3Rpb24odCl7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKz0yKXt2YXIgaT10W24rMF0sYT10W24rMV07aSo9ZSxhKj1yO3ZhciBvPWMqaS11KmEscz11KmkrYyphO3RbbiswXT1vK2dbMF0sdFtuKzFdPXMrZ1sxXX1yZXR1cm4gdH0pfSxfbj1mdW5jdGlvbih0LG4sZSxyLGksYSxvLHMsaCl7cmV0dXJuIG5ldyBaKHQsbixlLHIsaSxhLG8scyxoKX07Wi5wcm90b3R5cGU9e2NvbnN0cnVjdG9yOlosaW5pdDpmdW5jdGlvbigpe30sZ2V0VG90YWxMZW5ndGg6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sZW5ndGh9LGdldFBvaW50QXRMZW5ndGg6ZnVuY3Rpb24odCl7dmFyIG49dGhpczt0PDA/dD0wOnQ+dGhpcy5sZW5ndGgmJih0PXRoaXMubGVuZ3RoKTtmb3IodmFyIGU9dGhpcy5wYXJ0aWFsTGVuZ3Rocy5sZW5ndGgtMTt0aGlzLnBhcnRpYWxMZW5ndGhzW2VdPj10JiZ0aGlzLnBhcnRpYWxMZW5ndGhzW2VdPjA7KWUtLTtlPHRoaXMucGFydGlhbExlbmd0aHMubGVuZ3RoLTEmJmUrKztmb3IodmFyIHI9MCxpPTA7aTxlO2krKylyKz1uLnBhcnRpYWxMZW5ndGhzW2ldO3JldHVybiB0aGlzLmN1cnZlc1tlXS5nZXRQb2ludEF0TGVuZ3RoKHQtcil9LGdldFRhbmdlbnRBdExlbmd0aDpmdW5jdGlvbih0KXt2YXIgbj10aGlzO3Q8MD90PTA6dD50aGlzLmxlbmd0aCYmKHQ9dGhpcy5sZW5ndGgpO2Zvcih2YXIgZT10aGlzLnBhcnRpYWxMZW5ndGhzLmxlbmd0aC0xO3RoaXMucGFydGlhbExlbmd0aHNbZV0+PXQmJnRoaXMucGFydGlhbExlbmd0aHNbZV0+MDspZS0tO2U8dGhpcy5wYXJ0aWFsTGVuZ3Rocy5sZW5ndGgtMSYmZSsrO2Zvcih2YXIgcj0wLGk9MDtpPGU7aSsrKXIrPW4ucGFydGlhbExlbmd0aHNbaV07cmV0dXJuIHRoaXMuY3VydmVzW2VdLmdldFRhbmdlbnRBdExlbmd0aCh0LXIpfSxnZXRQcm9wZXJ0aWVzQXRMZW5ndGg6ZnVuY3Rpb24odCl7dmFyIG49dGhpcy5nZXRUYW5nZW50QXRMZW5ndGgodCksZT10aGlzLmdldFBvaW50QXRMZW5ndGgodCk7cmV0dXJue3g6ZS54LHk6ZS55LHRhbmdlbnRYOm4ueCx0YW5nZW50WTpuLnl9fX07dmFyIEVuPWZ1bmN0aW9uKHQsbixlLHIpe3JldHVybiBuZXcgVCh0LG4sZSxyKX07VC5wcm90b3R5cGUuZ2V0VG90YWxMZW5ndGg9ZnVuY3Rpb24oKXtyZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHRoaXMueDAtdGhpcy54MSwyKStNYXRoLnBvdyh0aGlzLnkwLXRoaXMueTEsMikpfSxULnByb3RvdHlwZS5nZXRQb2ludEF0TGVuZ3RoPWZ1bmN0aW9uKHQpe3ZhciBuPXQvTWF0aC5zcXJ0KE1hdGgucG93KHRoaXMueDAtdGhpcy54MSwyKStNYXRoLnBvdyh0aGlzLnkwLXRoaXMueTEsMikpLGU9KHRoaXMueDEtdGhpcy54MCkqbixyPSh0aGlzLnkxLXRoaXMueTApKm47cmV0dXJue3g6dGhpcy54MCtlLHk6dGhpcy55MCtyfX0sVC5wcm90b3R5cGUuZ2V0VGFuZ2VudEF0TGVuZ3RoPWZ1bmN0aW9uKCl7dmFyIHQ9TWF0aC5zcXJ0KCh0aGlzLngxLXRoaXMueDApKih0aGlzLngxLXRoaXMueDApKyh0aGlzLnkxLXRoaXMueTApKih0aGlzLnkxLXRoaXMueTApKTtyZXR1cm57eDoodGhpcy54MS10aGlzLngwKS90LHk6KHRoaXMueTEtdGhpcy55MCkvdH19LFQucHJvdG90eXBlLmdldFByb3BlcnRpZXNBdExlbmd0aD1mdW5jdGlvbih0KXt2YXIgbj10aGlzLmdldFBvaW50QXRMZW5ndGgodCksZT10aGlzLmdldFRhbmdlbnRBdExlbmd0aCgpO3JldHVybnt4Om4ueCx5Om4ueSx0YW5nZW50WDplLngsdGFuZ2VudFk6ZS55fX07dmFyIFNuPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIG4odCl7aWYoIXQpcmV0dXJuIG51bGw7Zm9yKHZhciBhLG89TW4odCkscz1bMCwwXSxoPVswLDBdLHU9MDt1PG8ubGVuZ3RoO3UrKylcIk1cIj09PW9bdV1bMF0/KHM9W29bdV1bMV0sb1t1XVsyXV0saS5wdXNoKG51bGwpKTpcIm1cIj09PW9bdV1bMF0/KHM9W29bdV1bMV0rc1swXSxvW3VdWzJdK3NbMV1dLGkucHVzaChudWxsKSk6XCJMXCI9PT1vW3VdWzBdPyhlKz1NYXRoLnNxcnQoTWF0aC5wb3coc1swXS1vW3VdWzFdLDIpK01hdGgucG93KHNbMV0tb1t1XVsyXSwyKSksaS5wdXNoKG5ldyBFbihzWzBdLG9bdV1bMV0sc1sxXSxvW3VdWzJdKSkscz1bb1t1XVsxXSxvW3VdWzJdXSk6XCJsXCI9PT1vW3VdWzBdPyhlKz1NYXRoLnNxcnQoTWF0aC5wb3cob1t1XVsxXSwyKStNYXRoLnBvdyhvW3VdWzJdLDIpKSxpLnB1c2gobmV3IEVuKHNbMF0sb1t1XVsxXStzWzBdLHNbMV0sb1t1XVsyXStzWzFdKSkscz1bb1t1XVsxXStzWzBdLG9bdV1bMl0rc1sxXV0pOlwiSFwiPT09b1t1XVswXT8oZSs9TWF0aC5hYnMoc1swXS1vW3VdWzFdKSxpLnB1c2gobmV3IEVuKHNbMF0sb1t1XVsxXSxzWzFdLHNbMV0pKSxzWzBdPW9bdV1bMV0pOlwiaFwiPT09b1t1XVswXT8oZSs9TWF0aC5hYnMob1t1XVsxXSksaS5wdXNoKG5ldyBFbihzWzBdLHNbMF0rb1t1XVsxXSxzWzFdLHNbMV0pKSxzWzBdPW9bdV1bMV0rc1swXSk6XCJWXCI9PT1vW3VdWzBdPyhlKz1NYXRoLmFicyhzWzFdLW9bdV1bMV0pLGkucHVzaChuZXcgRW4oc1swXSxzWzBdLHNbMV0sb1t1XVsxXSkpLHNbMV09b1t1XVsxXSk6XCJ2XCI9PT1vW3VdWzBdPyhlKz1NYXRoLmFicyhvW3VdWzFdKSxpLnB1c2gobmV3IEVuKHNbMF0sc1swXSxzWzFdLHNbMV0rb1t1XVsxXSkpLHNbMV09b1t1XVsxXStzWzFdKTpcInpcIj09PW9bdV1bMF18fFwiWlwiPT09b1t1XVswXT8oZSs9TWF0aC5zcXJ0KE1hdGgucG93KG9bMF1bMV0tc1swXSwyKStNYXRoLnBvdyhvWzBdWzJdLXNbMV0sMikpLGkucHVzaChuZXcgRW4oc1swXSxvWzBdWzFdLHNbMV0sb1swXVsyXSkpLHM9W29bMF1bMV0sb1swXVsyXV0pOlwiQ1wiPT09b1t1XVswXT8oYT1uZXcgYm4oc1swXSxzWzFdLG9bdV1bMV0sb1t1XVsyXSxvW3VdWzNdLG9bdV1bNF0sb1t1XVs1XSxvW3VdWzZdKSxlKz1hLmdldFRvdGFsTGVuZ3RoKCkscz1bb1t1XVs1XSxvW3VdWzZdXSxpLnB1c2goYSkpOlwiY1wiPT09b1t1XVswXT8oYT1uZXcgYm4oc1swXSxzWzFdLHNbMF0rb1t1XVsxXSxzWzFdK29bdV1bMl0sc1swXStvW3VdWzNdLHNbMV0rb1t1XVs0XSxzWzBdK29bdV1bNV0sc1sxXStvW3VdWzZdKSxlKz1hLmdldFRvdGFsTGVuZ3RoKCkscz1bb1t1XVs1XStzWzBdLG9bdV1bNl0rc1sxXV0saS5wdXNoKGEpKTpcIlNcIj09PW9bdV1bMF0/KGE9dT4wJiZbXCJDXCIsXCJjXCIsXCJTXCIsXCJzXCJdLmluZGV4T2Yob1t1LTFdWzBdKT4tMT9uZXcgYm4oc1swXSxzWzFdLDIqc1swXS1vW3UtMV1bb1t1LTFdLmxlbmd0aC00XSwyKnNbMV0tb1t1LTFdW29bdS0xXS5sZW5ndGgtM10sb1t1XVsxXSxvW3VdWzJdLG9bdV1bM10sb1t1XVs0XSk6bmV3IGJuKHNbMF0sc1sxXSxzWzBdLHNbMV0sb1t1XVsxXSxvW3VdWzJdLG9bdV1bM10sb1t1XVs0XSksZSs9YS5nZXRUb3RhbExlbmd0aCgpLHM9W29bdV1bM10sb1t1XVs0XV0saS5wdXNoKGEpKTpcInNcIj09PW9bdV1bMF0/KGE9dT4wJiZbXCJDXCIsXCJjXCIsXCJTXCIsXCJzXCJdLmluZGV4T2Yob1t1LTFdWzBdKT4tMT9uZXcgYm4oc1swXSxzWzFdLHNbMF0rYS5kLngtYS5jLngsc1sxXSthLmQueS1hLmMueSxzWzBdK29bdV1bMV0sc1sxXStvW3VdWzJdLHNbMF0rb1t1XVszXSxzWzFdK29bdV1bNF0pOm5ldyBibihzWzBdLHNbMV0sc1swXSxzWzFdLHNbMF0rb1t1XVsxXSxzWzFdK29bdV1bMl0sc1swXStvW3VdWzNdLHNbMV0rb1t1XVs0XSksZSs9YS5nZXRUb3RhbExlbmd0aCgpLHM9W29bdV1bM10rc1swXSxvW3VdWzRdK3NbMV1dLGkucHVzaChhKSk6XCJRXCI9PT1vW3VdWzBdPyhhPW5ldyBibihzWzBdLHNbMV0sb1t1XVsxXSxvW3VdWzJdLG9bdV1bM10sb1t1XVs0XSksZSs9YS5nZXRUb3RhbExlbmd0aCgpLGkucHVzaChhKSxzPVtvW3VdWzNdLG9bdV1bNF1dLGg9W29bdV1bMV0sb1t1XVsyXV0pOlwicVwiPT09b1t1XVswXT8oYT1uZXcgYm4oc1swXSxzWzFdLHNbMF0rb1t1XVsxXSxzWzFdK29bdV1bMl0sc1swXStvW3VdWzNdLHNbMV0rb1t1XVs0XSksZSs9YS5nZXRUb3RhbExlbmd0aCgpLGg9W3NbMF0rb1t1XVsxXSxzWzFdK29bdV1bMl1dLHM9W29bdV1bM10rc1swXSxvW3VdWzRdK3NbMV1dLGkucHVzaChhKSk6XCJUXCI9PT1vW3VdWzBdPyhhPXU+MCYmW1wiUVwiLFwicVwiLFwiVFwiLFwidFwiXS5pbmRleE9mKG9bdS0xXVswXSk+LTE/bmV3IGJuKHNbMF0sc1sxXSwyKnNbMF0taFswXSwyKnNbMV0taFsxXSxvW3VdWzFdLG9bdV1bMl0pOm5ldyBFbihzWzBdLG9bdV1bMV0sc1sxXSxvW3VdWzJdKSxpLnB1c2goYSksZSs9YS5nZXRUb3RhbExlbmd0aCgpLGg9WzIqc1swXS1oWzBdLDIqc1sxXS1oWzFdXSxzPVtvW3VdWzFdLG9bdV1bMl1dKTpcInRcIj09PW9bdV1bMF0/KGE9dT4wJiZbXCJRXCIsXCJxXCIsXCJUXCIsXCJ0XCJdLmluZGV4T2Yob1t1LTFdWzBdKT4tMT9uZXcgYm4oc1swXSxzWzFdLDIqc1swXS1oWzBdLDIqc1sxXS1oWzFdLHNbMF0rb1t1XVsxXSxzWzFdK29bdV1bMl0pOm5ldyBFbihzWzBdLHNbMF0rb1t1XVsxXSxzWzFdLHNbMV0rb1t1XVsyXSksZSs9YS5nZXRUb3RhbExlbmd0aCgpLGg9WzIqc1swXS1oWzBdLDIqc1sxXS1oWzFdXSxzPVtvW3VdWzFdK3NbMF0sb1t1XVsyXStzWzBdXSxpLnB1c2goYSkpOlwiQVwiPT09b1t1XVswXT8oYT1uZXcgX24oc1swXSxzWzFdLG9bdV1bMV0sb1t1XVsyXSxvW3VdWzNdLG9bdV1bNF0sb1t1XVs1XSxvW3VdWzZdLG9bdV1bN10pLGUrPWEuZ2V0VG90YWxMZW5ndGgoKSxzPVtvW3VdWzZdLG9bdV1bN11dLGkucHVzaChhKSk6XCJhXCI9PT1vW3VdWzBdJiYoYT1uZXcgX24oc1swXSxzWzFdLG9bdV1bMV0sb1t1XVsyXSxvW3VdWzNdLG9bdV1bNF0sb1t1XVs1XSxzWzBdK29bdV1bNl0sc1sxXStvW3VdWzddKSxlKz1hLmdldFRvdGFsTGVuZ3RoKCkscz1bc1swXStvW3VdWzZdLHNbMV0rb1t1XVs3XV0saS5wdXNoKGEpKSxyLnB1c2goZSk7cmV0dXJuIG59dmFyIGU9MCxyPVtdLGk9W107bi5nZXRUb3RhbExlbmd0aD1mdW5jdGlvbigpe3JldHVybiBlfSxuLmdldFBvaW50QXRMZW5ndGg9ZnVuY3Rpb24odCl7dmFyIG49YSh0KTtyZXR1cm4gaVtuLmldLmdldFBvaW50QXRMZW5ndGgobi5mcmFjdGlvbil9LG4uZ2V0VGFuZ2VudEF0TGVuZ3RoPWZ1bmN0aW9uKHQpe3ZhciBuPWEodCk7cmV0dXJuIGlbbi5pXS5nZXRUYW5nZW50QXRMZW5ndGgobi5mcmFjdGlvbil9LG4uZ2V0UHJvcGVydGllc0F0TGVuZ3RoPWZ1bmN0aW9uKHQpe3ZhciBuPWEodCk7cmV0dXJuIGlbbi5pXS5nZXRQcm9wZXJ0aWVzQXRMZW5ndGgobi5mcmFjdGlvbil9O3ZhciBhPWZ1bmN0aW9uKHQpe3Q8MD90PTA6dD5lJiYodD1lKTtmb3IodmFyIG49ci5sZW5ndGgtMTtyW25dPj10JiZyW25dPjA7KW4tLTtyZXR1cm4gbisrLHtmcmFjdGlvbjp0LXJbbi0xXSxpOm59fTtyZXR1cm4gbih0KX0sQ249J0FsbCBzaGFwZXMgbXVzdCBiZSBzdXBwbGllZCBhcyBhcnJheXMgb2YgW3gsIHldIHBvaW50cyBvciBhbiBTVkcgcGF0aCBzdHJpbmcgKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL1NWRy9BdHRyaWJ1dGUvZCkuXFxuRXhhbXBsZSB2YWxpZCB3YXlzIG9mIHN1cHBseWluZyBhIHNoYXBlIHdvdWxkIGJlOlxcbltbMCwgMF0sIFsxMCwgMF0sIFsxMCwgMTBdXVxcblwiTTAsMCBMMTAsMCBMMTAsMTBaXCJcXG4nLFpuPVwiZmx1YmJlci5hbGwoKSBleHBlY3RzIHR3byBhcnJheXMgb2YgZXF1YWwgbGVuZ3RoIGFzIGFyZ3VtZW50cy4gRWFjaCBlbGVtZW50IGluIGJvdGggYXJyYXlzIHNob3VsZCBiZSBhbiBhcnJheSBvZiBbeCwgeV0gcG9pbnRzIG9yIGFuIFNWRyBwYXRoIHN0cmluZyAoaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9kKS5cIixUbj1mdW5jdGlvbih0LG4pe2Zvcih2YXIgZSxyLGksYT10Lmxlbmd0aCxvPTEvMCxzPTA7czxhO3MrKykhZnVuY3Rpb24oaSl7cj0wLG4uZm9yRWFjaChmdW5jdGlvbihuLGUpe3ZhciBvPUYodFsoaStlKSVhXSxuKTtyKz1vKm99KSxyPG8mJihvPXIsZT1pKX0ocyk7ZSYmKGk9dC5zcGxpY2UoMCxlKSx0LnNwbGljZS5hcHBseSh0LFt0Lmxlbmd0aCwwXS5jb25jYXQoaSkpKX0sRm49ZnVuY3Rpb24odCxuLGUpe3ZvaWQgMD09PWUmJihlPXt9KTt2YXIgcj1lLm1heFNlZ21lbnRMZW5ndGg7dm9pZCAwPT09ciYmKHI9MTApO3ZhciBpPWUuc3RyaW5nO3ZvaWQgMD09PWkmJihpPSEwKTt2YXIgYT1KKHQsciksbz1KKG4scikscz10dChhLG8saSk7cmV0dXJuIWl8fFwic3RyaW5nXCIhPXR5cGVvZiB0JiZcInN0cmluZ1wiIT10eXBlb2Ygbj9zOmZ1bmN0aW9uKGUpe3JldHVybiBlPDFlLTQmJlwic3RyaW5nXCI9PXR5cGVvZiB0P3Q6MS1lPDFlLTQmJlwic3RyaW5nXCI9PXR5cGVvZiBuP246cyhlKX19LHpuPW50O250LmRldmlhdGlvbj1mdW5jdGlvbih0LG4sZSxyKXt2YXIgaT1uJiZuLmxlbmd0aCxhPWk/blswXSplOnQubGVuZ3RoLG89TWF0aC5hYnMoRXQodCwwLGEsZSkpO2lmKGkpZm9yKHZhciBzPTAsaD1uLmxlbmd0aDtzPGg7cysrKXt2YXIgdT1uW3NdKmUsYz1zPGgtMT9uW3MrMV0qZTp0Lmxlbmd0aDtvLT1NYXRoLmFicyhFdCh0LHUsYyxlKSl9dmFyIGY9MDtmb3Iocz0wO3M8ci5sZW5ndGg7cys9Myl7dmFyIGw9cltzXSplLHA9cltzKzFdKmUsZz1yW3MrMl0qZTtmKz1NYXRoLmFicygodFtsXS10W2ddKSoodFtwKzFdLXRbbCsxXSktKHRbbF0tdFtwXSkqKHRbZysxXS10W2wrMV0pKX1yZXR1cm4gMD09PW8mJjA9PT1mPzA6TWF0aC5hYnMoKGYtbykvbyl9LG50LmZsYXR0ZW49ZnVuY3Rpb24odCl7Zm9yKHZhciBuPXRbMF1bMF0ubGVuZ3RoLGU9e3ZlcnRpY2VzOltdLGhvbGVzOltdLGRpbWVuc2lvbnM6bn0scj0wLGk9MDtpPHQubGVuZ3RoO2krKyl7Zm9yKHZhciBhPTA7YTx0W2ldLmxlbmd0aDthKyspZm9yKHZhciBvPTA7bzxuO28rKyllLnZlcnRpY2VzLnB1c2godFtpXVthXVtvXSk7aT4wJiYocis9dFtpLTFdLmxlbmd0aCxlLmhvbGVzLnB1c2gocikpfXJldHVybiBlfTt2YXIgam49ZnVuY3Rpb24odCl7cmV0dXJuIHR9LEluPWZ1bmN0aW9uKHQpe2lmKG51bGw9PXQpcmV0dXJuIGpuO3ZhciBuLGUscj10LnNjYWxlWzBdLGk9dC5zY2FsZVsxXSxhPXQudHJhbnNsYXRlWzBdLG89dC50cmFuc2xhdGVbMV07cmV0dXJuIGZ1bmN0aW9uKHQscyl7c3x8KG49ZT0wKTt2YXIgaD0yLHU9dC5sZW5ndGgsYz1uZXcgQXJyYXkodSk7Zm9yKGNbMF09KG4rPXRbMF0pKnIrYSxjWzFdPShlKz10WzFdKSppK287aDx1OyljW2hdPXRbaF0sKytoO3JldHVybiBjfX0sVm49ZnVuY3Rpb24odCxuKXtmb3IodmFyIGUscj10Lmxlbmd0aCxpPXItbjtpPC0tcjspZT10W2ldLHRbaSsrXT10W3JdLHRbcl09ZX0sWG49ZnVuY3Rpb24odCxuKXtyZXR1cm5cIkdlb21ldHJ5Q29sbGVjdGlvblwiPT09bi50eXBlP3t0eXBlOlwiRmVhdHVyZUNvbGxlY3Rpb25cIixmZWF0dXJlczpuLmdlb21ldHJpZXMubWFwKGZ1bmN0aW9uKG4pe3JldHVybiBTdCh0LG4pfSl9OlN0KHQsbil9LFluPWZ1bmN0aW9uKHQsbil7ZnVuY3Rpb24gZShuKXt2YXIgZSxyPXQuYXJjc1tuPDA/fm46bl0saT1yWzBdO3JldHVybiB0LnRyYW5zZm9ybT8oZT1bMCwwXSxyLmZvckVhY2goZnVuY3Rpb24odCl7ZVswXSs9dFswXSxlWzFdKz10WzFdfSkpOmU9cltyLmxlbmd0aC0xXSxuPDA/W2UsaV06W2ksZV19ZnVuY3Rpb24gcih0LG4pe2Zvcih2YXIgZSBpbiB0KXt2YXIgcj10W2VdO2RlbGV0ZSBuW3Iuc3RhcnRdLGRlbGV0ZSByLnN0YXJ0LGRlbGV0ZSByLmVuZCxyLmZvckVhY2goZnVuY3Rpb24odCl7aVt0PDA/fnQ6dF09MX0pLHMucHVzaChyKX19dmFyIGk9e30sYT17fSxvPXt9LHM9W10saD0tMTtyZXR1cm4gbi5mb3JFYWNoKGZ1bmN0aW9uKGUscil7dmFyIGksYT10LmFyY3NbZTwwP35lOmVdO2EubGVuZ3RoPDMmJiFhWzFdWzBdJiYhYVsxXVsxXSYmKGk9blsrK2hdLG5baF09ZSxuW3JdPWkpfSksbi5mb3JFYWNoKGZ1bmN0aW9uKHQpe3ZhciBuLHIsaT1lKHQpLHM9aVswXSxoPWlbMV07aWYobj1vW3NdKWlmKGRlbGV0ZSBvW24uZW5kXSxuLnB1c2godCksbi5lbmQ9aCxyPWFbaF0pe2RlbGV0ZSBhW3Iuc3RhcnRdO3ZhciB1PXI9PT1uP246bi5jb25jYXQocik7YVt1LnN0YXJ0PW4uc3RhcnRdPW9bdS5lbmQ9ci5lbmRdPXV9ZWxzZSBhW24uc3RhcnRdPW9bbi5lbmRdPW47ZWxzZSBpZihuPWFbaF0paWYoZGVsZXRlIGFbbi5zdGFydF0sbi51bnNoaWZ0KHQpLG4uc3RhcnQ9cyxyPW9bc10pe2RlbGV0ZSBvW3IuZW5kXTt2YXIgYz1yPT09bj9uOnIuY29uY2F0KG4pO2FbYy5zdGFydD1yLnN0YXJ0XT1vW2MuZW5kPW4uZW5kXT1jfWVsc2UgYVtuLnN0YXJ0XT1vW24uZW5kXT1uO2Vsc2Ugbj1bdF0sYVtuLnN0YXJ0PXNdPW9bbi5lbmQ9aF09bn0pLHIobyxhKSxyKGEsbyksbi5mb3JFYWNoKGZ1bmN0aW9uKHQpe2lbdDwwP350OnRdfHxzLnB1c2goW3RdKX0pLHN9LEduPWZ1bmN0aW9uKHQsbil7Zm9yKHZhciBlPTAscj10Lmxlbmd0aDtlPHI7KXt2YXIgaT1lK3I+Pj4xO3RbaV08bj9lPWkrMTpyPWl9cmV0dXJuIGV9LE9uPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIG4odCxuKXt0LmZvckVhY2goZnVuY3Rpb24odCl7dDwwJiYodD1+dCk7dmFyIGU9aVt0XTtlP2UucHVzaChuKTppW3RdPVtuXX0pfWZ1bmN0aW9uIGUodCxlKXt0LmZvckVhY2goZnVuY3Rpb24odCl7bih0LGUpfSl9ZnVuY3Rpb24gcih0LG4pe1wiR2VvbWV0cnlDb2xsZWN0aW9uXCI9PT10LnR5cGU/dC5nZW9tZXRyaWVzLmZvckVhY2goZnVuY3Rpb24odCl7cih0LG4pfSk6dC50eXBlIGluIG8mJm9bdC50eXBlXSh0LmFyY3Msbil9dmFyIGk9e30sYT10Lm1hcChmdW5jdGlvbigpe3JldHVybltdfSksbz17TGluZVN0cmluZzpuLE11bHRpTGluZVN0cmluZzplLFBvbHlnb246ZSxNdWx0aVBvbHlnb246ZnVuY3Rpb24odCxuKXt0LmZvckVhY2goZnVuY3Rpb24odCl7ZSh0LG4pfSl9fTt0LmZvckVhY2gocik7Zm9yKHZhciBzIGluIGkpZm9yKHZhciBoPWlbc10sdT1oLmxlbmd0aCxjPTA7Yzx1OysrYylmb3IodmFyIGY9YysxO2Y8dTsrK2Ype3ZhciBsLHA9aFtjXSxnPWhbZl07KGw9YVtwXSlbcz1HbihsLGcpXSE9PWcmJmwuc3BsaWNlKHMsMCxnKSwobD1hW2ddKVtzPUduKGwscCldIT09cCYmbC5zcGxpY2UocywwLHApfXJldHVybiBhfSxEbj1mdW5jdGlvbih0LG4pe3JldHVybiB0PG4/LTE6dD5uPzE6dD49bj8wOk5hTn0sSG49ZnVuY3Rpb24odCl7cmV0dXJuIDE9PT10Lmxlbmd0aCYmKHQ9RnQodCkpLHtsZWZ0OmZ1bmN0aW9uKG4sZSxyLGkpe2ZvcihudWxsPT1yJiYocj0wKSxudWxsPT1pJiYoaT1uLmxlbmd0aCk7cjxpOyl7dmFyIGE9citpPj4+MTt0KG5bYV0sZSk8MD9yPWErMTppPWF9cmV0dXJuIHJ9LHJpZ2h0OmZ1bmN0aW9uKG4sZSxyLGkpe2ZvcihudWxsPT1yJiYocj0wKSxudWxsPT1pJiYoaT1uLmxlbmd0aCk7cjxpOyl7dmFyIGE9citpPj4+MTt0KG5bYV0sZSk+MD9pPWE6cj1hKzF9cmV0dXJuIHJ9fX0sTm49SG4oRG4pLFFuPShObi5yaWdodCxNYXRoLnNxcnQoNTApLE1hdGguc3FydCgxMCksTWF0aC5zcXJ0KDIpLGZ1bmN0aW9uKHQsbil7cmV0dXJuIGp0KHp0KEl0KHQpLHQpLG4pfSksVW49ZnVuY3Rpb24odCxuKXtpZih0Lmxlbmd0aD44KXJldHVybiB0Lm1hcChmdW5jdGlvbih0LG4pe3JldHVybiBufSk7dmFyIGU9dC5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIG4ubWFwKGZ1bmN0aW9uKG4pe3JldHVybiBYdCh0LG4pfSl9KTtyZXR1cm4gVnQodCxuLGUpfTt0LmludGVycG9sYXRlPUZuLHQuc2VwYXJhdGU9WXQsdC5jb21iaW5lPUd0LHQuaW50ZXJwb2xhdGVBbGw9T3QsdC5zcGxpdFBhdGhTdHJpbmc9Tix0LnRvUGF0aFN0cmluZz1ILHQuZnJvbUNpcmNsZT1IdCx0LnRvQ2lyY2xlPU50LHQuZnJvbVJlY3Q9UXQsdC50b1JlY3Q9VXQsT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSl9KTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/flubber/build/flubber.min.js\n");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay9idWlsZGluL2dsb2JhbC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanM/Y2QwMCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/webpack/buildin/global.js\n");

/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function(module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay9idWlsZGluL21vZHVsZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanM/Y2VkMiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuXHRpZiAoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcblx0XHRpZiAoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XG5cdH1cblx0cmV0dXJuIG1vZHVsZTtcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/webpack/buildin/module.js\n");

/***/ }),

/***/ "./src/Flubber.js":
/*!************************!*\
  !*** ./src/Flubber.js ***!
  \************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _kissmybutton_motorcortex__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @kissmybutton/motorcortex */ \"./node_modules/@kissmybutton/motorcortex/dist/main.js\");\n/* harmony import */ var _kissmybutton_motorcortex__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_kissmybutton_motorcortex__WEBPACK_IMPORTED_MODULE_0__);\n\nconst flubber = __webpack_require__(/*! flubber */ \"./node_modules/flubber/build/flubber.min.js\");\n\nclass Flubber extends _kissmybutton_motorcortex__WEBPACK_IMPORTED_MODULE_0___default.a.API.Incident {\n    onGetContext() {\n        this.interpolator = flubber.interpolate(this.getInitialValue('d'), this.animAttributes.d);\n    }\n\n    getScratchValue(id, attr) {\n        // console.log(this.element.getAttribute('d'));\n        return this.element.getAttribute('d');\n    }\n\n    onProgress(t) {\n        this.element.setAttribute(\"d\", this.interpolator(t));\n    }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Flubber);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvRmx1YmJlci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvRmx1YmJlci5qcz8wODY4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBNb3RvckNvcnRleCBmcm9tIFwiQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleFwiO1xuY29uc3QgZmx1YmJlciA9IHJlcXVpcmUoJ2ZsdWJiZXInKTtcblxuY2xhc3MgRmx1YmJlciBleHRlbmRzIE1vdG9yQ29ydGV4LkFQSS5JbmNpZGVudCB7XG4gIG9uR2V0Q29udGV4dCgpIHtcbiAgICAgIHRoaXMuaW50ZXJwb2xhdG9yID0gZmx1YmJlci5pbnRlcnBvbGF0ZSh0aGlzLmdldEluaXRpYWxWYWx1ZSgnZCcpLCB0aGlzLmFuaW1BdHRyaWJ1dGVzLmQpO1xuICB9XG5cbiAgZ2V0U2NyYXRjaFZhbHVlKGlkLCBhdHRyKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkJykpO1xuICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2QnKTtcbiAgfVxuXG4gIG9uUHJvZ3Jlc3ModCkge1xuICAgIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJkXCIsIHRoaXMuaW50ZXJwb2xhdG9yKHQpKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBGbHViYmVyO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVpBO0FBQ0E7QUFjQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/Flubber.js\n");

/***/ }),

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Flubber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Flubber */ \"./src/Flubber.js\");\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  npm_name: \"@kissmybutton/motorcortex-flubber\",\n  incidents: [{\n    exportable: _Flubber__WEBPACK_IMPORTED_MODULE_0__[\"default\"],\n    name: \"Flubber\"\n  }]\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbWFpbi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvbWFpbi5qcz8yZWUyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBGbHViYmVyIGZyb20gXCIuL0ZsdWJiZXJcIjtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBucG1fbmFtZTogXCJAa2lzc215YnV0dG9uL21vdG9yY29ydGV4LWZsdWJiZXJcIixcbiAgaW5jaWRlbnRzOiBbXG4gICAge1xuICAgICAgZXhwb3J0YWJsZTogRmx1YmJlcixcbiAgICAgIG5hbWU6IFwiRmx1YmJlclwiXG4gICAgfVxuICBdLFxufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRkE7QUFIQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/main.js\n");

/***/ }),

/***/ "./test/script.js":
/*!************************!*\
  !*** ./test/script.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const MCFlubber = __webpack_require__(/*! ../src/main.js */ \"./src/main.js\");\nconst MC = __webpack_require__(/*! @kissmybutton/motorcortex */ \"./node_modules/@kissmybutton/motorcortex/dist/main.js\");\nconst FlubberPlugin = MC.loadPlugin(MCFlubber);\n\nconst myClip = new MC.Clip({\n    id: 'my-clip',\n    type: 'closed',\n    host: document.getElementById('clip-container'),\n    html: `<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"960\" height=\"500\">\n            <g transform=\"translate(240 10) scale(30 30)\">\n                <path id=\"flubber\" d=\"M1,0 L2,2 L0,2 Z\"></path>\n            </g>\n        </svg>`,\n    css: `#flubber{\n        fill: #8b00ff;\n        display:block;\n    }`\n});\n\nconst flubberIncident = new FlubberPlugin.Flubber({\n    animatedAttrs: {\n        d: [[0, 0], [2, 0], [2, 1], [1, 2], [0, 1]]\n    }\n}, {\n    selector: '#flubber',\n    duration: 2000\n});\n\nconst fubberIncident2 = new FlubberPlugin.Flubber({\n    animatedAttrs: {\n        d: \"M2 1 h1 v1 h1 v1 h-1 v1 h-1 v-1 h-1 v-1 h1 z\"\n    }\n}, {\n    selector: '#flubber',\n    duration: 2000\n});\n\nmyClip.addIncident(flubberIncident, 0);\nmyClip.addIncident(fubberIncident2, 2000);\nconsole.log(myClip);\n\n// myClip.play();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi90ZXN0L3NjcmlwdC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy90ZXN0L3NjcmlwdC5qcz84ODdhIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IE1DRmx1YmJlciA9IHJlcXVpcmUoJy4uL3NyYy9tYWluLmpzJyk7XG5jb25zdCBNQyA9IHJlcXVpcmUoJ0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgnKTtcbmNvbnN0IEZsdWJiZXJQbHVnaW4gPSBNQy5sb2FkUGx1Z2luKE1DRmx1YmJlcik7XG5cbmNvbnN0IG15Q2xpcCA9IG5ldyBNQy5DbGlwKHtcbiAgICBpZDogJ215LWNsaXAnLFxuICAgIHR5cGU6ICdjbG9zZWQnLFxuICAgIGhvc3Q6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjbGlwLWNvbnRhaW5lcicpLFxuICAgIGh0bWw6IGA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjk2MFwiIGhlaWdodD1cIjUwMFwiPlxuICAgICAgICAgICAgPGcgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDI0MCAxMCkgc2NhbGUoMzAgMzApXCI+XG4gICAgICAgICAgICAgICAgPHBhdGggaWQ9XCJmbHViYmVyXCIgZD1cIk0xLDAgTDIsMiBMMCwyIFpcIj48L3BhdGg+XG4gICAgICAgICAgICA8L2c+XG4gICAgICAgIDwvc3ZnPmAsXG4gICAgY3NzOiBgI2ZsdWJiZXJ7XG4gICAgICAgIGZpbGw6ICM4YjAwZmY7XG4gICAgICAgIGRpc3BsYXk6YmxvY2s7XG4gICAgfWBcbn0pO1xuXG5jb25zdCBmbHViYmVySW5jaWRlbnQgPSBuZXcgRmx1YmJlclBsdWdpbi5GbHViYmVyKFxuICAgIHtcbiAgICAgICAgYW5pbWF0ZWRBdHRyczoge1xuICAgICAgICAgICAgZDogW1swLCAwXSwgWzIsIDBdLCBbMiwgMV0sIFsxLCAyXSwgWzAsIDFdXVxuICAgICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAgIHNlbGVjdG9yOiAnI2ZsdWJiZXInLFxuICAgICAgICBkdXJhdGlvbjogMjAwMFxuICAgIH1cbik7XG5cbmNvbnN0IGZ1YmJlckluY2lkZW50MiA9IG5ldyBGbHViYmVyUGx1Z2luLkZsdWJiZXIoXG4gICAge1xuICAgICAgICBhbmltYXRlZEF0dHJzOiB7XG4gICAgICAgICAgICBkOiBcIk0yIDEgaDEgdjEgaDEgdjEgaC0xIHYxIGgtMSB2LTEgaC0xIHYtMSBoMSB6XCJcbiAgICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgICBzZWxlY3RvcjogJyNmbHViYmVyJyxcbiAgICAgICAgZHVyYXRpb246IDIwMDBcbiAgICB9XG4pOyBcblxubXlDbGlwLmFkZEluY2lkZW50KGZsdWJiZXJJbmNpZGVudCwgMCk7XG5teUNsaXAuYWRkSW5jaWRlbnQoZnViYmVySW5jaWRlbnQyLCAyMDAwKTtcbmNvbnNvbGUubG9nKG15Q2xpcCk7XG5cblxuLy8gbXlDbGlwLnBsYXkoKTtcblxuXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUpBO0FBU0E7Ozs7QUFUQTtBQUNBO0FBY0E7QUFFQTtBQUNBO0FBREE7QUFEQTtBQU1BO0FBQ0E7QUFGQTtBQUNBO0FBS0E7QUFFQTtBQUNBO0FBREE7QUFEQTtBQU1BO0FBQ0E7QUFGQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFFQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./test/script.js\n");

/***/ })

/******/ });
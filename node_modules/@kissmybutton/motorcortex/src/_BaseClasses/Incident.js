const Helper = require('../_coreUtils/Helper');
const helper = new Helper();
const Channel = require('../_Channels/Channel');
const getIncidentsByChannel = require('../decorators/getIncidentsByChannel');
/* @handleResize is missing from Incident. The reason is that when the
ExtendableClip asks for the under-resize candidates via the "checkResize" pipe
message the message will never be handled by an Incident directly but rather via
its corresponding DOMAwareIncident
*/

/*
dna:
- originalId
- context
*/
class Incident {
    constructor(attrs = {}, props = {}, dna) {
        // super(props);
        this.attrs = attrs;
        this.props = props;
        this.dna = dna;

        this.context = dna.context;
        this.mcid = dna.mcid;

        this.id = props.id || helper.getAnId();
        this.modelId = props.modelId;

        // this parameter is initialised to false. Once the onGetContext method gets invoked this parameter
        // is set to true so we prevent multiple executions of the onGetContext method
        this.gotContext = false;

        /*
        these are the default values that define channeling for the default Incidents. These values get ovewriden through
        the loadPlugin method of MC with the values found on the main.js file of the plugin
        */
        this.plugin_channel_class = Channel;
        this.mc_plugin_npm_name = "motor-cortex-js";
        if (Object.prototype.hasOwnProperty.call(props, "plugin_channel_class")) {
            this.plugin_channel_class = props.plugin_channel_class;
        }
        if (Object.prototype.hasOwnProperty.call(props, "mc_plugin_npm_name")) {
            this.mc_plugin_npm_name = props.mc_plugin_npm_name;
        }

        this.hasIncidents = false;

        /*
        initialValues is an object holding the autmatically computed initial values of the animatedAttrs
        (if any). The initialValues are calculated by the AttributesChannel (only Incidents belonging to
        an AttributesChannel have initialValues).
        The keys set of this object is identical to the object attrs.animatedAttrs
        The only thing the generic AttributesChannel can't calculate is the initial value of an animated attr
        of a specific element when there are no other Incidents entered on its lanes yet. These values are
        the "scratchValues" and they are strongly dependend on the nature of the lib. E.g. for a CSS animation
        what we are looking for can be found on the computedStyle.
        */
        this.initialValues = {};

        /*
        The user has the ability to explicitely define the initial values for any of the animatedAttrs. The user
        can do that by providing the initialValues object on the attrs of the constructor.
        */
        this.userDefinedInitialValues = {};
        if (attrs != null && attrs != undefined) {
            if (Object.prototype.hasOwnProperty.call(attrs, "initialValues")) {
                this.userDefinedInitialValues = attrs.initialValues;
            }
        }

        /**
         * @member {boolean} - if autoGenerated is set to true, it means that this Incident has been auto-generated by its parent on initialisation.
         * This happens when plugins export Incidents that on initialisation they automatically create other incidents and automatically put them
         * on specific points on their timeline.
         */
        this.autoGenerated = false;

        this.onInitialise(attrs, props);
    }


    get selector() {
        return this.props.selector;
    }

    /* shortcuts for attrs.attrs and attrs.animatedAttrs */
    get animAttributes() {
        return this.attrs.animatedAttrs;
    }


    /**
    This method shoudl be overwritten by the Incidents of the plugins. The method returns
    the initial value that the element of it has as the library calculates / defines them. The
    returned value represents the very initial value of the element's attribute before
    any Incident that alters it gets added.

    @returns {mixed} - the initial value of the element's attribute just when the HTML & CSS
    of the Clip gets rendered
    */
    getScratchValue() {
        return 0;
    }

    get element() {
        if (this.contex === null) {
            return [];
        }
        if (this.context.getElementByMCID) {
            return this.context.getElementByMCID(this.mcid);
        }
        return this.context.getElements(this.selector)[0];
    }

    get attributeKey() {
        return Object.keys(this.attrs.animatedAttrs)[0];
    }

    get targetValue() {
        return this.animAttributes[this.attributeKey];
    }

    getElementAttribute(attr) {
        return this.element.getAttribute(attr);
    }

    @getIncidentsByChannel
    getIncidentsByChannel() {}

    _hasUserDefinedInitialValue(attr) {
        return Object.prototype.hasOwnProperty.call(this.userDefinedInitialValues, attr);
    }

    _getUserDefinedInitialValue(attr) {
        return this.userDefinedInitialValues[attr];
    }

    setInitialValue(value) {
        if (this._hasUserDefinedInitialValue(this.attributeKey)) {
            helper.notice(`Incident with id ${this.id} has initial value defined for ${this.attributeKey} and no change is allowed on it`);
            return;
        }
        this.initialValues[this.attributeKey] = value;
    }

    hasInitialValue() {
        const attr = this.attributeKey;
        return this._hasUserDefinedInitialValue(attr) || Object.prototype.hasOwnProperty.call(this.initialValues, attr);
    }

    get initialValue() {
        const attr = this.attributeKey;
        if (this._hasUserDefinedInitialValue(attr)) {
            return this._getUserDefinedInitialValue(attr);
        }
        return this.initialValues[attr];
    }

    getInitialValue() {
        const attr = this.attributeKey;
        if (this._hasUserDefinedInitialValue(attr)) {
            return this._getUserDefinedInitialValue(attr);
        }
        return this.initialValues[attr];
    }


    _onGetContextOnce() {
        // if the Incident belongs to a fragmented context there absolutely
        // no reason to run the getContext method of it
        try {
            if (this.context.fragment === true) {
                return;
            }
            if (!this.gotContext) {
                this.onGetContext();
                this.gotContext = true;
            }
        }
        catch (e) {
            console.log(e);
            console.log(this.mcid);
            // console.log(this.context);
        }
    }

    onGetContext() {
        helper.info('Overwritte the "onGetContext" method with the code you want to get executed', 'info')
    }

    lastWish() {}

    onInitialise() {
        helper.info('Overwritte the "onInialise" method with the code you want to get executed', 'info');
    }

    /**
     * Method called on progress of the timed incident.
     * @param {float} fraction - a number from 0 to 1 representing the fraction of duration covered
     * @param {int} milliseconds - the number of milliseconds passed from start of the incident
     */
    onProgress(fraction, milliseconds) { // eslint-disable-line no-unused-vars

    }


}

module.exports = Incident;

const DescriptiveGroup = require('./DescriptiveGroup');
const _TREECONST = require('../_Tree/_CONST');
const FragmentedClip = require('../_Clip/FragmentedClip');
const Clip = require('../_Clip/SCGroup');
const Channel = require('../_Channels/_Clip/ClipsChannel');
const incidentFromIngredients = require('../IncidentFromDefinition/incidentFromIngredients');
const ClipClone = require('../_Clip/RootClipClone');

class DescriptiveClip extends DescriptiveGroup {
    constructor(attrs, props = null) {
        let attrsToPass, propsToUse;

        if (props === null) {
            attrsToPass = {};
            propsToUse = attrs;
        }
        else { // else, in case the user has passed two arguments then both should be used
            attrsToPass = attrs;
            propsToUse = props;
        }

        super(attrsToPass, propsToUse);

        // isTheRootClip defines whether the Clip is the root or not. It depends on
        // the host or selector parameter passed on props (if host is present then
        // the Clip is the root Clip while if the Clip gets initialised by a selector
        // is not)
        this.isTheRootClip = false;
        // check if
        let ingredients = {
            id: this.id,
            attrs: attrsToPass,
            props: {
                ...propsToUse,
                html: Object.prototype.hasOwnProperty.call(propsToUse, "html") ? propsToUse.html : this.html,
                css: Object.prototype.hasOwnProperty.call(propsToUse, "css") ? propsToUse.css : this.css,
                fonts: Object.prototype.hasOwnProperty.call(propsToUse, "fonts") ? propsToUse.fonts : this.fonts
            },
            plugin_npm_name: this.constructor.plugin_npm_name,
            Channel: this.constructor.Channel
        };

        if (Object.prototype.hasOwnProperty.call(propsToUse, "selector") && propsToUse.selector !== undefined) {
            ingredients.Incident = FragmentedClip;
            // TODO it doesn't take in account the get html and get css of the Descriptive Clip
        }
        else {
            this.isTheRootClip = true;
            ingredients.Incident = this.constructor.Incident;
        }

        this.realClip = incidentFromIngredients(ingredients);
        if (this.isTheRootClip) {
            this.realClip.subscribeToDurationChange((newDuration) => {
                // TODO this.informForDurationChange();
            });
        }

        // passiveAddition is a flag property indicating that any Incident to be
        // added to the Clip will be passive. It initialises with value = false
        // on DescriptiveGroup where it's originaly defined.
        // Here we change its value just before the buildTree method execution
        // so all Incidents added on it get the "passive" flag and don't get
        // exported on the exportDefinition method. Once the buildTree method
        // finishes we set it back to its original value (false)
        this.passiveAddition = true;
        this._buildTree();
        this.passiveAddition = false;
    }

    static isClip = true; // a static member to help incidentFromDefinition identify clips
    static Incident = Clip;
    static plugin_npm_name = "@kissmybutton/self-contained-incidents";
    static Channel = Channel;
    static ClassName = "Clip";

    get selectorToPassToChildren() {
        return null; // the Clip (any Clip) resets the selection cascading
    }

    get inheritedSelector() {
        return this._inheritedSelector;
    }

    set inheritedSelector(value) {
        this._inheritedSelector = value;
    }

    get html() {
        return '';
    }

    get css() {
        return '';
    }

    get fonts() {
        return [];
    }

    /*
    the _buildTree method acts as a proxy to the buildTree method defined by the
    developers. The reason for this is that the actual buildTree method should
    be executed in different order on Groups and on Clips (that extend Groups).
    Calling the super on constructor fires the _buildTree execution on the
    Group's constructor but this breaks on Clip as the realClip has not been
    initialised yet.
    */
    _buildTree() {
        if (this.realClip === undefined) {
            return;
        }
        this.buildTree();
    }

    get runTimeInfo() {
        return this.realClip.runTimeInfo;
    }

    /**
     * When the resize command is given directly to a DescriptiveClip no checks
     * need to be performed.
     * DescriptiveClip directly invokes the _resize method of ExtendableClip which
     * resizes the full clip
     */
    resize(newSize) {
        this.realClip._resize(newSize / this.duration);

        this.duration = newSize;
        this.putMessageOnPipe('recalcDuration', {}, 'Groups', { selfExecute: false, direction: _TREECONST._DIRECTIONS._UP });
        this.putMessageOnPipe('flash', {}, 'RootClip', { selfExecute: true, direction: _TREECONST._DIRECTIONS._UP });

        return {
            result: true
        }
    }

    /*************************** HANDLING METHODS *******************************/
    handleCheckForClip(target, payload) { // eslint-disable-line no-unused-vars
        return true;
    }

    handleCheckAddition(target, payload) {
        /* Is the responsibility of the DescriptiveClip to pass the addition request
        to its real clip and expect for a response. */
        const res = this.realClip.addIncident(payload);
        if (res.result === true) {
            this.putMessageOnPipe('flash', {}, 'RootClip', { selfExecute: true, direction: _TREECONST._DIRECTIONS._UP });
        }
        return res;
    }

    handleCheckMove(target, payload) {
        const res = this.realClip.moveIncident(payload);
        if (res.result === true) {
            this.putMessageOnPipe('flash', {}, 'RootClip', { selfExecute: true, direction: _TREECONST._DIRECTIONS._UP });
        }
        return res;
    }

    handleCheckDeletion(target, payload) {
        const res = this.realClip.removeIncident(payload);
        if (res.result === true) {
            this.putMessageOnPipe('flash', {}, 'RootClip', { selfExecute: true, direction: _TREECONST._DIRECTIONS._UP });
        }
        return res;
    }

    handleCheckResize(target, payload) {
        const res = this.realClip.resizeIncident(payload);
        if (res.result === true) {
            this.putMessageOnPipe('flash', {}, 'RootClip', { selfExecute: true, direction: _TREECONST._DIRECTIONS._UP });
        }
        return res;
    }

    handleCheckEditAttributes(target, payload) { // eslint-disable-line no-unused-vars
        return {
            result: true
        }
    }

    handleCheckEditProperties(target, payload) { // eslint-disable-line no-unused-vars
        return {
            result: true
        }
    }

    handleFlash(target, payload) { // eslint-disable-line no-unused-vars
        if (this.isTheRootClip) {
            this.flash();
        }
        else {
            return this.bypass();
        }
    }

    /*********************** execution methods proxy *****************
     ****************************************************************/

    play(debug = false) {
        if (this.isTheRootClip) {
            this.realClip.play(debug);
            return true;
        }
        return false;
    }

    pause() {
        if (this.isTheRootClip) {
            this.realClip.pause();
            return true;
        }
        return false;
    }

    complete() {
        if (this.isTheRootClip) {
            this.realClip.complete();
            return true;
        }
        return false;
    }

    stop() {
        if (this.isTheRootClip) {
            this.realClip.stop();
            return true;
        }
        return false;
    }

    flash() {
        if (this.isTheRootClip) {
            this.realClip.flash();
            return true;
        }
        return false;
    }

    onProgress(fraction, millisecond) {
        if (this.isTheRootClip) {
            this.realClip.onProgress(fraction, millisecond);
            return true;
        }
        return false;
    }

    set executionSpeed(speed) {
        if (this.isTheRootClip) {
            this.realClip.executionSpeed = speed;
            return true;
        }
        return false;
    }


    /*********************** pub-sube methods proxy *******************
     ****************************************************************/
    subscribe(id, funct, threshold, roundTo) {
        if (this.isTheRootClip) {
            this.realClip.subscribe(id, funct, threshold, roundTo);
            return true;
        }
        return false;
    }

    unsubscribe(id) {
        return this.realClip.unsubscribe(id);
    }

    subscribeToDurationChange(funct) {
        if (this.isTheRootClip) {
            this.realClip.subscribeToDurationChange(funct);
            return true;
        }
        return false;
    }

    /*************************************************************/
    paste(host) {
        if (this.isTheRootClip) {
            const clipClone = new ClipClone({
                host: host,
                descriptiveIncident: this
            });
            return clipClone;
        }
        return null;
    }
}

module.exports = DescriptiveClip;

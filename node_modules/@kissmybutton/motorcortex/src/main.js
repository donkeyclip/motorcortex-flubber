let Validator = require("fastest-validator");

const DescriptiveIncident = require('./_DescriptiveIncidents/DescriptiveIncident');
const DescriptiveGroup = require('./_DescriptiveIncidents/DescriptiveGroup');
const DescriptiveClip = require('./_DescriptiveIncidents/DescriptiveClip');
const Incident = require('./_BaseClasses/Incident');

const AttributeChannel = require('./_Channels/_Attribute/AttributeChannel');

const TimeCapsule = require('./_coreUtils/TimeCapsule')

const Helper = require('./_coreUtils/Helper');
const helper = new Helper();

const checkPlugin = function (main) {
    if (Object.prototype.hasOwnProperty.call(main, "default")) {
        main = main.default;
    }

    const plugin_name = main.npm_name;
    let check = true;

    if (!Object.prototype.hasOwnProperty.call(main, "name")) {
        helper.error(`Warning on plugin ${plugin_name}. A plugin is always good to have its name on
        its main.js file, under the key "name". It's missing from this plugin`);
    }

    if (!Object.prototype.hasOwnProperty.call(main, "incidents")) {
        helper.error(`Error on plugin ${plugin_name}. A plugin must expose at least one Incident.
        Exposed plugin Incidents should be defined on the "incidents" key of the main.js file.`);
        check = false;
    }

    if (!helper.isArray(main.incidents)) {
        helper.error(`Error on plugin ${plugin_name}. thePlugin exposed Incidents are defined on the "incidents" key of the main.js file in array format.
        Please refer to the documentation`);
        check = false;
    }
    else {
        for (let i = 0; i < main.incidents.length; i++) {
            const exposedIncidentDefinition = main.incidents[i];

            if (typeof exposedIncidentDefinition.exportable === "object") {
                if (Object.prototype.hasOwnProperty.call(exposedIncidentDefinition.exportable, "default")) {
                    exposedIncidentDefinition.exportable = exposedIncidentDefinition.exportable.default;
                }
            }

            if (!(exposedIncidentDefinition.exportable.prototype instanceof DescriptiveGroup) &&
                !(exposedIncidentDefinition.exportable.prototype instanceof DescriptiveClip) &&
                !(exposedIncidentDefinition.exportable.prototype instanceof Incident)) {
                helper.error(`Error on plugin ${plugin_name}. Exportable Incidents by any plugin must extend one of the base classes provided by MotorCortex.
                ${exposedIncidentDefinition.exportable.constructor.name} doesn't.
                Please refer to documentation`);
                check = false;
            }

            if (!Object.prototype.hasOwnProperty.call(exposedIncidentDefinition, "name")) {
                helper.error(`Error on plugin ${plugin_name}. Exportable Incidents by any plugin must have the "name" key which defines the name of the exported Incident.
                Please refer to documentation`);
                check = false;
            }

            if (!Object.prototype.hasOwnProperty.call(exposedIncidentDefinition, "propTypes")) {
                helper.log(`Warning on plugin ${plugin_name}.
                It's always good for plugins to define the supported propTypes of their exposed Incidents' supported properties.
                ${exposedIncidentDefinition.exportable.constructor.name} doesn't.
                Please refer to documentation`, 'warning');
            }
        }
    }

    return check;
}

// plugin_name is the unique name of the plugin
function loadPlugin(plugin) {
    if (Object.prototype.hasOwnProperty.call(plugin, "default")) {
        plugin = plugin.default;
    }

    if (!Object.prototype.hasOwnProperty.call(plugin, "npm_name")) {
        plugin.npm_name = `plugin_${new Date().getTime()}`;
    }

    if (!checkPlugin(plugin)) {
        return false;
    }
    else {
        // thePlugin is the plugin object which will hold on its keys
        // the names of the exposed Incidents of its. The keys of this object
        // are going to be identical with the names of the classes exposed
        const thePlugin = {};

        if (Object.prototype.hasOwnProperty.call(plugin, "clip")) {
            // TODO Custom Clips strategy
        }

        // if the plugin definition has compositeAttributes then we dynamically
        // create a new Channel class extending AttributeChannel setting the
        // composite Attributes on the fly. We can then use this Channel class
        // for all Incidents exposed by the plugin
        let AttributeChannelToUse = AttributeChannel;
        if (Object.prototype.hasOwnProperty.call(plugin, "compositeAttributes")) {
            AttributeChannelToUse = class extends AttributeChannel {
                constructor(props) {
                    props.comboAttributes = plugin.compositeAttributes;
                    super(props);
                }
            }
        }

        // for each of the exposed Incidents
        for (let i = 0; i < plugin.incidents.length; i++) {
            const incidentClass = plugin.incidents[i].exportable;

            let DynamicDescriptiveIncident;
            // the exportable Incident can be either a Clip, a Compo or an Incident
            // if it is an Incident
            if (incidentClass.prototype instanceof Incident) {
                DynamicDescriptiveIncident = class extends DescriptiveIncident {
                    static Incident = incidentClass;
                    static plugin_npm_name = plugin.npm_name;
                    static plugin = plugin.name;
                    static ClassName = plugin.incidents[i].name;
                    static Channel = AttributeChannelToUse;
                }
            } // else if it is a Clip
            else if (incidentClass.prototype instanceof DescriptiveClip) {
                DynamicDescriptiveIncident = class extends incidentClass {
                    // static Incident = incidentClass;
                    static plugin = plugin.name;
                    static ClassName = plugin.incidents[i].name;
                }
            }
            else if (incidentClass.prototype instanceof DescriptiveGroup) {
                DynamicDescriptiveIncident = class extends incidentClass {
                    // static Incident = incidentClass;
                    static plugin = plugin.name;
                    static ClassName = plugin.incidents[i].name;
                }
            }

            Object.defineProperty(thePlugin, plugin.incidents[i].name, {
                get() {
                    // the getter will construct a wrapper class which on the constructor will instantiate an object of the
                    // exposed class, set to it the plugin name and channel class parameters and return
                    // it from the constructor
                    class WrapperClass {
                        constructor(attrs, props) {
                            const instantiatedIncident = new DynamicDescriptiveIncident(attrs, props);

                            if (Object.prototype.hasOwnProperty.call(plugin.incidents[i], "attributesValidationRules")) {
                                const v = new Validator();
                                const validationResult = v.validate(attrs, plugin.incidents[i].attributesValidationRules);
                                if (validationResult.length > 0) {
                                    return {
                                        result: false,
                                        errors: validationResult
                                    }
                                }
                            }
                            else {
                                helper.warning(`It's always good to provide attributesValidationRules to the exported incidents. ${plugin.npm_name}.${instantiatedIncident.constructor.name} doesn't provide it`)
                            }
                            return instantiatedIncident;
                        }
                    }
                    return WrapperClass;
                }
            })
        }
        return thePlugin;
    }

}

module.exports = {
    API: {
        Incident: Incident,
        Group: DescriptiveGroup,
        Clip: DescriptiveClip
    },
    Group: DescriptiveGroup,
    Clip: DescriptiveClip,
    loadPlugin: loadPlugin,
    TimeCapsule: TimeCapsule
}

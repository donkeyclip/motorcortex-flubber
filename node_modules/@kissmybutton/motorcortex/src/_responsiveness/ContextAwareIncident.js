const Leaf = require('../_Tree/Leaf');
const incidentFromIngredients = require('../IncidentFromDefinition/incidentFromIngredients');
const getIncidentsByChannel = require('../decorators/getIncidentsByChannel');


class ContextAwareIncident extends Leaf {
    constructor(constructionIngredients, contextData, mcid, attribute) {
        super({ id: `${constructionIngredients.incidentId}_${mcid}_${attribute}` });

        // a property to hold all of the contexts
        this.contexts = {};

        this.constructionIngredients = constructionIngredients;
        this.mcid = mcid;
        this.attribute = attribute;
        this._duration = constructionIngredients.props.duration;

        this.mc_plugin_npm_name = constructionIngredients.plugin_npm_name;
        this.plugin_channel_class = constructionIngredients.Channel;

        this.addContext(contextData);

        if (typeof this.constructionIngredients.attrs.animatedAttrs[this.attribute] === 'object') {
            this.originalAnimatedAttributeValue = Object.assign({}, this.constructionIngredients.attrs.animatedAttrs[this.attribute]);
        }
        else {
            this.originalAnimatedAttributeValue = this.constructionIngredients.attrs.animatedAttrs[this.attribute];
        }
    }


    get originalContext() {
        return this.contexts[this.originalContextKey];
    }


    get duration() {
        return this._duration;
    }

    set duration(milliseconds) {
        this._duration = milliseconds;

        for (let context in this.contexts) {
            this.contexts[context].duration = milliseconds;
        }
    }

    addContext(contextData, forceGetContext = false) {
        // if it's the first context to be added then it's the original
        let isTheOriginalContext = false;
        if (Object.keys(this.contexts).length === 0) {
            this.originalContextKey = contextData.clipId;
            isTheOriginalContext = true;
        }

        const ingredientsToPass = { ...this.constructionIngredients, context: contextData.context, mcid: this.mcid };
        const whatToAdd = incidentFromIngredients(ingredientsToPass);
        this.contexts[contextData.clipId] = whatToAdd;

        // when we add a new context we must set the inital value of the newly added Incidents
        if (!isTheOriginalContext) {
            this.contexts[contextData.clipId].setInitialValue(this.getInitialValue());
        }

        if (forceGetContext === true) {
            this.contexts[contextData.clipId]._onGetContextOnce();
        }
    }

    handleAddContext(target, payload) {
        this.addContext(payload, true);
        return true;
    }

    @getIncidentsByChannel
    getIncidentsByChannel() {}

    onProgress(fraction, milliseconds, contextId) {
        if (contextId === undefined) {
            for (let context in this.contexts) {
                this.contexts[context].onProgress(fraction, milliseconds);
            }
            return;
        }

        try {
            this.contexts[contextId].onProgress(fraction, milliseconds);
        }
        catch (e) {
            console.log('--------- ERROR -----------');
            console.log(e);
        }
    }

    /** METHODS THAT ACT AS "PROXY" TO ALL OF THE INCIDENTS BELONGING TO
     * THE INCIDENTS COLLECTION OF THE CONTEXT AWARE INCIDENT
     **/

    // sample methods. Return the required information out of the Incident of
    // the originalContext
    hasInitialValue() {
        return this.originalContext.hasInitialValue();
    }

    getInitialValue(attribute = null) {
        if (attribute === null) {
            attribute = this.attribute;
        }
        return this.originalContext.getInitialValue();
    }

    get animatedAttributeValue() {
        return this.constructionIngredients.attrs.animatedAttrs[this.attribute];
    }

    getScratchValue() {
        return this.originalContext.getScratchValue();
    }

    // massive editing methods that apply the request massively to all of the
    // Incidents of all of the contexts
    gotContext() {
        for (let context in this.contexts) {
            this.contexts[context].gotContext();
        }
    }

    _onGetContextOnce() {
        for (let context in this.contexts) {
            this.contexts[context]._onGetContextOnce();
        }
    }

    lastWish() {
        for (let context in this.contexts) {
            this.contexts[context].lastWish();
        }
    }

    onGetContext() {
        for (let context in this.contexts) {
            this.contexts[context].onGetContext();
        }
    }

    setInitialValue(value) {
        for (let context in this.contexts) {
            this.contexts[context].setInitialValue(value);
        }
    }

    setCompoAttrKeyValue(key, value) {
        for (let context in this.contexts) {
            this.contexts[context].attrs.animatedAttrs[this.attribute][key] = value;
            this.contexts[context].lastWish();
            this.contexts[context].onGetContext();
        }
    }


}

module.exports = ContextAwareIncident;

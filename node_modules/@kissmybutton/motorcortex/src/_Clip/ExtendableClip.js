const Helper = require('../_coreUtils/Helper');
const helper = new Helper();
const Group = require('../_BaseClasses/Group');
const selfContainedIncidentsNpmName = '@kissmybutton/self-contained-incidents'; // TODO remove this
const _TREECONST = require('../_Tree/_CONST');


class ExtendableClip extends Group {
    /**
     * @param {object} props - an object that should contain all of the following keys:
     * - html (the html template to render)
     * - css (the css template of the isolated tree)
     * - initParams (optional / the initialisation parameteres that will be passed both on the css and the html templates in order to render)
     * - host (an Element object that will host the isolated tree)
     * - containerParams (an object that holds parameters to affect the container of the isolated tree, e.g. width, height etc)
     * - type (optional, defaults to "iframe") the type of the Clip. It can be one of the:
     *  - iframe
     *  - plain
     */
    constructor(attrs, props) {
        super(attrs, props);

        this.attrs = attrs;
        this.props = props;

        this.isTheClip = true;
        this.volume = 1;
        this.speed = 1;

        this.blockingWaitings = {};

        /**
         * The cnannels attribute holds a list of all intantiated Channels of the Incidents belonging to the clip
         * this attribute is only valuable when the Group becomes the Clip
         * The format of the attribute is:
         *  key-value pairs in the manner:
         * <mc_plugin_npm_name>: Channel object
         */
        this.instantiatedChannels = {};

        /**
         * The instantiatedCopiesContexts is a key-value pairs colleciton holding the
         * contexts of all instantiated ClipCopies
         **/
        this.instantiatedCopiesContexts = {};

        this.onClipInitialise();

        this.durationSubs = [];

        this.runTimeInfo = {
            currentMillisecond: 0,
            state: 'idle' // supported states: idle, playing, paused, blocked
        }

        /**
          @member {object} - listeners are functions to be executed on time change of the Clip.
          It has the following format:
         listeners: {
            listener_id: {
                     funct : the function to be executed
                     threshold : the threshold of delta
                     roundTo : round millisecond
                 },
                 listener_id: {
                     funct : the function to be executed
                     threshold : the threshold of delta
                     roundTo : round millisecond
                 },
                 ...
           }
           */
        this.listeners = {};

        // previousTimeStamp is a property holding the last timestamp that the
        // requestAnimationFrame ran
        this.previousTimeStamp = -1;
    }


    onClipInitialise() {
        // called when group gets initialised
    }

    set executionSpeed(speed) {
        this.speed = parseFloat(speed);
    }

    /**
     * This method is been called when a new ClipCopy enters the real tree successfully.
     * @param {object} contextData - keys: clipId, context
     **/
    addContext(contextData) {
        this.instantiatedCopiesContexts[contextData.clipId] = contextData.context;
        contextData.instantiatedCopiesContexts = this.instantiatedCopiesContexts;
        const res = this.putMessageOnPipe('addContext', contextData, {}, { selfExecute: false, direction: _TREECONST._DIRECTIONS._DOWN });
        return res;
    }

    /*
    ExtendableClip (as its name implies) is a Class that should be extended by
    any specific kind of Clip, such as Fragmented or SCGroup. This method must
    be overitten by the new Classes. This definition here is just for reference / help
    purposes
    */
    exportConstructionArguments() {
        return {
            attrs: this.attrs,
            props: this.props
        }
    }

    /**
     * completely resizes the Clip without any checks
     */
    _resize(durationFraction) {
        for (let key in this.instantiatedChannels) {
            this.instantiatedChannels[key]._resize(durationFraction);
        }
        this.setNewDuration(this.duration * durationFraction);
        for (let i = 0; i < this.durationSubs.length; i++) {
            this.durationSubs[i](this.duration);
        }
    }

    // ************ PUB SUB ********************
    // *****************************************
    /**
      By subscribing a module can get notified about changes on the Clip's time
      subscribe method subscribes a function to the time change dispatcher. As Clip uses requestAnimationFrame for its timing
      each cyrcle / step gets the current time and subtracts the previous time so it know how many milliseconds has elapsed
      since last step. Subscribers can set to get informed about time changes only if the delta is greater than a given
      number (e.g. greater than 300ms). That property is passed as the second argument "threshold".
      Finally if any of the subscribers want the Scene to provide back a rounded number of the milliseconds. Options:
        - 1 (round it on its actual units
       - 10 (round it on tenths)
       - 100 (round it on hundreds)
       - 1000 (round it on thousands)
      the first argument provides an id to the listener for future reference (deletion etc)
      the second argument is a function that takes two arguments: millisecond, state (current millisecond of the Scene
      and the state of it  */
    subscribe(id, funct, threshold, roundTo) {
        if (!threshold) {
            threshold = 0;
        }
        if (!roundTo) {
            roundTo = 1; // round second to its units, meaning leave it as it is
        }
        this.listeners[id] = {
            funct: funct,
            threshold: threshold,
            roundTo: roundTo,
            cavaDelta: 0
        };
    }

    unsubscribe(id) {
        if (Object.prototype.hasOwnProperty.call(this.listeners, id)) {
            delete this.listeners[id];
        }
    }



    /*********************************************************
    Editing commands input methods
    *********************************************************/
    /**
     * This command comes form the Clip's parent Descriptor class. The payload
     * is identical to the payload that comes to the Description class:
     * {
     *  incident: the Descriptive Incident to be added
     *  millisecond: the millisecond to add it
     *  parentGroupId: the id of the Group to which we want to the Incident to
     * }
     */
    addIncident(payload) {
        const candidates = this.putMessageOnPipe('addIncident', {
                incident: payload.incident,
                millisecond: payload.millisecond,
                parentGroupId: payload.parentGroupId,
                contextData: {
                    clipId: this.id,
                    context: this.context
                }
            },
            payload.parentGroupId, { selfExecute: true, direction: _TREECONST._DIRECTIONS._DOWN });
        // concatenate candidates
        // console.log(candidates);

        const totalIncidentsByPlugin = {};
        for (let i = 0; i < candidates.length; i++) {
            const incidentsByPlugin = candidates[i].response.getIncidentsByChannel(candidates[i].positionDelta + payload.millisecond);
            for (let pluginName in incidentsByPlugin) {
                if (!Object.prototype.hasOwnProperty.call(totalIncidentsByPlugin, pluginName)) {
                    totalIncidentsByPlugin[pluginName] = [];
                }
                totalIncidentsByPlugin[pluginName].push(...incidentsByPlugin[pluginName]);
            }
        }
        const res = this.checkAddition(totalIncidentsByPlugin);
        if (res.result === true) {
            res.execute();

            // up to that point the only context Incident that has been initialised on the
            // ContextAwareIncidents of the candidates is the original context of the
            // ExtendableClip.
            for (let i = 0; i < candidates.length; i++) {
                candidates[i].responder.addChild(candidates[i].response, payload.millisecond);

                // recalculate duration the groups that we added
                // the incidents to along with their parents
                candidates[i].responder.putMessageOnPipe('recalcDuration', {}, 'Groups', { selfExecute: true, direction: _TREECONST._DIRECTIONS._UP });

                // we also need to add every existing (copied) context to the ContextAwareIncidents
                // created on the candidates process
                for (let contextKey in this.instantiatedCopiesContexts) {
                    candidates[i].responder.putMessageOnPipe('addContext', {
                            clipId: contextKey,
                            context: this.instantiatedCopiesContexts[contextKey]
                        },
                        'ContextAwareIncidents', { selfExecute: false, direction: _TREECONST._DIRECTIONS._DOWN });
                }
            }
        }
        return res;
    }


    // *******************************************************
    // INCIDENTS MANAGEMENT METHODS
    // POLYMORPHISM APPLIED. IF THE GROUP HAS NO PARENT IT ACTS AS A SCENE. IF THE GROUP HAS PARENT IT ACTS AS
    // A "TRANSPARENT GROUP"

    /**
     * The method returns either:
        {
            result:true,
            execute: // an array of functions that when executed it will add the Incidents on the Channels
        }
        or
        {
            result: false,
            errors
        }
    */
    checkAddition(incidentsById, type = "all-or-nothing") {
        // prepare the return payload
        let toReturnResult = true;
        let toReturnErrors = [];
        let toReturnExecutables = [];

        // for each key of the incidentsById object perform the check
        for (let key in incidentsById) {
            // if the clip had no channel instantiated for the specific key (plugin id) yet create it
            if (!Object.prototype.hasOwnProperty.call(this.instantiatedChannels, key)) {
                // intstantiate the channel of the plugin by using the reference to the class definition stored on
                // the very first incident of the array
                this.instantiatedChannels[key] = new incidentsById[key][0].incident.plugin_channel_class({
                    runTimeInfo: this.runTimeInfo,
                    context: this.context,
                    getIncidentById: this.getIncidentById
                });
            }

            // perform the check
            const pluginResult = this.instantiatedChannels[key].addIncidents(incidentsById[key], type);
            toReturnResult = toReturnResult && pluginResult.result;
            if (pluginResult.result === false) {
                toReturnErrors = toReturnErrors.concat(pluginResult.errors);
            }
            else {
                toReturnExecutables.push(pluginResult.execute);
            }
        } // enf of iteration on the incidentsById keys

        const toReturnExecute = function () {
            for (let i = 0; i < toReturnExecutables.length; i++) {
                toReturnExecutables[i]();
            }
        }

        const additionResult = {
            result: toReturnResult,
            errors: toReturnErrors,
            execute: toReturnExecute
        }
        return additionResult;
    }


    /**
     * This command comes form the Clip's parent Descriptor class. The payload
     * is identical to the payload that comes to the Description class:
     * {
     *  incident: the Descriptive Incident to be repositioned
     *  millisecond: the new millisecond to put it
     *  parentGroupId: the id of the
     * }
     */
    moveIncident(payload) {
        const candidates = this.putMessageOnPipe('moveIncident', {
                incidentId: payload.id,
                millisecond: payload.millisecond,
                parentGroupId: payload.parentGroupId,
                contextData: {
                    clipId: this.id,
                    context: this.context
                }
            },
            payload.parentGroupId, { selfExecute: true, direction: _TREECONST._DIRECTIONS._DOWN });

        const totalIncidentsByPlugin = {};
        for (let i = 0; i < candidates.length; i++) {
            const incidentsByPlugin = candidates[i].response.getIncidentsByChannel(candidates[i].positionDelta + payload.millisecond);
            for (let pluginName in incidentsByPlugin) {
                if (!Object.prototype.hasOwnProperty.call(totalIncidentsByPlugin, pluginName)) {
                    totalIncidentsByPlugin[pluginName] = [];
                }
                totalIncidentsByPlugin[pluginName].push(...incidentsByPlugin[pluginName]);
            }
        }

        const res = this.checkMove(totalIncidentsByPlugin, payload.positionDelta);
        if (res.result === true) {
            res.execute();
            for (let i = 0; i < candidates.length; i++) {
                candidates[i].responder.editPosition(candidates[i].response.id, payload.millisecond);

                // recalculate duration the groups that we added
                // the incidents to along with their parents
                candidates[i].responder.putMessageOnPipe('recalcDuration', {}, 'Groups', { selfExecute: true, direction: _TREECONST._DIRECTIONS._UP });
            }
        }
        return res;
    }

    /**
     * The checkEdit method serves exactly what its name implies. To check if the edit of an Incident (edit of Incident's position given in milliseconds delta)
     * is valid and accepted, according to the rules defined on the channels.
     * The method boobles up until it reaches the Clip.
     * @param {object} incident - the incident to edit
     * @param {int} millisecondsDelta - the milliseconds delta of the Incident's start time
     The method should return either:
        {
            result:true,
            execute: // an array of functions that when executed it will edit the Incidents on the Channels
        }
        or
        {
            result: false,
            errors
        }
    */
    checkMove(incidentsById, millisecondsDelta) {
        // prepare the return payload
        let toReturnResult = true;
        let toReturnErrors = [];
        let toReturnExecutables = [];

        // for each key of the incidentsById object perform the check
        for (let key in incidentsById) {
            // perform the check
            const pluginResult = this.instantiatedChannels[key].editIncidents(incidentsById[key], millisecondsDelta);
            toReturnResult = toReturnResult && pluginResult.result;
            if (pluginResult.result === false) {
                toReturnErrors = toReturnErrors.concat(pluginResult.errors);
            }
            else {
                toReturnExecutables.push(pluginResult.execute);
            }
        } // enf of iteration on the incidentsById keys

        const toReturnExecute = function () {
            for (let i = 0; i < toReturnExecutables.length; i++) {
                toReturnExecutables[i]();
            }
        }

        const editResult = {
            result: toReturnResult,
            errors: toReturnErrors,
            execute: toReturnExecute
        }
        return editResult;
    }

    removeIncident(payload) {
        const candidates = this.putMessageOnPipe('removeIncident', {
                incidentId: payload.id,
                parentGroupId: payload.parentGroupId,
                contextData: {
                    clipId: this.id,
                    context: this.context
                }
            },
            payload.parentGroupId, { selfExecute: true, direction: _TREECONST._DIRECTIONS._DOWN });

        const totalIncidentsByPlugin = {};
        for (let i = 0; i < candidates.length; i++) {
            const incidentsByPlugin = candidates[i].response.getIncidentsByChannel();
            for (let pluginName in incidentsByPlugin) {
                if (!Object.prototype.hasOwnProperty.call(totalIncidentsByPlugin, pluginName)) {
                    totalIncidentsByPlugin[pluginName] = [];
                }
                totalIncidentsByPlugin[pluginName].push(...incidentsByPlugin[pluginName]);
            }
        }

        const res = this.checkDelete(totalIncidentsByPlugin);
        if (res.result === true) {
            res.execute();
            for (let i = 0; i < candidates.length; i++) {
                candidates[i].responder.removeChild(candidates[i].response.id);

                // recalculate duration the groups that we added
                // the incidents to along with their parents
                candidates[i].responder.putMessageOnPipe('recalcDuration', {}, 'Groups', { selfExecute: true, direction: _TREECONST._DIRECTIONS._UP });
            }
        }
        return res;
    }


    /**
     * The checkDelete method serves exactly what its name implies. To check if the deletion of an Incident
     * is valid and accepted, according to the rules defined on the channels.
     * The method boobles up until it reaches the Clip.
     * @param {object} incident - the incident to edit
      The result might be either:
        {
            result:true,
            execute: // an array of functions that when executed it will remove the Incident on the Channels
        }
        or
        {
            result: false,
            errors
        }
    */
    checkDelete(incidentsById) {
        // prepare the return payload
        let toReturnResult = true;
        let toReturnErrors = [];
        let toReturnExecutables = [];

        // for each key of the incidentsById object perform the check
        for (let key in incidentsById) {
            // perform the check
            const pluginResult = this.instantiatedChannels[key].removeIncidents(incidentsById[key]);
            toReturnResult = toReturnResult && pluginResult.result;
            if (pluginResult.result === false) {
                toReturnErrors = toReturnErrors.concat(pluginResult.errors);
            }
            else {
                toReturnExecutables.push(pluginResult.execute);
            }
        } // enf of iteration on the incidentsById keys

        const toReturnExecute = function () {
            for (let i = 0; i < toReturnExecutables.length; i++) {
                toReturnExecutables[i]();
            }
        }

        const removeResult = {
            result: toReturnResult,
            errors: toReturnErrors,
            execute: toReturnExecute
        }
        return removeResult;
    }

    /**
     * This command comes form the Clip's parent Descriptor class. The payload
     * is identical to the payload that comes to the Description class:
     * {
     *  id: the id of the Incident to resize
     *  newSize: the milliseconds of the new duration
     *  fraction: the division of the new duration to the current
     * }
     */
    resizeIncident(payload) {
        const candidates = this.putMessageOnPipe('resize', {
                incidentId: payload.id,
                newSize: payload.newSize,
                fraction: payload.fraction,
                contextData: {
                    clipId: this.id,
                    context: this.context
                }
            },
            payload.id, { selfExecute: false, direction: _TREECONST._DIRECTIONS._DOWN });

        const totalIncidentsByPlugin = {};
        for (let i = 0; i < candidates.length; i++) {
            const incidentsByPlugin = candidates[i].response.getIncidentsByChannel(candidates[i].positionDelta);
            for (let pluginName in incidentsByPlugin) {
                if (!Object.prototype.hasOwnProperty.call(totalIncidentsByPlugin, pluginName)) {
                    totalIncidentsByPlugin[pluginName] = [];
                }
                totalIncidentsByPlugin[pluginName].push(...incidentsByPlugin[pluginName]);
            }
        }

        const res = this.checkResize(payload.fraction, totalIncidentsByPlugin, candidates[0].positionDelta);
        if (res.result === true) {
            res.execute();
            for (let i = 0; i < candidates.length; i++) {
                candidates[i].responder.setNewDuration(payload.newSize);
            }
        }
        return res;
    }

    /**
     * checks if a duration edit is feasible and doesn't cause conflicts
     * @param {int} duration - the new duration
     **/
    checkResize(durationFraction, incidentsById, adjustMillisecond = 0) {
        // prepare the return payload
        let toReturnResult = true;
        let toReturnErrors = [];
        let toReturnExecutables = [];
        // for each key of the incidentsById object perform the check
        for (let key in incidentsById) {
            // perform the check
            const adjustedIncidents = helper.systoleDiastoleProjections(incidentsById[key], durationFraction, adjustMillisecond);
            const pluginResult = this.instantiatedChannels[key].checkResizedIncidents(adjustedIncidents);
            toReturnResult = toReturnResult && pluginResult.result;
            if (pluginResult.result === false) {
                toReturnErrors = toReturnErrors.concat(pluginResult.errors);
            }
            else {
                toReturnExecutables.push(pluginResult.execute);
            }
        } // enf of iteration on the incidentsById keys

        const toReturnExecute = function () {
            for (let i = 0; i < toReturnExecutables.length; i++) {
                toReturnExecutables[i]();
            }
        }

        const editResult = {
            result: toReturnResult,
            errors: toReturnErrors,
            execute: toReturnExecute
        }
        return editResult;

    }


    get context() {
        return this.ownContext;
    }


    /**
     * Returns an object with keys the keys of all the plugins Incidents of which appear in the
     * tree of the Group. All Incidents are projected to the Group's timeline.
     * The array includes the Group's projection too
     */
    getIncidentsByChannel(adjustMillisecond = 0) {
        let incidentsByPlugin = {};
        incidentsByPlugin[selfContainedIncidentsNpmName] = [{
            millisecond: adjustMillisecond,
            incident: this,
            id: this.id
        }];

        return incidentsByPlugin;
    }


    setVolume(newVal) {
        this.volume = parseFloat(newVal);
        // this.putMessageOnPipe(pipeMessages._GAIN_CHANGE, { gain: newVal }, false, "down");
    }

    _onGetContextOnce() {
        return; // Clips do not get context from noone
    }


    // special recalcDuration handling so any potential clip copies update their trees
    handleRecalcDuration(target, payload) { // eslint-disable-line no-unused-vars
        if (this._calculateDuration()) {
            for (let i = 0; i < this.durationSubs.length; i++) {
                this.durationSubs[i](this.duration);
            }
        }
        return true;
    }

    subscribeToDurationChange(method) {
        this.durationSubs.push(method);
    }


    // *******************************************************
    // STEP FUNCTION
    step(timestamp, debug = false) {
        if (this.runTimeInfo.state !== 'playing') {
            return;
        }

        const that = this;
        if (this.previousTimeStamp === -1) {
            this.previousTimeStamp = timestamp;
        }

        // progressStep is the progress made from previousTimeStamp both in milliseconds and in fraction [0 to 1]
        const progress = {
            milliseconds: Math.round(this.runTimeInfo.currentMillisecond + (timestamp - this.previousTimeStamp) * this.speed),
            fraction: (this.runTimeInfo.currentMillisecond + (timestamp - this.previousTimeStamp) * this.speed) / this.duration
        };

        if (progress.fraction >= 1) {
            this.onProgress(1, this.duration);
            this.complete();
            return;
        }
        else if (progress.fraction < 0) {
            this.onProgress(0, 0);
            this.complete();
            // this.broadcastEvent('state-change', { oldState: "playing", newState: "idle" });
            return;
        }

        this.onProgress(progress.fraction, progress.milliseconds);

        this.previousTimeStamp = timestamp;

        if (debug === false) {
            window.requestAnimationFrame(that.step.bind(that));
        }
    }

    /**
     * Method called on progress of the timed incident.
     * @param {float} fraction - a number from 0 to 1 representing the fraction of duration covered
     * @param {int} milliseconds - the number of milliseconds passed from start of the incident
     * @param {string} contextId - defaults to the id of the realClip itself. Don't forget that a realClip
     *      might belong to a selector Clip (so it's a Fragmented Clip), with many "real" ClipCopies. All ClipCopies hold
     *      a reference to this Clip via their "realClip" property. Whenever any
     *      of these ClipCopies progresses (via the onProgress method) calls
     *      the "onProgress" of the realClip, passing their id so the ContextAwareIncidents
     *      that will also progress via the Channels know which specific Incident to progress.
     *      That's the result of keeping just one real tree, belonging always to the realClip
     *      (either Fragmented or Hosted) ending to ContextAwareIncident leafs that
     *      are the ones to hold the ClipCopies instances.
     * @param {boolean} forceReset - set to true in cases we want full flash of the state
     */
    onProgress(fraction, milliseconds, contextId = this.id, forceReset = false) {
        for (let key in this.instantiatedChannels) {
            const channel = this.instantiatedChannels[key];
            channel.moveTo(this.runTimeInfo.currentMillisecond, milliseconds, contextId, forceReset);
        }

        for (const key in this.listeners) {
            const listner = this.listeners[key];
            // console.log(`Math.abs(${milliseconds} + ${listner.cavaDelta} - ${this.runTimeInfo.currentMillisecond}) > ${listner.threshold}`);
            if (Math.abs(milliseconds + listner.cavaDelta - this.runTimeInfo.currentMillisecond) > listner.threshold) {
                listner.funct(helper.roundNumberTo(milliseconds, listner.roundTo), this.runTimeInfo.state);
                listner.cavaDelta = 0;
            }
            else {
                listner.cavaDelta += Math.abs(milliseconds - this.runTimeInfo.currentMillisecond);
            }
        }

        this.runTimeInfo.currentMillisecond = milliseconds;
    }

    _setState(newState) {
        if (newState != this.runTimeInfo.state) {
            this.runTimeInfo.state = newState;
            for (const key in this.listeners) {
                const listner = this.listeners[key];
                listner.funct(this.runTimeInfo.currentMillisecond, newState);
            }
        }
    }

    // execution methods
    play(debug = false) {
        if (this.runTimeInfo.state === 'idle' || this.runTimeInfo.state === 'paused' || this.runTimeInfo.state === 'transitional') {
            if (this.runTimeInfo.state === 'paused') {
                const delta = new Date().getTime() - this.pauseMoment;
                this.previousTimeStamp += delta;
            }

            this._setState('playing');
            this.onPlay();
            if (debug === false) {
                window.requestAnimationFrame((timestamp) => {
                    this.step(timestamp);
                });
            }
        }
    }

    pause() {
        if (this.runTimeInfo.state === 'playing') {
            this._setState('paused');
            this.pauseMoment = new Date().getTime();
            this.onWait();
        }
    }

    complete() {
        this._setState('idle');
        this.previousTimeStamp = -1;
        this.runTimeInfo.currentMillisecond = 0;
    }

    stop() {
        this._setState('transitional');
        this.previousTimeStamp = -1;
    }

    flash() {
        for (let key in this.instantiatedChannels) {
            const channel = this.instantiatedChannels[key];
            channel.moveTo(0, this.runTimeInfo.currentMillisecond, this.id, true);
        }
    }

    onPlay() {

    }

    onWait() {

    }

}

module.exports = ExtendableClip;

const Helper = require('../../_coreUtils/Helper');
const helper = new Helper();
const conf = require('../../configuration/generalConf');

class HTMLFragmentContextHandler {
    /**
     * @param {object} props - an object that should contain all of the following keys:
     * - html (the html template to render)
     * - css (the css template of the isolated tree)
     * - initParams (optional / the initialisation parameteres that will be passed both on the css and the html templates in order to render)
     * - host (an Element object that will host the isolated tree)
     * - containerParams (an object that holds parameters to affect the container of the isolated tree, e.g. width, height etc)
     */
    constructor(originalProps = {}) {
        let props = Object.assign({}, originalProps);

        if (!helper.isObject(props)) {
            helper.error(`HTMLFragmentContextHandler expects an object on its constructor. ${typeof props} passed`);
            return false;
        }

        if (!Object.prototype.hasOwnProperty.call(props, "html")) {
            props.html = '';
        }

        this.isDOM = true;

        const fragment = document.createDocumentFragment();
        const wrapper = document.createElement('div');
        if (Object.prototype.hasOwnProperty.call(props, "containerParams")) {
            if (Object.prototype.hasOwnProperty.call(props, "width")) {
                wrapper.style.width = props.containerParams.width;
            }
            if (Object.prototype.hasOwnProperty.call(props, "height")) {
                wrapper.style.height = props.containerParams.height;
            }
        }
        wrapper.innerHTML = helper.renderTemplate(props.html, { params: props.initParams });
        fragment.appendChild(wrapper);

        wrapper.style.overflow = "hidden";

        this.rootElement = wrapper;

        this.context = {
            document: document,
            window: window,
            clipContainer: this.rootElement,
            rootElement: wrapper,
            unmount: function () {
                props.host.removeChild(fragment);
            },
            getElements: this.getElements.bind(this),
            getMCID: this.getMCID.bind(this),
            setMCID: this.setMCID.bind(this),
            getElementSelectorByMCID: this.getElementSelectorByMCID.bind(this),
            getElementByMCID: this.getElementByMCID.bind(this),
            fragment: true
        };

        this.elementsByMCID = {};
    }

    getElementByMCID(mcid) {
        if (Object.prototype.hasOwnProperty.call(this.elementsByMCID, mcid)) {
            return this.elementsByMCID[mcid];
        }
        else {
            const element = this.context.rootElement.querySelector(this.getElementSelectorByMCID(mcid));
            this.elementsByMCID[mcid] = element;
            return element;
        }
    }

    getElements(selector) {
        return Array.from(this.context.rootElement.querySelectorAll(selector));
    }

    getMCID(element) {
        return element.getAttribute(conf.elements_data_attribute_name);
    }

    setMCID(element, mcid) {
        element.setAttribute(conf.elements_data_attribute_name, mcid);
    }

    getElementSelectorByMCID(mcid) {
        return '[' + conf.elements_data_attribute_name + '="' + mcid + '"]';
    }

}

module.exports = HTMLFragmentContextHandler;

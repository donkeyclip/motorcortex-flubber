/*
lane:
     * [
     *      {
     *          id: the id of the Incident
     *          millisecond: the millisecond of the channel this Animation (that affects the selector/attribute pair) runs
     *      }
     *  ]
*/

function updateFinalValues(initialValues, originalFinalValues, finalValues) {
    // console.log(initialValues, originalFinalValues);
    let change = false;
    for (let key in initialValues) {
        if (!Object.prototype.hasOwnProperty.call(originalFinalValues, key)) {
            change = true;
            finalValues[key] = initialValues[key];
        }
    }
    return change;
}

/**
 * This function takes as input the index of the affected incident on the lane,
 * the lane and it re-calculates the
 * initial and final values of all the following incidents in the lane.
 * The function is used only in cases of combo attributes
 **/
function setInitialValue(lane, incidentsById, newInitialValues, affectedIndex) {
    const affectedItem = lane[affectedIndex];
    const affectedIncident = incidentsById._get(affectedItem.id);
    affectedIncident.setInitialValue(newInitialValues);

    const change = updateFinalValues(affectedIncident.getInitialValue(), affectedIncident.originalAnimatedAttributeValue, affectedIncident.animatedAttributeValue);

    // if the final values have changed according to the new initial values and there is
    // a following incident on the lane
    if (change && affectedIndex < lane.length - 1) {
        affectedIncident.lastWish();
        affectedIncident.onGetContext();
        setInitialValue(lane, incidentsById, affectedIncident.animatedAttributeValue, affectedIndex + 1);
    }
}

module.exports = setInitialValue;

"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var DescriptiveGroup = require('./DescriptiveGroup');

var _TREECONST = require('../_Tree/_CONST');

var FragmentedClip = require('../_Clip/FragmentedClip');

var Clip = require('../_Clip/SCGroup');

var Channel = require('../_Channels/_Clip/ClipsChannel');

var incidentFromIngredients = require('../IncidentFromDefinition/incidentFromIngredients');

var ClipClone = require('../_Clip/RootClipClone');

var DescriptiveClip =
/*#__PURE__*/
function (_DescriptiveGroup) {
  _inherits(DescriptiveClip, _DescriptiveGroup);

  function DescriptiveClip(attrs) {
    var _this;

    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    _classCallCheck(this, DescriptiveClip);

    var attrsToPass, propsToUse;

    if (props === null) {
      attrsToPass = {};
      propsToUse = attrs;
    } else {
      // else, in case the user has passed two arguments then both should be used
      attrsToPass = attrs;
      propsToUse = props;
    }

    _this = _possibleConstructorReturn(this, _getPrototypeOf(DescriptiveClip).call(this, attrsToPass, propsToUse)); // isTheRootClip defines whether the Clip is the root or not. It depends on
    // the host or selector parameter passed on props (if host is present then
    // the Clip is the root Clip while if the Clip gets initialised by a selector
    // is not)

    _this.isTheRootClip = false; // check if

    var ingredients = {
      id: _this.id,
      attrs: attrsToPass,
      props: _objectSpread({}, propsToUse, {
        html: Object.prototype.hasOwnProperty.call(propsToUse, "html") ? propsToUse.html : _this.html,
        css: Object.prototype.hasOwnProperty.call(propsToUse, "css") ? propsToUse.css : _this.css,
        fonts: Object.prototype.hasOwnProperty.call(propsToUse, "fonts") ? propsToUse.fonts : _this.fonts
      }),
      plugin_npm_name: _this.constructor.plugin_npm_name,
      Channel: _this.constructor.Channel
    };

    if (Object.prototype.hasOwnProperty.call(propsToUse, "selector") && propsToUse.selector !== undefined) {
      ingredients.Incident = FragmentedClip; // TODO it doesn't take in account the get html and get css of the Descriptive Clip
    } else {
      _this.isTheRootClip = true;
      ingredients.Incident = _this.constructor.Incident;
    }

    _this.realClip = incidentFromIngredients(ingredients);

    if (_this.isTheRootClip) {
      _this.realClip.subscribeToDurationChange(function (newDuration) {// TODO this.informForDurationChange();
      });
    } // passiveAddition is a flag property indicating that any Incident to be
    // added to the Clip will be passive. It initialises with value = false
    // on DescriptiveGroup where it's originaly defined.
    // Here we change its value just before the buildTree method execution
    // so all Incidents added on it get the "passive" flag and don't get
    // exported on the exportDefinition method. Once the buildTree method
    // finishes we set it back to its original value (false)


    _this.passiveAddition = true;

    _this._buildTree();

    _this.passiveAddition = false;
    return _this;
  }

  _createClass(DescriptiveClip, [{
    key: "_buildTree",

    /*
    the _buildTree method acts as a proxy to the buildTree method defined by the
    developers. The reason for this is that the actual buildTree method should
    be executed in different order on Groups and on Clips (that extend Groups).
    Calling the super on constructor fires the _buildTree execution on the
    Group's constructor but this breaks on Clip as the realClip has not been
    initialised yet.
    */
    value: function _buildTree() {
      if (this.realClip === undefined) {
        return;
      }

      this.buildTree();
    }
  }, {
    key: "resize",

    /**
     * When the resize command is given directly to a DescriptiveClip no checks
     * need to be performed.
     * DescriptiveClip directly invokes the _resize method of ExtendableClip which
     * resizes the full clip
     */
    value: function resize(newSize) {
      this.realClip._resize(newSize / this.duration);

      this.duration = newSize;
      this.putMessageOnPipe('recalcDuration', {}, 'Groups', {
        selfExecute: false,
        direction: _TREECONST._DIRECTIONS._UP
      });
      this.putMessageOnPipe('flash', {}, 'RootClip', {
        selfExecute: true,
        direction: _TREECONST._DIRECTIONS._UP
      });
      return {
        result: true
      };
    }
    /*************************** HANDLING METHODS *******************************/

  }, {
    key: "handleCheckForClip",
    value: function handleCheckForClip(target, payload) {
      // eslint-disable-line no-unused-vars
      return true;
    }
  }, {
    key: "handleCheckAddition",
    value: function handleCheckAddition(target, payload) {
      /* Is the responsibility of the DescriptiveClip to pass the addition request
      to its real clip and expect for a response. */
      var res = this.realClip.addIncident(payload);

      if (res.result === true) {
        this.putMessageOnPipe('flash', {}, 'RootClip', {
          selfExecute: true,
          direction: _TREECONST._DIRECTIONS._UP
        });
      }

      return res;
    }
  }, {
    key: "handleCheckMove",
    value: function handleCheckMove(target, payload) {
      var res = this.realClip.moveIncident(payload);

      if (res.result === true) {
        this.putMessageOnPipe('flash', {}, 'RootClip', {
          selfExecute: true,
          direction: _TREECONST._DIRECTIONS._UP
        });
      }

      return res;
    }
  }, {
    key: "handleCheckDeletion",
    value: function handleCheckDeletion(target, payload) {
      var res = this.realClip.removeIncident(payload);

      if (res.result === true) {
        this.putMessageOnPipe('flash', {}, 'RootClip', {
          selfExecute: true,
          direction: _TREECONST._DIRECTIONS._UP
        });
      }

      return res;
    }
  }, {
    key: "handleCheckResize",
    value: function handleCheckResize(target, payload) {
      var res = this.realClip.resizeIncident(payload);

      if (res.result === true) {
        this.putMessageOnPipe('flash', {}, 'RootClip', {
          selfExecute: true,
          direction: _TREECONST._DIRECTIONS._UP
        });
      }

      return res;
    }
  }, {
    key: "handleCheckEditAttributes",
    value: function handleCheckEditAttributes(target, payload) {
      // eslint-disable-line no-unused-vars
      return {
        result: true
      };
    }
  }, {
    key: "handleCheckEditProperties",
    value: function handleCheckEditProperties(target, payload) {
      // eslint-disable-line no-unused-vars
      return {
        result: true
      };
    }
  }, {
    key: "handleFlash",
    value: function handleFlash(target, payload) {
      // eslint-disable-line no-unused-vars
      if (this.isTheRootClip) {
        this.flash();
      } else {
        return this.bypass();
      }
    }
    /*********************** execution methods proxy *****************
     ****************************************************************/

  }, {
    key: "play",
    value: function play() {
      var debug = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (this.isTheRootClip) {
        this.realClip.play(debug);
        return true;
      }

      return false;
    }
  }, {
    key: "pause",
    value: function pause() {
      if (this.isTheRootClip) {
        this.realClip.pause();
        return true;
      }

      return false;
    }
  }, {
    key: "complete",
    value: function complete() {
      if (this.isTheRootClip) {
        this.realClip.complete();
        return true;
      }

      return false;
    }
  }, {
    key: "stop",
    value: function stop() {
      if (this.isTheRootClip) {
        this.realClip.stop();
        return true;
      }

      return false;
    }
  }, {
    key: "flash",
    value: function flash() {
      if (this.isTheRootClip) {
        this.realClip.flash();
        return true;
      }

      return false;
    }
  }, {
    key: "onProgress",
    value: function onProgress(fraction, millisecond) {
      if (this.isTheRootClip) {
        this.realClip.onProgress(fraction, millisecond);
        return true;
      }

      return false;
    }
  }, {
    key: "subscribe",

    /*********************** pub-sube methods proxy *******************
     ****************************************************************/
    value: function subscribe(id, funct, threshold, roundTo) {
      if (this.isTheRootClip) {
        this.realClip.subscribe(id, funct, threshold, roundTo);
        return true;
      }

      return false;
    }
  }, {
    key: "unsubscribe",
    value: function unsubscribe(id) {
      return this.realClip.unsubscribe(id);
    }
  }, {
    key: "subscribeToDurationChange",
    value: function subscribeToDurationChange(funct) {
      if (this.isTheRootClip) {
        this.realClip.subscribeToDurationChange(funct);
        return true;
      }

      return false;
    }
    /*************************************************************/

  }, {
    key: "paste",
    value: function paste(host) {
      if (this.isTheRootClip) {
        var clipClone = new ClipClone({
          host: host,
          descriptiveIncident: this
        });
        return clipClone;
      }

      return null;
    }
  }, {
    key: "selectorToPassToChildren",
    get: function get() {
      return null; // the Clip (any Clip) resets the selection cascading
    }
  }, {
    key: "inheritedSelector",
    get: function get() {
      return this._inheritedSelector;
    },
    set: function set(value) {
      this._inheritedSelector = value;
    }
  }, {
    key: "html",
    get: function get() {
      return '';
    }
  }, {
    key: "css",
    get: function get() {
      return '';
    }
  }, {
    key: "fonts",
    get: function get() {
      return [];
    }
  }, {
    key: "runTimeInfo",
    get: function get() {
      return this.realClip.runTimeInfo;
    }
  }, {
    key: "executionSpeed",
    set: function set(speed) {
      if (this.isTheRootClip) {
        this.realClip.executionSpeed = speed;
        return true;
      }

      return false;
    }
  }]);

  return DescriptiveClip;
}(DescriptiveGroup);

_defineProperty(DescriptiveClip, "isClip", true);

_defineProperty(DescriptiveClip, "Incident", Clip);

_defineProperty(DescriptiveClip, "plugin_npm_name", "@kissmybutton/self-contained-incidents");

_defineProperty(DescriptiveClip, "Channel", Channel);

_defineProperty(DescriptiveClip, "ClassName", "Clip");

module.exports = DescriptiveClip;
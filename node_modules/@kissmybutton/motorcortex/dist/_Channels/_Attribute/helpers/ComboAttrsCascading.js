"use strict";

/*
lane:
     * [
     *      {
     *          id: the id of the Incident
     *          millisecond: the millisecond of the channel this Animation (that affects the selector/attribute pair) runs
     *      }
     *  ]
*/
function updateFinalValues(initialValues, originalFinalValues, finalValues) {
  // console.log(initialValues, originalFinalValues);
  var change = false;

  for (var key in initialValues) {
    if (!Object.prototype.hasOwnProperty.call(originalFinalValues, key)) {
      change = true;
      finalValues[key] = initialValues[key];
    }
  }

  return change;
}
/**
 * This function takes as input the index of the affected incident on the lane,
 * the lane and it re-calculates the
 * initial and final values of all the following incidents in the lane.
 * The function is used only in cases of combo attributes
 **/


function setInitialValue(lane, incidentsById, newInitialValues, affectedIndex) {
  var affectedItem = lane[affectedIndex];

  var affectedIncident = incidentsById._get(affectedItem.id);

  affectedIncident.setInitialValue(newInitialValues);
  var change = updateFinalValues(affectedIncident.getInitialValue(), affectedIncident.originalAnimatedAttributeValue, affectedIncident.animatedAttributeValue); // if the final values have changed according to the new initial values and there is
  // a following incident on the lane

  if (change && affectedIndex < lane.length - 1) {
    affectedIncident.lastWish();
    affectedIncident.onGetContext();
    setInitialValue(lane, incidentsById, affectedIncident.animatedAttributeValue, affectedIndex + 1);
  }
}

module.exports = setInitialValue;
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Helper = require('../_coreUtils/Helper');

var helper = new Helper();

var Group = require('../_BaseClasses/Group');

var selfContainedIncidentsNpmName = '@kissmybutton/self-contained-incidents'; // TODO remove this

var _TREECONST = require('../_Tree/_CONST');

var ExtendableClip =
/*#__PURE__*/
function (_Group) {
  _inherits(ExtendableClip, _Group);

  /**
   * @param {object} props - an object that should contain all of the following keys:
   * - html (the html template to render)
   * - css (the css template of the isolated tree)
   * - initParams (optional / the initialisation parameteres that will be passed both on the css and the html templates in order to render)
   * - host (an Element object that will host the isolated tree)
   * - containerParams (an object that holds parameters to affect the container of the isolated tree, e.g. width, height etc)
   * - type (optional, defaults to "iframe") the type of the Clip. It can be one of the:
   *  - iframe
   *  - plain
   */
  function ExtendableClip(attrs, props) {
    var _this;

    _classCallCheck(this, ExtendableClip);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(ExtendableClip).call(this, attrs, props));
    _this.attrs = attrs;
    _this.props = props;
    _this.isTheClip = true;
    _this.volume = 1;
    _this.speed = 1;
    _this.blockingWaitings = {};
    /**
     * The cnannels attribute holds a list of all intantiated Channels of the Incidents belonging to the clip
     * this attribute is only valuable when the Group becomes the Clip
     * The format of the attribute is:
     *  key-value pairs in the manner:
     * <mc_plugin_npm_name>: Channel object
     */

    _this.instantiatedChannels = {};
    /**
     * The instantiatedCopiesContexts is a key-value pairs colleciton holding the
     * contexts of all instantiated ClipCopies
     **/

    _this.instantiatedCopiesContexts = {};

    _this.onClipInitialise();

    _this.durationSubs = [];
    _this.runTimeInfo = {
      currentMillisecond: 0,
      state: 'idle' // supported states: idle, playing, paused, blocked

      /**
        @member {object} - listeners are functions to be executed on time change of the Clip.
        It has the following format:
       listeners: {
          listener_id: {
                   funct : the function to be executed
                   threshold : the threshold of delta
                   roundTo : round millisecond
               },
               listener_id: {
                   funct : the function to be executed
                   threshold : the threshold of delta
                   roundTo : round millisecond
               },
               ...
         }
         */

    };
    _this.listeners = {}; // previousTimeStamp is a property holding the last timestamp that the
    // requestAnimationFrame ran

    _this.previousTimeStamp = -1;
    return _this;
  }

  _createClass(ExtendableClip, [{
    key: "onClipInitialise",
    value: function onClipInitialise() {// called when group gets initialised
    }
  }, {
    key: "addContext",

    /**
     * This method is been called when a new ClipCopy enters the real tree successfully.
     * @param {object} contextData - keys: clipId, context
     **/
    value: function addContext(contextData) {
      this.instantiatedCopiesContexts[contextData.clipId] = contextData.context;
      contextData.instantiatedCopiesContexts = this.instantiatedCopiesContexts;
      var res = this.putMessageOnPipe('addContext', contextData, {}, {
        selfExecute: false,
        direction: _TREECONST._DIRECTIONS._DOWN
      });
      return res;
    }
    /*
    ExtendableClip (as its name implies) is a Class that should be extended by
    any specific kind of Clip, such as Fragmented or SCGroup. This method must
    be overitten by the new Classes. This definition here is just for reference / help
    purposes
    */

  }, {
    key: "exportConstructionArguments",
    value: function exportConstructionArguments() {
      return {
        attrs: this.attrs,
        props: this.props
      };
    }
    /**
     * completely resizes the Clip without any checks
     */

  }, {
    key: "_resize",
    value: function _resize(durationFraction) {
      for (var key in this.instantiatedChannels) {
        this.instantiatedChannels[key]._resize(durationFraction);
      }

      this.setNewDuration(this.duration * durationFraction);

      for (var i = 0; i < this.durationSubs.length; i++) {
        this.durationSubs[i](this.duration);
      }
    } // ************ PUB SUB ********************
    // *****************************************

    /**
      By subscribing a module can get notified about changes on the Clip's time
      subscribe method subscribes a function to the time change dispatcher. As Clip uses requestAnimationFrame for its timing
      each cyrcle / step gets the current time and subtracts the previous time so it know how many milliseconds has elapsed
      since last step. Subscribers can set to get informed about time changes only if the delta is greater than a given
      number (e.g. greater than 300ms). That property is passed as the second argument "threshold".
      Finally if any of the subscribers want the Scene to provide back a rounded number of the milliseconds. Options:
        - 1 (round it on its actual units
       - 10 (round it on tenths)
       - 100 (round it on hundreds)
       - 1000 (round it on thousands)
      the first argument provides an id to the listener for future reference (deletion etc)
      the second argument is a function that takes two arguments: millisecond, state (current millisecond of the Scene
      and the state of it  */

  }, {
    key: "subscribe",
    value: function subscribe(id, funct, threshold, roundTo) {
      if (!threshold) {
        threshold = 0;
      }

      if (!roundTo) {
        roundTo = 1; // round second to its units, meaning leave it as it is
      }

      this.listeners[id] = {
        funct: funct,
        threshold: threshold,
        roundTo: roundTo,
        cavaDelta: 0
      };
    }
  }, {
    key: "unsubscribe",
    value: function unsubscribe(id) {
      if (Object.prototype.hasOwnProperty.call(this.listeners, id)) {
        delete this.listeners[id];
      }
    }
    /*********************************************************
    Editing commands input methods
    *********************************************************/

    /**
     * This command comes form the Clip's parent Descriptor class. The payload
     * is identical to the payload that comes to the Description class:
     * {
     *  incident: the Descriptive Incident to be added
     *  millisecond: the millisecond to add it
     *  parentGroupId: the id of the Group to which we want to the Incident to
     * }
     */

  }, {
    key: "addIncident",
    value: function addIncident(payload) {
      var candidates = this.putMessageOnPipe('addIncident', {
        incident: payload.incident,
        millisecond: payload.millisecond,
        parentGroupId: payload.parentGroupId,
        contextData: {
          clipId: this.id,
          context: this.context
        }
      }, payload.parentGroupId, {
        selfExecute: true,
        direction: _TREECONST._DIRECTIONS._DOWN
      }); // concatenate candidates
      // console.log(candidates);

      var totalIncidentsByPlugin = {};

      for (var i = 0; i < candidates.length; i++) {
        var incidentsByPlugin = candidates[i].response.getIncidentsByChannel(candidates[i].positionDelta + payload.millisecond);

        for (var pluginName in incidentsByPlugin) {
          var _totalIncidentsByPlug;

          if (!Object.prototype.hasOwnProperty.call(totalIncidentsByPlugin, pluginName)) {
            totalIncidentsByPlugin[pluginName] = [];
          }

          (_totalIncidentsByPlug = totalIncidentsByPlugin[pluginName]).push.apply(_totalIncidentsByPlug, _toConsumableArray(incidentsByPlugin[pluginName]));
        }
      }

      var res = this.checkAddition(totalIncidentsByPlugin);

      if (res.result === true) {
        res.execute(); // up to that point the only context Incident that has been initialised on the
        // ContextAwareIncidents of the candidates is the original context of the
        // ExtendableClip.

        for (var _i = 0; _i < candidates.length; _i++) {
          candidates[_i].responder.addChild(candidates[_i].response, payload.millisecond); // recalculate duration the groups that we added
          // the incidents to along with their parents


          candidates[_i].responder.putMessageOnPipe('recalcDuration', {}, 'Groups', {
            selfExecute: true,
            direction: _TREECONST._DIRECTIONS._UP
          }); // we also need to add every existing (copied) context to the ContextAwareIncidents
          // created on the candidates process


          for (var contextKey in this.instantiatedCopiesContexts) {
            candidates[_i].responder.putMessageOnPipe('addContext', {
              clipId: contextKey,
              context: this.instantiatedCopiesContexts[contextKey]
            }, 'ContextAwareIncidents', {
              selfExecute: false,
              direction: _TREECONST._DIRECTIONS._DOWN
            });
          }
        }
      }

      return res;
    } // *******************************************************
    // INCIDENTS MANAGEMENT METHODS
    // POLYMORPHISM APPLIED. IF THE GROUP HAS NO PARENT IT ACTS AS A SCENE. IF THE GROUP HAS PARENT IT ACTS AS
    // A "TRANSPARENT GROUP"

    /**
     * The method returns either:
        {
            result:true,
            execute: // an array of functions that when executed it will add the Incidents on the Channels
        }
        or
        {
            result: false,
            errors
        }
    */

  }, {
    key: "checkAddition",
    value: function checkAddition(incidentsById) {
      var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "all-or-nothing";
      // prepare the return payload
      var toReturnResult = true;
      var toReturnErrors = [];
      var toReturnExecutables = []; // for each key of the incidentsById object perform the check

      for (var key in incidentsById) {
        // if the clip had no channel instantiated for the specific key (plugin id) yet create it
        if (!Object.prototype.hasOwnProperty.call(this.instantiatedChannels, key)) {
          // intstantiate the channel of the plugin by using the reference to the class definition stored on
          // the very first incident of the array
          this.instantiatedChannels[key] = new incidentsById[key][0].incident.plugin_channel_class({
            runTimeInfo: this.runTimeInfo,
            context: this.context,
            getIncidentById: this.getIncidentById
          });
        } // perform the check


        var pluginResult = this.instantiatedChannels[key].addIncidents(incidentsById[key], type);
        toReturnResult = toReturnResult && pluginResult.result;

        if (pluginResult.result === false) {
          toReturnErrors = toReturnErrors.concat(pluginResult.errors);
        } else {
          toReturnExecutables.push(pluginResult.execute);
        }
      } // enf of iteration on the incidentsById keys


      var toReturnExecute = function toReturnExecute() {
        for (var i = 0; i < toReturnExecutables.length; i++) {
          toReturnExecutables[i]();
        }
      };

      var additionResult = {
        result: toReturnResult,
        errors: toReturnErrors,
        execute: toReturnExecute
      };
      return additionResult;
    }
    /**
     * This command comes form the Clip's parent Descriptor class. The payload
     * is identical to the payload that comes to the Description class:
     * {
     *  incident: the Descriptive Incident to be repositioned
     *  millisecond: the new millisecond to put it
     *  parentGroupId: the id of the
     * }
     */

  }, {
    key: "moveIncident",
    value: function moveIncident(payload) {
      var candidates = this.putMessageOnPipe('moveIncident', {
        incidentId: payload.id,
        millisecond: payload.millisecond,
        parentGroupId: payload.parentGroupId,
        contextData: {
          clipId: this.id,
          context: this.context
        }
      }, payload.parentGroupId, {
        selfExecute: true,
        direction: _TREECONST._DIRECTIONS._DOWN
      });
      var totalIncidentsByPlugin = {};

      for (var i = 0; i < candidates.length; i++) {
        var incidentsByPlugin = candidates[i].response.getIncidentsByChannel(candidates[i].positionDelta + payload.millisecond);

        for (var pluginName in incidentsByPlugin) {
          var _totalIncidentsByPlug2;

          if (!Object.prototype.hasOwnProperty.call(totalIncidentsByPlugin, pluginName)) {
            totalIncidentsByPlugin[pluginName] = [];
          }

          (_totalIncidentsByPlug2 = totalIncidentsByPlugin[pluginName]).push.apply(_totalIncidentsByPlug2, _toConsumableArray(incidentsByPlugin[pluginName]));
        }
      }

      var res = this.checkMove(totalIncidentsByPlugin, payload.positionDelta);

      if (res.result === true) {
        res.execute();

        for (var _i2 = 0; _i2 < candidates.length; _i2++) {
          candidates[_i2].responder.editPosition(candidates[_i2].response.id, payload.millisecond); // recalculate duration the groups that we added
          // the incidents to along with their parents


          candidates[_i2].responder.putMessageOnPipe('recalcDuration', {}, 'Groups', {
            selfExecute: true,
            direction: _TREECONST._DIRECTIONS._UP
          });
        }
      }

      return res;
    }
    /**
     * The checkEdit method serves exactly what its name implies. To check if the edit of an Incident (edit of Incident's position given in milliseconds delta)
     * is valid and accepted, according to the rules defined on the channels.
     * The method boobles up until it reaches the Clip.
     * @param {object} incident - the incident to edit
     * @param {int} millisecondsDelta - the milliseconds delta of the Incident's start time
     The method should return either:
        {
            result:true,
            execute: // an array of functions that when executed it will edit the Incidents on the Channels
        }
        or
        {
            result: false,
            errors
        }
    */

  }, {
    key: "checkMove",
    value: function checkMove(incidentsById, millisecondsDelta) {
      // prepare the return payload
      var toReturnResult = true;
      var toReturnErrors = [];
      var toReturnExecutables = []; // for each key of the incidentsById object perform the check

      for (var key in incidentsById) {
        // perform the check
        var pluginResult = this.instantiatedChannels[key].editIncidents(incidentsById[key], millisecondsDelta);
        toReturnResult = toReturnResult && pluginResult.result;

        if (pluginResult.result === false) {
          toReturnErrors = toReturnErrors.concat(pluginResult.errors);
        } else {
          toReturnExecutables.push(pluginResult.execute);
        }
      } // enf of iteration on the incidentsById keys


      var toReturnExecute = function toReturnExecute() {
        for (var i = 0; i < toReturnExecutables.length; i++) {
          toReturnExecutables[i]();
        }
      };

      var editResult = {
        result: toReturnResult,
        errors: toReturnErrors,
        execute: toReturnExecute
      };
      return editResult;
    }
  }, {
    key: "removeIncident",
    value: function removeIncident(payload) {
      var candidates = this.putMessageOnPipe('removeIncident', {
        incidentId: payload.id,
        parentGroupId: payload.parentGroupId,
        contextData: {
          clipId: this.id,
          context: this.context
        }
      }, payload.parentGroupId, {
        selfExecute: true,
        direction: _TREECONST._DIRECTIONS._DOWN
      });
      var totalIncidentsByPlugin = {};

      for (var i = 0; i < candidates.length; i++) {
        var incidentsByPlugin = candidates[i].response.getIncidentsByChannel();

        for (var pluginName in incidentsByPlugin) {
          var _totalIncidentsByPlug3;

          if (!Object.prototype.hasOwnProperty.call(totalIncidentsByPlugin, pluginName)) {
            totalIncidentsByPlugin[pluginName] = [];
          }

          (_totalIncidentsByPlug3 = totalIncidentsByPlugin[pluginName]).push.apply(_totalIncidentsByPlug3, _toConsumableArray(incidentsByPlugin[pluginName]));
        }
      }

      var res = this.checkDelete(totalIncidentsByPlugin);

      if (res.result === true) {
        res.execute();

        for (var _i3 = 0; _i3 < candidates.length; _i3++) {
          candidates[_i3].responder.removeChild(candidates[_i3].response.id); // recalculate duration the groups that we added
          // the incidents to along with their parents


          candidates[_i3].responder.putMessageOnPipe('recalcDuration', {}, 'Groups', {
            selfExecute: true,
            direction: _TREECONST._DIRECTIONS._UP
          });
        }
      }

      return res;
    }
    /**
     * The checkDelete method serves exactly what its name implies. To check if the deletion of an Incident
     * is valid and accepted, according to the rules defined on the channels.
     * The method boobles up until it reaches the Clip.
     * @param {object} incident - the incident to edit
      The result might be either:
        {
            result:true,
            execute: // an array of functions that when executed it will remove the Incident on the Channels
        }
        or
        {
            result: false,
            errors
        }
    */

  }, {
    key: "checkDelete",
    value: function checkDelete(incidentsById) {
      // prepare the return payload
      var toReturnResult = true;
      var toReturnErrors = [];
      var toReturnExecutables = []; // for each key of the incidentsById object perform the check

      for (var key in incidentsById) {
        // perform the check
        var pluginResult = this.instantiatedChannels[key].removeIncidents(incidentsById[key]);
        toReturnResult = toReturnResult && pluginResult.result;

        if (pluginResult.result === false) {
          toReturnErrors = toReturnErrors.concat(pluginResult.errors);
        } else {
          toReturnExecutables.push(pluginResult.execute);
        }
      } // enf of iteration on the incidentsById keys


      var toReturnExecute = function toReturnExecute() {
        for (var i = 0; i < toReturnExecutables.length; i++) {
          toReturnExecutables[i]();
        }
      };

      var removeResult = {
        result: toReturnResult,
        errors: toReturnErrors,
        execute: toReturnExecute
      };
      return removeResult;
    }
    /**
     * This command comes form the Clip's parent Descriptor class. The payload
     * is identical to the payload that comes to the Description class:
     * {
     *  id: the id of the Incident to resize
     *  newSize: the milliseconds of the new duration
     *  fraction: the division of the new duration to the current
     * }
     */

  }, {
    key: "resizeIncident",
    value: function resizeIncident(payload) {
      var candidates = this.putMessageOnPipe('resize', {
        incidentId: payload.id,
        newSize: payload.newSize,
        fraction: payload.fraction,
        contextData: {
          clipId: this.id,
          context: this.context
        }
      }, payload.id, {
        selfExecute: false,
        direction: _TREECONST._DIRECTIONS._DOWN
      });
      var totalIncidentsByPlugin = {};

      for (var i = 0; i < candidates.length; i++) {
        var incidentsByPlugin = candidates[i].response.getIncidentsByChannel(candidates[i].positionDelta);

        for (var pluginName in incidentsByPlugin) {
          var _totalIncidentsByPlug4;

          if (!Object.prototype.hasOwnProperty.call(totalIncidentsByPlugin, pluginName)) {
            totalIncidentsByPlugin[pluginName] = [];
          }

          (_totalIncidentsByPlug4 = totalIncidentsByPlugin[pluginName]).push.apply(_totalIncidentsByPlug4, _toConsumableArray(incidentsByPlugin[pluginName]));
        }
      }

      var res = this.checkResize(payload.fraction, totalIncidentsByPlugin, candidates[0].positionDelta);

      if (res.result === true) {
        res.execute();

        for (var _i4 = 0; _i4 < candidates.length; _i4++) {
          candidates[_i4].responder.setNewDuration(payload.newSize);
        }
      }

      return res;
    }
    /**
     * checks if a duration edit is feasible and doesn't cause conflicts
     * @param {int} duration - the new duration
     **/

  }, {
    key: "checkResize",
    value: function checkResize(durationFraction, incidentsById) {
      var adjustMillisecond = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      // prepare the return payload
      var toReturnResult = true;
      var toReturnErrors = [];
      var toReturnExecutables = []; // for each key of the incidentsById object perform the check

      for (var key in incidentsById) {
        // perform the check
        var adjustedIncidents = helper.systoleDiastoleProjections(incidentsById[key], durationFraction, adjustMillisecond);
        var pluginResult = this.instantiatedChannels[key].checkResizedIncidents(adjustedIncidents);
        toReturnResult = toReturnResult && pluginResult.result;

        if (pluginResult.result === false) {
          toReturnErrors = toReturnErrors.concat(pluginResult.errors);
        } else {
          toReturnExecutables.push(pluginResult.execute);
        }
      } // enf of iteration on the incidentsById keys


      var toReturnExecute = function toReturnExecute() {
        for (var i = 0; i < toReturnExecutables.length; i++) {
          toReturnExecutables[i]();
        }
      };

      var editResult = {
        result: toReturnResult,
        errors: toReturnErrors,
        execute: toReturnExecute
      };
      return editResult;
    }
  }, {
    key: "getIncidentsByChannel",

    /**
     * Returns an object with keys the keys of all the plugins Incidents of which appear in the
     * tree of the Group. All Incidents are projected to the Group's timeline.
     * The array includes the Group's projection too
     */
    value: function getIncidentsByChannel() {
      var adjustMillisecond = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var incidentsByPlugin = {};
      incidentsByPlugin[selfContainedIncidentsNpmName] = [{
        millisecond: adjustMillisecond,
        incident: this,
        id: this.id
      }];
      return incidentsByPlugin;
    }
  }, {
    key: "setVolume",
    value: function setVolume(newVal) {
      this.volume = parseFloat(newVal); // this.putMessageOnPipe(pipeMessages._GAIN_CHANGE, { gain: newVal }, false, "down");
    }
  }, {
    key: "_onGetContextOnce",
    value: function _onGetContextOnce() {
      return; // Clips do not get context from noone
    } // special recalcDuration handling so any potential clip copies update their trees

  }, {
    key: "handleRecalcDuration",
    value: function handleRecalcDuration(target, payload) {
      // eslint-disable-line no-unused-vars
      if (this._calculateDuration()) {
        for (var i = 0; i < this.durationSubs.length; i++) {
          this.durationSubs[i](this.duration);
        }
      }

      return true;
    }
  }, {
    key: "subscribeToDurationChange",
    value: function subscribeToDurationChange(method) {
      this.durationSubs.push(method);
    } // *******************************************************
    // STEP FUNCTION

  }, {
    key: "step",
    value: function step(timestamp) {
      var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (this.runTimeInfo.state !== 'playing') {
        return;
      }

      var that = this;

      if (this.previousTimeStamp === -1) {
        this.previousTimeStamp = timestamp;
      } // progressStep is the progress made from previousTimeStamp both in milliseconds and in fraction [0 to 1]


      var progress = {
        milliseconds: Math.round(this.runTimeInfo.currentMillisecond + (timestamp - this.previousTimeStamp) * this.speed),
        fraction: (this.runTimeInfo.currentMillisecond + (timestamp - this.previousTimeStamp) * this.speed) / this.duration
      };

      if (progress.fraction >= 1) {
        this.onProgress(1, this.duration);
        this.complete();
        return;
      } else if (progress.fraction < 0) {
        this.onProgress(0, 0);
        this.complete(); // this.broadcastEvent('state-change', { oldState: "playing", newState: "idle" });

        return;
      }

      this.onProgress(progress.fraction, progress.milliseconds);
      this.previousTimeStamp = timestamp;

      if (debug === false) {
        window.requestAnimationFrame(that.step.bind(that));
      }
    }
    /**
     * Method called on progress of the timed incident.
     * @param {float} fraction - a number from 0 to 1 representing the fraction of duration covered
     * @param {int} milliseconds - the number of milliseconds passed from start of the incident
     * @param {string} contextId - defaults to the id of the realClip itself. Don't forget that a realClip
     *      might belong to a selector Clip (so it's a Fragmented Clip), with many "real" ClipCopies. All ClipCopies hold
     *      a reference to this Clip via their "realClip" property. Whenever any
     *      of these ClipCopies progresses (via the onProgress method) calls
     *      the "onProgress" of the realClip, passing their id so the ContextAwareIncidents
     *      that will also progress via the Channels know which specific Incident to progress.
     *      That's the result of keeping just one real tree, belonging always to the realClip
     *      (either Fragmented or Hosted) ending to ContextAwareIncident leafs that
     *      are the ones to hold the ClipCopies instances.
     * @param {boolean} forceReset - set to true in cases we want full flash of the state
     */

  }, {
    key: "onProgress",
    value: function onProgress(fraction, milliseconds) {
      var contextId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.id;
      var forceReset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

      for (var key in this.instantiatedChannels) {
        var channel = this.instantiatedChannels[key];
        channel.moveTo(this.runTimeInfo.currentMillisecond, milliseconds, contextId, forceReset);
      }

      for (var _key in this.listeners) {
        var listner = this.listeners[_key]; // console.log(`Math.abs(${milliseconds} + ${listner.cavaDelta} - ${this.runTimeInfo.currentMillisecond}) > ${listner.threshold}`);

        if (Math.abs(milliseconds + listner.cavaDelta - this.runTimeInfo.currentMillisecond) > listner.threshold) {
          listner.funct(helper.roundNumberTo(milliseconds, listner.roundTo), this.runTimeInfo.state);
          listner.cavaDelta = 0;
        } else {
          listner.cavaDelta += Math.abs(milliseconds - this.runTimeInfo.currentMillisecond);
        }
      }

      this.runTimeInfo.currentMillisecond = milliseconds;
    }
  }, {
    key: "_setState",
    value: function _setState(newState) {
      if (newState != this.runTimeInfo.state) {
        this.runTimeInfo.state = newState;

        for (var key in this.listeners) {
          var listner = this.listeners[key];
          listner.funct(this.runTimeInfo.currentMillisecond, newState);
        }
      }
    } // execution methods

  }, {
    key: "play",
    value: function play() {
      var _this2 = this;

      var debug = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (this.runTimeInfo.state === 'idle' || this.runTimeInfo.state === 'paused' || this.runTimeInfo.state === 'transitional') {
        if (this.runTimeInfo.state === 'paused') {
          var delta = new Date().getTime() - this.pauseMoment;
          this.previousTimeStamp += delta;
        }

        this._setState('playing');

        this.onPlay();

        if (debug === false) {
          window.requestAnimationFrame(function (timestamp) {
            _this2.step(timestamp);
          });
        }
      }
    }
  }, {
    key: "pause",
    value: function pause() {
      if (this.runTimeInfo.state === 'playing') {
        this._setState('paused');

        this.pauseMoment = new Date().getTime();
        this.onWait();
      }
    }
  }, {
    key: "complete",
    value: function complete() {
      this._setState('idle');

      this.previousTimeStamp = -1;
      this.runTimeInfo.currentMillisecond = 0;
    }
  }, {
    key: "stop",
    value: function stop() {
      this._setState('transitional');

      this.previousTimeStamp = -1;
    }
  }, {
    key: "flash",
    value: function flash() {
      for (var key in this.instantiatedChannels) {
        var channel = this.instantiatedChannels[key];
        channel.moveTo(0, this.runTimeInfo.currentMillisecond, this.id, true);
      }
    }
  }, {
    key: "onPlay",
    value: function onPlay() {}
  }, {
    key: "onWait",
    value: function onWait() {}
  }, {
    key: "executionSpeed",
    set: function set(speed) {
      this.speed = parseFloat(speed);
    }
  }, {
    key: "context",
    get: function get() {
      return this.ownContext;
    }
  }]);

  return ExtendableClip;
}(Group);

module.exports = ExtendableClip;
"use strict";

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var Validator = require("fastest-validator");

var DescriptiveIncident = require('./_DescriptiveIncidents/DescriptiveIncident');

var DescriptiveGroup = require('./_DescriptiveIncidents/DescriptiveGroup');

var DescriptiveClip = require('./_DescriptiveIncidents/DescriptiveClip');

var Incident = require('./_BaseClasses/Incident');

var AttributeChannel = require('./_Channels/_Attribute/AttributeChannel');

var TimeCapsule = require('./_coreUtils/TimeCapsule');

var Helper = require('./_coreUtils/Helper');

var helper = new Helper();

var checkPlugin = function checkPlugin(main) {
  if (Object.prototype.hasOwnProperty.call(main, "default")) {
    main = main["default"];
  }

  var plugin_name = main.npm_name;
  var check = true;

  if (!Object.prototype.hasOwnProperty.call(main, "name")) {
    helper.error("Warning on plugin ".concat(plugin_name, ". A plugin is always good to have its name on\n        its main.js file, under the key \"name\". It's missing from this plugin"));
  }

  if (!Object.prototype.hasOwnProperty.call(main, "incidents")) {
    helper.error("Error on plugin ".concat(plugin_name, ". A plugin must expose at least one Incident.\n        Exposed plugin Incidents should be defined on the \"incidents\" key of the main.js file."));
    check = false;
  }

  if (!helper.isArray(main.incidents)) {
    helper.error("Error on plugin ".concat(plugin_name, ". thePlugin exposed Incidents are defined on the \"incidents\" key of the main.js file in array format.\n        Please refer to the documentation"));
    check = false;
  } else {
    for (var i = 0; i < main.incidents.length; i++) {
      var exposedIncidentDefinition = main.incidents[i];

      if (_typeof(exposedIncidentDefinition.exportable) === "object") {
        if (Object.prototype.hasOwnProperty.call(exposedIncidentDefinition.exportable, "default")) {
          exposedIncidentDefinition.exportable = exposedIncidentDefinition.exportable["default"];
        }
      }

      if (!(exposedIncidentDefinition.exportable.prototype instanceof DescriptiveGroup) && !(exposedIncidentDefinition.exportable.prototype instanceof DescriptiveClip) && !(exposedIncidentDefinition.exportable.prototype instanceof Incident)) {
        helper.error("Error on plugin ".concat(plugin_name, ". Exportable Incidents by any plugin must extend one of the base classes provided by MotorCortex.\n                ").concat(exposedIncidentDefinition.exportable.constructor.name, " doesn't.\n                Please refer to documentation"));
        check = false;
      }

      if (!Object.prototype.hasOwnProperty.call(exposedIncidentDefinition, "name")) {
        helper.error("Error on plugin ".concat(plugin_name, ". Exportable Incidents by any plugin must have the \"name\" key which defines the name of the exported Incident.\n                Please refer to documentation"));
        check = false;
      }

      if (!Object.prototype.hasOwnProperty.call(exposedIncidentDefinition, "propTypes")) {
        helper.log("Warning on plugin ".concat(plugin_name, ".\n                It's always good for plugins to define the supported propTypes of their exposed Incidents' supported properties.\n                ").concat(exposedIncidentDefinition.exportable.constructor.name, " doesn't.\n                Please refer to documentation"), 'warning');
      }
    }
  }

  return check;
}; // plugin_name is the unique name of the plugin


function loadPlugin(plugin) {
  if (Object.prototype.hasOwnProperty.call(plugin, "default")) {
    plugin = plugin["default"];
  }

  if (!Object.prototype.hasOwnProperty.call(plugin, "npm_name")) {
    plugin.npm_name = "plugin_".concat(new Date().getTime());
  }

  if (!checkPlugin(plugin)) {
    return false;
  } else {
    // thePlugin is the plugin object which will hold on its keys
    // the names of the exposed Incidents of its. The keys of this object
    // are going to be identical with the names of the classes exposed
    var thePlugin = {};

    if (Object.prototype.hasOwnProperty.call(plugin, "clip")) {} // TODO Custom Clips strategy
    // if the plugin definition has compositeAttributes then we dynamically
    // create a new Channel class extending AttributeChannel setting the
    // composite Attributes on the fly. We can then use this Channel class
    // for all Incidents exposed by the plugin


    var AttributeChannelToUse = AttributeChannel;

    if (Object.prototype.hasOwnProperty.call(plugin, "compositeAttributes")) {
      AttributeChannelToUse =
      /*#__PURE__*/
      function (_AttributeChannel) {
        _inherits(AttributeChannelToUse, _AttributeChannel);

        function AttributeChannelToUse(props) {
          _classCallCheck(this, AttributeChannelToUse);

          props.comboAttributes = plugin.compositeAttributes;
          return _possibleConstructorReturn(this, _getPrototypeOf(AttributeChannelToUse).call(this, props));
        }

        return AttributeChannelToUse;
      }(AttributeChannel);
    } // for each of the exposed Incidents


    var _loop = function _loop(i) {
      var incidentClass = plugin.incidents[i].exportable;
      var DynamicDescriptiveIncident = void 0; // the exportable Incident can be either a Clip, a Compo or an Incident
      // if it is an Incident

      if (incidentClass.prototype instanceof Incident) {
        var _class, _temp;

        DynamicDescriptiveIncident = (_temp = _class =
        /*#__PURE__*/
        function (_DescriptiveIncident) {
          _inherits(DynamicDescriptiveIncident, _DescriptiveIncident);

          function DynamicDescriptiveIncident() {
            _classCallCheck(this, DynamicDescriptiveIncident);

            return _possibleConstructorReturn(this, _getPrototypeOf(DynamicDescriptiveIncident).apply(this, arguments));
          }

          return DynamicDescriptiveIncident;
        }(DescriptiveIncident), _defineProperty(_class, "Incident", incidentClass), _defineProperty(_class, "plugin_npm_name", plugin.npm_name), _defineProperty(_class, "plugin", plugin.name), _defineProperty(_class, "ClassName", plugin.incidents[i].name), _defineProperty(_class, "Channel", AttributeChannelToUse), _temp);
      } // else if it is a Clip
      else if (incidentClass.prototype instanceof DescriptiveClip) {
          var _class2, _temp2;

          DynamicDescriptiveIncident = (_temp2 = _class2 =
          /*#__PURE__*/
          function (_incidentClass) {
            _inherits(DynamicDescriptiveIncident, _incidentClass);

            function DynamicDescriptiveIncident() {
              _classCallCheck(this, DynamicDescriptiveIncident);

              return _possibleConstructorReturn(this, _getPrototypeOf(DynamicDescriptiveIncident).apply(this, arguments));
            }

            return DynamicDescriptiveIncident;
          }(incidentClass), _defineProperty(_class2, "plugin", plugin.name), _defineProperty(_class2, "ClassName", plugin.incidents[i].name), _temp2);
        } else if (incidentClass.prototype instanceof DescriptiveGroup) {
          var _class3, _temp3;

          DynamicDescriptiveIncident = (_temp3 = _class3 =
          /*#__PURE__*/
          function (_incidentClass2) {
            _inherits(DynamicDescriptiveIncident, _incidentClass2);

            function DynamicDescriptiveIncident() {
              _classCallCheck(this, DynamicDescriptiveIncident);

              return _possibleConstructorReturn(this, _getPrototypeOf(DynamicDescriptiveIncident).apply(this, arguments));
            }

            return DynamicDescriptiveIncident;
          }(incidentClass), _defineProperty(_class3, "plugin", plugin.name), _defineProperty(_class3, "ClassName", plugin.incidents[i].name), _temp3);
        }

      Object.defineProperty(thePlugin, plugin.incidents[i].name, {
        get: function get() {
          // the getter will construct a wrapper class which on the constructor will instantiate an object of the
          // exposed class, set to it the plugin name and channel class parameters and return
          // it from the constructor
          var WrapperClass = function WrapperClass(attrs, props) {
            _classCallCheck(this, WrapperClass);

            var instantiatedIncident = new DynamicDescriptiveIncident(attrs, props);

            if (Object.prototype.hasOwnProperty.call(plugin.incidents[i], "attributesValidationRules")) {
              var v = new Validator();
              var validationResult = v.validate(attrs, plugin.incidents[i].attributesValidationRules);

              if (validationResult.length > 0) {
                return {
                  result: false,
                  errors: validationResult
                };
              }
            } else {
              helper.warning("It's always good to provide attributesValidationRules to the exported incidents. ".concat(plugin.npm_name, ".").concat(instantiatedIncident.constructor.name, " doesn't provide it"));
            }

            return instantiatedIncident;
          };

          return WrapperClass;
        }
      });
    };

    for (var i = 0; i < plugin.incidents.length; i++) {
      _loop(i);
    }

    return thePlugin;
  }
}

module.exports = {
  API: {
    Incident: Incident,
    Group: DescriptiveGroup,
    Clip: DescriptiveClip
  },
  Group: DescriptiveGroup,
  Clip: DescriptiveClip,
  loadPlugin: loadPlugin,
  TimeCapsule: TimeCapsule
};